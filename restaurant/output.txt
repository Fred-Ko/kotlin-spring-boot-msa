
// ===== domains/common/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    // 필수 Spring Framework 의존성만 유지
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    // Swagger
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
}

// ===== domains/common/presentation/GlobalExceptionHandler.kt =====
package com.restaurant.common.presentation

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.error.CommonSystemErrorCode // 공통 시스템 에러 코드 임포트
import com.restaurant.common.core.exception.DomainException
import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.independent.outbox.infrastructure.error.OutboxException // Outbox 예외 임포트
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.context.request.WebRequest
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler
import org.springframework.http.ProblemDetail // RFC 9457 ProblemDetail 임포트
import java.net.URI
import java.time.Instant
import jakarta.persistence.OptimisticLockException // OptimisticLockException 임포트

@RestControllerAdvice
class GlobalExceptionHandler : ResponseEntityExceptionHandler() {

    // Rule 51: Handle MethodArgumentNotValidException for Request DTO validation failures
    override fun handleMethodArgumentNotValid(
        ex: MethodArgumentNotValidException,
        headers: org.springframework.http.HttpHeaders,
        status: HttpStatus,
        request: WebRequest
    ): ResponseEntity<Any>? {
        // Rule 48: Validation failure response follows RFC 9457 ProblemDetail
        val problemDetail = ProblemDetail.forStatusAndDetail(
            HttpStatus.BAD_REQUEST,
            "Request validation failed."
        ).apply {
            title = "Validation Error"
            type = URI.create("about:blank") // Or a specific URI for validation errors
            // Add invalid-params field (Rule 48)
            setProperty("invalid-params", ex.bindingResult.fieldErrors.map {
                mapOf("field" to it.field, "reason" to it.defaultMessage)
            })
             // correlationId는 여기에 직접 접근하기 어려울 수 있음. MDC 등을 통해 전달 필요. (Rule 37, 49, 50)
             // Temporarily use a placeholder or assume MDC is configured.
             // setProperty("correlationId", getCorrelationIdFromMDC())
        }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problemDetail)
    }

    // Rule 51: Handle DomainException
    @ExceptionHandler(DomainException::class)
    fun handleDomainException(ex: DomainException, request: WebRequest): ResponseEntity<ProblemDetail> {
        // Rule 73: Determine HttpStatus based on ErrorCode.code or Exception type
        val determinedHttpStatus = determineHttpStatusFromCode(ex.errorCode.code)
        val problemDetail = ProblemDetail.forStatusAndDetail(
            determinedHttpStatus,
            ex.message // Rule 72: Use message from exception
        ).apply {
            title = "Domain Error"
            type = URI.create("about:blank") // Or a specific URI for domain errors
            setProperty("errorCode", ex.errorCode.code) // Rule 49: Include custom error code
             // correlationId 설정 (Rule 37, 49, 50)
             // setProperty("correlationId", getCorrelationIdFromMDC())
        }
        return ResponseEntity.status(determinedHttpStatus).body(problemDetail)
    }

    // Rule 51: Handle ApplicationException
    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(ex: ApplicationException, request: WebRequest): ResponseEntity<ProblemDetail> {
        // Rule 73: Determine HttpStatus based on ErrorCode.code or Exception type
        val determinedHttpStatus = determineHttpStatusFromCode(ex.errorCode.code)
        val problemDetail = ProblemDetail.forStatusAndDetail(
            determinedHttpStatus,
            ex.message // Rule 72: Use message from exception
        ).apply {
            title = "Application Error"
            type = URI.create("about:blank") // Or a specific URI for application errors
            setProperty("errorCode", ex.errorCode.code) // Rule 49: Include custom error code
             // correlationId 설정 (Rule 37, 49, 50)
             // setProperty("correlationId", getCorrelationIdFromMDC())
        }
         // Rule 71: Log application exceptions with errorCode
         logger.error("Application Exception, correlationId={}, errorCode={}, error={}", "placeholder-correlation-id", ex.errorCode.code, ex.message, ex)
        return ResponseEntity.status(determinedHttpStatus).body(problemDetail)
    }

    // Rule 51, 73: Handle OptimisticLockException (Concurrency Control)
    @ExceptionHandler(OptimisticLockException::class)
    fun handleOptimisticLockException(ex: OptimisticLockException, request: WebRequest): ResponseEntity<ProblemDetail> {
        // Rule 73: Determine HttpStatus (Conflict is common for concurrency issues)
        val determinedHttpStatus = HttpStatus.CONFLICT // Or INTERNAL_SERVER_ERROR depending on desired behavior
        // Rule 73: Use a common error code for concurrency failures
        val errorCode = CommonSystemErrorCode.CONCURRENCY_FAILURE // Assuming this exists or define it.

        val problemDetail = ProblemDetail.forStatusAndDetail(
            determinedHttpStatus,
            "Concurrency conflict occurred. Please try again."
        ).apply {
            title = "Concurrency Error"
            type = URI.create("about:blank") // Or a specific URI
            setProperty("errorCode", errorCode.code)
             // correlationId 설정 (Rule 37, 49, 50)
             // setProperty("correlationId", getCorrelationIdFromMDC())
        }
         logger.error("OptimisticLockException, correlationId={}, errorCode={}", "placeholder-correlation-id", errorCode.code, ex)
        return ResponseEntity.status(determinedHttpStatus).body(problemDetail)
    }

     // Rule 51, 73: Handle OutboxException
     @ExceptionHandler(OutboxException::class)
     fun handleOutboxException(ex: OutboxException, request: WebRequest): ResponseEntity<ProblemDetail> {
         // Rule 73: Outbox errors are typically internal/infrastructure failures
         val determinedHttpStatus = HttpStatus.INTERNAL_SERVER_ERROR

         val problemDetail = ProblemDetail.forStatusAndDetail(
             determinedHttpStatus,
             ex.message // Use the specific message from OutboxException
         ).apply {
             title = "Outbox System Error"
             type = URI.create("about:blank") // Or a specific URI
             setProperty("errorCode", ex.errorCode.code)
              // correlationId 설정 (Rule 37, 49, 50)
             // setProperty("correlationId", getCorrelationIdFromMDC())
         }
          logger.error("OutboxException, correlationId={}, errorCode={}, error={}", "placeholder-correlation-id", ex.errorCode.code, ex.message, ex)
         return ResponseEntity.status(determinedHttpStatus).body(problemDetail)
     }

    // Rule 51: Generic Exception handler for unhandled exceptions
    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception, request: WebRequest): ResponseEntity<ProblemDetail> {
        val determinedHttpStatus = HttpStatus.INTERNAL_SERVER_ERROR
        val errorCode = CommonSystemErrorCode.SYSTEM_ERROR // Assuming this exists or define it

        val problemDetail = ProblemDetail.forStatusAndDetail(
            determinedHttpStatus,
            "An unexpected error occurred."
        ).apply {
            title = "System Error"
            type = URI.create("about:blank") // Or a specific URI
             setProperty("errorCode", errorCode.code)
             // correlationId 설정 (Rule 37, 49, 50)
             // setProperty("correlationId", getCorrelationIdFromMDC())
        }
        logger.error("Unhandled Exception, correlationId={}, errorCode={}", "placeholder-correlation-id", errorCode.code, ex)
        return ResponseEntity.status(determinedHttpStatus).body(problemDetail)
    }

    // Rule 73: Custom logic to map ErrorCode string patterns to HttpStatus
    private fun determineHttpStatusFromCode(errorCode: String): HttpStatus {
        return when {
            errorCode.startsWith("USER-DOMAIN-") -> when (errorCode) {
                // Map specific domain errors to appropriate HTTP statuses
                "USER-DOMAIN-001" -> HttpStatus.NOT_FOUND // USER_NOT_FOUND
                "USER-DOMAIN-002" -> HttpStatus.CONFLICT // DUPLICATE_USERNAME
                "USER-DOMAIN-003" -> HttpStatus.UNAUTHORIZED // INVALID_PASSWORD
                "USER-DOMAIN-004" -> HttpStatus.BAD_REQUEST // INVALID_INPUT_FORMAT (Example for Validation)
                "USER-DOMAIN-005" -> HttpStatus.BAD_REQUEST // PASSWORD_POLICY_VIOLATION (Example for Validation)
                else -> HttpStatus.BAD_REQUEST // Default for other domain errors
            }
            errorCode.startsWith("USER-APPLICATION-") -> when (errorCode) {
                 // Map specific application errors
                "USER-APPLICATION-001" -> HttpStatus.BAD_REQUEST // INVALID_INPUT (Example)
                "USER-APPLICATION-002" -> HttpStatus.UNAUTHORIZED // AUTHENTICATION_FAILED (Example)
                // Note: EXTERNAL_SERVICE_ERROR, SYSTEM_ERROR might default to INTERNAL_SERVER_ERROR
                else -> HttpStatus.INTERNAL_SERVER_ERROR // Default for other application errors
            }
             // Outbox errors are typically internal, so they might all map to INTERNAL_SERVER_ERROR
             errorCode.startsWith("OUTBOX-INFRA-") -> HttpStatus.INTERNAL_SERVER_ERROR

            // Handle common system error codes
             errorCode == CommonSystemErrorCode.CONCURRENCY_FAILURE.code -> HttpStatus.CONFLICT // OptimisticLockException mapping
             errorCode == CommonSystemErrorCode.SYSTEM_ERROR.code -> HttpStatus.INTERNAL_SERVER_ERROR // Generic system error

            // Add other domain/application error code mappings here
            else -> HttpStatus.INTERNAL_SERVER_ERROR // Default for unmapped codes
        }
    }

    // Helper function to get correlationId (requires MDC setup)
    // private fun getCorrelationIdFromMDC(): String? {
    //     // Implementation depends on how MDC is populated (e.g., via a Filter/Interceptor)
    //     return org.slf4j.MDC.get("correlationId")
    // }

}

// Need CommonSystemErrorCode enum in domains/common/core/error (Rule 67)
/*
package com.restaurant.common.core.error

enum class CommonSystemErrorCode(override val code: String, override val message: String) : ErrorCode {
    SYSTEM_ERROR("COMMON-SYSTEM-999", "An unexpected system error occurred."),
    CONCURRENCY_FAILURE("COMMON-SYSTEM-500", "Concurrency conflict. Please try again.") // Example for OptimisticLockException
    // Add other common system error codes
}
*/
// ... existing code ...
// ===== domains/common/src/main/kotlin/com/restaurant/common/core/error/CommonSystemErrorCode.kt =====
package com.restaurant.common.core.error

/**
 * 일반적인 시스템 수준의 오류에 대한 오류 코드 정의
 * 규칙 67에 따라 시스템 오류 코드 정의
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    SYSTEM_ERROR("COMMON-SYSTEM-999", "An unexpected system error occurred."),
    CONCURRENCY_FAILURE("COMMON-SYSTEM-500", "Concurrency conflict. Please try again."),
    EXTERNAL_SERVICE_ERROR("COMMON-SYSTEM-501", "External service call failed."),
    DATABASE_ERROR("COMMON-SYSTEM-502", "Database operation failed."),
    NETWORK_ERROR("COMMON-SYSTEM-503", "Network communication error."),
    RESOURCE_NOT_FOUND("COMMON-SYSTEM-404", "Requested resource could not be found."),
    VALIDATION_ERROR("COMMON-SYSTEM-400", "Input validation failed."),
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/error/ErrorCode.kt =====
package com.restaurant.common.core.error

/**
 * 모든 에러 코드가 구현해야 하는 공통 인터페이스
 */
interface ErrorCode {
    /**
     * 에러 코드 (예: USER-001)
     */
    val code: String

    /**
     * 에러 메시지
     */
    val message: String
}

abstract class BaseErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    companion object {
        fun fromCode(
            errorCodes: List<ErrorCode>,
            code: String?,
        ): ErrorCode? = errorCodes.find { it.code == code }
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/ApplicationException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 애플리케이션 레이어에서 발생하는 기술적 또는 외부 요인 관련 예외의 기본 클래스.
 */
abstract class ApplicationException(
    message: String,
    cause: Throwable? = null, // 원인 예외를 포함할 수 있도록 cause 추가
) : RuntimeException(message, cause) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/DomainException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 도메인 비즈니스 규칙 위반 시 발생하는 기본 예외 클래스.
 */
abstract class DomainException(
    message: String,
) : RuntimeException(message) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/InfrastructureException.kt =====
package com.restaurant.common.core.exception

open class InfrastructureException(
    message: String,
) : RuntimeException(message)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/PresentationException.kt =====
package com.restaurant.common.core.exception

open class PresentationException(
    message: String,
) : RuntimeException(message)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/query/QueryResult.kt =====
package com.restaurant.common.core.query

data class QueryResult<T>(
    val success: Boolean,
    val data: T? = null,
    val errorCode: String? = null,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/query/dto/CursorPageDto.kt =====
package com.restaurant.common.core.query.dto

/**
 * 커서 기반 페이징 결과 DTO
 *
 * @property items 조회된 아이템 목록
 * @property nextCursor 다음 페이지 요청 시 사용할 커서 (null이면 마지막 페이지)
 * @property hasNext 다음 페이지 존재 여부
 */
data class CursorPageDto<T>(
    val items: List<T>,
    val nextCursor: String?,
    val hasNext: Boolean,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt =====
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    protected fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }

    fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    fun clearDomainEvents() {
        domainEvents.clear()
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt =====
package com.restaurant.common.domain.event

import java.time.LocalDateTime

/**
 * 모든 도메인 이벤트가 구현해야 하는 공통 인터페이스.
 */
interface DomainEvent {
    /**
     * 이벤트가 발생한 Aggregate의 루트 엔티티 ID (UUID의 문자열 표현).
     */
    val aggregateId: String

    /**
     * 이벤트가 발생한 Aggregate의 타입 이름.
     */
    val aggregateType: String // 예: "User", "Order"

    /**
     * 이벤트 발생 시각.
     */
    val occurredAt: LocalDateTime

    /**
     * 이벤트 고유 ID.
     */
    val eventId: String
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/infrastructure/mapper/EntityMapper.kt =====
package com.restaurant.common.infrastructure.mapper

interface EntityMapper<D, E> {
    fun toEntity(domain: D): E

    fun toDomain(entity: E): D
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt =====
package com.restaurant.common.presentation

import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.common.core.exception.DomainException
import com.restaurant.common.core.exception.InfrastructureException
import com.restaurant.common.core.exception.PresentationException
import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.independent.outbox.infrastructure.error.OutboxException
import jakarta.persistence.OptimisticLockException
import jakarta.validation.ConstraintViolationException
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.context.request.WebRequest
import java.net.URI
import java.time.Instant
import java.util.UUID
import org.slf4j.MDC

@ControllerAdvice
class GlobalExceptionHandler(
    @Value("\${app.problem.base-url:https://api.restaurant.com/problems}") private val problemBaseUrl: String,
) {
    private val log = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)

    /**
     * MDC(Mapped Diagnostic Context)에서 correlationId를 가져옵니다.
     * correlationId가 없는 경우 새로 생성합니다.
     */
    private fun getCorrelationIdFromMDC(): String {
        return MDC.get("correlationId") ?: UUID.randomUUID().toString()
    }

    /**
     * 에러 코드에 따른 HTTP 상태 코드 매핑
     */
    private fun determineHttpStatusFromCode(code: String): HttpStatus =
        when {
            // Account Domain Error Codes
            code == "ACCOUNT-DOMAIN-001" -> HttpStatus.NOT_FOUND // Account not found
            code == "ACCOUNT-DOMAIN-002" -> HttpStatus.BAD_REQUEST // Insufficient balance

            // Account Application Error Codes
            code == "ACCOUNT-APPLICATION-001" -> HttpStatus.NOT_FOUND // Account not found
            code == "ACCOUNT-APPLICATION-002" -> HttpStatus.BAD_REQUEST // Insufficient balance (if ApplicationException wraps this, although Rule 70 limits ApplicationException)
            code == "ACCOUNT-APPLICATION-003" -> HttpStatus.NOT_FOUND // Transaction not found
            code == "ACCOUNT-APPLICATION-004" -> HttpStatus.BAD_REQUEST // Transaction already cancelled
            code == "ACCOUNT-APPLICATION-999" -> HttpStatus.INTERNAL_SERVER_ERROR // System error

            // User Domain Error Codes
            code == "USER-DOMAIN-001" -> HttpStatus.NOT_FOUND // User not found
            code == "USER-DOMAIN-002" -> HttpStatus.CONFLICT // Duplicate email
            code == "USER-DOMAIN-003" -> HttpStatus.BAD_REQUEST // Password mismatch
            code == "USER-DOMAIN-004" -> HttpStatus.NOT_FOUND // Address not found
            code == "USER-DOMAIN-005" -> HttpStatus.BAD_REQUEST // Max address limit
            code == "USER-DOMAIN-006" -> HttpStatus.BAD_REQUEST // Default address cannot be removed
            code == "USER-DOMAIN-007" -> HttpStatus.BAD_REQUEST // Cannot remove last address
            code == "USER-DOMAIN-008" -> HttpStatus.BAD_REQUEST // Invalid password format
            code == "USER-DOMAIN-009" -> HttpStatus.BAD_REQUEST // Invalid input (general domain validation)

            // User Application Error Codes
            code == "USER-APPLICATION-001" -> HttpStatus.BAD_REQUEST // Invalid input (application level validation)
            code == "USER-APPLICATION-002" -> HttpStatus.UNAUTHORIZED // Authentication failed
            code == "USER-APPLICATION-003" -> HttpStatus.INTERNAL_SERVER_ERROR // External service error
            code == "USER-APPLICATION-999" -> HttpStatus.INTERNAL_SERVER_ERROR // System error

            // Outbox Error Codes (assuming OUTBOX-XXX maps to Internal Server Error unless specified)
            code.startsWith("OUTBOX-") -> HttpStatus.INTERNAL_SERVER_ERROR

            // 인증/인가 관련 에러
            code.startsWith("AUTH-") -> HttpStatus.UNAUTHORIZED
            code.contains("-AUTH-") -> HttpStatus.UNAUTHORIZED
            code.contains("-FORBIDDEN-") -> HttpStatus.FORBIDDEN

            // 리소스 찾을 수 없음
            code.contains("-NOT-FOUND") -> HttpStatus.NOT_FOUND
            code.endsWith("-404") -> HttpStatus.NOT_FOUND

            // 중복/충돌
            code.contains("-DUPLICATE-") -> HttpStatus.CONFLICT
            code.contains("-CONFLICT-") -> HttpStatus.CONFLICT
            code.endsWith("-409") -> HttpStatus.CONFLICT

            // 유효성 검증 실패
            code.contains("-INVALID-") -> HttpStatus.BAD_REQUEST
            code.contains("-VALIDATION-") -> HttpStatus.BAD_REQUEST
            code.endsWith("-400") -> HttpStatus.BAD_REQUEST

            // 비즈니스 규칙 위반
            code.startsWith("BIZ-") -> HttpStatus.UNPROCESSABLE_ENTITY
            code.contains("-RULE-") -> HttpStatus.UNPROCESSABLE_ENTITY
            code.endsWith("-422") -> HttpStatus.UNPROCESSABLE_ENTITY

            // 시스템/인프라 에러
            code.startsWith("SYS-") -> HttpStatus.INTERNAL_SERVER_ERROR
            code.contains("-SYSTEM-") -> HttpStatus.INTERNAL_SERVER_ERROR
            code.endsWith("-500") -> HttpStatus.INTERNAL_SERVER_ERROR

            // 기본값
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }

    private fun createProblemDetail(
        status: HttpStatus,
        code: String,
        title: String,
        detail: String?,
        request: WebRequest,
    ): ProblemDetail {
        val correlationId = getCorrelationIdFromRequest(request) ?: getCorrelationIdFromMDC()
        return ProblemDetail.forStatus(status).apply {
            type = URI.create("$problemBaseUrl/${code.lowercase()}")
            this.title = title
            this.detail = detail ?: "오류가 발생했습니다."
            setProperty("errorCode", code)
            setProperty("timestamp", Instant.now().toString())
            setProperty("correlationId", correlationId)
        }
    }

    /**
     * 요청 헤더에서 correlationId를 가져옵니다.
     */
    private fun getCorrelationIdFromRequest(request: WebRequest): String? {
        return request.getHeader("X-Correlation-Id")
    }

    /**
     * 요청 헤더 또는 MDC에서 correlationId를 가져옵니다.
     */
    private fun getCorrelationId(request: WebRequest): String {
        return getCorrelationIdFromRequest(request) ?: getCorrelationIdFromMDC()
    }

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val code = ex.errorCode.code
        val status = determineHttpStatusFromCode(code)
        val title = ex.errorCode.message

        log.warn(
            "Domain Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)

        // AccountDomainException 상세 정보 추가 (AccountGlobalExceptionHandler에서 가져옴)
        when (ex) {
            is AccountDomainException.Account.InsufficientBalance -> {
                 problem.setProperty("currentBalance", ex.currentBalance.value)
                 problem.setProperty("requiredAmount", ex.requiredAmount.value)
            }
            // UserDomainException.Validation 예외는 별도 핸들러에서 처리
        }

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(
        ex: ApplicationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val code = ex.errorCode.code
        val status = determineHttpStatusFromCode(code)
        val title = ex.errorCode.message

        log.error(
            "Application Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(InfrastructureException::class)
    fun handleInfrastructureException(
        ex: InfrastructureException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "INFRASTRUCTURE_ERROR"
        val title = "Infrastructure Error"
        val detail = ex.message ?: "인프라스트럭처 처리 중 오류가 발생했습니다."

        log.error(
            "Infrastructure Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(PresentationException::class)
    fun handlePresentationException(
        ex: PresentationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "PRESENTATION_ERROR"
        val title = "Presentation Error"
        val detail = ex.message ?: "프레젠테이션 처리 중 오류가 발생했습니다."

        log.warn(
            "Presentation Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(
        ex: MethodArgumentNotValidException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.bindingResult.fieldErrors.map {
                mapOf("field" to it.field, "reason" to (it.defaultMessage ?: "유효하지 않은 값입니다."))
            }
        log.warn(
            "Validation Exception Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams.toString(),
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(
        ex: ConstraintViolationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.constraintViolations.map {
                mapOf("field" to it.propertyPath.toString(), "reason" to it.message)
            }
        log.warn(
            "Constraint Violation Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleMessageNotReadableException(
        ex: HttpMessageNotReadableException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "MESSAGE_NOT_READABLE"
        val title = "Invalid Request Body"
        val detail = "요청 본문의 형식이 잘못되었거나 읽을 수 없습니다."
        log.warn(
            "Message Not Readable Exception Handled: correlationId={}, error={}",
            correlationId,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(OptimisticLockException::class)
    fun handleOptimisticLockException(
        ex: OptimisticLockException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.CONFLICT // Rule 31, 73: OptimisticLockException maps to Conflict
        // Assuming a common concurrency error code exists or using a generic system error code
        val code = "COMMON-SYSTEM-CONCURRENCY-FAILURE" // Or determine from CommonSystemErrorCode if defined
        val title = "Concurrency Conflict"
        val detail = "데이터 동시성 충돌이 발생했습니다. 다시 시도해주세요."

        log.warn(
            "Optimistic Lock Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(OutboxException::class)
    fun handleOutboxException(
        ex: OutboxException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val code = ex.errorCode.code // Use Outbox module's specific error code
        val status = determineHttpStatusFromCode(code) // Map status based on code pattern
        val title = ex.errorCode.message
        val detail = ex.message ?: "Outbox 처리 중 오류가 발생했습니다."

        log.error(
            "Outbox Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(
        ex: Exception,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "SYSTEM_ERROR"
        val title = "Internal Server Error"
        val detail = "서버에서 예상치 못한 오류가 발생했습니다."
        log.error(
            "Unhandled Exception: correlationId={}, error={}",
            correlationId,
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    // Add handler for UserDomainException.Validation
    @ExceptionHandler(UserDomainException.Validation::class)
    fun handleUserValidationException(
        ex: UserDomainException.Validation,
        request: WebRequest
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val code = ex.errorCode.code // e.g., USER-DOMAIN-008, USER-DOMAIN-009
        val status = determineHttpStatusFromCode(code) // Should map to BAD_REQUEST
        val title = ex.errorCode.message // e.g., "비밀번호 형식이 올바르지 않습니다.", "입력값이 유효하지 않습니다."
        val detail = ex.message

        log.warn(
            "User Domain Validation Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex
        )

        val problem = createProblemDetail(status, code, title, detail, request)

        // Rule 48: 유효성 검사 실패 상세 정보를 invalid-params 필드에 포함
        when (ex) {
            is UserDomainException.Validation.InvalidPassword -> {
                problem.setProperty("invalid-params", listOf(
                    mapOf("field" to "password", "reason" to ex.message)
                ))
            }
            is UserDomainException.Validation.InvalidEmail -> {
                problem.setProperty("invalid-params", listOf(
                    mapOf("field" to "email", "reason" to ex.message)
                ))
            }
            // 다른 Validation 예외도 필요에 따라 처리
            else -> {
                // 일반적인 경우 메시지만 포함
                problem.setProperty("invalid-params", listOf(
                    mapOf("field" to "unknown", "reason" to ex.message)
                ))
            }
        }

        return ResponseEntity.status(status).body(problem)
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt =====
package com.restaurant.common.presentation.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "커맨드 실행 결과 응답")
data class CommandResultResponse(
    @field:Schema(description = "처리 상태", example = "SUCCESS", required = true)
    val status: String,
    @field:Schema(description = "결과 메시지", example = "처리가 성공적으로 완료되었습니다.", required = true)
    val message: String,
    @field:Schema(description = "상관 관계 ID", example = "123e4567-e89b-12d3-a456-426614174000", required = true)
    val correlationId: String,
) : RepresentationModel<CommandResultResponse>()

// ===== domains/user/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))

    // Spring Boot 버전을 통일
    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-security:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.5")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/ChangePasswordCommand.kt =====
package com.restaurant.application.user.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteAddressCommand.kt =====
package com.restaurant.application.user.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteUserCommand.kt =====
package com.restaurant.application.user.command

data class DeleteUserCommand(
    val userId: String,
    val password: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/LoginCommand.kt =====
package com.restaurant.application.user.command

data class LoginCommand(
    val email: String,
    val password: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterAddressCommand.kt =====
package com.restaurant.application.user.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterUserCommand.kt =====
package com.restaurant.application.user.command

data class RegisterUserCommand(
    val email: String,
    val password: String,
    val name: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateAddressCommand.kt =====
package com.restaurant.application.user.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateProfileCommand.kt =====
package com.restaurant.application.user.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.dto.LoginResult
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): LoginResult {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (LoginResult 반환)
            val userId = user.id.value.toString()
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, userId)

            // 실제 구현에서는 JWT 토큰 생성 로직이 들어갈 것임
            return LoginResult(
                userId = userId,
                accessToken = "jwt.access.token.$userId", // 임시 구현
                refreshToken = "jwt.refresh.token.$userId", // 임시 구현
            )
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/LoginResult.kt =====
package com.restaurant.application.user.dto

import java.util.UUID

// 로그인 결과를 담는 데이터 클래스
data class LoginResult(
    val userId: String,
    val accessToken: String = UUID.randomUUID().toString(), // 임시 구현
    val refreshToken: String = UUID.randomUUID().toString(), // 임시 구현
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/UserProfileDto.kt =====
package com.restaurant.application.user.dto

import java.time.LocalDateTime

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val addresses: List<AddressDto> = emptyList(),
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime,
) {
    data class AddressDto(
        val id: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/error/UserApplicationErrorCode.kt =====
package com.restaurant.application.user.error

import com.restaurant.common.core.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    val code: String,
    val message: String,
) : ErrorCode {
    INVALID_INPUT("USER-APPLICATION-001", "입력값이 유효하지 않습니다."),
    AUTHENTICATION_FAILED("USER-APPLICATION-002", "인증에 실패했습니다."), // 예시: JWT 토큰 검증 실패 등
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-003", "외부 서비스 호출에 실패했습니다."),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/error/UserApplicationException.kt =====
package com.restaurant.application.user.error

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException

/**
 * User 애플리케이션 레이어 관련 예외
 */
sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    override val message: String,
    override val cause: Throwable? = null,
) : ApplicationException(errorCode, message, cause) {

    data class UnexpectedError(override val cause: Throwable?) : UserApplicationException(
        UserApplicationErrorCode.UNEXPECTED_ERROR,
        "An unexpected error occurred in the user application layer.",
        cause
    )

    data class UnexpectedApplicationError(
        // errorCode가 해당 도메인의 ApplicationErrorCode Enum 참조 (Rule 68)
        override val errorCode: UserApplicationErrorCode = UserApplicationErrorCode.SYSTEM_ERROR,
        override val message: String = "An unexpected application error occurred",
        val originalCause: Throwable? = null
    ) : UserApplicationException(errorCode, message, originalCause)

    data class ExternalServiceFailure(
        override val errorCode: UserApplicationErrorCode = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR,
        override val message: String = "External service call failed",
        val externalService: String? = null,
        val originalCause: Throwable? = null
    ) : UserApplicationException(errorCode, message, originalCause)

    data class AuthenticationFailed(
        override val errorCode: UserApplicationErrorCode = UserApplicationErrorCode.AUTHENTICATION_FAILED,
        override val message: String = "Authentication failed"
    ) : UserApplicationException(errorCode, message)

    // Add other specific application exceptions here
}

// UserApplicationErrorCode Enum은 별도의 파일에 정의되어야 함 (Rule 67)
/*
package com.restaurant.application.user.error

import com.restaurant.common.core.error.ErrorCode // Common ErrorCode 인터페이스 임포트

enum class UserApplicationErrorCode(override val code: String, override val message: String) : ErrorCode { // Rule 67 준수
    INVALID_INPUT("USER-APPLICATION-001", "입력값이 유효하지 않습니다."),
    AUTHENTICATION_FAILED("USER-APPLICATION-002", "인증에 실패했습니다."), // 예시: JWT 토큰 검증 실패 등
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-003", "외부 서비스 호출에 실패했습니다."),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}
*/
// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/exception/UserApplicationException.kt =====
package com.restaurant.application.user.exception

import com.restaurant.application.user.error.UserApplicationErrorCode
import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException

sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    final override val message: String = errorCode.message,
) : ApplicationException(message) {
    data class InvalidInput(
        val details: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.INVALID_INPUT,
            if (details != null) "유효하지 않은 입력: $details" else UserApplicationErrorCode.INVALID_INPUT.message,
        )

    data class AuthenticationFailed(
        val reason: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.AUTHENTICATION_FAILED,
            if (reason != null) "인증 실패: $reason" else UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        )

    data class ExternalServiceError(
        val serviceName: String,
        val causeError: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR,
            "외부 서비스($serviceName) 호출 오류${causeError?.let { ": $it" } ?: ""}",
        )

    data class SystemError(
        val causeException: Throwable? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.SYSTEM_ERROR,
            "시스템 오류 발생${causeException?.message?.let { ": $it" } ?: ""}",
        )
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/extensions/UserDtoExtensions.kt =====
package com.restaurant.application.user.extensions

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.model.Address

/**
 * Domain 객체를 Application DTO로 변환하는 확장 함수들
 */

fun User.toUserProfileDto(): UserProfileDto =
    UserProfileDto(
        id = this.id.value.toString(),
        email = this.email.value,
        name = this.name.value,
        addresses = this.addresses.map { it.toAddressDto() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

fun Address.toAddressDto(): UserProfileDto.AddressDto =
    UserProfileDto.AddressDto(
        id = this.addressId.value.toString(),
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/ChangePasswordCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(ChangePasswordCommandHandler::class.java)

    @Transactional
    fun handle(
        command: ChangePasswordCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: Create VOs outside try-catch
        val userId = UserId.fromString(command.userId)
        Password.validateRaw(command.newPassword)
        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.fromEncoded(encodedNewPassword)

        log.debug("Attempting password change, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for password change, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 현재 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.currentPassword, user.password.encodedValue)) {
                log.warn("Password change failed: Current password mismatch, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("현재 비밀번호가 일치하지 않습니다.")
            }

            // 비밀번호 변경 (Aggregate 호출)
            val updatedUser = user.changePassword(newPasswordVo)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info("Password changed successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during password change, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during password change, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug("Attempting to delete address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address deletion, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 삭제 (Aggregate 호출 - 내부에서 AddressNotFound 예외 발생 가능)
            val updatedUser = user.removeAddress(addressId)
            // 저장
            userRepository.save(updatedUser)

            log.info("Address deleted successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                command.addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                command.userId,
                command.addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 삭제 커맨드 핸들러
 */
@Service
class DeleteUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to delete address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address deletion, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 주소 삭제 (Domain 로직 호출)
            val updatedUser = user.removeAddress(addressId)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address deleted successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(DeleteUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteUserCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        log.debug("Attempting user deletion, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for deletion, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Password mismatch during user deletion, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("비밀번호가 일치하지 않습니다.")
            }

            // 사용자 삭제
            userRepository.delete(user)

            log.info("User deleted successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user deletion, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 시스템 오류
            log.error(
                "System error during user deletion, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/GetUserProfileQueryHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.application.user.extensions.toUserProfileDto
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(GetUserProfileQueryHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        query: GetUserProfileQuery,
        correlationId: String? = null,
    ): UserProfileDto {
        val userId = UserId.fromString(query.userId)
        log.debug("Attempting to get user profile, correlationId={}, userId={}", correlationId, userId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for profile query, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = query.userId)
                }
        val result = user.toUserProfileDto()
        log.debug("User profile retrieved successfully, correlationId={}, userId={}", correlationId, userId)
        return result
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): String {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (UserId 반환)
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, user.id.value)
            return user.id.value.toString()
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(RegisterAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 및 Domain Entity 생성
        val userId = UserId.fromString(command.userId)
        val address =
            Address.create(
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )

        log.debug("Attempting to register address, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address registration, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 추가 (Aggregate 호출)
            val updatedUser = user.addAddress(address)
            // 저장 (Repository)
            userRepository.save(updatedUser)

            log.info("Address registered successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address registration, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address registration, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import org.slf4j.LoggerFactory
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(RegisterUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterUserCommand,
        correlationId: String? = null,
    ): String {
        // Validate raw inputs and create VOs
        val email = Email.of(command.email)
        Password.validateRaw(command.password) // Validate raw password
        val name = Name.of(command.name)
        // Encode password and create Password VO
        val encodedPassword = passwordEncoder.encode(command.password)
        val password = Password.fromEncoded(encodedPassword)

        // 이메일 중복 검증 (Domain 예외 사용)
        if (userRepository.existsByEmail(email)) {
            // DuplicateEmail 예외는 ErrorCode를 내부적으로 가지므로 별도 로깅 불필요
            throw UserDomainException.User.DuplicateEmail(email = command.email)
        }

        try {
            // 사용자 생성 (이제 User 인스턴스만 반환)
            val newUser = User.create(email, password, name)

            // 사용자 저장 (Repository에서 이벤트 처리)
            val savedUser = userRepository.save(newUser)

            log.info("사용자 등록 성공, correlationId={}, email={}", correlationId, email)
            // Return UUID instead of Long
            return savedUser.id.value.toString()
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user registration, correlationId={}, errorCode={}, error: {}",
                correlationId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (dive: DataIntegrityViolationException) {
            // Catch potential unique constraint violations not caught by existsByEmail (race condition)
            log.error(
                "Data integrity violation during user registration, possibly duplicate email race condition, correlationId={}, error: {}",
                correlationId,
                dive.message,
                dive,
            )
            // Re-throw as duplicate email domain exception
            throw UserDomainException.User.DuplicateEmail(email.value)
        } catch (e: Exception) {
            // 기타 예상치 못한 오류
            log.error("사용자 등록 중 시스템 오류 발생, correlationId={}, error={}", correlationId, e.message, e)
            // Wrap as ApplicationException.SystemError before propagating
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)
        val updatedAddressData =
            Address.reconstitute(
                addressId = addressId,
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )
        log.debug("Attempting to update address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for address update, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }
        val updatedUser = user.updateAddress(addressId, updatedAddressData)
        userRepository.save(updatedUser)
        log.info("Address updated successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateProfileCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        try {
            // 사용자 조회 - DomainException (NotFound)는 상위로 전파
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("사용자를 찾을 수 없음, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 프로필 업데이트
            val updatedUser = user.updateProfile(name = name)
            userRepository.save(updatedUser)

            log.info("사용자 프로필 업데이트 성공, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            log.error(
                "사용자 프로필 업데이트 중 도메인 오류 발생, correlationId={}, errorCode={}, error={}",
                correlationId,
                de.errorCode.code,
                de.message,
                de,
            )
            throw de
        } catch (e: Exception) {
            log.error(
                "사용자 프로필 업데이트 중 시스템 오류 발생, correlationId={}, error={}",
                correlationId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to update address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 업데이트할 주소 객체 생성
            val updatedAddress =
                Address.reconstitute(
                    addressId = addressId,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            // 현재 주소를 찾고 업데이트
            val updatedUser = user.updateAddress(addressId, updatedAddress)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address updated successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address update, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address update, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserProfileCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 프로필 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        log.debug(
            "Attempting to update user profile, correlationId={}, userId={}",
            correlationId,
            userId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for profile update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 프로필 업데이트 (Domain 로직 호출)
            val updatedUser = user.updateProfile(name)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "User profile updated successfully, correlationId={}, userId={}",
                correlationId,
                userId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during profile update, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during profile update, correlationId={}, userId={}, error={}",
                correlationId,
                userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/query/GetUserProfileQuery.kt =====
package com.restaurant.application.user.query

data class GetUserProfileQuery(
    val userId: String,
)

// ===== domains/user/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt =====
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories

@SpringBootApplication
@ComponentScan(
    basePackages = [
        "com.restaurant.apps.user",
        "com.restaurant.presentation.user",
        "com.restaurant.application.user",
        "com.restaurant.infrastructure.user",
        "com.restaurant.common",
        "com.restaurant.independent.outbox",
    ],
)
@EntityScan(
    basePackages = [
        "com.restaurant.infrastructure.user.entity",
        "com.restaurant.independent.outbox.infrastructure.entity",
    ],
)
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.infrastructure.user.repository",
        "com.restaurant.independent.outbox.infrastructure.persistence",
    ],
)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SecurityConfig.kt =====
package com.restaurant.apps.user.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() } // 개발 편의상 CSRF 비활성화 (실제 환경에서는 필요에 따라 설정)
            .authorizeHttpRequests { authz ->
                authz.anyRequest().permitAll() // 개발 편의상 모든 요청 허용 (실제 환경에서는 인증/인가 필요)
            }
        return http.build()
    }
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SwaggerConfig.kt =====
package com.restaurant.apps.user.config

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import org.springdoc.core.models.GroupedOpenApi
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfig {
    @Bean
    fun publicApi(): GroupedOpenApi =
        GroupedOpenApi
            .builder()
            .group("user-api-v1")
            .pathsToMatch("/api/v1/users/**")
            .build()

    @Bean
    fun springOpenAPI(): OpenAPI =
        OpenAPI()
            .info(
                Info()
                    .title("User Service API")
                    .description("User Service API Documentation")
                    .version("v1"),
            )
}

// ===== domains/user/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.
    // NOTE: HttpStatus 사용을 위해 임시로 추가 (Rule 10 위반 가능성)

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/aggregate/User.kt =====
package com.restaurant.domain.user.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.domain.user.event.UserEvent
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime
import java.util.UUID

data class User
    private constructor(
        val id: UserId,
        val email: Email,
        val password: Password,
        val name: Name,
        val addresses: List<Address> = emptyList(),
        val createdAt: LocalDateTime = LocalDateTime.now(),
        val updatedAt: LocalDateTime = LocalDateTime.now(),
    ) : AggregateRoot() {
        companion object {
            fun create(
                email: Email,
                password: Password,
                name: Name,
            ): User {
                val userId = UserId.generate()
                val user = User(id = userId, email = email, password = password, name = name)
                val event =
                    UserEvent.Created(
                        userId = userId,
                        email = email.value,
                        name = name.value,
                        eventId = UUID.randomUUID().toString(),
                        occurredAt = user.createdAt,
                    )
                user.addDomainEvent(event)
                return user
            }

            fun reconstitute(
                id: UserId,
                email: Email,
                password: Password,
                name: Name,
                addresses: List<Address> = emptyList(),
                createdAt: LocalDateTime,
                updatedAt: LocalDateTime,
            ): User =
                User(
                    id = id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
        }

        fun updateProfile(name: Name): User {
            val updated = this.copy(name = name, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.ProfileUpdated(
                    userId = this.id,
                    name = name.value,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun changePassword(encodedPassword: Password): User {
            val updated = this.copy(password = encodedPassword, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.PasswordChanged(
                    userId = this.id,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun addAddress(address: Address): User {
            val newAddresses =
                if (address.isDefault) {
                    addresses.map { it.update(isDefault = false) } + address
                } else {
                    if (addresses.isEmpty()) {
                        listOf(address.update(isDefault = true))
                    } else {
                        addresses + address
                    }
                }
            val updated = this.copy(addresses = newAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressAdded(
                    userId = this.id,
                    addressId = address.addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun updateAddress(
            addressId: AddressId,
            updatedAddress: Address,
        ): User {
            if (addressId != updatedAddress.addressId) {
                throw UserDomainException.Validation.InvalidAddressFormat(
                    "수정하려는 주소의 ID(${addressId.value})와 전달된 주소 데이터의 ID(${updatedAddress.addressId.value})가 일치하지 않습니다.",
                )
            }

            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            val newAddresses =
                if (updatedAddress.isDefault) {
                    addresses.map {
                        when {
                            it.addressId == addressId -> updatedAddress
                            else -> it.update(isDefault = false)
                        }
                    }
                } else {
                    val currentDefault = addresses.find { it.isDefault }
                    if (currentDefault?.addressId == addressId) {
                        val addressesWithoutOriginal = addresses.filter { it.addressId != addressId }
                        val updatedList = addressesWithoutOriginal + updatedAddress
                        if (updatedList.size > 1) {
                            val firstOther = updatedList.first { it.addressId != addressId }
                            updatedList.map { adr ->
                                if (adr.addressId == firstOther.addressId) adr.update(isDefault = true) else adr
                            }
                        } else {
                            listOf(updatedAddress.update(isDefault = true))
                        }
                    } else {
                        addresses.map { if (it.addressId == addressId) updatedAddress else it }
                    }
                }

            val ensuredAddresses =
                if (newAddresses.none { it.isDefault } && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressUpdated(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun removeAddress(addressId: AddressId): User {
            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            if (addresses.size == 1) {
                throw UserDomainException.Address.CannotRemoveLastAddress(
                    addressId = addressId.value.toString(),
                )
            }

            val newAddresses = addresses.filter { it.addressId != addressId }
            val ensuredAddresses =
                if (existingAddress.isDefault && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressRemoved(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        private fun copy(
            email: Email = this.email,
            password: Password = this.password,
            name: Name = this.name,
            addresses: List<Address> = this.addresses,
            createdAt: LocalDateTime = this.createdAt,
            updatedAt: LocalDateTime = this.updatedAt,
        ): User {
            val copiedUser =
                User(
                    id = this.id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
            return copiedUser
        }
    }

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/error/UserDomainErrorCodes.kt =====
package com.restaurant.domain.user.error

import com.restaurant.common.core.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-003", "비밀번호가 일치하지 않습니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-004", "주소를 찾을 수 없습니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-005", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-006", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-007", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-008", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_INPUT("USER-DOMAIN-009", "입력값이 유효하지 않습니다."),
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/error/UserDomainException.kt =====
package com.restaurant.domain.user.error

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.DomainException

/**
 * User 도메인 관련 예외 최상위 클래스
 */
sealed class UserDomainException(
    override val errorCode: ErrorCode,
    override val message: String,
    override val cause: Throwable? = null,
) : DomainException(errorCode, message, cause) {

    // Rule 68: Validation 관련 DomainException 하위 타입 정의
    // Rule 14, 61: VO 유효성 검사 실패 시 상속하는 베이스 예외 타입
    // sealed class Validation(...) : UserDomainException(...) { ... }

    data class UserNotFound(val userId: String) : UserDomainException(
        UserDomainErrorCodes.USER_NOT_FOUND,
        "User not found with ID: $userId",
    )

    data class DuplicateUsername(val username: String) : UserDomainException(
        UserDomainErrorCodes.DUPLICATE_USERNAME,
        "Username already exists: $username",
    )

    data class InvalidCredentials(
        override val errorCode: UserDomainErrorCodes = UserDomainErrorCodes.INVALID_PASSWORD,
        override val message: String = "Invalid username or password"
    ) : UserDomainException(errorCode, message, null)

    // Add other specific domain exceptions here
}

// UserDomainErrorCodes Enum에 필요한 추가 코드 (예시)
// UserDomainErrorCodes Enum은 별도의 파일에 정의되어야 함 (Rule 67)
/*
package com.restaurant.domain.user.error

import com.restaurant.common.core.error.ErrorCode // Common ErrorCode 인터페이스 임포트

enum class UserDomainErrorCodes(override val code: String, override val message: String) : ErrorCode { // Rule 67 준수
    USER_NOT_FOUND("USER-DOMAIN-001", "User not found"),
    DUPLICATE_USERNAME("USER-DOMAIN-002", "Username already exists"),
    INVALID_PASSWORD("USER-DOMAIN-003", "Invalid password"),
    INVALID_INPUT_FORMAT("USER-DOMAIN-004", "Invalid input format"), // 유효성 검사 실패 예시
    PASSWORD_POLICY_VIOLATION("USER-DOMAIN-005", "Password does not meet policy requirements"), // 유효성 검사 실패 예시
    // Add other domain error codes here following the pattern {DOMAIN}-DOMAIN-{NUMBER}
}
*/
// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/event/UserEvent.kt =====
package com.restaurant.domain.user.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime

sealed class UserEvent(
    open val userId: UserId,
    override val eventId: String,
    override val occurredAt: LocalDateTime,
) : DomainEvent {
    override val aggregateId: String
        get() = userId.value.toString()
    override val aggregateType: String
        get() = User::class.java.simpleName

    data class Created(
        override val userId: UserId,
        val email: String,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class ProfileUpdated(
        override val userId: UserId,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class PasswordChanged(
        override val userId: UserId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressAdded(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressUpdated(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressRemoved(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/exception/UserDomainException.kt =====
package com.restaurant.domain.user.exception

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.DomainException
import com.restaurant.domain.user.error.UserDomainErrorCodes

// sealed class UserDomainException(...): DomainException(...) 제거

// 최상위 sealed class 는 marker 역할만 하거나, 공통 필드(message)만 가질 수 있음
sealed class UserDomainException(
    message: String,
) : DomainException(message) {
    // Rule 68, 73: 상위 클래스 DomainException의 abstract val errorCode를 override로 명시
    abstract override val errorCode: ErrorCode

    sealed class Validation(
        message: String,
        override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
    ) : UserDomainException(message) {
        data class InvalidEmailFormat(
            val email: String,
        ) : Validation("이메일 형식이 올바르지 않습니다: $email")

        data class InvalidPasswordFormat(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
        ) : Validation("비밀번호 형식이 올바르지 않습니다: $reason")

        data class InvalidNameFormat(
            val name: String,
        ) : Validation("이름 형식이 올바르지 않습니다: $name")

        data class InvalidAddressFormat(
            val reason: String,
        ) : Validation("주소 형식이 올바르지 않습니다: $reason")

        data class InvalidPhoneNumberFormat(
            val phoneNumber: String,
        ) : Validation("전화번호 형식이 올바르지 않습니다: $phoneNumber")
    }

    // 각 하위 sealed class 또는 data class 에서 errorCode 를 override
    sealed class User(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String,
            // Rule 68: errorCode 를 override 로 명시적 지정
            override val errorCode: ErrorCode = UserDomainErrorCodes.USER_NOT_FOUND,
        ) : User("사용자를 찾을 수 없습니다: $userId") // 생성자에서 message 전달

        data class DuplicateEmail(
            val email: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.DUPLICATE_EMAIL,
        ) : User("이미 등록된 이메일입니다: $email")

        data class InvalidCredentials(
            override val errorCode: ErrorCode = UserDomainErrorCodes.PASSWORD_MISMATCH,
        ) : User(errorCode.message) // ErrorCode의 기본 메시지 사용

        data class InvalidInput(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
        ) : User("잘못된 사용자 입력: $reason")
    }

    sealed class Address(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String, // 사용자 ID도 String으로 변경
            val addressId: String, // Long -> String (AddressId.value.toString())
            override val errorCode: ErrorCode = UserDomainErrorCodes.ADDRESS_NOT_FOUND,
        ) : Address("사용자($userId)의 주소($addressId)를 찾을 수 없습니다.")

        data class MaxLimitExceeded(
            val userId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
        ) : Address("사용자($userId)의 최대 주소 등록 개수를 초과했습니다.")

        data class DefaultAddressRemovalAttempt(
            val addressId: String, // Long -> String
            override val errorCode: ErrorCode = UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
        ) : Address("기본 주소($addressId)는 삭제할 수 없습니다.")

        data class CannotRemoveLastAddress(
            val addressId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
        ) : Address("마지막 주소($addressId)는 삭제할 수 없습니다.")
    }
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/model/Address.kt =====
package com.restaurant.domain.user.model

import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.vo.AddressId

data class Address
    private constructor(
        val addressId: AddressId,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    ) {
        init {
            if (street.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("도로명 주소는 비어있을 수 없습니다.")
            }
            if (zipCode.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("우편번호는 비어있을 수 없습니다.")
            }
        }

        companion object {
            fun create(
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean = false,
            ): Address =
                Address(
                    addressId = AddressId.generate(),
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )

            fun reconstitute(
                addressId: AddressId,
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean,
            ): Address =
                Address(
                    addressId = addressId,
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )
        }

        fun update(
            street: String = this.street,
            detail: String = this.detail,
            zipCode: String = this.zipCode,
            isDefault: Boolean = this.isDefault,
        ): Address =
            Address(
                addressId = this.addressId,
                street = street,
                detail = detail,
                zipCode = zipCode,
                isDefault = isDefault,
            )
    }

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/repository/UserRepository.kt =====
package com.restaurant.domain.user.repository

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId

interface UserRepository {
    fun save(user: User): User

    fun findById(id: UserId): User?

    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun delete(user: User)
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/AddressId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class AddressId private constructor(
    val value: UUID,
) {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun fromString(value: String): AddressId = AddressId(UUID.fromString(value))

        fun of(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Email.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Email private constructor(
    val value: String,
) {
    init {
        if (!value.matches(EMAIL_REGEX)) {
            throw UserDomainException.Validation.InvalidEmailFormat(value)
        }
    }

    companion object {
        private val EMAIL_REGEX = Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+$")

        fun of(value: String): Email = Email(value)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Name.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Name private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        fun of(name: String): Name = Name(name)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Password.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Password private constructor(
    val encodedValue: String,
) {
    init {
        if (encodedValue.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호 값(인코딩 또는 raw)은 비어있을 수 없습니다.")
        }
    }

    companion object {
        private const val MIN_RAW_LENGTH = 8

        fun validateRaw(rawPassword: String) {
            if (rawPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 비어있을 수 없습니다.")
            }
            if (rawPassword.length < MIN_RAW_LENGTH) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 최소 ${MIN_RAW_LENGTH}글자 이상이어야 합니다.")
            }
        }

        fun fromEncoded(encodedPassword: String): Password {
            if (encodedPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("인코딩된 비밀번호 값은 비어있을 수 없습니다.")
            }
            return Password(encodedPassword)
        }
    }

    override fun toString(): String = "********"
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/PhoneNumber.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class PhoneNumber private constructor(
    val value: String,
) {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^\\d{3}-\\d{3,4}-\\d{4}$")

        fun of(value: String): PhoneNumber = PhoneNumber(value)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/UserId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class UserId private constructor(
    val value: UUID,
) {
    companion object {
        fun of(value: UUID): UserId = UserId(value)

        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromString(value: String): UserId = UserId(UUID.fromString(value))
    }

    override fun toString(): String = value.toString()
}

// ===== domains/user/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1"
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))
    implementation(project(":independent:outbox:application")) // OutboxEventRepository 사용을 위한 의존성 추가

    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.persistence:jakarta.persistence-api:3.1.0")
    implementation("org.mapstruct:mapstruct:1.6.3")

    // Avro & Kafka
    implementation("org.apache.avro:avro:1.11.3")
    implementation("io.confluent:kafka-avro-serializer:7.5.3")
    implementation("io.confluent:kafka-schema-registry-client:7.5.3")
    implementation("org.apache.kafka:kafka-clients")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// Avro 플러그인 설정
avro {
    isCreateSetters.set(false)
    fieldVisibility.set("PRIVATE")
    isCreateOptionalGetters.set(false)
    isGettersReturnOptional.set(false)
    outputCharacterEncoding.set("UTF-8")
    stringType.set("String")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    source(tasks.withType<com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask>().map { it.outputs })
}

tasks.named("compileKotlin") {
    dependsOn("generateAvroJava")
}

repositories {
    mavenCentral()
    maven {
        url = uri("https://packages.confluent.io/maven/")
    }
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/AddressEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.util.UUID

@Entity
@Table(name = "user_addresses")
class AddressEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "address_id", nullable = false, unique = true) val addressId: UUID,
    @Column(nullable = false) val street: String,
    @Column val detail: String,
    @Column(name = "zip_code", nullable = false) val zipCode: String,
    @Column(name = "is_default", nullable = false) val isDefault: Boolean,
    @Version
    @Column(nullable = false)
    val version: Long = 0,
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AddressEntity

        // 도메인 ID로 비교
        return addressId == other.addressId
    }

    override fun hashCode(): Int {
        // 도메인 ID 기반 해시코드
        return addressId.hashCode()
    }

    override fun toString(): String =
        "AddressEntity(id=$id, addressId=$addressId, street='$street', detail='$detail', zipCode='$zipCode', isDefault=$isDefault, version=$version)"
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/UserEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.LocalDateTime
import java.util.ArrayList
import java.util.UUID

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false) val email: String,
    @Column(nullable = false) val password: String,
    @Column(nullable = false) val name: String,
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime = LocalDateTime.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: LocalDateTime = LocalDateTime.now(),
    @Version
    @Column(nullable = false)
    val version: Long = 0,
) {
    // JPA 필드는 private으로 설정
    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    private var addressEntities: MutableList<AddressEntity> = ArrayList()

    // 주소 목록에 대한 불변 뷰 제공 (프로퍼티로 제공)
    val addresses: List<AddressEntity>
        get() = addressEntities.toList()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UserEntity

        if (id != other.id) return false
        if (email != other.email) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + email.hashCode()
        return result
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, email='$email', name='$name', createdAt=$createdAt, updatedAt=$updatedAt, addresses=${addressEntities.size}, version=$version)"
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/AddressEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.infrastructure.user.entity.AddressEntity

// AddressEntity -> Address 변환
fun AddressEntity.toDomain(): Address {
    // val id = this.id ?: throw IllegalStateException("영속화된 AddressEntity의 ID는 null일 수 없습니다") // Long id 제거

    return Address.reconstitute(
        // id = id, // Long id 제거
        addressId = AddressId.of(this.addressId), // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
    )
}

// Address -> AddressEntity 변환 (UserEntity 참조 없이)
fun Address.toEntity(): AddressEntity =
    AddressEntity(
        id = null, // JPA가 Long ID를 관리하도록 null 전달 (기존 id 필드 사용 제거)
        addressId = this.addressId.value, // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
        user = null, // Will be set when added to UserEntity
        // version은 JPA가 관리하거나, 필요시 Domain 객체에서 전달받아 설정
    )

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/UserEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import com.restaurant.infrastructure.user.entity.UserEntity

// UserEntity -> User 변환
fun UserEntity.toDomain(): User {
    // addresses는 Lazy Loading이므로 트랜잭션 경계 내에서만 접근해야 함
    val domainAddresses = this.addresses.map { it.toDomain() } // addresses getter is already List

    return User.reconstitute(
        id = UserId.of(this.domainId), // Use domainId for UserId
        email = Email.of(email),
        password = Password.fromEncoded(password),
        name = Name.of(name),
        addresses = domainAddresses,
        createdAt = createdAt,
        updatedAt = updatedAt,
    )
}

// User -> UserEntity 변환
fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            id = null, // Let JPA handle the Long ID generation
            domainId =
                this.id?.value
                    ?: throw IllegalArgumentException(
                        "User Domain ID cannot be null for entity conversion",
                    ), // Use UUID from Domain
            email = email.value,
            password = password.encodedValue,
            name = name.value,
            createdAt = createdAt,
            updatedAt = updatedAt,
        )
    // Set addresses manually, establishing the bidirectional link
    this.addresses.map { address ->
        // 람다 파라미터를 새 줄로 이동
        address.toEntity().apply { user = entity } // Set back-reference
    }
    // JPA Cascade 설정에 의존하여 저장하므로 별도 설정 불필요
    return entity
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/SpringDataJpaUserRepository.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.infrastructure.user.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByDomainId(domainId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    fun existsByEmail(email: String): Boolean

    fun deleteByDomainId(domainId: UUID)
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/UserRepositoryImpl.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.common.infrastructure.avro.envelope.EventEnvelope
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.infrastructure.user.avro.UserEventPayload
import com.restaurant.infrastructure.user.extensions.toDomain
import com.restaurant.infrastructure.user.extensions.toEntity
import org.apache.avro.io.EncoderFactory
import org.apache.avro.specific.SpecificDatumWriter
import org.springframework.stereotype.Repository
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.time.Instant
import java.util.UUID
import java.util.concurrent.TimeUnit
import com.restaurant.infrastructure.user.avro.Address as AvroAddress

@Repository
class UserRepositoryImpl(
    private val jpaRepository: SpringDataJpaUserRepository,
    private val outboxMessageRepository: OutboxMessageRepository,
) : UserRepository {
    override fun save(user: User): User {
        val domainEvents = user.getDomainEvents().toList()

        val entity = user.toEntity()
        val savedEntity = jpaRepository.save(entity)

        if (domainEvents.isNotEmpty()) {
            val aggregateId = user.id.value.toString()
            val aggregateType = "User"
            val correlationId = UUID.randomUUID().toString() // TODO: MDC에서 가져오기

            val outboxMessages =
                domainEvents.map { domainEvent ->
                    // 1. Create the UserEventPayload (Event content)
                    val avroPayload = createAvroPayload(user)
                    val payloadBytes = serializeAvroPayload(avroPayload)

                    // 2. Create the Envelope with metadata and the serialized payload
                    val envelope =
                        createEnvelope(
                            eventId = correlationId,
                            timestamp = Instant.now(),
                            source = "user",
                            aggregateType = aggregateType,
                            aggregateId = aggregateId,
                            eventType = domainEvent::class.java.simpleName,
                            payloadBytes = payloadBytes,
                        )

                    // 3. Serialize the Envelope
                    val envelopeBytes = serializeEnvelope(envelope)

                    // 4. Determine Kafka topic
                    val topic = resolveTopic(domainEvent)

                    // 5. Create headers for Kafka message (duplicating some envelope data for filtering without deserializing)
                    val headers =
                        mapOf(
                            "correlationId" to correlationId,
                            "aggregateType" to aggregateType,
                            "aggregateId" to aggregateId,
                            "eventType" to domainEvent::class.java.simpleName,
                            "eventId" to correlationId,
                            "timestamp" to Instant.now().toString(),
                        )

                    // 6. Create OutboxMessage with full Envelope payload
                    OutboxMessage(
                        payload = envelopeBytes,
                        topic = topic,
                        headers = headers,
                        aggregateId = aggregateId,
                        aggregateType = aggregateType,
                    )
                }
            outboxMessageRepository.saveAll(outboxMessages)
        }

        user.clearDomainEvents()
        return savedEntity.toDomain()
    }

    override fun findById(id: UserId): User? = jpaRepository.findByDomainId(id.value)?.toDomain()

    override fun findByEmail(email: Email): User? = jpaRepository.findByEmail(email.value)?.toDomain()

    override fun existsByEmail(email: Email): Boolean = jpaRepository.existsByEmail(email.value)

    override fun delete(user: User) {
        jpaRepository.deleteByDomainId(user.id.value)
    }

    private fun createAvroPayload(user: User): UserEventPayload =
        UserEventPayload
            .newBuilder()
            .setUserId(user.id.value.toString())
            .setEmail(user.email.value)
            .setName(user.name.value)
            .setAddresses(
                user.addresses.map { address ->
                    AvroAddress
                        .newBuilder()
                        .setAddressId(address.id.value.toString())
                        .setZipCode(address.zipCode)
                        .setStreet(address.street)
                        .setDetail(address.detail)
                        .setIsDefault(address.isDefault)
                        .build()
                },
            ).build()

    private fun serializeAvroPayload(payload: UserEventPayload): ByteArray {
        val writer = SpecificDatumWriter(UserEventPayload::class.java)
        val out = ByteArrayOutputStream()
        val encoder = EncoderFactory.get().binaryEncoder(out, null)
        writer.write(payload, encoder)
        encoder.flush()
        out.close()
        return out.toByteArray()
    }

    private fun createEnvelope(
        eventId: String,
        timestamp: Instant,
        source: String,
        aggregateType: String,
        aggregateId: String,
        eventType: String,
        payloadBytes: ByteArray,
    ): EventEnvelope {
        // Convert payload bytes to ByteBuffer as required by Avro
        val payloadBuffer = ByteBuffer.wrap(payloadBytes)

        // Create metadata map if needed
        val metadata =
            mapOf(
                "createdAt" to timestamp.toString(),
                "eventType" to eventType,
            )

        return EventEnvelope
            .newBuilder()
            .setSchemaVersion(1)
            .setEventId(eventId)
            .setTimestamp(TimeUnit.SECONDS.toNanos(timestamp.epochSecond) + timestamp.nano)
            .setSource(source)
            .setAggregateType(aggregateType)
            .setAggregateId(aggregateId)
            .setEventType(eventType)
            .setPayload(payloadBuffer)
            .setMetadata(metadata)
            .build()
    }

    private fun serializeEnvelope(envelope: EventEnvelope): ByteArray {
        val writer = SpecificDatumWriter(EventEnvelope::class.java)
        val out = ByteArrayOutputStream()
        val encoder = EncoderFactory.get().binaryEncoder(out, null)
        writer.write(envelope, encoder)
        encoder.flush()
        out.close()
        return out.toByteArray()
    }

    private fun resolveTopic(event: DomainEvent): String {
        val environment = "dev" // TODO: 설정에서 가져오기
        val domain = "user"
        val eventType = "domain-event"
        val entity = "user"
        val version = "v1"
        return "$environment.$domain.$eventType.$entity.$version"
    }
}

// ===== domains/user/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.3.2")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserAddressCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1

// RegisterAddressRequestV1 -> RegisterAddressCommand 변환
fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// UpdateAddressRequestV1 -> UpdateAddressCommand 변환
fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1

// RegisterUserRequestV1 -> RegisterUserCommand 변환
fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
    )

// LoginRequestV1 -> LoginCommand 변환
fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

// UpdateProfileRequestV1 -> UpdateProfileCommand 변환
fun UpdateProfileRequestV1.toCommand(userId: String): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId,
        name = this.name,
    )

// ChangePasswordRequestV1 -> ChangePasswordCommand 변환
fun ChangePasswordRequestV1.toCommand(userId: String): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId,
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

// DeleteUserRequestV1 -> DeleteUserCommand 변환
fun DeleteUserRequestV1.toCommand(userId: String): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId,
        password = this.currentPassword,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserQueryRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.query.GetUserProfileQuery

// String (UUID) -> GetUserProfileQuery 변환
fun String.toGetUserProfileQuery(): GetUserProfileQuery =
    GetUserProfileQuery(
        userId = this,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/response/UserQueryResponseExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.response

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.presentation.user.v1.query.dto.response.AddressResponseV1
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1

// UserProfileDto -> UserProfileResponseV1 변환
fun UserProfileDto.toResponse(): UserProfileResponseV1 =
    UserProfileResponseV1(
        id = this.id,
        email = this.email,
        name = this.name,
        addresses = this.addresses.map { it.toResponse() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

// UserProfileDto.AddressDto -> AddressResponseV1 변환
fun UserProfileDto.AddressDto.toResponse(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// List<UserProfileDto.AddressDto> -> List<AddressResponseV1> 변환
fun List<UserProfileDto.AddressDto>.toResponse(): List<AddressResponseV1> = map { it.toResponse() }

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserAddressControllerV1.kt =====
package com.restaurant.presentation.user.v1.command

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.command.handler.DeleteAddressCommandHandler
import com.restaurant.application.user.command.handler.RegisterAddressCommandHandler
import com.restaurant.application.user.command.handler.UpdateAddressCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
@Tag(name = "주소 관리", description = "사용자의 배달 주소 등록, 수정, 삭제 API")
class UserAddressControllerV1(
    private val registerAddressCommandHandler: RegisterAddressCommandHandler,
    private val updateAddressCommandHandler: UpdateAddressCommandHandler,
    private val deleteAddressCommandHandler: DeleteAddressCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserAddressControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping
    @Operation(summary = "주소 등록", description = "사용자의 새로운 배달 주소를 등록합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "주소 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId)

        registerAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PutMapping("/{addressId}")
    @Operation(summary = "주소 수정", description = "등록된 배달 주소를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
        @Valid @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId, addressId)

        updateAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{addressId}")
    @Operation(summary = "주소 삭제", description = "등록된 배달 주소를 삭제합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = DeleteAddressCommand(userId, addressId)

        deleteAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 삭제되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserCommandControllerV1.kt =====
package com.restaurant.presentation.user.v1.command
import com.restaurant.application.user.command.handler.UpdateProfileCommandHandler
import com.restaurant.application.user.handler.ChangePasswordCommandHandler
import com.restaurant.application.user.handler.DeleteUserCommandHandler
import com.restaurant.application.user.handler.LoginCommandHandler
import com.restaurant.application.user.handler.RegisterUserCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.presentation.user.v1.command.dto.response.LoginResponseV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 관리", description = "사용자 등록, 로그인, 프로필 관리 API")
class UserCommandControllerV1(
    private val registerUserCommandHandler: RegisterUserCommandHandler,
    private val loginCommandHandler: LoginCommandHandler,
    private val updateProfileCommandHandler: UpdateProfileCommandHandler,
    private val changePasswordCommandHandler: ChangePasswordCommandHandler,
    private val deleteUserCommandHandler: DeleteUserCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserCommandControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping("/register")
    @Operation(summary = "사용자 등록", description = "신규 사용자를 시스템에 등록합니다. 이메일, 이름, 비밀번호가 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "사용자 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "409",
                description = "이미 존재하는 이메일",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun registerUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 등록 요청: email={}, correlationId={}", request.email, correlationId)

        // extension 함수 사용
        val userId = registerUserCommandHandler.handle(request.toCommand(), correlationId)

        log.info("사용자 등록 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자가 성공적으로 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "로그인", description = "이메일과 비밀번호로 로그인합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그인 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = LoginResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "401",
                description = "로그인 실패 (이메일 또는 비밀번호 불일치)",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun login(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: LoginRequestV1,
    ): ResponseEntity<LoginResponseV1> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그인 요청: email={}, correlationId={}", request.email, correlationId)

        val loginResult = loginCommandHandler.handle(request.toCommand(), correlationId)

        log.info("로그인 성공: userId={}, correlationId={}", loginResult, correlationId)

        val response =
            LoginResponseV1(
                status = "SUCCESS",
                message = "로그인 성공",
                userId = loginResult,
                accessToken = "",
                refreshToken = "",
                correlationId = correlationId,
            )

        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(loginResult, correlationId)).withRel("user-profile"),
        )

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "프로필 수정", description = "사용자 프로필 정보를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun updateProfile(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("프로필 수정 요청: userId={}, correlationId={}", userId, correlationId)

        updateProfileCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("프로필 수정 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "프로필이 성공적으로 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "비밀번호 변경", description = "사용자 비밀번호를 변경합니다. 현재 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "비밀번호 변경 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "401",
                description = "현재 비밀번호가 일치하지 않음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun changePassword(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("비밀번호 변경 요청: userId={}, correlationId={}", userId, correlationId)

        changePasswordCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("비밀번호 변경 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "비밀번호가 성공적으로 변경되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "사용자 탈퇴", description = "사용자 계정을 삭제합니다. 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "사용자 탈퇴 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "401",
                description = "비밀번호가 일치하지 않음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema = Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun deleteUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 탈퇴 요청: userId={}, correlationId={}", userId, correlationId)

        deleteUserCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("사용자 탈퇴 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자 계정이 성공적으로 삭제되었습니다.",
                correlationId = correlationId,
            )

        return ResponseEntity.ok(response)
    }

    @PostMapping("/logout")
    @Operation(summary = "로그아웃", description = "현재 사용자 세션을 종료합니다. (토큰 기반 인증에서는 클라이언트 측 토큰 삭제로 처리)")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그아웃 요청 처리됨",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
        ],
    )
    fun logout(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그아웃 요청: correlationId={}", correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "로그아웃 요청이 처리되었습니다.",
                correlationId = correlationId,
            )
        response.add(
            linkTo(methodOn(UserCommandControllerV1::class.java).login(correlationId, LoginRequestV1("", ""))).withRel("login"),
        )

        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/ChangePasswordRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

// 주소 삭제 시 별도 요청 본문이 필요 없을 수 있으나, ktlint 규칙상 파일 생성
data class DeleteAddressRequestV1(
    // 필요한 필드가 있다면 추가
    val dummy: String? = null, // ktlint 회피용 임시 필드
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/LoginRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterUserRequestV1(
    @field:Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val password: String,
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateProfileRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/response/LoginResponseV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답")
data class LoginResponseV1(
    @Schema(description = "상태", example = "SUCCESS") val status: String,
    @Schema(description = "메시지", example = "로그인 성공") val message: String,
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val userId: String,
    @Schema(description = "액세스 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val accessToken: String,
    @Schema(description = "리프레시 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val refreshToken: String,
    @Schema(description = "상관 관계 ID", example = "correlationId-123") val correlationId: String,
) : RepresentationModel<LoginResponseV1>()

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/UserQueryControllerV1.kt =====
package com.restaurant.presentation.user.v1.query

import com.restaurant.application.user.handler.GetUserProfileQueryHandler
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.presentation.user.extensions.v1.response.toResponse
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 조회", description = "사용자 프로필 조회 API")
class UserQueryControllerV1(
    private val getUserProfileQueryHandler: GetUserProfileQueryHandler,
) {
    private val log = LoggerFactory.getLogger(UserQueryControllerV1::class.java)

    @GetMapping("/{userId}")
    @Operation(summary = "사용자 프로필 조회", description = "사용자 ID를 통해 프로필 정보를 조회합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 조회 성공",
                content = [Content(mediaType = "application/json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema =
                            io.swagger.v3.oas.annotations.media
                                .Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationId: String? = null,
    ): ResponseEntity<UserProfileResponseV1> {
        val finalCorrelationId =
            correlationId ?: java.util.UUID
                .randomUUID()
                .toString()
        log.debug("사용자 프로필 조회 요청, correlationId={}, userId={}", finalCorrelationId, userId)
        val query = GetUserProfileQuery(userId)
        val result = getUserProfileQueryHandler.handle(query, finalCorrelationId)
        val response = result.toResponse()
        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, finalCorrelationId)).withSelfRel(),
        )
        log.info("사용자 프로필 조회 성공, correlationId={}, userId={}", finalCorrelationId, userId)
        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/AddressResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/UserProfileResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import java.time.LocalDateTime

@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: LocalDateTime,
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: LocalDateTime,
) : RepresentationModel<UserProfileResponseV1>()

// ===== independent/outbox/application/build.gradle.kts =====
plugins {
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(platform("org.springframework.boot:spring-boot-dependencies:3.3.2"))

    // Core dependencies
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.slf4j:slf4j-api:2.0.12")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.springframework:spring-tx")
    implementation("org.springframework:spring-web")
    implementation("org.springframework:spring-context")
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("jakarta.validation:jakarta.validation-api")

    // Test dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.mockito:mockito-core")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.2.1")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.springframework:spring-test")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
        jvmTarget = "21"
    }
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxPoller.kt =====
package com.restaurant.independent.outbox.application

import com.restaurant.independent.outbox.application.error.OutboxException
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.OutboxMessageSenderPort
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox 메시지를 주기적으로 폴링하여 처리하는 컴포넌트.
 */
@Component
class OutboxPoller(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSenderPort,
    @Value("\${outbox.polling.max-retries:3}")
    private val maxRetries: Int = 3,
    @Value("\${outbox.polling.batch-size:100}")
    private val batchSize: Int = 100,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * 대기 중인 메시지를 처리합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어합니다.
     */
    @Scheduled(fixedDelayString = "\${outbox.polling.interval:1000}")
    @Transactional
    fun pollMessages() {
        try {
            // PENDING 상태의 메시지를 조회하고 처리
            val messages = outboxMessageRepository.findByStatus(OutboxMessageStatus.PENDING, batchSize)
            messages.forEach { message ->
                try {
                    processMessage(message)
                } catch (e: Exception) {
                    handleMessageProcessingError(message, e)
                }
            }

            // 실패한 메시지 중 재시도 가능한 것들을 처리
            val failedMessages = outboxMessageRepository.findByStatus(OutboxMessageStatus.FAILED, batchSize)
            failedMessages.forEach { message ->
                try {
                    if (message.retryCount < maxRetries) {
                        processMessage(message)
                    } else {
                        // 최대 재시도 횟수를 초과한 메시지는 DEAD_LETTERED 상태로 변경
                        outboxMessageRepository.updateStatus(
                            id = message.id,
                            newStatus = OutboxMessageStatus.DEAD_LETTERED,
                        )
                        log.warn("Message ${message.id} marked as dead-lettered after ${message.retryCount} retries")
                    }
                } catch (e: Exception) {
                    handleMessageProcessingError(message, e)
                }
            }
        } catch (e: Exception) {
            log.error("Error during message polling", e)
            throw OutboxException.PollingException(
                message = "Failed to poll messages: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 단일 메시지를 처리합니다.
     */
    private fun processMessage(message: OutboxMessage) {
        try {
            // 메시지를 PROCESSING 상태로 변경
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.PROCESSING,
            )

            // Kafka로 메시지 전송
            outboxMessageSender.send(message)

            // 전송 성공 시 SENT 상태로 변경
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.SENT,
            )

            log.info("Successfully processed message ${message.id}")
        } catch (e: Exception) {
            log.error("Failed to process message ${message.id}", e)
            throw OutboxException.MessageSendException(
                message = "Failed to send message to Kafka: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 메시지 처리 오류를 처리합니다.
     */
    private fun handleMessageProcessingError(
        message: OutboxMessage,
        error: Exception,
    ) {
        try {
            // 실패 상태로 변경하고 재시도 횟수 증가
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.FAILED,
                incrementRetry = true,
            )

            if (message.retryCount >= maxRetries) {
                log.error(
                    "Max retry count ($maxRetries) exceeded for message ${message.id}",
                    error,
                )
                throw OutboxException.MaxRetriesExceededException(
                    message = "Max retry count ($maxRetries) exceeded for message ${message.id}",
                    cause = error,
                )
            }

            log.warn(
                "Failed to process message ${message.id}, will retry later. Current retry count: ${message.retryCount}",
                error,
            )
        } catch (e: Exception) {
            log.error("Error while handling message processing failure for message ${message.id}", e)
            throw e
        }
    }
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/config/OutboxConfig.kt =====
package com.restaurant.independent.outbox.application.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import org.springframework.scheduling.annotation.EnableScheduling

/**
 * Outbox 모듈의 설정을 제공하는 설정 클래스.
 */
@Configuration
@EnableScheduling
@ConfigurationProperties(prefix = "outbox.polling")
class OutboxConfig {
    /**
     * 메시지 처리 배치 크기
     */
    var batchSize: Int = 100

    /**
     * 최대 재시도 횟수
     */
    var maxRetries: Int = 3

    /**
     * 대기 중인 메시지 폴링 간격 (밀리초)
     */
    var pendingMessagesInterval: Long = 5000

    /**
     * 실패한 메시지 폴링 간격 (밀리초)
     */
    var failedMessagesInterval: Long = 60000
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxErrorCode.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Outbox 모듈의 자체적인 에러 코드 정의
 * Rule 67, 80에 따라 common 모듈의 ErrorCode와 독립적으로 정의
 */
enum class OutboxErrorCode(
    val code: String,
    val message: String,
) {
    // Message 저장 관련 오류
    MESSAGE_SAVE_FAILED(
        code = "OUTBOX-001",
        message = "Failed to save outbox message",
    ),
    MESSAGE_SERIALIZATION_FAILED(
        code = "OUTBOX-002",
        message = "Failed to serialize outbox message",
    ),

    // Message 전송 관련 오류
    MESSAGE_SEND_FAILED(
        code = "OUTBOX-003",
        message = "Failed to send outbox message",
    ),
    MAX_RETRIES_EXCEEDED(
        code = "OUTBOX-004",
        message = "Maximum retry attempts exceeded for outbox message",
    ),

    // Polling 관련 오류
    POLLING_ERROR(
        code = "OUTBOX-005",
        message = "Error occurred during message polling",
    ),

    // 기타 시스템 오류
    UNEXPECTED_ERROR(
        code = "OUTBOX-999",
        message = "Unexpected error occurred in outbox processing",
    ),
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxException.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Outbox 모듈의 자체적인 예외 클래스 정의
 * Rule 67, 68, 80에 따라 common 모듈의 예외와 독립적으로 정의
 */
sealed class OutboxException(
    message: String,
    cause: Throwable? = null,
    val errorCode: OutboxErrorCode,
) : RuntimeException(message, cause) {
    /**
     * 메시지 저장 실패 예외
     */
    class MessageSaveException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SAVE_FAILED,
        )

    /**
     * 메시지 직렬화 실패 예외
     */
    class MessageSerializationException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SERIALIZATION_FAILED,
        )

    /**
     * 메시지 전송 실패 예외
     */
    class MessageSendException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SEND_FAILED,
        )

    /**
     * 최대 재시도 횟수 초과 예외
     */
    class MaxRetriesExceededException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MAX_RETRIES_EXCEEDED,
        )

    /**
     * 메시지 폴링 실패 예외
     */
    class PollingException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.POLLING_ERROR,
        )

    /**
     * 예상치 못한 시스템 오류 예외
     */
    class UnexpectedErrorException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.UNEXPECTED_ERROR,
        )
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxStorageException.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Exception thrown when outbox message storage operations fail.
 * This is a module-specific exception that does not depend on any domain exceptions.
 */
class OutboxStorageException : RuntimeException {
    /**
     * Creates a new OutboxStorageException with the specified error message.
     *
     * @param message The error message
     */
    constructor(message: String) : super(message)

    /**
     * Creates a new OutboxStorageException with the specified error message and cause.
     *
     * @param message The error message
     * @param cause The underlying cause of the failure
     */
    constructor(message: String, cause: Throwable) : super(message, cause)
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxMessageRepository.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.error.OutboxStorageException
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import java.util.UUID

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 * 이 인터페이스는 Outbox 메시지의 저장, 조회, 상태 업데이트 등의 작업을 정의합니다.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다.
     *
     * @param message 저장할 메시지
     * @return 저장된 메시지
     * @throws OutboxStorageException 저장 작업 실패 시
     */
    @Throws(OutboxStorageException::class)
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     * @return 저장된 메시지 목록
     * @throws OutboxStorageException 저장 작업 실패 시
     */
    @Throws(OutboxStorageException::class)
    fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage>

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: UUID): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어해야 합니다.
     *
     * @param status 조회할 메시지 상태
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다.
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID
     * @param newStatus 새로운 상태
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 시간 이전에 생성된 실패 상태의 메시지들을 조회합니다.
     *
     * @param maxRetries 최대 재시도 횟수
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>

    fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    fun countByStatus(status: OutboxMessageStatus): Long

    fun incrementRetryCount(id: UUID): OutboxMessage?

    /**
     * 특정 상태의 메시지들을 조회하고 즉시 처리 중 상태로 잠급니다.
     * 동시성 제어를 위해 사용됩니다.
     *
     * @param status 조회할 메시지 상태 (주로 PENDING)
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findAndLockPending(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxMessageSenderPort.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import java.util.concurrent.CompletableFuture

/**
 * Outbox 메시지 전송을 위한 Port 인터페이스 (Application Layer)
 */
interface OutboxMessageSenderPort {
    /**
     * 단일 Outbox 메시지를 비동기적으로 전송한다.
     * 실제 Kafka 전송 성공 여부는 Future를 통해 확인해야 한다.
     */
    fun send(message: OutboxMessage): CompletableFuture<*>
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxMessage.kt =====
package com.restaurant.independent.outbox.application.port.model

import java.time.Instant
import java.util.UUID

// Add import for OutboxMessageStatus
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus

/**
 * Represents a message to be stored in the outbox.
 * This is a technology-agnostic model that contains all necessary information for message delivery.
 *
 * @property id Unique identifier for the message
 * @property payload The serialized message content as a byte array
 * @property topic The target Kafka topic for message delivery
 * @property headers Additional message headers including correlationId, aggregateType, aggregateId, etc.
 * @property aggregateId Domain ID of the aggregate that generated the event (in string format)
 * @property aggregateType Type of the aggregate that generated the event
 * @property status Current status of the message
 * @property retryCount Number of retry attempts made
 * @property createdAt When the message was created
 * @property updatedAt When the message was last updated
 * @property lastAttemptTime When the last delivery attempt was made
 */
data class OutboxMessage(
    val id: UUID = UUID.randomUUID(),
    val payload: ByteArray,
    val topic: String,
    val headers: Map<String, String>,
    val aggregateId: String,
    val aggregateType: String,
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val createdAt: Instant = Instant.now(),
    val updatedAt: Instant = createdAt,
    val lastAttemptTime: Instant? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateId != other.aggregateId) return false
        if (aggregateType != other.aggregateType) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String =
        "OutboxMessage(" +
            "id=$id, " +
            "topic='$topic', " +
            "headers=$headers, " +
            "aggregateId='$aggregateId', " +
            "aggregateType='$aggregateType', " +
            "status=$status, " +
            "retryCount=$retryCount, " +
            "createdAt=$createdAt, " +
            "updatedAt=$updatedAt, " +
            "lastAttemptTime=$lastAttemptTime" +
            ")"
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxMessageStatus.kt =====
package com.restaurant.independent.outbox.application.port.model

/**
 * Outbox 메시지의 상태를 나타내는 enum
 */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,
}

// ===== independent/outbox/build.gradle.kts =====
plugins {
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.jpa") version "2.1.20"
    kotlin("plugin.allopen") version "2.1.20"
    // id("org.jlleitschuh.gradle.ktlint")
    // id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Avro plugin - Rule 106/109 위반으로 제거
}

group = "com.restaurant.independent"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
    // Confluent repository for Kafka Avro Serializer etc.
    maven { url = uri("https://packages.confluent.io/maven/") }
}

// Define versions
object Versions {
    const val SPRING_BOOT = "3.3.2"
    const val KOTLIN_LOGGING = "3.0.5"
    const val MOCKK = "1.13.9"
    const val SPRING_MOCKK = "4.0.2"
}

dependencies {
    // Spring Boot
    // implementation(platform("org.springframework.boot:spring-boot-dependencies:${Versions.SPRING_BOOT}"))
    // implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("io.confluent:kafka-avro-serializer:7.6.0") // Use a compatible version
    implementation("org.apache.avro:avro:1.11.3") // Use a compatible version

    // Kotlin
    // implementation("org.jetbrains.kotlin:kotlin-reflect")
    // implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    // implementation("com.fasterxml.jackson.module:jackson-module-kotlin")

    // Logging
    // implementation("io.github.microutils:kotlin-logging-jvm:${Versions.KOTLIN_LOGGING}")

    // Project Dependencies

    // Spring Boot Starters
    // implementation("org.springframework.boot:spring-boot-starter-validation") // Optional, as per instructions

    // Kafka & Avro
    // implementation("org.apache.avro:avro:$avroVersion")
    // implementation("io.confluent:kafka-avro-serializer:$kafkaAvroSerializerVersion")
    // implementation("io.confluent:kafka-schema-registry-client:$kafkaAvroSerializerVersion")

    // MapStruct (Optional - for DTO mapping, e.g., DomainEvent <-> Avro)
    // implementation("org.mapstruct:mapstruct:$mapstructVersion")
    // kapt("org.mapstruct:mapstruct-processor:$mapstructVersion")

    // Database (Test scope)
    testRuntimeOnly("com.h2database:h2")

    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("io.mockk:mockk:${Versions.MOCKK}")
    testImplementation("org.springframework.kafka:spring-kafka-test")
    testImplementation("com.ninja-squad:springmockk:${Versions.SPRING_MOCKK}")
    testImplementation("org.testcontainers:junit-jupiter")
    testImplementation("org.testcontainers:kafka")
    // Add Kotest dependencies if needed
    // testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    // testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
}

kotlin {
    jvmToolchain(21)
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// Configure Kotlin JPA plugin
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

noArg {
    annotation("jakarta.persistence.Entity")
}

// If using MapStruct, configure kapt
// kapt {
//    correctErrorTypes = true
// }

// ===== independent/outbox/infrastructure/build.gradle.kts =====
plugins {
    id("org.springframework.boot") version "3.3.2"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    kotlin("plugin.jpa") version "2.1.20"
    kotlin("plugin.allopen")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1"
}

dependencies {
    implementation(project(":independent:outbox:application"))

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("io.github.microutils:kotlin-logging-jvm:3.0.5")

    implementation("io.confluent:kafka-avro-serializer:7.6.0")
    implementation("org.apache.avro:avro:1.11.3")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.kafka:spring-kafka-test")
    testRuntimeOnly("com.h2database:h2")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs += "-Xjsr305=strict"
        jvmTarget = "21"
    }
}

tasks.bootJar {
    enabled = false
}

tasks.jar {
    enabled = true
}

allopen {
    annotations("jakarta.persistence.Entity", "jakarta.persistence.Embeddable", "jakarta.persistence.MappedSuperclass")
}

noArg {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

avro {
    createSetters = false
    fieldVisibility = "PRIVATE"
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/config/KafkaConfig.kt =====
package com.restaurant.independent.outbox.infrastructure.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

@Configuration
class KafkaConfig {
    @Value("\${spring.kafka.bootstrap-servers}")
    private lateinit var bootstrapServers: String

    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> {
        val configProps =
            mapOf(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                // 추가 설정
                ProducerConfig.ACKS_CONFIG to "all",
                ProducerConfig.RETRIES_CONFIG to 3,
                ProducerConfig.RETRY_BACKOFF_MS_CONFIG to 1000,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1,
            )
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(producerFactory())
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/entity/OutboxMessageEntity.kt =====
package com.restaurant.independent.outbox.infrastructure.entity

import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.Id
import jakarta.persistence.Table
import java.time.Instant
import java.util.UUID

/**
 * Outbox 메시지의 JPA 엔티티.
 */
@Entity
@Table(name = "outbox_messages")
data class OutboxMessageEntity(
    @Id
    val id: UUID,
    @Column(nullable = false)
    val payload: ByteArray,
    @Column(nullable = false)
    val topic: String,
    @Column(nullable = false)
    val headers: Map<String, String>,
    @Column(name = "aggregate_id", nullable = false)
    val aggregateId: String,
    @Column(name = "aggregate_type", nullable = false)
    val aggregateType: String,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    val status: OutboxMessageStatus,
    @Column(nullable = false)
    val retryCount: Int,
    @Column(nullable = false)
    val createdAt: Instant,
    @Column(nullable = false)
    val updatedAt: Instant,
    @Column(nullable = true)
    val lastAttemptTime: Instant?,
) {
    /**
     * ByteArray 필드가 포함된 엔티티의 equals/hashCode 구현
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessageEntity

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateId != other.aggregateId) return false
        if (aggregateType != other.aggregateType) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/error/OutboxErrorCode.kt =====
package com.restaurant.independent.outbox.infrastructure.error

/**
 * Outbox 모듈의 자체적인 에러 코드 정의
 * Rule 67, 80에 따라 common 모듈의 ErrorCode와 독립적으로 정의
 */
enum class OutboxErrorCode(
    val code: String,
    val message: String,
) {
    // Message 저장 관련 오류
    MESSAGE_SAVE_FAILED(
        code = "OUTBOX-001",
        message = "Failed to save outbox message",
    ),
    MESSAGE_SERIALIZATION_FAILED(
        code = "OUTBOX-002",
        message = "Failed to serialize outbox message",
    ),

    // Message 전송 관련 오류
    MESSAGE_SEND_FAILED(
        code = "OUTBOX-003",
        message = "Failed to send outbox message",
    ),
    MAX_RETRIES_EXCEEDED(
        code = "OUTBOX-004",
        message = "Maximum retry attempts exceeded for outbox message",
    ),

    // Polling 관련 오류
    POLLING_ERROR(
        code = "OUTBOX-005",
        message = "Error occurred during message polling",
    ),

    // 기타 시스템 오류
    UNEXPECTED_ERROR(
        code = "OUTBOX-999",
        message = "Unexpected error occurred in outbox processing",
    ),
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/error/OutboxException.kt =====
package com.restaurant.independent.outbox.infrastructure.error

/**
 * Outbox 모듈의 자체적인 예외 클래스 정의
 * Rule 67, 68, 80에 따라 common 모듈의 예외와 독립적으로 정의
 */
sealed class OutboxException(
    message: String,
    cause: Throwable? = null,
    val errorCode: OutboxErrorCode,
) : RuntimeException(message, cause) {
    /**
     * 메시지 저장 실패 예외
     */
    class MessageSaveException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SAVE_FAILED,
        )

    /**
     * 메시지 직렬화 실패 예외
     */
    class MessageSerializationException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SERIALIZATION_FAILED,
        )

    /**
     * 메시지 전송 실패 예외
     */
    class MessageSendException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SEND_FAILED,
        )

    /**
     * 최대 재시도 횟수 초과 예외
     */
    class MaxRetriesExceededException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MAX_RETRIES_EXCEEDED,
        )

    /**
     * 메시지 폴링 실패 예외
     */
    class PollingException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.POLLING_ERROR,
        )

    /**
     * 예상치 못한 시스템 오류 예외
     */
    class UnexpectedErrorException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.UNEXPECTED_ERROR,
        )
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/extensions/OutboxMessageExtensions.kt =====
package com.restaurant.independent.outbox.infrastructure.extensions

import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity

/**
 * OutboxMessage 모델과 OutboxMessageEntity 간의 변환을 위한 확장 함수들.
 */

/**
 * Converts an OutboxMessage domain model to an OutboxMessageEntity.
 */
fun OutboxMessage.toEntity(): OutboxMessageEntity =
    OutboxMessageEntity(
        id = this.id,
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

/**
 * Converts an OutboxMessageEntity to an OutboxMessage domain model.
 */
fun OutboxMessageEntity.toDomainModel(): OutboxMessage =
    OutboxMessage(
        id = this.id,
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/kafka/KafkaConfig.kt =====
package com.restaurant.independent.outbox.infrastructure.kafka

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Outbox 모듈의 Kafka 설정을 제공하는 설정 클래스.
 */
@Configuration
class KafkaConfig(
    @Value("\${spring.kafka.bootstrap-servers}")
    private val bootstrapServers: String,
    @Value("\${spring.kafka.producer.client-id}")
    private val clientId: String,
    @Value("\${spring.kafka.producer.acks}")
    private val acks: String,
    @Value("\${spring.kafka.producer.retries}")
    private val retries: Int,
    @Value("\${spring.kafka.producer.batch-size}")
    private val batchSize: Int,
    @Value("\${spring.kafka.producer.buffer-memory}")
    private val bufferMemory: Long,
    @Value("\${spring.kafka.producer.compression-type}")
    private val compressionType: String,
    @Value("\${spring.kafka.producer.max-in-flight-requests-per-connection}")
    private val maxInFlightRequestsPerConnection: Int,
    @Value("\${spring.kafka.producer.max-request-size}")
    private val maxRequestSize: Int,
    @Value("\${spring.kafka.producer.request-timeout-ms}")
    private val requestTimeoutMs: Int,
    @Value("\${spring.kafka.producer.enable-idempotence}")
    private val enableIdempotence: Boolean,
    @Value("\${spring.kafka.producer.properties.schema.registry.url:http://localhost:8081}")
    private val schemaRegistryUrl: String,
) {
    /**
     * Kafka Producer 설정을 생성합니다.
     */
    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> {
        val configProps =
            mutableMapOf<String, Any>(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.CLIENT_ID_CONFIG to clientId,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                ProducerConfig.ACKS_CONFIG to acks,
                ProducerConfig.RETRIES_CONFIG to retries,
                ProducerConfig.BATCH_SIZE_CONFIG to batchSize,
                ProducerConfig.BUFFER_MEMORY_CONFIG to bufferMemory,
                ProducerConfig.COMPRESSION_TYPE_CONFIG to compressionType,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to maxInFlightRequestsPerConnection,
                ProducerConfig.MAX_REQUEST_SIZE_CONFIG to maxRequestSize,
                ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG to requestTimeoutMs,
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG to enableIdempotence,
                ProducerConfig.TRANSACTION_TIMEOUT_CONFIG to 900000, // 15 minutes
                ProducerConfig.TRANSACTIONAL_ID_CONFIG to "outbox-tx-",
                "schema.registry.url" to schemaRegistryUrl,
            )

        return DefaultKafkaProducerFactory(configProps)
    }

    /**
     * KafkaTemplate을 생성합니다.
     */
    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(producerFactory())
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/kafka/OutboxMessageSender.kt =====
package com.restaurant.independent.outbox.infrastructure.kafka

import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity
import com.restaurant.independent.outbox.infrastructure.error.OutboxErrorCodes
import com.restaurant.independent.outbox.infrastructure.error.OutboxException
import org.apache.kafka.clients.producer.ProducerRecord
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Component

/**
 * Outbox 메시지를 Kafka로 전송하는 컴포넌트.
 */
@Component
class OutboxMessageSender(
    private val kafkaTemplate: KafkaTemplate<String, ByteArray>,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    fun send(message: OutboxMessageEntity) {
        try {
            val record =
                ProducerRecord(
                    message.topic,
                    null, // partition
                    message.aggregateId, // key
                    message.payload, // value
                    message.headers.map { (key, value) ->
                        org.apache.kafka.common.header.internals
                            .RecordHeader(key, value.toByteArray())
                    },
                )

            kafkaTemplate
                .send(record)
                .whenComplete { result, ex ->
                    if (ex != null) {
                        log.error("Failed to send message to Kafka. Topic: ${message.topic}, AggregateId: ${message.aggregateId}", ex)
                        throw OutboxException(
                            errorCode = OutboxErrorCodes.KAFKA_SEND_ERROR,
                            message = "Failed to send message to Kafka",
                            cause = ex,
                        )
                    } else {
                        log.debug("Successfully sent message to Kafka. Topic: ${message.topic}, Offset: ${result.recordMetadata.offset()}")
                    }
                }
        } catch (e: Exception) {
            log.error("Error while preparing Kafka message. Topic: ${message.topic}, AggregateId: ${message.aggregateId}", e)
            throw OutboxException(
                errorCode = OutboxErrorCodes.KAFKA_MESSAGE_PREPARATION_ERROR,
                message = "Error while preparing Kafka message",
                cause = e,
            )
        }
    }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/persistence/OutboxMessageRepositoryImpl.kt =====
package com.restaurant.independent.outbox.infrastructure.persistence

import com.restaurant.independent.outbox.application.error.OutboxStorageException
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.independent.outbox.infrastructure.repository.SpringDataJpaOutboxMessageRepository
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.util.UUID

/**
 * OutboxMessageRepository 인터페이스의 JPA 구현체.
 */
@Repository
class OutboxMessageRepositoryImpl(
    private val jpaOutboxMessageRepository: SpringDataJpaOutboxMessageRepository,
) : OutboxMessageRepository {
    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        try {
            val entity = jpaOutboxMessageRepository.save(message.toEntity())
            return entity.toDomainModel()
        } catch (e: Exception) {
            throw OutboxStorageException(
                message = "Failed to save outbox message: ${e.message}",
                cause = e,
            )
        }
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage> {
        try {
            val entities = jpaOutboxMessageRepository.saveAll(messages.map { it.toEntity() })
            return entities.map { it.toDomainModel() }
        } catch (e: Exception) {
            throw OutboxStorageException(
                message = "Failed to save outbox messages: ${e.message}",
                cause = e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: UUID): OutboxMessage? =
        jpaOutboxMessageRepository
            .findById(id)
            .map { it.toDomainModel() }
            .orElse(null)

    @Transactional(readOnly = true)
    override fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatusOrderByCreatedAtAsc(status, limit)
            .map { it.toDomainModel() }

    @Transactional
    override fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        val entity =
            jpaOutboxMessageRepository.findById(id).orElse(null)
                ?: return null

        val updatedEntity =
            entity.copy(
                status = newStatus,
                retryCount = if (incrementRetry) entity.retryCount + 1 else entity.retryCount,
                updatedAt = Instant.now(),
                lastAttemptTime = if (newStatus == OutboxMessageStatus.PROCESSING) Instant.now() else entity.lastAttemptTime,
            )

        return jpaOutboxMessageRepository.save(updatedEntity).toDomainModel()
    }

    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> {
        val entities = jpaOutboxMessageRepository.findAndLockByStatus(status, limit)
        entities.forEach { entity ->
            entity.status = OutboxMessageStatus.PROCESSING
            entity.updatedAt = Instant.now()
            entity.lastAttemptTime = Instant.now()
        }
        return jpaOutboxMessageRepository.saveAll(entities).map { it.toDomainModel() }
    }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long = jpaOutboxMessageRepository.countByStatus(status)

    @Transactional
    override fun incrementRetryCount(id: UUID): OutboxMessage? {
        val entity = jpaOutboxMessageRepository.findByIdOrNull(id) ?: return null
        entity.retryCount++
        entity.updatedAt = Instant.now()
        entity.lastAttemptTime = Instant.now()
        return jpaOutboxMessageRepository.save(entity).toDomainModel()
    }

    @Transactional(readOnly = true)
    override fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
                OutboxMessageStatus.FAILED,
                maxRetries,
                limit,
            ).map { it.toDomainModel() }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/persistence/SpringDataJpaOutboxMessageRepository.kt =====
package com.restaurant.independent.outbox.infrastructure.persistence

import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.util.UUID

/**
 * Outbox 메시지 엔티티를 위한 Spring Data JPA Repository 인터페이스.
 */
interface SpringDataJpaOutboxMessageRepository : JpaRepository<OutboxMessageEntity, UUID> {
    /**
     * 특정 상태의 메시지들을 조회합니다.
     */
    fun findByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessageEntity>

    /**
     * 특정 상태의 메시지들을 처리 중 상태로 업데이트하고 조회합니다.
     * 동시성 제어를 위해 SELECT FOR UPDATE SKIP LOCKED를 사용합니다.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        value = "SELECT o FROM OutboxMessageEntity o WHERE o.status = :status ORDER BY o.createdAt ASC LIMIT :limit",
        nativeQuery = false,
    )
    fun findAndLockByStatus(
        @Param("status") status: OutboxMessageStatus,
        @Param("limit") limit: Int,
    ): List<OutboxMessageEntity>

    /**
     * 특정 상태의 메시지 수를 조회합니다.
     */
    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 특정 재시도 횟수를 초과한 실패 상태의 메시지들을 조회합니다.
     */
    fun findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        retryCount: Int,
        limit: Int,
    ): List<OutboxMessageEntity>
}
