네, 알겠습니다. 각 시나리오의 단계들을 더 깊이 있게 구체화하여, 각 도메인의 역할과 이벤트 흐름을 더욱 명확하게 보여드리겠습니다.

---

### **온라인 배달 주문 서비스: 핵심 시나리오 (심층 구체화 및 이벤트 드리븐)**

**전제**: 각 도메인은 비즈니스 로직의 응집성을 가지고 독립적으로 운영됩니다. 도메인 간의 통신은 주로 비동기적인 이벤트 발행/구독 방식을 통해 이루어지며, 필요한 경우 동기적인 Query 호출을 사용합니다.

---

**시나리오 1: 사용자 온보딩 및 기본 정보 설정**

1.  **회원 가입 요청**:
    *   **사용자 행동**: 웹/앱에서 회원가입 페이지에 접속하여 이메일, 비밀번호, 닉네임 등을 입력하고 "가입하기" 버튼을 클릭한다.
    *   **`User` 도메인 (Command)**: `POST /api/v1/users/register` 요청을 수신한다. 입력값 유효성을 검증(이메일 형식, 비밀번호 강도, 이메일 중복 여부 등)하고, 새로운 `User` 엔티티를 생성하여 데이터베이스에 저장한다.
    *   **이벤트 발행**: `User` 도메인은 `userId`, `email`, `registeredAt` 등의 정보를 담아 **`UserRegisteredEvent`**를 발행한다.
2.  **계좌 자동 생성**:
    *   **`Account` 도메인 (Event Subscriber)**: `UserRegisteredEvent`를 구독한다.
    *   **`Account` 도메인 로직**: 이벤트로부터 `userId`를 추출하여 해당 `userId`에 대한 기본 `Account` 엔티티(예: 잔액 0, 기본 통화)를 생성하고 저장한다.
3.  **로그인**:
    *   **사용자 행동**: 이메일과 비밀번호를 입력하여 "로그인" 버튼을 클릭한다.
    *   **`User` 도메인 (Command)**: `POST /api/v1/users/login` 요청을 수신한다. 입력된 자격 증명을 검증하고, 성공 시 인증 토큰(JWT 등)을 발급하여 응답한다.
4.  **프로필 및 주소 등록**:
    *   **사용자 행동**: 로그인 후, 마이페이지에서 자신의 이름, 전화번호, 기본 배달 주소(도로명, 상세 주소, 우편번호 등)를 입력하고 저장한다.
    *   **`User` 도메인 (Command)**: `PUT /api/v1/users/{userId}/profile` 및 `POST /api/v1/users/{userId}/addresses` 요청을 수신한다. 입력된 프로필/주소 정보의 유효성을 검증하고, 해당 `User` 엔티티 및 `Address` 엔티티를 업데이트/생성한다.
    *   **이벤트 발행**: (선택적) `UserProfileUpdatedEvent`, `UserAddressRegisteredEvent` 등을 발행하여 다른 도메인(예: 알림, 통계)에 변경 사실을 알릴 수 있다.

**시나리오 2: 음식점 및 메뉴 탐색**

1.  **음식점 검색 및 목록 조회**:
    *   **사용자 행동**: 앱/웹 홈 화면에서 현재 위치를 기반으로 하거나, 특정 카테고리(예: "한식", "중식") 또는 검색어(예: "돈까스")를 입력하여 음식점 목록을 조회한다.
    *   **`Restaurant` 도메인 (Query)**: `GET /api/v1/restaurants?lat={lat}&lon={lon}&category={category}&query={query}` 요청을 수신한다. 조건에 맞는 `Restaurant` 엔티티들을 조회하여 이름, 평점, 예상 배달 시간, 최소 주문 금액 등 요약 정보를 반환한다.
2.  **음식점 상세 조회**:
    *   **사용자 행동**: 목록에서 특정 음식점을 선택하여 상세 페이지로 이동한다.
    *   **`Restaurant` 도메인 (Query)**: `GET /api/v1/restaurants/{restaurantId}` 요청을 수신한다. 해당 `Restaurant` 엔티티의 상세 정보(영업 시간, 상세 주소, 전화번호, 리뷰 요약 등)를 반환한다.
3.  **(필요 도메인: Menu) 메뉴 목록 조회**:
    *   **사용자 행동**: 음식점 상세 페이지에서 해당 음식점이 제공하는 메뉴들을 확인한다.
    *   **(Menu 도메인 Query)**: `GET /api/v1/restaurants/{restaurantId}/menus` 요청을 수신한다. 선택된 `Restaurant`의 모든 `Menu` 엔티티(이름, 가격, 설명, 이미지, 옵션 목록, 품절 여부)를 조회하여 반환한다.

**시나리오 3: 주문 생성 및 결제 처리**

1.  **주문 생성 요청**:
    *   **사용자 행동**: 장바구니에 담긴 메뉴들을 확인하고, 배달 주소 및 결제 수단을 선택한 후 "주문하기" 버튼을 클릭한다.
    *   **`Order` 도메인 (Command)**: `POST /api/v1/orders` 요청을 수신한다.
        *   **내부 검증 (Query)**:
            *   `Restaurant` 도메인에 해당 `restaurantId`가 유효하고 현재 영업 중인지, 최소 주문 금액을 만족하는지 동기적으로 확인한다.
            *   `Menu` 도메인에 `orderItems`로 전달된 `menuId`와 `optionId`들이 유효하고 품절이 아닌지, 가격이 일치하는지 동기적으로 확인한다.
            *   `User` 도메인에 `deliveryAddressId`가 해당 `userId`에 속하는 유효한 주소인지 동기적으로 확인한다.
        *   **로직**: 모든 검증이 통과되면, `totalAmount`, `deliveryFee`, `finalAmount` 등을 계산하고, `Order` 엔티티를 `CREATED` 상태로 데이터베이스에 저장한다. `OrderItem` 엔티티들도 함께 저장된다.
    *   **이벤트 발행**: 생성된 `Order`의 핵심 정보(예: `orderId`, `userId`, `restaurantId`, `finalAmount`, `paymentMethodId`, `deliveryAddress`)를 담아 **`OrderCreatedEvent`**를 발행한다.
2.  **결제 프로세스 시작**:
    *   **`Payment` 도메인 (Event Subscriber)**: **`OrderCreatedEvent`**를 구독한다.
    *   **`Payment` 도메인 로직**: 이벤트로부터 `orderId`, `userId`, `finalAmount`, `paymentMethodId` 등을 추출하여 외부 결제 게이트웨이(PG사)에 실제 결제 승인을 요청한다. PG사 응답을 기다린다.
3.  **결제 결과 발행**:
    *   **`Payment` 도메인 (Callback Handler)**: PG사로부터 결제 성공/실패 콜백을 수신한다. `Payment` 엔티티의 상태를 `APPROVED` 또는 `FAILED`로 업데이트한다.
    *   **이벤트 발행**: 결제 결과에 따라 **`PaymentApprovedEvent`** (포함: `paymentId`, `orderId`, `transactionId`, `amount`) 또는 **`PaymentFailedEvent`** (포함: `orderId`, `reason`)를 발행한다.
4.  **주문 상태 업데이트**:
    *   **`Order` 도메인 (Event Subscriber)**: **`PaymentApprovedEvent`** 또는 **`PaymentFailedEvent`**를 구독한다.
    *   **`Order` 도메인 로직**: `PaymentApprovedEvent`를 받으면, `Order` 엔티티의 `status`를 'PAID'로 업데이트하고, `paymentId`를 연결한다. `PaymentFailedEvent`를 받으면, `status`를 'PAYMENT_FAILED'로 업데이트한다.
5.  **결제 완료 알림**:
    *   **`Order` 도메인 (Event Publisher)**: `Order` 엔티티의 `status`가 'PAID'로 변경되면 (즉, `PaymentApprovedEvent`를 처리한 후), **`OrderPaidEvent`** (포함: `orderId`, `userId`, `restaurantId`, `totalAmount`, `deliveryAddress`)를 발행한다. 이 이벤트는 주문이 이제 배달 및 음식점 처리를 시작할 준비가 되었음을 알린다.

**시나리오 4: 음식점의 주문 접수 및 조리**

1.  **새 주문 알림**:
    *   **`Restaurant` 도메인 (Event Subscriber)**: **`OrderPaidEvent`**를 구독한다.
    *   **`Restaurant` 도메인 로직**: 이벤트로부터 `restaurantId`를 확인하고, 해당 음식점의 점주에게 새로운 주문이 들어왔음을 실시간으로 알림(푸시 알림, 대시보드 업데이트 등)을 보낸다.
2.  **주문 접수 및 `OrderAcceptedEvent` 발행**:
    *   **음식점 점주 행동**: 새로운 주문을 확인하고, 주문을 접수할지 거절할지 결정한다.
    *   **`Restaurant` 도메인 (Command)**: 점주가 "주문 접수" 버튼을 클릭하면, `PATCH /api/v1/restaurants/{restaurantId}/orders/{orderId}/accept` 요청을 수신한다. 주문을 접수 상태로 변경하고, 예상 조리 시간 등을 업데이트한다.
    *   **이벤트 발행**: `orderId`, `restaurantId`, `estimatedPreparationTime` 등을 담아 **`OrderAcceptedEvent`**를 발행한다.
3.  **주문 상태 업데이트 (접수 완료)**:
    *   **`Order` 도메인 (Event Subscriber)**: **`OrderAcceptedEvent`**를 구독한다.
    *   **`Order` 도메인 로직**: `Order` 엔티티의 `status`를 'ACCEPTED'로 변경하고, `acceptedTime`과 `deliveryExpectedTime`을 업데이트한다.
4.  **조리 완료 및 `OrderPreparedEvent` 발행**:
    *   **음식점 점주 행동**: 음식이 모두 조리되면, "조리 완료" 버튼을 클릭한다.
    *   **`Restaurant` 도메인 (Command)**: `PATCH /api/v1/restaurants/{restaurantId}/orders/{orderId}/prepared` 요청을 수신한다.
    *   **이벤트 발행**: `orderId`, `restaurantId` 등을 담아 **`OrderPreparedEvent`**를 발행한다.

**시나리오 5: 배달 진행 및 완료**

1.  **배달 요청 생성 트리거**:
    *   **`Delivery` 도메인 (Event Subscriber)**: **`OrderPreparedEvent`**를 구독한다.
    *   **`Delivery` 도메인 로직**: 이벤트로부터 `orderId`, `restaurantId`, `deliveryAddress` 등을 추출하여 새로운 `Delivery` 엔티티를 생성하고 `PENDING` 상태로 저장한다.
    *   **이벤트 발행**: `deliveryId`, `orderId`, `pickupLocation`, `deliveryLocation` 등을 담아 **`DeliveryRequestedEvent`**를 발행한다.
2.  **배달원 할당 및 `DeliveryAssignedEvent` 발행**:
    *   **`Delivery` 도메인 로직**: `DeliveryRequestedEvent`를 처리하거나 별도의 배차 로직을 통해 적합한 `DeliveryPerson`을 찾아 `deliveryId`에 할당한다. `Delivery` 엔티티의 `status`를 'ASSIGNED'로 변경한다.
    *   **이벤트 발행**: `deliveryId`, `orderId`, `deliveryPersonId` 등을 담아 **`DeliveryAssignedEvent`**를 발행한다.
3.  **음식 픽업 및 `DeliveryPickedUpEvent` 발행**:
    *   **배달원 행동**: 음식점에 도착하여 음식을 픽업한 후, 배달원 앱에서 "픽업 완료" 버튼을 클릭한다.
    *   **`Delivery` 도메인 (Command)**: `PATCH /api/v1/deliveries/{deliveryId}/status` (상태: `PICKED_UP`) 요청을 수신한다. `Delivery` 엔티티의 `status`를 'PICKED_UP'으로 변경하고 `pickupTime`을 기록한다.
    *   **이벤트 발행**: `deliveryId`, `orderId`, `pickupTime` 등을 담아 **`DeliveryPickedUpEvent`**를 발행한다.
4.  **배달 완료 및 `DeliveryCompletedEvent` 발행**:
    *   **배달원 행동**: 사용자에게 음식을 전달한 후, 배달원 앱에서 "배달 완료" 버튼을 클릭한다.
    *   **`Delivery` 도메인 (Command)**: `PATCH /api/v1/deliveries/{deliveryId}/status` (상태: `DELIVERED`) 요청을 수신한다. `Delivery` 엔티티의 `status`를 'DELIVERED'로 변경하고 `deliveryTime`을 기록한다.
    *   **이벤트 발행**: `deliveryId`, `orderId`, `deliveryTime` 등을 담아 **`DeliveryCompletedEvent`**를 발행한다.
5.  **주문 상태 최종 업데이트**:
    *   **`Order` 도메인 (Event Subscriber)**: **`DeliveryCompletedEvent`**를 구독한다.
    *   **`Order` 도메인 로직**: `Order` 엔티티의 `status`를 'DELIVERED'로 최종 업데이트하고, `deliveryCompletedTime`을 기록한다.

**시나리오 6: 주문 및 결제 내역 조회**

1.  **주문 내역 조회**:
    *   **사용자 행동**: 마이페이지에서 자신의 과거/현재 주문 목록을 확인한다.
    *   **`Order` 도메인 (Query)**: `GET /api/v1/users/{userId}/orders` 요청을 수신한다. 해당 `userId`의 모든 `Order` 엔티티를 조회하여 간략한 목록을 반환한다. (필터링, 페이지네이션 가능)
2.  **결제 내역 조회**:
    *   **사용자 행동**: 마이페이지에서 자신의 결제 내역을 확인한다.
    *   **`Payment` 도메인 (Query)**: `GET /api/v1/users/{userId}/payments` 요청을 수신한다. 해당 `userId`의 모든 `Payment` 엔티티를 조회하여 목록을 반환한다.
3.  **특정 주문/결제/배달 상세 조회**:
    *   **사용자 행동**: 특정 주문, 결제 또는 배달의 상세 정보를 확인하기 위해 해당 항목을 클릭한다.
    *   **각 도메인 (Query)**:
        *   `GET /api/v1/orders/{orderId}`: `Order` 도메인이 상세 주문 정보(주문 항목, 최종 금액, 상태 등)를 반환한다.
        *   `GET /api/v1/payments/{paymentId}`: `Payment` 도메인이 상세 결제 정보(결제 수단, 거래 ID, 승인 시간 등)를 반환한다.
        *   `GET /api/v1/orders/{orderId}/delivery-status` (또는 `GET /api/v1/deliveries/{deliveryId}`): `Delivery` 도메인이 해당 주문의 배달 상태 및 배달원 정보를 반환한다.

**시나리오 7: 주문 취소 및 환불**

1.  **주문 취소 요청**:
    *   **사용자 행동**: 주문 상세 페이지에서 "주문 취소" 버튼을 클릭한다. (또는 음식점/관리자가 취소를 요청할 수 있다.)
    *   **`Order` 도메인 (Command)**: `POST /api/v1/orders/{orderId}/cancel` 요청을 수신한다. 현재 주문 상태가 취소 가능한지 검증한다. (예: 이미 배달 완료된 주문은 취소 불가)
    *   **로직**: `Order` 엔티티의 `status`를 'CANCELED'로 변경한다.
    *   **이벤트 발행**: `orderId`, `userId`, `restaurantId`, `amountToRefund`, `cancelReason` 등을 담아 **`OrderCanceledEvent`**를 발행한다.
2.  **결제 환불 요청 트리거**:
    *   **`Payment` 도메인 (Event Subscriber)**: **`OrderCanceledEvent`**를 구독한다.
    *   **`Payment` 도메인 로직**: 이벤트로부터 `orderId`와 `amountToRefund`를 추출하여 해당 주문과 연결된 `Payment` 엔티티를 찾고, 외부 PG사에 환불을 요청한다.
3.  **환불 결과 발행**:
    *   **`Payment` 도메인 (Callback Handler)**: PG사로부터 환불 성공/실패 콜백을 수신한다. `Payment` 엔티티의 `status`를 'REFUNDED' 또는 'REFUND_FAILED'로 업데이트한다.
    *   **이벤트 발행**: 환불 결과에 따라 **`PaymentRefundedEvent`** (포함: `paymentId`, `orderId`, `refundAmount`) 또는 **`PaymentRefundFailedEvent`**를 발행한다.
4.  **주문 상태 최종 업데이트**:
    *   **`Order` 도메인 (Event Subscriber)**: **`PaymentRefundedEvent`**를 구독한다.
    *   **`Order` 도메인 로직**: `Order` 엔티티의 `status`를 'REFUNDED'로 최종 업데이트한다.
5.  **배달 취소**:
    *   **`Delivery` 도메인 (Event Subscriber)**: **`OrderCanceledEvent`**를 구독한다.
    *   **`Delivery` 도메인 로직**: 이벤트로부터 `orderId`를 확인하고, 해당 주문에 대한 배달이 현재 진행 중이라면 이를 취소한다. (예: 배달원에게 알림, `Delivery` 엔티티 상태를 'CANCELED'로 변경)
    *   **이벤트 발행**: (선택적) `DeliveryCanceledEvent`를 발행할 수 있다.

---