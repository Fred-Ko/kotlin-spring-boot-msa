Starting a Gradle Daemon, 1 incompatible Daemon could not be reused, use --status for details
> Task :buildSrc:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :buildSrc:compileKotlin UP-TO-DATE
> Task :buildSrc:compileJava NO-SOURCE
> Task :buildSrc:compileGroovy NO-SOURCE
> Task :buildSrc:pluginDescriptors UP-TO-DATE
> Task :buildSrc:processResources NO-SOURCE
> Task :buildSrc:classes UP-TO-DATE
> Task :buildSrc:jar UP-TO-DATE
> Task :apps:user-app:clean
> Task :independent:outbox:clean
> Task :domains:common:application:clean
> Task :domains:common:domain:clean
> Task :domains:common:infrastructure:clean
> Task :domains:common:presentation:clean
> Task :domains:user:application:clean
> Task :domains:user:domain:clean
> Task :domains:user:infrastructure:clean
> Task :domains:user:presentation:clean

BUILD SUCCESSFUL in 6s
13 actionable tasks: 10 executed, 3 up-to-date
모듈들의 전체 코드가 첨부되어있다.
코드를 보면 불완전 한 부분도 있고 규칙을 지키지 않는 부분도 있다.
따라서 코드에 기준으로 작업을 완료하려고 하면 완성이 안될꺼다. 왜냐하면 코드가 정말 엉망이기 떄문이다. 어떤 요구사항인지 잘생각해서 수정계획을 해야한다.
그래서 이를 수정하기 위한 작업 지시서가 필요하다. 작업 지시서를 만들어라.
- tree 구조를 보고 규칙에 맞지않는 부분을 찾아서 삭제할 파일, 이동할 파일에 대한 작업지시서는 최우선이다. 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 규칙을 지키지 않는 부분에 대한 작업지시서를 작성하라
- 프로그램이 정상적으로 동작하기위해 추가적으로 작업해야하는 작업지시서를 작성하라
- 작업지시서는 단계가 명확하게 표현되어야 한다. 하지만 작업의 순서를 잘생각해서 먼저되어야 하는건 꼭 먼저하도록 단계를 잘 생각하라.
- build.gradle.kts는 최상위 파일에 공통부분을 최대한 모아놓고 각 모듈별로 필요한 부분은 모듈 내부에 작성한다.
- 작업지시서에서는 Gradle 의존성에 대한 버전에 대해서 지적하지 않는다. 모두 최신버전으로 팀내에서 직접 관리하는 영역이다.
- 필요없는 파일은 삭제하도록 지시하라.
- 필요없는 코드는 주석보단 삭제를 하도록 지시하라.
- 현재 코드를 유지하는 경우는 작업지시서에 굳이 명시하지 않아도 된다.
- 작업지시서는 ~을 확인해라. 같은 모호한 문장은 절대로 안된다. ~을 어떻게 고쳐라 같이 매우 명시적이여야 한다.
- 작업지시서는 어떤 파일이 어떤 부분이 잘못작성되었고 어떻게 고쳐야한다. 그리고 근거는 무엇이다 라는 명시적 문장이 있어야 한다.
- 작업지시서에 코드 레벨을 너무 자세하게 설명하지 않아도 된다.
- 작업지시서 제일 하단에는 모든 작업이 끝나고 확인해야할 체크리스트를 작성한다.
- ktlint 는 사용하지 않는다. (현재 단계에서는 그 어떤 린트도 제외)

작업 지시서에 항상 상단에 첨부할 문구
```
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.

작업시 항상 기억해야할 규칙
- 파일을 수정할때는 import 구문이 완벽한지 한번씩 더 체크하도록 한다. 만약 확인이 필요하다면 다른 파일을 조회할 수 있다.
- 작업을 진행하는 도중에 작업지시서에 없는 수정사항은 일단 보류하고 작업지시서를 최우선으로 수정한다.
- 이런식의 참조는 금지한다. ( ex -> event: com.restaurant.domains.common.domain.event.DomainEvent ) 항상 import 구문을 추가해서 참조하도록 한다.
- com.restaurant.domains.common.* 과 같은 import는 절대로 금지한다.
- 공통으로 수정해야할 패턴이 확실하다면 커맨드 명령어로 한번에 처리한다. 단, 프로젝트 내부에 build,bin 같은 제외할 경로는 명확히 명시한다.
- 필요없는 코드는 주석처리 하지 말고 삭제하도록 하라.
- 파일을 생성 할때는 위치가 올바른지 확인하기 위해서 파일 구조도를 참고하도록 한다.
- 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 의존성 버전은 항상 tools 이용해서 최신 스테이블 버전을 활용하도록 한다.
- 확인하고 싶은 디렉토리 구조가 있다면 tree 명령어로 최대한 효율적이게 진행하라. 단 bin,build 는 제외한다.
- 패키지나 폴더 경로에 in은 예약어이니 input이나 이런걸로 피하라.
```

====================================================================n

> Task :buildSrc:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :buildSrc:compileKotlin UP-TO-DATE
> Task :buildSrc:compileJava NO-SOURCE
> Task :buildSrc:compileGroovy NO-SOURCE
> Task :buildSrc:pluginDescriptors UP-TO-DATE
> Task :buildSrc:processResources NO-SOURCE
> Task :buildSrc:classes UP-TO-DATE
> Task :buildSrc:jar UP-TO-DATE
> Task :independent:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:check
> Task :apps:user-app:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :apps:user-app:processResources
> Task :independent:outbox:processResources
> Task :domains:common:application:processResources NO-SOURCE
> Task :domains:common:domain:processResources NO-SOURCE
> Task :domains:common:infrastructure:processResources NO-SOURCE
> Task :domains:common:presentation:processResources NO-SOURCE
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:presentation:processResources NO-SOURCE
> Task :apps:user-app:check
> Task :domains:user:domain:check
> Task :domains:user:infrastructure:check
> Task :domains:user:presentation:check
> Task :independent:outbox:check
> Task :domains:common:domain:compileKotlin
> Task :domains:common:domain:compileJava NO-SOURCE
> Task :domains:common:domain:classes UP-TO-DATE
> Task :domains:common:domain:jar
> Task :domains:common:application:compileKotlin
> Task :domains:common:application:compileJava NO-SOURCE
> Task :domains:common:application:classes UP-TO-DATE
> Task :domains:common:application:jar
> Task :domains:common:infrastructure:compileKotlin
> Task :domains:common:infrastructure:compileJava NO-SOURCE
> Task :domains:common:infrastructure:classes UP-TO-DATE
> Task :domains:common:infrastructure:jar
> Task :independent:outbox:compileKotlin
> Task :independent:outbox:compileJava NO-SOURCE
> Task :independent:outbox:classes
> Task :independent:outbox:jar
> Task :independent:outbox:assemble
> Task :independent:outbox:build
> Task :domains:user:domain:compileKotlin
> Task :domains:user:domain:compileJava NO-SOURCE
> Task :domains:user:domain:classes UP-TO-DATE
> Task :domains:user:domain:jar
> Task :domains:user:domain:assemble
> Task :domains:user:domain:build

> Task :domains:user:application:compileKotlin FAILED
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetAddressByIdQueryHandler.kt:17:62 Return type of 'getAddressById' is not a subtype of the return type of the overridden member 'fun getAddressById(query: GetAddressByIdQuery): Address' defined in 'com/restaurant/user/application/query/usecase/GetAddressByIdUseCase'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserAddressesQueryHandler.kt:13:1 Class 'GetUserAddressesQueryHandler' is not abstract and does not implement abstract member 'getUserAddresses'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserAddressesQueryHandler.kt:16:5 'getUserAddresses' overrides nothing. Potential signatures for overriding:
fun getUserAddresses(query: <ERROR TYPE REF: Symbol not found for GetAllAddressesQuery>): List<Address>
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserProfileQueryHandler.kt:14:1 Class 'GetUserProfileQueryHandler' is not abstract and does not implement abstract member 'getUserProfile'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserProfileQueryHandler.kt:18:5 'getUserProfile' overrides nothing. Potential signatures for overriding:
fun getUserProfile(query: <ERROR TYPE REF: Symbol not found for GetUserProfileQuery>): UserProfileDto
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAllAddressesUseCase.kt:3:50 Unresolved reference 'GetAllAddressesQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAllAddressesUseCase.kt:10:32 Unresolved reference 'GetAllAddressesQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetProfileByIdUseCase.kt:3:50 Unresolved reference 'GetProfileByIdQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetProfileByIdUseCase.kt:10:31 Unresolved reference 'GetProfileByIdQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserAddressesUseCase.kt:3:50 Unresolved reference 'GetAllAddressesQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserAddressesUseCase.kt:10:33 Unresolved reference 'GetAllAddressesQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserProfileUseCase.kt:3:50 Unresolved reference 'GetUserProfileQuery'.
e: file:///Users/junhoko/Documents/Fredko/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserProfileUseCase.kt:10:31 Unresolved reference 'GetUserProfileQuery'.

> Task :domains:common:presentation:compileKotlin

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':domains:user:application:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 15s
17 actionable tasks: 14 executed, 3 up-to-date


==============================================================
 Gradle Build Completed: 2025-06-09 22:05:17 
==============================================================


==============================================================

# Project Structure

domains
├── common
│   ├── application
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── application
│   │                               ├── dto
│   │                               │   ├── Command.kt
│   │                               │   └── Query.kt
│   │                               ├── exception
│   │                               │   └── ApplicationException.kt
│   │                               └── usecase
│   │                                   ├── CommandUseCase.kt
│   │                                   └── QueryUseCase.kt
│   ├── domain
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── domain
│   │                               ├── aggregate
│   │                               │   └── AggregateRoot.kt
│   │                               ├── error
│   │                               │   ├── CommonSystemErrorCode.kt
│   │                               │   └── ErrorCode.kt
│   │                               ├── event
│   │                               │   └── DomainEvent.kt
│   │                               └── exception
│   │                                   └── DomainException.kt
│   ├── infrastructure
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── infrastructure
│   │                               └── entity
│   │                                   └── BaseEntity.kt
│   └── presentation
│       ├── build.gradle.kts
│       └── src
│           └── main
│               └── kotlin
│                   └── com
│                       └── restaurant
│                           └── common
│                               └── presentation
│                                   ├── config
│                                   │   ├── OpenApiConfig.kt
│                                   │   └── PasswordEncoderConfig.kt
│                                   ├── dto
│                                   │   └── response
│                                   │       └── CommandResultResponse.kt
│                                   └── GlobalExceptionHandler.kt
└── user
    ├── application
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── application
    │                               ├── command
    │                               │   ├── dto
    │                               │   │   ├── ChangePasswordCommand.kt
    │                               │   │   ├── DeleteAddressCommand.kt
    │                               │   │   ├── DeleteUserCommand.kt
    │                               │   │   ├── LoginCommand.kt
    │                               │   │   ├── RegisterAddressCommand.kt
    │                               │   │   ├── RegisterUserCommand.kt
    │                               │   │   ├── UpdateAddressCommand.kt
    │                               │   │   └── UpdateProfileCommand.kt
    │                               │   ├── handler
    │                               │   │   ├── ChangePasswordCommandHandler.kt
    │                               │   │   ├── DeleteAddressCommandHandler.kt
    │                               │   │   ├── DeleteUserCommandHandler.kt
    │                               │   │   ├── LoginCommandHandler.kt
    │                               │   │   ├── RegisterAddressCommandHandler.kt
    │                               │   │   ├── RegisterUserCommandHandler.kt
    │                               │   │   ├── UpdateAddressCommandHandler.kt
    │                               │   │   └── UpdateProfileCommandHandler.kt
    │                               │   └── usecase
    │                               │       ├── ChangePasswordUseCase.kt
    │                               │       ├── DeleteAddressUseCase.kt
    │                               │       ├── DeleteUserUseCase.kt
    │                               │       ├── LoginUseCase.kt
    │                               │       ├── RegisterAddressUseCase.kt
    │                               │       ├── RegisterUserUseCase.kt
    │                               │       ├── UpdateAddressUseCase.kt
    │                               │       └── UpdateProfileUseCase.kt
    │                               ├── error
    │                               │   └── UserApplicationErrorCode.kt
    │                               ├── exception
    │                               │   └── UserApplicationException.kt
    │                               └── query
    │                                   ├── dto
    │                                   │   ├── AddressDto.kt
    │                                   │   ├── GetAddressByIdQuery.kt
    │                                   │   ├── GetUserAddressesQuery.kt
    │                                   │   ├── GetUserProfileByIdQuery.kt
    │                                   │   ├── LoginResult.kt
    │                                   │   └── UserProfileDto.kt
    │                                   ├── handler
    │                                   │   ├── GetAddressByIdQueryHandler.kt
    │                                   │   ├── GetUserAddressesQueryHandler.kt
    │                                   │   └── GetUserProfileQueryHandler.kt
    │                                   └── usecase
    │                                       ├── GetAddressByIdUseCase.kt
    │                                       ├── GetAllAddressesUseCase.kt
    │                                       ├── GetProfileByIdUseCase.kt
    │                                       ├── GetUserAddressesUseCase.kt
    │                                       └── GetUserProfileUseCase.kt
    ├── domain
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── domain
    │                               ├── aggregate
    │                               │   └── User.kt
    │                               ├── entity
    │                               │   └── Address.kt
    │                               ├── error
    │                               │   └── UserDomainErrorCodes.kt
    │                               ├── event
    │                               │   └── UserEvent.kt
    │                               ├── exception
    │                               │   └── UserDomainException.kt
    │                               ├── repository
    │                               │   └── UserRepository.kt
    │                               └── vo
    │                                   ├── AddressId.kt
    │                                   ├── Email.kt
    │                                   ├── Name.kt
    │                                   ├── Password.kt
    │                                   ├── PhoneNumber.kt
    │                                   ├── UserId.kt
    │                                   ├── Username.kt
    │                                   ├── UserStatus.kt
    │                                   └── UserType.kt
    ├── infrastructure
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           ├── kotlin
    │           │   └── com
    │           │       └── restaurant
    │           │           └── user
    │           │               └── infrastructure
    │           │                   ├── entity
    │           │                   │   ├── AddressEntity.kt
    │           │                   │   └── UserEntity.kt
    │           │                   ├── mapper
    │           │                   │   ├── AddressEntityMapper.kt
    │           │                   │   ├── DomainEventToOutboxMessageConverter.kt
    │           │                   │   └── UserEntityMapper.kt
    │           │                   └── repository
    │           │                       ├── SpringDataJpaUserRepository.kt
    │           │                       └── UserRepositoryImpl.kt
    │           └── resources
    │               └── schemas
    └── presentation
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── user
                                └── presentation
                                    └── v1
                                        ├── command
                                        │   ├── controller
                                        │   │   ├── UserAddressController.kt
                                        │   │   └── UserController.kt
                                        │   ├── dto
                                        │   │   └── request
                                        │   │       ├── ChangePasswordRequestV1.kt
                                        │   │       ├── DeleteUserRequestV1.kt
                                        │   │       ├── LoginRequestV1.kt
                                        │   │       ├── RegisterAddressRequestV1.kt
                                        │   │       ├── RegisterUserRequestV1.kt
                                        │   │       ├── UpdateAddressRequestV1.kt
                                        │   │       └── UpdateProfileRequestV1.kt
                                        │   └── extensions
                                        │       └── dto
                                        │           └── request
                                        │               └── UserCommandRequestExtensions.kt
                                        └── query
                                            ├── controller
                                            │   ├── UserAddressQueryController.kt
                                            │   └── UserQueryController.kt
                                            ├── dto
                                            │   ├── request
                                            │   └── response
                                            │       ├── AddressDetailResponseV1.kt
                                            │       ├── AddressResponseV1.kt
                                            │       ├── LoginResponseV1.kt
                                            │       └── UserProfileResponseV1.kt
                                            └── extensions
                                                └── dto
                                                    ├── request
                                                    └── response
                                                        ├── UserAddressQueryResponseExtensions.kt
                                                        └── UserQueryResponseExtensions.kt
independent
└── outbox
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── outbox
            │               ├── application
            │               │   ├── dto
            │               │   │   ├── OutboxMessage.kt
            │               │   │   ├── OutboxMessageRepository.kt
            │               │   │   └── OutboxMessageStatus.kt
            │               │   ├── handler
            │               │   │   ├── OutboxMetricsHandler.kt
            │               │   │   ├── OutboxPoller.kt
            │               │   │   └── ProcessOutboxEventsUseCaseHandler.kt
            │               │   └── usecase
            │               │       └── ProcessOutboxEventsUseCase.kt
            │               └── infrastructure
            │                   ├── config
            │                   │   └── OutboxKafkaConfig.kt
            │                   ├── converter
            │                   │   └── StringMapConverter.kt
            │                   ├── entity
            │                   │   └── OutboxEventEntity.kt
            │                   ├── error
            │                   │   └── OutboxErrorCodes.kt
            │                   ├── exception
            │                   │   └── OutboxException.kt
            │                   ├── extensions
            │                   │   └── OutboxEventEntityExtensions.kt
            │                   ├── messaging
            │                   │   └── OutboxMessageSender.kt
            │                   └── repository
            │                       ├── JpaOutboxEventRepository.kt
            │                       ├── JpaOutboxMessageRepository.kt
            │                       └── OutboxMessageRepositoryImpl.kt
            └── resources
                └── db
                    └── migration
apps
└── user-app
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── apps
            │               └── user
            │                   ├── config
            │                   │   ├── KafkaConfig.kt
            │                   │   └── SerializationConfig.kt
            │                   └── UserApplication.kt
            └── resources
gradle
└── wrapper

154 directories, 125 files
==============================================================




====================================================================
 File: apps/user-app/build.gradle.kts
 Path: apps/user-app/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    id("org.springframework.boot") version "3.5.0"
    id("io.spring.dependency-management")
}

extra["springCloudVersion"] = "2023.0.1" // Spring Cloud 2023.0.1 is compatible with Spring Boot 3.2.x

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

// Force kotlinx-serialization versions before dependencies
configurations.all {
    resolutionStrategy {
        force("org.jetbrains.kotlinx:kotlinx-serialization-core:1.8.1")
        force("org.jetbrains.kotlinx:kotlinx-serialization-core-jvm:1.8.1")
        force("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.1")
        force("org.jetbrains.kotlinx:kotlinx-serialization-json-jvm:1.8.1")

        eachDependency {
            if (requested.group == "org.jetbrains.kotlinx" && requested.name.contains("serialization")) {
                if (requested.name.contains("bom")) {
                    // Skip BOM entirely
                    return@eachDependency
                }
                useVersion("1.8.1")
            }
        }
    }

    // Spring Cloud Function is required for StreamBridge to work properly
    // Previously excluded but needed for StreamBridge
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.cloud:spring-cloud-dependencies:${property("springCloudVersion")}")
    }
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":domains:common:infrastructure"))
    implementation(project(":domains:common:presentation"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:user:presentation"))
    implementation(project(":independent:outbox"))

    // Spring Boot Starters
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-actuator")

    // Spring Cloud Stream with Function
    implementation("org.springframework.cloud:spring-cloud-stream")
    implementation("org.springframework.cloud:spring-cloud-stream-binder-kafka")
    implementation("org.springframework.cloud:spring-cloud-stream-binder-kafka-streams")
    implementation("org.springframework.cloud:spring-cloud-function-context")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // Database
    runtimeOnly("org.postgresql:postgresql")
    runtimeOnly("com.h2database:h2")
    implementation("org.flywaydb:flyway-core")

    // Resilience4j
    implementation("io.github.resilience4j:resilience4j-kotlin")
    implementation("io.github.resilience4j:resilience4j-spring-boot3")

    // UUID Generator
    implementation("com.fasterxml.uuid:java-uuid-generator:5.1.0")
    implementation("io.confluent:kafka-avro-serializer:7.5.0")
    // implementation("io.confluent:kafka-json-schema-serializer:7.5.0")
    implementation("com.github.avro-kotlin.avro4k:avro4k-core:2.3.0")

    // SpringDoc OpenAPI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.6")

    // Jackson for JSON processing
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")

    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    implementation("org.jetbrains.kotlin:kotlin-stdlib")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.1")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.8.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.1")

    // Swagger Annotations
    implementation("io.swagger.core.v3:swagger-annotations-jakarta:2.2.31")
    implementation("org.webjars:swagger-ui:5.22.0")

    // Test Dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
    }
    testImplementation("org.springframework.security:spring-security-test")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:postgresql:1.21.0")
    testImplementation("org.testcontainers:kafka:1.21.0")
    testImplementation("org.awaitility:awaitility:4.2.1")
    testImplementation("org.springframework.kafka:spring-kafka-test")
}

tasks.bootJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.bootRun {
    jvmArgs = listOf(
        "-Xmx1024m",
        "-Xms512m",
        "-XX:MaxMetaspaceSize=256m",
        "-XX:+UseG1GC",
        "-XX:+HeapDumpOnOutOfMemoryError"
    )
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/KafkaConfig.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/KafkaConfig.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.apps.user.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

@Configuration
class KafkaConfig {
    @Value("\${spring.kafka.bootstrap-servers}")
    private lateinit var bootstrapServers: String

    @Value("\${spring.kafka.producer.properties.acks:all}")
    private lateinit var producerAcks: String

    @Bean
    fun stringProducerFactory(): ProducerFactory<String, String> {
        val configProps: MutableMap<String, Any> = HashMap()
        configProps[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = bootstrapServers
        configProps[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java
        configProps[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java
        configProps[ProducerConfig.ACKS_CONFIG] = producerAcks
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun stringKafkaTemplate(): KafkaTemplate<String, String> = KafkaTemplate(stringProducerFactory())
}

====================================================================


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/SerializationConfig.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/SerializationConfig.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.apps.user.config

import kotlinx.serialization.json.Json
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SerializationConfig {
    @Bean
    fun kotlinJson(): Json =
        Json {
            // 필요한 경우 kotlinx.serialization.json.Json 설정을 추가합니다.
            // 예: ignoreUnknownKeys = true, prettyPrint = false 등
            // 현재 UserEvent.kt의 kotlinx.serialization 어노테이션과 호환되도록 기본 설정을 사용합니다.
            // UserEvent의 @SerialName 등이 스키마와 일치하는지 중요합니다.
            isLenient = true // JSON 포맷이 조금 유연해야 할 경우
            ignoreUnknownKeys = true // 스키마에 없는 키가 있어도 무시
            // explicitNulls = false // null 값을 명시적으로 보내지 않을 경우 (스키마 호환성 확인 필요)
        }
}

====================================================================


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
/**
 * UserApplication entry point for the user service.
 *
 * Configures component scanning and enables scheduling for Outbox Poller.
 *
 * @author junoko
 */
package com.restaurant.apps.user

import org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication(
    exclude = [
        SecurityAutoConfiguration::class,
        UserDetailsServiceAutoConfiguration::class,
        ManagementWebSecurityAutoConfiguration::class,
    ],
)
// Scan components in config, user.presentation, user.application, user.infra, outbox
@ComponentScan(
    basePackages = [
        "com.restaurant.common.presentation",
        "com.restaurant.user.presentation",
        "com.restaurant.user.application",
        "com.restaurant.user.infrastructure",
        "com.restaurant.apps.user.config",
        "com.restaurant.outbox.application",
        "com.restaurant.outbox.infrastructure",
    ],
)
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.user.infrastructure.repository",
        "com.restaurant.outbox.infrastructure.repository",
    ],
)
@EntityScan(
    basePackages = [
        "com.restaurant.user.infrastructure.entity",
        "com.restaurant.outbox.infrastructure.entity",
    ],
)
@EnableScheduling // Outbox Poller 활성화
open class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

====================================================================


====================================================================
 File: build.gradle.kts
 Path: build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
/**
 * build.gradle.kts for the root project.
 *
 * Configures plugins, dependency management, and global build settings.
 *
 * @author junoko
 */

buildscript {
    repositories {
        gradlePluginPortal()
        maven("https://packages.confluent.io/maven/")
    }
}

plugins {
    // Only versions are declared here for subprojects
    kotlin("jvm") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.spring") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.jpa") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.allopen") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.serialization") version "2.1.0" apply false
    id("org.springframework.boot") version "3.5.0" apply false
    id("io.spring.dependency-management") version "1.1.7" apply false
    id("com.github.imflog.kafka-schema-registry-gradle-plugin") version "2.3.2" apply false
}


====================================================================


====================================================================
 File: domains/common/application/build.gradle.kts
 Path: domains/common/application/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
    id("org.springframework.boot") version "3.5.0"
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
    dependencies {
        dependency("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
        dependency("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
        dependency("io.github.resilience4j:resilience4j-spring-boot3:2.3.0")
        dependency("io.github.resilience4j:resilience4j-kotlin:2.3.0")
        dependency("org.springframework.boot:spring-boot-starter:3.5.0")
        dependency("org.springframework.boot:spring-boot-starter-validation:3.5.0")
        dependency("org.springframework.boot:spring-boot-starter-test:3.5.0")
        dependency("io.mockk:mockk:1.14.2")
        dependency("org.junit.jupiter:junit-jupiter:5.13.0-M3")
        dependency("org.assertj:assertj-core:4.0.0-M1")
    }
}

dependencies {
    implementation(project(":domains:common:domain"))
    
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.3.0")
    implementation("io.github.resilience4j:resilience4j-kotlin:2.3.0")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk")
    testImplementation("org.junit.jupiter:junit-jupiter")
    testImplementation("org.assertj:assertj-core")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.jar {
    enabled = true
}
tasks.bootJar {
    enabled = false
}

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Command.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Command.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.application.dto

interface Command

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Query.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Query.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.application.dto

interface Query

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.application.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom application exceptions.
 * Represents errors occurring in the application layer (e.g., use case execution failures).
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class ApplicationException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this application exception.
     */
    abstract val errorCode: ErrorCode
}

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/CommandUseCase.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/CommandUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.application.usecase

import com.restaurant.common.application.dto.Command

interface CommandUseCase<COMMAND : Command, RESULT> {
    fun execute(command: COMMAND): RESULT
}

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/QueryUseCase.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/QueryUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.application.usecase

import com.restaurant.common.application.dto.Query

interface QueryUseCase<QUERY : Query, RESULT> {
    fun execute(query: QUERY): RESULT
}

====================================================================


====================================================================
 File: domains/common/domain/build.gradle.kts
 Path: domains/common/domain/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0"
    kotlin("plugin.allopen") version "2.1.0"
    kotlin("plugin.serialization") version "2.1.0"
    id("io.spring.dependency-management")
    id("org.springframework.boot") version "3.5.0"
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.1.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-core:1.8.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.1")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")
    implementation("jakarta.validation:jakarta.validation-api:3.1.1")
    implementation("com.fasterxml.uuid:java-uuid-generator:5.1.0")

    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.jar {
    enabled = true
}
tasks.bootJar {
    enabled = false
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

/**
 * Base class for all Aggregate Roots.
 * Provides methods to manage domain events.
 * Rule 17, 18
 */
abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    /**
     * Returns the list of recorded domain events.
     */
    open fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    /**
     * Clears the list of recorded domain events.
     */
    open fun clearDomainEvents() {
        domainEvents.clear()
    }

    /**
     * Adds a domain event to the list of recorded events.
     * This method is protected to ensure it's only called within the Aggregate implementation.
     */
    protected fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.domain.error

/**
 * Common system-level error codes.
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    INTERNAL_SERVER_ERROR("COMMON-SYSTEM-001", "Internal server error"),
    INVALID_REQUEST("COMMON-SYSTEM-002", "Invalid request"),
    RESOURCE_NOT_FOUND("COMMON-SYSTEM-003", "Resource not found"),
    UNAUTHORIZED("COMMON-SYSTEM-004", "Unauthorized"),
    FORBIDDEN("COMMON-SYSTEM-005", "Forbidden"),
    VALIDATION_ERROR("COMMON-SYSTEM-006", "Validation error"),
    CONFLICT("COMMON-SYSTEM-007", "Conflict"),
    TOO_MANY_REQUESTS("COMMON-SYSTEM-008", "Too many requests"),
    SERVICE_UNAVAILABLE("COMMON-SYSTEM-009", "Service unavailable"),
    OPTIMISTIC_LOCK_ERROR("COMMON-SYSTEM-010", "Optimistic lock error"),
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.domain.error

/**
 * Base interface for all error codes in the system.
 * Error codes should follow the format: {DOMAIN}-{LAYER}-{CODE}
 */
interface ErrorCode {
    /**
     * The unique code for this error.
     * Format: {DOMAIN}-{LAYER}-{CODE}
     * Example: USER-DOMAIN-001, USER-APP-002
     */
    val code: String

    /**
     * A human-readable message describing this error.
     */
    val message: String
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.domain.event

import java.time.Instant
import java.util.UUID

/**
 * Base interface for domain events. (Rule 32)
 */
interface DomainEvent {
    val eventId: UUID
    val occurredAt: Instant
    val aggregateId: String
    val aggregateType: String
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.domain.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom domain exceptions.
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class DomainException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    abstract val errorCode: ErrorCode
}

====================================================================


====================================================================
 File: domains/common/infrastructure/build.gradle.kts
 Path: domains/common/infrastructure/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    kotlin("plugin.serialization") version "2.1.0"
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

tasks.named("bootJar") {
    enabled = false
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0") // JPA 어노테이션 사용 목적
    implementation("org.springframework.kafka:spring-kafka:4.0.0-M2")

    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("org.springframework.kafka:spring-kafka-test:4.0.0-M2")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.testcontainers:testcontainers:1.21.0")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:kafka:1.21.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/entity/BaseEntity.kt
 Path: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/entity/BaseEntity.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.infrastructure.entity

import jakarta.persistence.Column
import jakarta.persistence.MappedSuperclass
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import java.time.Instant

/**
 * Base entity class for JPA entities providing common fields like
 * creation and update timestamps.
 */
@MappedSuperclass
abstract class BaseEntity {
    @Column(name = "created_at", nullable = false, updatable = false)
    var createdAt: Instant = Instant.now()
        protected set

    @Column(name = "updated_at", nullable = false)
    var updatedAt: Instant = Instant.now()
        protected set

    @PrePersist
    protected fun onCreate() {
        createdAt = Instant.now()
        updatedAt = Instant.now()
    }

    @PreUpdate
    protected fun onUpdate() {
        updatedAt = Instant.now()
    }
}

====================================================================


====================================================================
 File: domains/common/presentation/build.gradle.kts
 Path: domains/common/presentation/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework.boot:spring-boot-starter-web:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")

    // implementation("org.springframework.boot:spring-boot-starter-security:3.2.3") // Spring Security 추가
    implementation("org.springframework.security:spring-security-crypto:6.5.0") // PasswordEncoder만 사용
    // JPA는 presentation 레이어에서 직접 사용하지 않지만, 예외 처리를 위해 compileOnly로 추가
    compileOnly("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7") // Kotlin Logging 추가

    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/OpenApiConfig.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/OpenApiConfig.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.presentation.config

import io.swagger.v3.oas.models.Components
import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Contact
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.info.License
import io.swagger.v3.oas.models.security.SecurityRequirement
import io.swagger.v3.oas.models.security.SecurityScheme
import io.swagger.v3.oas.models.servers.Server
import io.swagger.v3.oas.models.tags.Tag
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class OpenApiConfig {
    @Bean
    fun openAPI(): OpenAPI =
        OpenAPI()
            .info(
                Info()
                    .title("Restaurant User Service API")
                    .description(
                        """
                        ## 사용자 관리 서비스 API
                        
                        이 API는 레스토랑 플랫폼의 사용자 관리 기능을 제공합니다.
                        
                        ### 주요 기능
                        - 사용자 회원가입 및 로그인
                        - 사용자 프로필 관리
                        - 사용자 주소 관리
                        - 비밀번호 변경 및 계정 삭제
                        
                        ### 인증 방식
                        JWT Bearer Token을 사용합니다. 로그인 후 받은 accessToken을 Authorization 헤더에 포함시켜 주세요.
                        
                        ### 오류 응답
                        모든 오류 응답은 RFC 9457 ProblemDetail 형식을 따릅니다.
                        
                        ### API 버전 관리
                        - v1: 현재 안정 버전
                        - CQRS 패턴 적용: Command(생성/수정/삭제)와 Query(조회) 분리
                        """.trimIndent(),
                    ).version("1.0.0")
                    .contact(
                        Contact()
                            .name("Restaurant Development Team")
                            .email("dev@restaurant.com")
                            .url("https://restaurant.com"),
                    ).license(
                        License()
                            .name("MIT License")
                            .url("https://opensource.org/licenses/MIT"),
                    ),
            ).servers(
                listOf(
                    Server()
                        .url("http://localhost:8090")
                        .description("개발 서버 (Local)"),
                    Server()
                        .url("https://dev-api.restaurant.com")
                        .description("개발 환경 (Development)"),
                    Server()
                        .url("https://staging-api.restaurant.com")
                        .description("스테이징 환경 (Staging)"),
                    Server()
                        .url("https://api.restaurant.com")
                        .description("운영 환경 (Production)"),
                ),
            ).components(
                Components()
                    .addSecuritySchemes(
                        "bearerAuth",
                        SecurityScheme()
                            .type(SecurityScheme.Type.HTTP)
                            .scheme("bearer")
                            .bearerFormat("JWT")
                            .description("JWT Bearer Token 인증"),
                    ),
            ).security(
                listOf(
                    SecurityRequirement().addList("bearerAuth"),
                ),
            ).tags(
                listOf(
                    Tag().name("Health Check").description("애플리케이션 상태 확인 API"),
                    Tag().name("Simple").description("간단한 테스트 API"),
                    Tag().name("User Commands").description("사용자 계정 관리 API (생성/수정/삭제)"),
                    Tag().name("User Queries").description("사용자 정보 조회 API"),
                    Tag().name("User Address Commands").description("사용자 주소 관리 API (생성/수정/삭제)"),
                    Tag().name("User Address Queries").description("사용자 주소 조회 API"),
                ),
            )
}

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/PasswordEncoderConfig.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/PasswordEncoderConfig.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.presentation.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder

@Configuration
class PasswordEncoderConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()
}

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.presentation.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Command 요청 결과 응답")
data class CommandResultResponse(
    @Schema(description = "처리 상태", example = "SUCCESS")
    val status: String,
    @Schema(description = "결과 메시지", example = "요청이 성공적으로 처리되었습니다.")
    val message: String,
    @Schema(description = "생성/수정된 리소스의 ID (선택적)", example = "a1b2c3d4-e5f6-7890-1234-567890abcdef", nullable = true)
    val resourceId: String? = null // 필요에 따라 추가
)

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.common.presentation

import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.common.domain.error.CommonSystemErrorCode
import com.restaurant.common.domain.error.ErrorCode
import com.restaurant.common.domain.exception.DomainException
import com.restaurant.outbox.infrastructure.error.OutboxErrorCodes
import com.restaurant.outbox.infrastructure.exception.OutboxException
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.persistence.OptimisticLockException
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import java.net.URI
import java.time.Instant

private val log = KotlinLogging.logger {}

@RestControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValidException(
        ex: MethodArgumentNotValidException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.VALIDATION_ERROR
        log.error(ex) { "Validation failed, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.bindingResult.fieldErrors.joinToString(", ") { it.defaultMessage ?: "" }
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleHttpMessageNotReadableException(
        ex: HttpMessageNotReadableException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INVALID_REQUEST
        log.error(ex) { "Invalid request, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.message ?: "Invalid request body"
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException::class)
    fun handleMethodArgumentTypeMismatchException(
        ex: MethodArgumentTypeMismatchException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INVALID_REQUEST
        log.error(ex) { "Invalid argument type, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = "Parameter '${ex.name}' has invalid value: '${ex.value}'"
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = ex.errorCode
        log.error(ex) { "Domain exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(
        ex: ApplicationException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = ex.errorCode
        log.error(ex) { "Application exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(OptimisticLockException::class)
    fun handleOptimisticLockException(
        ex: OptimisticLockException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.OPTIMISTIC_LOCK_ERROR
        log.error(ex) { "Optimistic lock exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.CONFLICT)
        problemDetail.title = "Optimistic Lock Error"
        problemDetail.detail = "The resource you are trying to update has been modified by another transaction. Please try again."
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(IllegalArgumentException::class)
    fun handleIllegalArgumentException(
        ex: IllegalArgumentException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INVALID_REQUEST
        log.error(ex) { "Illegal argument exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST)
        problemDetail.title = "Bad Request"
        problemDetail.detail = ex.message ?: "Invalid argument provided."
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(OutboxException::class)
    fun handleOutboxException(
        ex: OutboxException,
        request: HttpServletRequest,
    ): ProblemDetail {
        log.error(ex) { "Outbox exception occurred, errorCode=${ex.errorCode.code}" }
        // OutboxErrorCodes를 기반으로 HttpStatus 직접 결정
        val httpStatus = determineHttpStatusFromOutboxErrorCode(ex.errorCode)
        val problemDetail = ProblemDetail.forStatus(httpStatus)
        problemDetail.title = ex.errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", ex.errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    // 새로운 private 함수 추가 (OutboxErrorCodes 전용 HttpStatus 결정 로직)
    private fun determineHttpStatusFromOutboxErrorCode(errorCode: OutboxErrorCodes): HttpStatus =
        when (errorCode) {
            OutboxErrorCodes.MESSAGE_NOT_FOUND -> HttpStatus.NOT_FOUND
            OutboxErrorCodes.KAFKA_SEND_FAILED,
            OutboxErrorCodes.MESSAGE_PROCESSING_FAILED,
            OutboxErrorCodes.DATABASE_ERROR,
            OutboxErrorCodes.SERIALIZATION_ERROR,
            OutboxErrorCodes.DATABASE_OPERATION_FAILED,
            OutboxErrorCodes.UNEXPECTED_INFRA_ERROR,
            -> HttpStatus.INTERNAL_SERVER_ERROR
            OutboxErrorCodes.MAX_RETRIES_EXCEEDED -> HttpStatus.SERVICE_UNAVAILABLE
            OutboxErrorCodes.INVALID_MESSAGE_STATUS -> HttpStatus.BAD_REQUEST
        }

    @ExceptionHandler(Exception::class)
    fun handleAllExceptions(
        ex: Exception,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INTERNAL_SERVER_ERROR
        log.error(ex) { "An unexpected error occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR)
        problemDetail.title = "Internal Server Error"
        problemDetail.detail = "An unexpected error occurred. Please try again later."
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    private fun determineHttpStatusFromErrorCode(errorCode: ErrorCode): HttpStatus =
        when (errorCode) {
            is CommonSystemErrorCode ->
                when (errorCode) {
                    CommonSystemErrorCode.VALIDATION_ERROR, CommonSystemErrorCode.INVALID_REQUEST -> HttpStatus.BAD_REQUEST
                    CommonSystemErrorCode.RESOURCE_NOT_FOUND -> HttpStatus.NOT_FOUND
                    CommonSystemErrorCode.UNAUTHORIZED -> HttpStatus.UNAUTHORIZED
                    CommonSystemErrorCode.FORBIDDEN -> HttpStatus.FORBIDDEN
                    CommonSystemErrorCode.CONFLICT, CommonSystemErrorCode.OPTIMISTIC_LOCK_ERROR -> HttpStatus.CONFLICT
                    CommonSystemErrorCode.TOO_MANY_REQUESTS -> HttpStatus.TOO_MANY_REQUESTS
                    CommonSystemErrorCode.SERVICE_UNAVAILABLE -> HttpStatus.SERVICE_UNAVAILABLE
                    else -> HttpStatus.INTERNAL_SERVER_ERROR
                }

            // OutboxErrorCodes는 별도의 determineHttpStatusFromOutboxErrorCode 함수에서 처리
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }

    private fun setCommonProblemProperties(
        problemDetail: ProblemDetail,
        request: HttpServletRequest,
    ) {
        problemDetail.type = URI.create("https://errors.restaurant.com/${problemDetail.properties?.get("errorCode")}")
        problemDetail.instance = URI.create(request.requestURI)
        problemDetail.setProperty("timestamp", Instant.now())
    }
}

====================================================================


====================================================================
 File: domains/user/application/build.gradle.kts
 Path: domains/user/application/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

dependencies {
    implementation("io.github.microutils:kotlin-logging-jvm:4.0.0-beta-2")
    implementation("org.springframework.security:spring-security-crypto:6.5.0")
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework:spring-tx:7.0.0-M5") // 트랜잭션 의존성 추가
    implementation("org.springframework.boot:spring-boot-starter:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.3.0")
    implementation("io.github.resilience4j:resilience4j-kotlin:2.3.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

// Remove explicit task dependencies to avoid circular dependency
tasks.named("compileKotlin") {
    mustRunAfter(tasks.named("processResources"))
}

tasks.named("compileTestKotlin") {
    mustRunAfter(tasks.named("processTestResources"))
}

// Ensure test tasks use JUnit Platform
tasks.withType<Test> {
    useJUnitPlatform()
}

// Make jar task enabled
tasks.withType<Jar> {
    enabled = true
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/ChangePasswordCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/ChangePasswordCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteAddressCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteUserCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

import jakarta.validation.constraints.NotBlank

data class DeleteUserCommand(
    val userId: String,
    val reason: String? = null,
    @field:NotBlank(message = "비밀번호 확인은 필수입니다.")
    val password: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/LoginCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/LoginCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

data class LoginCommand(
    val email: String,
    val password: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterAddressCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

data class RegisterAddressCommand(
    val userId: String,
    val name: String,
    val street: String,
    val detail: String,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterUserCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size
import jakarta.validation.constraints.Email as JakartaEmail

/**
 * Command DTO for registering a new user.
 * Rule App-Struct (dto/command)
 */
data class RegisterUserCommand(
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:JakartaEmail(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    val phoneNumber: String? = null,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateAddressCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val name: String,
    val street: String,
    val detail: String,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateProfileCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateProfileCommand.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.dto

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
    val phoneNumber: String?,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/ChangePasswordCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/ChangePasswordCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.ChangePasswordCommand
import com.restaurant.user.application.command.usecase.ChangePasswordUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : ChangePasswordUseCase {
    @Transactional
    override fun changePassword(command: ChangePasswordCommand) {
        try {
            val userId = UserId.ofString(command.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(command.userId)

            val currentPassword = Password.of(command.currentPassword)
            val encodedNewPassword = passwordEncoder.encode(command.newPassword)
            val newPassword = Password.of(encodedNewPassword)
            val updatedUser = user.changePassword(currentPassword, newPassword)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid password data format: ${iae.message}", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to change password due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteAddressCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.DeleteAddressCommand
import com.restaurant.user.application.command.usecase.DeleteAddressUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) : DeleteAddressUseCase {
    @Transactional
    override fun deleteAddress(command: DeleteAddressCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.deleteAddress(addressIdVo)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to delete address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteUserCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.DeleteUserCommand
import com.restaurant.user.application.command.usecase.DeleteUserUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
) : DeleteUserUseCase {
    @Transactional
    override fun deleteUser(command: DeleteUserCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.withdraw()

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to delete user due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/LoginCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/LoginCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.LoginCommand
import com.restaurant.user.application.command.usecase.LoginUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.LoginResult
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : LoginUseCase {
    @Transactional(readOnly = true)
    override fun login(command: LoginCommand): LoginResult {
        try {
            val emailVo = Email.of(command.email)
            val user =
                userRepository.findByEmail(emailVo)
                    ?: throw UserDomainException.User.InvalidCredentials(command.email)

            if (!passwordEncoder.matches(command.password, user.password.value)) {
                throw UserDomainException.User.InvalidCredentials(command.email)
            }

            val accessToken = "dummy-access-token"
            val refreshToken = "dummy-refresh-token"

            return LoginResult(
                id = user.id.value.toString(),
                username = user.username.value,
                accessToken = accessToken,
                refreshToken = refreshToken,
            )
        } catch (de: UserDomainException.User.InvalidCredentials) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid email or password format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Login failed due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterAddressCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.RegisterAddressCommand
import com.restaurant.user.application.command.usecase.RegisterAddressUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) : RegisterAddressUseCase {
    @Transactional
    override fun registerAddress(command: RegisterAddressCommand): AddressId {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val addressId = AddressId.generate()
            val address =
                Address.create(
                    addressId = addressId,
                    name = command.name,
                    streetAddress = command.street,
                    detailAddress = command.detail,
                    city = command.city,
                    state = command.state,
                    country = command.country,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )
            val updatedUser = user.addAddress(address)
            userRepository.save(updatedUser)

            return updatedUser.addresses.first { it.addressId == address.addressId }.addressId
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to register address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterUserCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.RegisterUserCommand
import com.restaurant.user.application.command.usecase.RegisterUserUseCase
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.UserType
import com.restaurant.user.domain.vo.Username
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : RegisterUserUseCase {
    @Transactional
    override fun register(command: RegisterUserCommand): UserId {
        val username = Username.of(command.username)
        val email = Email.of(command.email)
        val name = Name.of(command.name)
        val password = Password.of(passwordEncoder.encode(command.password))
        val phoneNumberVo = command.phoneNumber?.let { PhoneNumber.of(it) }
        val user =
            User.create(
                id = UserId.generate(),
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumberVo,
                userType = UserType.CUSTOMER,
            )
        userRepository.save(user)
        return user.id
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateAddressCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.UpdateAddressCommand
import com.restaurant.user.application.command.usecase.UpdateAddressUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) : UpdateAddressUseCase {
    @Transactional
    override fun updateAddress(command: UpdateAddressCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser =
                user.updateAddress(
                    addressId = addressIdVo,
                    name = Name.of(command.name),
                    streetAddress = command.street,
                    detailAddress = command.detail,
                    city = command.city,
                    state = command.state,
                    country = command.country,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to update address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateProfileCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateProfileCommandHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.UpdateProfileCommand
import com.restaurant.user.application.command.usecase.UpdateProfileUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) : UpdateProfileUseCase {
    @Transactional
    override fun updateProfile(command: UpdateProfileCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val name = Name.of(command.name)
            val phoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }

            val updatedUser = user.updateProfile(name, phoneNumber)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid input format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to update profile due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/ChangePasswordUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/ChangePasswordUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.ChangePasswordCommand

interface ChangePasswordUseCase {
    fun changePassword(command: ChangePasswordCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteAddressUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.DeleteAddressCommand

/**
 * 주소 삭제 유스케이스 인터페이스
 */
interface DeleteAddressUseCase {
    fun deleteAddress(command: DeleteAddressCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteUserUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.DeleteUserCommand

/**
 * 사용자 삭제 유스케이스 인터페이스
 */
interface DeleteUserUseCase {
    fun deleteUser(command: DeleteUserCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/LoginUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/LoginUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.LoginCommand
import com.restaurant.user.application.query.dto.LoginResult

/**
 * 로그인 유스케이스 인터페이스
 */
interface LoginUseCase {
    fun login(command: LoginCommand): LoginResult
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterAddressUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.RegisterAddressCommand
import com.restaurant.user.domain.vo.AddressId

/**
 * 주소 등록 유스케이스 인터페이스
 */
interface RegisterAddressUseCase {
    fun registerAddress(command: RegisterAddressCommand): AddressId
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterUserUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.RegisterUserCommand
import com.restaurant.user.domain.vo.UserId

/**
 * 사용자 등록 유스케이스 인터페이스
 */
interface RegisterUserUseCase {
    fun register(command: RegisterUserCommand): UserId
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateAddressUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.UpdateAddressCommand

/**
 * 주소 업데이트 유스케이스 인터페이스
 */
interface UpdateAddressUseCase {
    fun updateAddress(command: UpdateAddressCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateProfileUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.UpdateProfileCommand

/**
 * 프로필 업데이트 유스케이스 인터페이스
 */
interface UpdateProfileUseCase {
    fun updateProfile(command: UpdateProfileCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    BAD_REQUEST("USER-APPLICATION-001", "Bad request received by application."),
    INVALID_INPUT("USER-APPLICATION-002", "Invalid input provided to application."),
    AUTHENTICATION_FAILED("USER-APPLICATION-003", "Authentication failed."),
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-004", "External service communication error."),
    UNEXPECTED_ERROR("USER-APPLICATION-500", "An unexpected error occurred in the application."),
    USER_NOT_FOUND_BY_EMAIL("USER-APPLICATION-005", "User not found by email"),
    INVALID_CREDENTIALS("USER-APPLICATION-006", "Invalid username or password"),
    USER_INACTIVE("USER-APPLICATION-007", "User account is inactive"),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.exception

import com.restaurant.common.domain.error.ErrorCode
import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.user.application.error.UserApplicationErrorCode

/**
 * User Application 레이어 관련 예외 정의 (Rule 68)
 */
sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    message: String? = null,
    cause: Throwable? = null,
) : ApplicationException(message ?: errorCode.message, cause) {
    /**
     * 인증 실패 관련 예외
     */
    class AuthenticationFailed(
        message: String? = UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.AUTHENTICATION_FAILED, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - e.g., Invalid UUID format
     */
    class BadRequest(
        message: String? = UserApplicationErrorCode.BAD_REQUEST.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.BAD_REQUEST, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - more specific than BadRequest
     */
    class InvalidInput(
        message: String? = UserApplicationErrorCode.INVALID_INPUT.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.INVALID_INPUT, message, cause)

    /**
     * 외부 서비스 연동 오류
     */
    class ExternalServiceError(
        message: String? = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR, message, cause)

    /**
     * 예상치 못한 시스템 오류 (Application 레벨)
     */
    class UnexpectedError(
        message: String? = UserApplicationErrorCode.UNEXPECTED_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.UNEXPECTED_ERROR, message, cause)

    /**
     * Login specific exceptions
     */
    class UserNotFound(
        errorCode: ErrorCode,
        identifier: String,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, "User not found with identifier: $identifier", cause)

    class InvalidCredentials(
        errorCode: ErrorCode,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, cause = cause)

    class UserInactive(
        errorCode: ErrorCode,
        userId: String,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, "User is inactive: $userId", cause)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/AddressDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/AddressDto.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.dto

import java.time.Instant

data class AddressDto(
    val id: String,
    val name: String,
    val streetAddress: String,
    val detailAddress: String?,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
    val version: Long,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetAddressByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetAddressByIdQuery.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.dto

data class GetAddressByIdQuery(
    val userId: String,
    val addressId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserAddressesQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserAddressesQuery.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.dto

data class GetUserAddressesQuery(
    val userId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserProfileByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserProfileByIdQuery.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.dto

data class GetUserProfileByIdQuery(
    val userId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/LoginResult.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/LoginResult.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.dto

/**
 * 로그인 결과 DTO (Application Layer)
 */
data class LoginResult(
    val id: String,
    val username: String,
    val accessToken: String,
    val refreshToken: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/UserProfileDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/UserProfileDto.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.dto

import java.time.Instant

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val username: String,
    val phoneNumber: String?,
    val userType: String,
    val addresses: List<AddressDto>,
    val createdAt: Instant,
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) {
    data class AddressDto(
        val id: String,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetAddressByIdQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetAddressByIdQueryHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.handler

import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetAddressByIdQuery
import com.restaurant.user.application.query.usecase.GetAddressByIdUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service

@Service
class GetAddressByIdQueryHandler(
    private val userRepository: UserRepository,
) : GetAddressByIdUseCase {
    override fun getAddressById(query: GetAddressByIdQuery): AddressDto {
        try {
            val userId = UserId.ofString(query.userId)
            val addressId = AddressId.ofString(query.addressId)
            val user =
                userRepository.findById(userId)
                    ?: throw UserDomainException.User.NotFound(userId.toString())

            val address =
                user.addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(addressId.toString())

            return AddressDto(
                id = address.addressId.value.toString(),
                name = address.name,
                streetAddress = address.streetAddress,
                detailAddress = address.detailAddress,
                city = address.city,
                state = address.state,
                country = address.country,
                zipCode = address.zipCode,
                isDefault = address.isDefault,
                createdAt = address.createdAt,
                updatedAt = address.updatedAt,
                version = address.version,
            )
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to fetch address due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserAddressesQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserAddressesQueryHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.handler

import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetUserAddressesQuery
import com.restaurant.user.application.query.usecase.GetUserAddressesUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service

@Service
class GetUserAddressesQueryHandler(
    private val userRepository: UserRepository,
) : GetUserAddressesUseCase {
    override fun getUserAddresses(query: GetUserAddressesQuery): List<AddressDto> {
        try {
            val userId = UserId.ofString(query.userId)
            val user =
                userRepository.findById(userId)
                    ?: throw UserDomainException.User.NotFound(userId.toString())

            return user.addresses.map { address ->
                AddressDto(
                    id = address.addressId.value.toString(),
                    name = address.name,
                    streetAddress = address.streetAddress,
                    detailAddress = address.detailAddress,
                    city = address.city,
                    state = address.state,
                    country = address.country,
                    zipCode = address.zipCode,
                    isDefault = address.isDefault,
                    createdAt = address.createdAt,
                    updatedAt = address.updatedAt,
                    version = address.version,
                )
            }
        } catch (de: UserDomainException.User.NotFound) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to fetch addresses due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserProfileQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserProfileQueryHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.handler

import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.GetUserProfileByIdQuery
import com.restaurant.user.application.query.dto.UserProfileDto
import com.restaurant.user.application.query.usecase.GetUserProfileUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) : GetUserProfileUseCase {
    @Transactional(readOnly = true)
    override fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto {
        try {
            val userId = UserId.ofString(query.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(userId.toString())

            return UserProfileDto(
                id = user.id.value.toString(),
                username = user.username.value,
                email = user.email.value,
                name = user.name.value,
                phoneNumber = user.phoneNumber?.value,
                addresses =
                    user.addresses.map { address ->
                        UserProfileDto.AddressDto(
                            id = address.addressId.value.toString(),
                            name = address.name,
                            streetAddress = address.streetAddress,
                            detailAddress = address.detailAddress,
                            city = address.city,
                            state = address.state,
                            country = address.country,
                            zipCode = address.zipCode,
                            isDefault = address.isDefault,
                        )
                    },
                userType = user.userType.name,
                status = user.status.name,
                createdAt = user.createdAt,
                updatedAt = user.updatedAt,
                version = user.version,
            )
        } catch (de: UserDomainException.User.NotFound) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to fetch profile due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAddressByIdUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAddressByIdUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetAddressByIdQuery
import com.restaurant.user.domain.entity.Address

/**
 * 주소 ID로 주소 조회 유스케이스 인터페이스
 */
interface GetAddressByIdUseCase {
    fun getAddressById(query: GetAddressByIdQuery): Address
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAllAddressesUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAllAddressesUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetAllAddressesQuery
import com.restaurant.user.domain.entity.Address

/**
 * 모든 주소 조회 유스케이스 인터페이스
 */
interface GetAllAddressesUseCase {
    fun getAllAddresses(query: GetAllAddressesQuery): List<Address>
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetProfileByIdUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetProfileByIdUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetProfileByIdQuery
import com.restaurant.user.application.query.dto.UserProfileDto

/**
 * 프로필 ID로 프로필 조회 유스케이스 인터페이스
 */
interface GetProfileByIdUseCase {
    fun getProfileById(query: GetProfileByIdQuery): UserProfileDto
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserAddressesUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserAddressesUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetAllAddressesQuery
import com.restaurant.user.domain.entity.Address

/**
 * 특정 사용자의 모든 주소 조회 유스케이스 인터페이스
 */
interface GetUserAddressesUseCase {
    fun getUserAddresses(query: GetAllAddressesQuery): List<Address>
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserProfileUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetUserProfileQuery
import com.restaurant.user.application.query.dto.UserProfileDto

/**
 * 사용자 프로필 조회 유스케이스 인터페이스
 */
interface GetUserProfileUseCase {
    fun getUserProfile(query: GetUserProfileQuery): UserProfileDto
}

====================================================================


====================================================================
 File: domains/user/domain/build.gradle.kts
 Path: domains/user/domain/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    kotlin("plugin.serialization") version "2.1.0"
    id("io.spring.dependency-management")
}

dependencies {
    implementation(project(":domains:common:domain"))
    
    // kotlinx.serialization
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-core:1.7.1")
    
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.1.0")
    implementation("com.github.avro-kotlin.avro4k:avro4k-core:2.3.0")
    implementation("jakarta.validation:jakarta.validation-api:3.1.0")
    implementation("com.fasterxml.uuid:java-uuid-generator:5.1.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

tasks {
    withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        compilerOptions {
            freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
        }
    }

    withType<Test> {
        useJUnitPlatform()
    }

}

sourceSets {
    main {
        kotlin.srcDirs("src/main/kotlin")
    }
    test {
        kotlin.srcDirs("src/test/kotlin")
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.aggregate

import com.fasterxml.jackson.annotation.JsonIgnore
import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.UserStatus
import com.restaurant.user.domain.vo.UserType
import com.restaurant.user.domain.vo.Username
import java.time.Instant
import kotlin.ConsistentCopyVisibility

/**
 * User Aggregate Root (Rule 10)
 * 사용자와 관련된 모든 비즈니스 로직을 담당하는 Aggregate Root
 */
@ConsistentCopyVisibility
data class User private constructor(
    val id: UserId,
    val username: Username,
    val email: Email,
    val password: Password,
    val name: Name,
    val phoneNumber: PhoneNumber?,
    val userType: UserType,
    val status: UserStatus,
    val addresses: List<Address>,
    val createdAt: Instant,
    val updatedAt: Instant,
    @JsonIgnore
    val version: Long = 0L,
) : AggregateRoot() {
    companion object {
        private const val MAX_ADDRESSES = 10

        /**
         * 새로운 User를 생성합니다.
         */
        fun create(
            id: UserId,
            username: Username,
            email: Email,
            password: Password,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
        ): User {
            val now = Instant.now()
            val user =
                User(
                    id = id,
                    username = username,
                    email = email,
                    password = password,
                    name = name,
                    phoneNumber = phoneNumber,
                    userType = userType,
                    status = UserStatus.ACTIVE,
                    addresses = emptyList(),
                    createdAt = now,
                    updatedAt = now,
                    version = 0L,
                )

            // addDomainEvent는 protected 메서드
            user.addDomainEvent(
                UserEvent.Created(
                    username = username.value,
                    email = email.value,
                    name = name.value,
                    phoneNumber = phoneNumber?.value,
                    userType = userType.name,
                    id = id,
                    occurredAt = now,
                ),
            )

            return user
        }

        /**
         * 기존 데이터로부터 User를 재구성합니다.
         */
        fun reconstitute(
            id: UserId,
            username: Username,
            email: Email,
            password: Password,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
            status: UserStatus,
            addresses: List<Address>,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): User {
            // 기본 주소 검증
            val defaultAddresses = addresses.filter { it.isDefault }
            if (defaultAddresses.size > 1) {
                throw UserDomainException.Address.MultipleDefaultsOnInit()
            }

            return User(
                id = id,
                username = username,
                email = email,
                password = password,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = status,
                addresses = addresses,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
        }
    }

    /**
     * 사용자 정보를 업데이트합니다.
     */
    fun updateProfile(
        name: Name,
        phoneNumber: PhoneNumber?,
    ): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        if (this.name == name && this.phoneNumber == phoneNumber) {
            return this
        }

        val updatedUser =
            copy(
                name = name,
                phoneNumber = phoneNumber,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.ProfileUpdated(
                name = name.value,
                phoneNumber = phoneNumber?.value,
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 비밀번호를 변경합니다.
     */
    fun changePassword(
        currentPassword: Password,
        newPassword: Password,
    ): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        if (this.password != currentPassword) {
            throw UserDomainException.User.PasswordMismatch()
        }

        if (this.password == newPassword) {
            return this
        }

        val updatedUser =
            copy(
                password = newPassword,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.PasswordChanged(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 주소를 추가합니다.
     */
    fun addAddress(address: Address): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        if (addresses.size >= MAX_ADDRESSES) {
            throw UserDomainException.Address.LimitExceeded(MAX_ADDRESSES)
        }

        if (addresses.any { it.addressId == address.addressId }) {
            throw UserDomainException.Address.DuplicateAddressId(address.addressId.value.toString())
        }

        val updatedAddresses =
            if (address.isDefault) {
                // 새 주소가 기본 주소라면, 기존 기본 주소들을 비기본으로 변경
                val newAddresses = addresses.map { it.copy(isDefault = false) }.toMutableList()
                newAddresses.add(address)
                newAddresses.toList()
            } else {
                addresses + address
            }

        val updatedUser =
            copy(
                addresses = updatedAddresses,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.AddressAdded(
                addressId = address.addressId,
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 주소를 업데이트합니다.
     */
    fun updateAddress(
        addressId: AddressId,
        name: Name,
        streetAddress: String,
        detailAddress: String?,
        city: String,
        state: String,
        country: String,
        zipCode: String,
        isDefault: Boolean,
    ): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        val existingAddress =
            addresses.find { it.addressId == addressId }
                ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        val updatedAddress =
            existingAddress.copy(
                name = name.value,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                updatedAt = Instant.now(),
            )

        val updatedAddresses = addresses.map { if (it.addressId == addressId) updatedAddress else it }

        if (isDefault && updatedAddresses.count { it.isDefault } > 1) {
            throw UserDomainException.Address.MultipleDefaults()
        }

        val updatedUser =
            copy(
                addresses = updatedAddresses,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.AddressUpdated(
                id = id,
                addressId = addressId,
                name = name.value,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 주소를 삭제합니다.
     */
    fun deleteAddress(addressId: AddressId): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        val existingAddress =
            addresses.find { it.addressId == addressId }
                ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        val updatedAddresses = addresses.filter { it.addressId != addressId }

        val updatedUser =
            copy(
                addresses = updatedAddresses,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.AddressDeleted(
                addressId = addressId,
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 사용자 계정을 비활성화합니다.
     */
    fun deactivate(): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }
        if (status == UserStatus.INACTIVE) {
            return this
        }

        val updatedUser =
            copy(
                status = UserStatus.INACTIVE,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.Deactivated(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 사용자 계정을 활성화합니다.
     */
    fun activate(): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }
        if (status == UserStatus.ACTIVE) {
            return this
        }

        val updatedUser =
            copy(
                status = UserStatus.ACTIVE,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.Activated(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 사용자 계정을 탈퇴 처리합니다.
     */
    fun withdraw(): User {
        if (status == UserStatus.WITHDRAWN) {
            return this
        }

        val updatedUser =
            copy(
                status = UserStatus.WITHDRAWN,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.Withdrawn(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 기본 주소를 가져옵니다.
     */
    fun getDefaultAddress(): Address? = addresses.find { it.isDefault }

    /**
     * 특정 주소를 가져옵니다.
     */
    fun getAddress(addressId: AddressId): Address? = addresses.find { it.addressId == addressId }

    /**
     * 사용자가 활성 상태인지 확인합니다.
     */
    fun isActive(): Boolean = status == UserStatus.ACTIVE

    /**
     * 사용자가 탈퇴 상태인지 확인합니다.
     */
    fun isWithdrawn(): Boolean = status == UserStatus.WITHDRAWN
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.entity

import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import java.time.Instant

/**
 * Address Domain Entity (Rule 11)
 * User Aggregate에 속하지만 자체 식별자를 가짐.
 */
data class Address constructor(
    val addressId: AddressId,
    val name: String,
    val streetAddress: String,
    val detailAddress: String?,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
    val version: Long = 0L,
) {
    init {
        if (streetAddress.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Street address cannot be blank.")
        }
        validateZipCode(zipCode)
        if (name.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Name cannot be blank.")
        }
        if (city.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("City cannot be blank.")
        }
        if (state.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("State cannot be blank.")
        }
        if (country.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Country cannot be blank.")
        }
    }

    fun updateDetails(
        name: String,
        streetAddress: String,
        detailAddress: String?,
        city: String,
        state: String,
        country: String,
        zipCode: String,
        isDefault: Boolean,
    ): Address {
        validateZipCode(zipCode)
        if (this.name == name &&
            this.streetAddress == streetAddress &&
            this.detailAddress == detailAddress &&
            this.city == city &&
            this.state == state &&
            this.country == country &&
            this.zipCode == zipCode &&
            this.isDefault == isDefault
        ) {
            return this
        }
        return this.copy(
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun toData(): UserEvent.AddressData =
        UserEvent.AddressData(
            id = addressId.value.toString(),
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
        )

    companion object {
        private fun validateZipCode(zipCode: String) {
            if (zipCode.isBlank() || zipCode.length != 5 || !zipCode.all { it.isDigit() }) {
                throw UserDomainException.Validation.InvalidAddressFormat("Zip code must be 5 digits.")
            }
        }

        fun create(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
        ): Address {
            validateZipCode(zipCode)
            val now = Instant.now()
            return Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = now,
                updatedAt = now,
                version = 0L,
            )
        }

        fun reconstitute(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): Address =
            Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
    }

    fun markAsDefault(): Address {
        if (this.isDefault) return this
        return this.copy(
            isDefault = true,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun markAsNonDefault(): Address {
        if (!this.isDefault) return this
        return this.copy(
            isDefault = false,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum (Rule 67)
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    DUPLICATE_USERNAME("USER-DOMAIN-003", "이미 사용중인 사용자 이름입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-004", "비밀번호가 일치하지 않습니다."),
    USER_ALREADY_WITHDRAWN("USER-DOMAIN-005", "이미 탈퇴한 사용자입니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-006", "주소를 찾을 수 없습니다."),
    DUPLICATE_ADDRESS_ID("USER-DOMAIN-007", "이미 존재하는 주소 ID 입니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-008", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-009", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-010", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_EMAIL_FORMAT("USER-DOMAIN-101", "잘못된 이메일 형식입니다."),
    INVALID_USERNAME_FORMAT("USER-DOMAIN-102", "사용자 이름 형식이 올바르지 않습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-103", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_NAME_FORMAT("USER-DOMAIN-104", "잘못된 이름 형식입니다."),
    INVALID_ADDRESS_FORMAT("USER-DOMAIN-105", "잘못된 주소 형식입니다."),
    INVALID_PHONE_NUMBER_FORMAT("USER-DOMAIN-106", "잘못된 전화번호 형식입니다."),
    INVALID_USER_ID_FORMAT("USER-DOMAIN-107", "잘못된 사용자 ID 형식입니다."),
    INVALID_ADDRESS_ID_FORMAT("USER-DOMAIN-108", "잘못된 주소 ID 형식입니다."),
    ADDRESS_ID_MISMATCH("USER-DOMAIN-201", "주소 ID가 일치하지 않습니다."),
    INVALID_CREDENTIALS("USER-DOMAIN-056", "Invalid credentials"),
    ADMIN_CANNOT_BE_WITHDRAWN("USER-DOMAIN-057", "Admin user cannot be withdrawn"),
    MULTIPLE_DEFAULT_ADDRESSES("USER-DOMAIN-109", "Cannot have multiple default addresses"),
    DEFAULT_ADDRESS_NOT_FOUND("USER-DOMAIN-108", "Default address not found"),
    PERSISTENCE_ERROR("USER-DOMAIN-901", "Persistence error occurred"),
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.time.Instant
import java.util.UUID

/**
 * Custom serializer for UUID
 */
object UUIDSerializer : KSerializer<UUID> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("UUID", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: UUID,
    ) {
        encoder.encodeString(value.toString())
    }

    override fun deserialize(decoder: Decoder): UUID = UUID.fromString(decoder.decodeString())
}

/**
 * Custom serializer for Instant
 */
object InstantSerializer : KSerializer<Instant> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Instant", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: Instant,
    ) {
        encoder.encodeString(value.toString())
    }

    override fun deserialize(decoder: Decoder): Instant = Instant.parse(decoder.decodeString())
}

/**
 * Sealed class grouping all domain events related to the User aggregate. (Rule 34)
 */
@Serializable
sealed class UserEvent : DomainEvent {
    @Serializable(with = UUIDSerializer::class)
    abstract override val eventId: UUID

    @Serializable(with = InstantSerializer::class)
    abstract override val occurredAt: Instant
    abstract val id: UserId

    override val aggregateId: String
        get() = id.value.toString()
    override val aggregateType: String
        get() = "User"

    /**
     * User Created Event
     */
    @Serializable
    @SerialName("Created")
    data class Created(
        val username: String,
        val email: String,
        val name: String,
        val phoneNumber: String?,
        val userType: String,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Deleted Event
     */
    @Serializable
    @SerialName("Deleted")
    data class Deleted(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Password Changed Event
     */
    @Serializable
    @SerialName("PasswordChanged")
    data class PasswordChanged(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Profile Updated Event
     */
    @Serializable
    @SerialName("ProfileUpdated")
    data class ProfileUpdated(
        val name: String,
        val phoneNumber: String?,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Address Added Event
     */
    @Serializable
    @SerialName("AddressAdded")
    data class AddressAdded(
        val addressId: AddressId,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Address Updated Event
     */
    @Serializable
    @SerialName("AddressUpdated")
    data class AddressUpdated(
        val addressId: AddressId,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Address Deleted Event
     */
    @Serializable
    @SerialName("AddressDeleted")
    data class AddressDeleted(
        val addressId: AddressId,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Withdrawn Event
     */
    @Serializable
    @SerialName("Withdrawn")
    data class Withdrawn(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Deactivated Event
     */
    @Serializable
    @SerialName("Deactivated")
    data class Deactivated(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Activated Event
     */
    @Serializable
    @SerialName("Activated")
    data class Activated(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * Address Data for events (Rule 33, 34)
     */
    @Serializable
    data class AddressData(
        val id: String,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.exception

import com.restaurant.common.domain.exception.DomainException
import com.restaurant.user.domain.error.UserDomainErrorCodes

/**
 * Sealed class representing all possible domain exceptions for the User aggregate. (Rule 68)
 */
sealed class UserDomainException(
    override val errorCode: UserDomainErrorCodes,
    message: String? = errorCode.message, // String? 타입으로 변경하고, null일 경우 errorCode.message 사용
    cause: Throwable? = null,
) : DomainException(message, cause) { // DomainException 생성자 변경에 따라 수정
    /**
     * Validation-related exceptions
     */
    sealed class Validation(
        override val errorCode: UserDomainErrorCodes,
        message: String = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class InvalidEmailFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_EMAIL_FORMAT,
                message,
            )

        class InvalidUsernameFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USERNAME_FORMAT,
                message,
            )

        class InvalidUserIdFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USER_ID_FORMAT,
                message,
            )

        class InvalidPasswordFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
                message,
            )

        class InvalidNameFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_NAME_FORMAT,
                message,
            )

        class InvalidPhoneNumberFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PHONE_NUMBER_FORMAT,
                message,
            )

        class InvalidAddressFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                message,
            )

        class InvalidAddressIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_ID_FORMAT,
                "Invalid address ID format: $value",
            )
    }

    /**
     * User-related exceptions
     */
    sealed class User(
        override val errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            userId: String,
        ) : User(
                UserDomainErrorCodes.USER_NOT_FOUND,
                "User not found with ID: $userId",
            )

        class DuplicateUsername(
            username: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_USERNAME,
                "Username already exists: $username",
            )

        class DuplicateEmail(
            email: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_EMAIL,
                "Email already exists: $email",
            )

        class PasswordMismatch : User(UserDomainErrorCodes.PASSWORD_MISMATCH)

        class AlreadyWithdrawn : User(UserDomainErrorCodes.USER_ALREADY_WITHDRAWN)

        class InvalidCredentials(
            username: String,
        ) : User(
                UserDomainErrorCodes.INVALID_CREDENTIALS,
                "Invalid credentials for username: $username",
            )

        class AdminCannotBeWithdrawn :
            User(
                UserDomainErrorCodes.ADMIN_CANNOT_BE_WITHDRAWN,
                "Admin user cannot be withdrawn.",
            )
    }

    /**
     * Address-related exceptions
     */
    sealed class Address(
        override val errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_NOT_FOUND,
                "Address not found with ID: $addressId",
            )

        class DefaultAddressNotFound(
            message: String = "Default address ID does not exist in the address list.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_NOT_FOUND,
                message,
            )

        class DuplicateAddressId(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.DUPLICATE_ADDRESS_ID,
                "Address ID already exists: $addressId",
            )

        class IdMismatch(
            existingId: String,
            newId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_ID_MISMATCH,
                "Address ID mismatch: expected $existingId, got $newId",
            )

        class LimitExceeded(
            limit: Int,
        ) : Address(
                UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
                "Cannot add more addresses, limit is $limit",
            )

        class CannotDeleteDefault(
            message: String = "Cannot remove the default address.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
                message,
            )

        class CannotDeleteLast(
            message: String = "Cannot remove the last address.",
        ) : Address(
                UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
                message,
            )

        class MultipleDefaults(
            message: String = "Multiple default addresses found.",
        ) : Address(
                UserDomainErrorCodes.MULTIPLE_DEFAULT_ADDRESSES,
                message,
            )

        class MultipleDefaultsOnInit(
            val reason: String = "Cannot initialize user with multiple default addresses.",
        ) : Address(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                reason,
            )
    }

    class PersistenceError(
        override val errorCode: UserDomainErrorCodes = UserDomainErrorCodes.PERSISTENCE_ERROR,
        message: String,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause)
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username

interface UserRepository {
    fun findById(id: UserId): User?

    fun findByUsername(username: Username): User?

    fun findByEmail(email: Email): User? // findByEmail 메서드 추가
    fun existsByUsername(username: Username): Boolean

    fun existsByEmail(email: Email): Boolean

    fun save(user: User): User

    fun delete(user: User)
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.UUID
import java.io.Serializable as JavaSerializable

@Serializable(with = AddressIdSerializer::class)
@JvmInline
value class AddressId private constructor(
    val value: UUID,
) : JavaSerializable {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun ofString(value: String): AddressId =
            try {
                AddressId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidAddressIdFormat(value)
            }

        fun of(value: UUID): AddressId = AddressId(value)

        fun fromUUID(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

/**
 * Custom serializer for AddressId to handle UUID serialization
 */
object AddressIdSerializer : KSerializer<AddressId> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("AddressId", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: AddressId,
    ) {
        encoder.encodeString(value.value.toString())
    }

    override fun deserialize(decoder: Decoder): AddressId {
        val uuidString = decoder.decodeString()
        return AddressId.ofString(uuidString)
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * Value object representing an email address.
 * This class ensures that the email address is valid according to a basic pattern.
 */
@JvmInline
value class Email private constructor(
    val value: String,
) {
    companion object {
        private val EMAIL_PATTERN =
            Regex(
                "[a-zA-Z0-9+._%\\-]{1,256}" +
                    "@" +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
                    "(" +
                    "\\." +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
                    ")+",
            )

        /**
         * Creates a new Email from a string value.
         * @throws UserDomainException.Validation if the email format is invalid
         */
        fun of(value: String): Email {
            if (!EMAIL_PATTERN.matches(value)) {
                throw UserDomainException.Validation.InvalidEmailFormat("Invalid email format: $value")
            }
            return Email(value.lowercase())
        }
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Name private constructor(
    val value: String,
) : Serializable {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat("Invalid name format: $value")
        }
    }

    companion object {
        private const val MIN_LENGTH = 2
        private const val MAX_LENGTH = 50

        fun of(value: String): Name {
            if (value.isBlank() || value.length < MIN_LENGTH || value.length > MAX_LENGTH) {
                throw UserDomainException.Validation.InvalidNameFormat("이름은 $MIN_LENGTH 자 이상 $MAX_LENGTH 자 이하이어야 하며, 공백일 수 없습니다: '$value'")
            }
            return Name(value)
        }
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * 비밀번호 Value Object
 */
@JvmInline
value class Password private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password cannot be blank.")
        }
        if (value.length < 8) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must be at least 8 characters long.")
        }
        if (!value.contains(Regex("[A-Z]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one uppercase letter.")
        }
        if (!value.contains(Regex("[a-z]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one lowercase letter.")
        }
        if (!value.contains(Regex("[0-9]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one digit.")
        }
        if (!value.contains(Regex("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?~`]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one special character.")
        }
    }

    override fun toString(): String = "********"

    companion object {
        /**
         * Creates a Password VO from a pre-encoded password string.
         * All validation is performed during object creation.
         */
        fun of(encodedPassword: String): Password = Password(encodedPassword)
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class PhoneNumber private constructor(
    val value: String,
) : Serializable {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^010-?\\d{4}-?\\d{4}$")

        fun of(value: String): PhoneNumber {
            val normalizedValue = value.replace("-", "")
            if (!PHONE_NUMBER_REGEX.matches(value)) {
                throw UserDomainException.Validation.InvalidPhoneNumberFormat("휴대폰 번호 형식이 올바르지 않습니다: $value")
            }

            return PhoneNumber(normalizedValue)
        }
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.UUID
import java.io.Serializable as JavaSerializable

/**
 * Value object representing a unique user identifier.
 * This class wraps a UUID and provides type safety and validation.
 */
@Serializable(with = UserIdSerializer::class)
@JvmInline
value class UserId private constructor(
    val value: UUID,
) : JavaSerializable {
    companion object {
        /**
         * Creates a new UserId from a UUID.
         */
        fun of(uuid: UUID): UserId = UserId(uuid)

        /**
         * Creates a new UserId from a string representation of a UUID.
         * @throws UserDomainException.Validation if the string is not a valid UUID
         */
        fun ofString(value: String): UserId =
            try {
                UserId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUserIdFormat(value)
            }

        /**
         * Generates a new random UserId.
         */
        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromUUID(value: UUID): UserId = UserId(value)
    }

    override fun toString(): String = value.toString()
}

/**
 * Custom serializer for UserId to handle UUID serialization
 */
object UserIdSerializer : KSerializer<UserId> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("UserId", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: UserId,
    ) {
        encoder.encodeString(value.value.toString())
    }

    override fun deserialize(decoder: Decoder): UserId {
        val uuidString = decoder.decodeString()
        return UserId.ofString(uuidString)
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Username(
    val value: String,
) : Serializable {
    init {

        if (value.isBlank() || value.length < 3 || value.length > 20) {
            throw UserDomainException.Validation.InvalidUsernameFormat(value)
        }
    }

    companion object {
        fun of(value: String): Username = Username(value)
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserStatus.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserStatus.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo

/**
 * Represents the status of a user account.
 */
enum class UserStatus {
    ACTIVE,
    INACTIVE,
    WITHDRAWN,
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserType.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserType.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.domain.vo

/**
 * Represents the type of user.
 */
enum class UserType {
    CUSTOMER,
    ADMIN,
}

====================================================================


====================================================================
 File: domains/user/infrastructure/build.gradle.kts
 Path: domains/user/infrastructure/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
import java.net.URLClassLoader

plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    kotlin("plugin.serialization") version "2.1.0" // For kotlinx.serialization
    id("com.github.imflog.kafka-schema-registry-gradle-plugin") version "2.3.2"
    id("io.spring.dependency-management") version "1.1.7"
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:infrastructure")) // For BaseEntity if needed
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application")) // For DTOs if any indirect use
    implementation(project(":independent:outbox")) // For OutboxMessageRepository interface

    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0")
    implementation("org.flywaydb:flyway-core:11.8.2")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.19.0")
    implementation("com.fasterxml.jackson.module:jackson-module-jsonSchema:2.19.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.1.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7") // Logging
    
    // kotlinx.serialization 의존성 추가
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.0")

    // Kafka 관련
    implementation("org.springframework.kafka:spring-kafka:4.0.0-M2")
    implementation("org.apache.kafka:kafka-clients:3.9.0")
    implementation("io.confluent:kafka-schema-registry-client:7.8.0")
    implementation("io.confluent:kafka-json-schema-serializer:7.8.0")

    runtimeOnly("org.postgresql:postgresql:42.7.5")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.testcontainers:testcontainers:1.21.0")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:postgresql:1.21.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

// JSON Schema 생성 태스크 (Rule VII.1.3.2) - buildSrc의 GenerateJsonSchemaTask 사용
tasks.register<GenerateJsonSchemaTask>("generateJsonSchema") {
    group = "schema"
    description = "Generate JSON schemas from UserEvent data classes using Jackson JsonSchemaGenerator"
    dependsOn("compileKotlin")
    
    packageName.set("com.restaurant.user.domain.event")
    domainEventInterface.set("com.restaurant.common.domain.event.DomainEvent")
    outputDir.set(file("src/main/resources/schemas"))
}

// Schema Registry 설정 (Rule VII.1.3.3)
schemaRegistry {
    url.set("http://localhost:8081") // 개발 환경용, 실제 환경에서는 환경변수로 설정
    
    register {
        subject("dev.user.domain-event.user.v1-value", "${projectDir}/src/main/resources/schemas/user_event.json", "JSON")
    }
    
    compatibility {
        subject("dev.user.domain-event.user.v1-value", "${projectDir}/src/main/resources/schemas/user_event.json", "JSON")
    }
}

// Schema Registry 태스크들이 generateJsonSchema 후에 실행되도록 설정 (Rule VII.1.3.3)
tasks.named("registerSchemasTask") {
    dependsOn("generateJsonSchema")
}

tasks.named("testSchemasTask") {
    dependsOn("generateJsonSchema")
}

// build 태스크가 스키마 생성을 포함하도록 설정 (Rule VII.1.3.2)
tasks.named("build") {
    dependsOn("generateJsonSchema")
}

// processResources가 generateJsonSchema 후에 실행되도록 설정
tasks.named("processResources") {
    dependsOn("generateJsonSchema")
} 
====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/AddressEntity.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/AddressEntity.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant
import java.util.UUID

import com.restaurant.common.infrastructure.entity.BaseEntity

@Entity
@Table(name = "addresses")
class AddressEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, unique = true) // domainId는 unique해야 할 가능성이 높습니다.
    val domainId: UUID,
    @Column(nullable = false)
    val name: String,
    @Column(nullable = false)
    val streetAddress: String,
    @Column(nullable = true)
    val detailAddress: String?,
    @Column(nullable = false)
    val city: String,
    @Column(nullable = false)
    val state: String,
    @Column(nullable = false)
    val country: String,
    @Column(nullable = false)
    val zipCode: String,
    @Column(nullable = false)
    val isDefault: Boolean,
    @Version
    @Column(nullable = false)
    val version: Long = 0L,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null // UserEntity와의 관계 추가
) : BaseEntity() 
====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/UserEntity.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/UserEntity.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.entity

import com.restaurant.user.domain.vo.UserStatus
import com.restaurant.user.domain.vo.UserType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.CascadeType
import java.time.Instant
import java.util.Objects
import java.util.UUID

import com.restaurant.common.infrastructure.entity.BaseEntity

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false, length = 50)
    val username: String,
    @Column(nullable = false)
    val passwordHash: String,
    @Column(unique = true, nullable = false)
    val email: String,
    @Column(nullable = false, length = 50)
    val name: String,
    @Column(length = 20)
    val phoneNumber: String?,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val userType: UserType,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val status: UserStatus = UserStatus.ACTIVE,
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY, mappedBy = "user")
    var addresses: MutableList<AddressEntity> = mutableListOf(), // MutableList로 변경
    @Version
    @Column(nullable = false)
    val version: Long = 0L
) : BaseEntity() {
    // AddressEntity 추가를 위한 편의 메서드 (선택적, 양방향 관계 설정 시 유용)
    fun addAddress(address: AddressEntity) {
        addresses.add(address)
        address.user = this // AddressEntity에 user 필드가 있다고 가정
    }

    fun removeAddress(address: AddressEntity) {
        addresses.remove(address)
        address.user = null // AddressEntity에 user 필드가 있다고 가정
    }


    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as UserEntity
        return Objects.equals(id, that.id) &&
            domainId == that.domainId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: domainId)
    }

    override fun toString(): String {
        val defaultAddressDomainId = addresses.find { it.isDefault }?.domainId?.toString() ?: "N/A"
        return "UserEntity(id=$id, domainId=$domainId, username='$username', email='$email', userType=$userType, defaultAddressDomainId=${defaultAddressDomainId}, addresses=${addresses.size}, createdAt=${this.createdAt}, updatedAt=${this.updatedAt}, version=$version)"
    }
} 
====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/AddressEntityMapper.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/AddressEntityMapper.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.mapper

import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.infrastructure.entity.AddressEntity
import java.time.Instant

// Address.reconstitute에서 userId를 사용하지 않는다고 가정
fun AddressEntity.toDomain(): Address =
    Address.reconstitute(
        addressId = AddressId.of(this.domainId),
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )

// AddressEntity 생성 시 UserEntity를 받지 않음
// UserEntity의 addresses 컬렉션에 추가될 때 관계가 설정됨
fun Address.toEntity(): AddressEntity =
    AddressEntity(
        // id는 DB 자동 생성
        domainId = this.addressId.value,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        version = this.version, // Address 도메인 객체에 해당 필드가 있다고 가정
        // user 필드는 UserEntity에서 AddressEntity를 추가하면서 설정
    )

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/DomainEventToOutboxMessageConverter.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/DomainEventToOutboxMessageConverter.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.mapper

// import com.fasterxml.jackson.databind.ObjectMapper // ObjectMapper import 제거
import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.user.domain.event.UserEvent
import kotlinx.serialization.encodeToString // kotlinx.serialization import 추가
import kotlinx.serialization.json.Json // kotlinx.serialization import 추가
import org.springframework.stereotype.Component

@Component
class DomainEventToOutboxMessageConverter(
    private val kotlinJson: Json, // 주입받은 Json Bean 사용
) {
    fun convert(domainEvent: UserEvent): OutboxMessage {
        // UserEvent 객체를 JSON 문자열로 직렬화 (주입받은 kotlinJson 사용)
        val payloadAsJsonString = kotlinJson.encodeToString(domainEvent)
        val topic = determineTopic(domainEvent)

        val headers = mutableMapOf<String, String>()
        headers["aggregateId"] = domainEvent.aggregateId
        headers["aggregateType"] = domainEvent.aggregateType
        headers["eventType"] = determineEventType(domainEvent)
        headers["eventId"] = domainEvent.eventId.toString()
        headers["occurredAt"] = domainEvent.occurredAt.toString()
        headers["contentType"] = "application/json" // KafkaJsonSchemaSerializer가 처리하므로 유지
        headers["schemaVersion"] = "v1" // 필요시 스키마 버전 명시

        return OutboxMessage(
            payload = payloadAsJsonString, // JSON 문자열로 직렬화된 payload 전달
            topic = topic,
            headers = headers,
            aggregateType = domainEvent.aggregateType,
            aggregateId = domainEvent.aggregateId,
            eventType = determineEventType(domainEvent),
        )
    }

    private fun determineTopic(event: UserEvent): String {
        val environment = System.getenv("APP_ENV") ?: "dev"
        val domain = "user"
        val entityName = "user"
        val eventTypeCategory = "domain-event"
        val version = "v1"

        return "$environment.$domain.$eventTypeCategory.$entityName.$version"
    }

    private fun determineEventType(event: UserEvent): String =
        when (event) {
            is UserEvent.Created -> "UserEvent.Created"
            is UserEvent.ProfileUpdated -> "UserEvent.ProfileUpdated"
            is UserEvent.PasswordChanged -> "UserEvent.PasswordChanged"
            is UserEvent.AddressAdded -> "UserEvent.AddressAdded"
            is UserEvent.AddressUpdated -> "UserEvent.AddressUpdated"
            is UserEvent.AddressDeleted -> "UserEvent.AddressDeleted"
            is UserEvent.Withdrawn -> "UserEvent.Withdrawn"
            is UserEvent.Deactivated -> "UserEvent.Deactivated"
            is UserEvent.Activated -> "UserEvent.Activated"
            is UserEvent.Deleted -> "UserEvent.Deleted"
            else -> event::class.simpleName ?: "UnknownEvent"
        }
}

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/UserEntityMapper.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/UserEntityMapper.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.mapper

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.entity.UserEntity

fun UserEntity.toDomain(): User {
    val userDomainId = UserId.of(this.domainId)
    val domainAddresses =
        this.addresses
            .map { addressEntity ->
                addressEntity.toDomain() // userId 인자 제거됨
            }.toList()

    // User.reconstitute에서 defaultAddressId를 사용하지 않거나,
    // User 도메인 객체가 addresses 리스트 내 isDefault 플래그로 관리한다고 가정
    return User.reconstitute(
        id = userDomainId,
        username = Username.of(this.username),
        password = Password.of(this.passwordHash),
        email = Email.of(this.email),
        name = Name.of(this.name),
        phoneNumber = this.phoneNumber?.let { PhoneNumber.of(it) },
        userType = this.userType,
        status = this.status,
        addresses = domainAddresses,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )
}

fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            domainId = this.id.value,
            username = this.username.value,
            passwordHash = this.password.value,
            email = this.email.value,
            name = this.name.value,
            phoneNumber = this.phoneNumber?.value,
            userType = this.userType,
            status = this.status,
            version = this.version,
        )

    // addresses 변환 및 양방향 관계 설정
    val addressEntities =
        this.addresses
            .map { address ->
                val addressEntity = address.toEntity()
                addressEntity.user = entity // UserEntity에 대한 참조 설정
                addressEntity
            }.toMutableList()
    entity.addresses = addressEntities
    return entity
}

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/SpringDataJpaUserRepository.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/SpringDataJpaUserRepository.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.repository

import com.restaurant.user.infrastructure.entity.UserEntity
import org.springframework.data.jpa.repository.JpaRepository
import java.util.UUID

interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    fun findByDomainId(domainId: UUID): UserEntity?

    fun findByUsername(username: String): UserEntity?

    fun findByEmail(email: String): UserEntity?

    fun existsByUsername(username: String): Boolean

    fun existsByEmail(email: String): Boolean
}

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/UserRepositoryImpl.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/UserRepositoryImpl.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.mapper.DomainEventToOutboxMessageConverter
import com.restaurant.user.infrastructure.mapper.toDomain
import com.restaurant.user.infrastructure.mapper.toEntity
import org.springframework.stereotype.Repository

@Repository
class UserRepositoryImpl(
    private val springDataJpaUserRepository: SpringDataJpaUserRepository,
    private val outboxMessageRepository: OutboxMessageRepository,
    private val domainEventToOutboxMessageConverter: DomainEventToOutboxMessageConverter,
) : UserRepository {
    override fun findById(id: UserId): User? = springDataJpaUserRepository.findByDomainId(id.value)?.toDomain()

    override fun findByUsername(username: Username): User? = springDataJpaUserRepository.findByUsername(username.value)?.toDomain()

    override fun findByEmail(email: Email): User? = springDataJpaUserRepository.findByEmail(email.value)?.toDomain()

    override fun existsByUsername(username: Username): Boolean = springDataJpaUserRepository.existsByUsername(username.value)

    override fun existsByEmail(email: Email): Boolean = springDataJpaUserRepository.existsByEmail(email.value)

    override fun save(user: User): User {
        val userEntity = user.toEntity()
        // 주의: userEntity의 addresses 내부 AddressEntity들이 userEntity를 참조하도록 설정 필요 (양방향 관계)
        // User.toEntity() 내부 또는 여기서 명시적으로 설정
        userEntity.addresses.forEach { it.user = userEntity }

        val savedEntity = springDataJpaUserRepository.save(userEntity)

        // 도메인 이벤트 처리
        val domainEvents = user.getDomainEvents()
        if (domainEvents.isNotEmpty()) {
            val outboxMessages = domainEvents.map { 
                domainEventToOutboxMessageConverter.convert(it as UserEvent)
            }

            if (outboxMessages.isNotEmpty()) {
                outboxMessageRepository.saveAll(outboxMessages)
            }

            user.clearDomainEvents()
        }

        return savedEntity.toDomain()
    }

    override fun delete(user: User) {
        springDataJpaUserRepository.delete(user.toEntity())
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/build.gradle.kts
 Path: domains/user/presentation/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common:presentation"))
    
    implementation("org.springframework.boot:spring-boot-starter-web:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")

    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.6")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserAddressController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserAddressController.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.controller

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.command.IDeleteAddressCommandHandler
import com.restaurant.user.application.command.IRegisterAddressCommandHandler
import com.restaurant.user.application.command.IUpdateAddressCommandHandler
import com.restaurant.user.application.command.dto.DeleteAddressCommand
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.command.extensions.dto.request.toCommand
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.servlet.support.ServletUriComponentsBuilder
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(name = "User Address Commands", description = "사용자 주소 관리 API (생성/수정/삭제)")
@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
class UserAddressController(
    private val registerAddressCommandHandler: IRegisterAddressCommandHandler,
    private val updateAddressCommandHandler: IUpdateAddressCommandHandler,
    private val deleteAddressCommandHandler: IDeleteAddressCommandHandler,
) {
    @PostMapping
    @Operation(
        summary = "사용자 주소 등록",
        description = "특정 사용자의 새로운 주소를 등록합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "주소 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden) - 다른 사용자의 주소 등록 시도 등",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun registerAddress(
        @Parameter(description = "주소를 등록할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "주소 등록 요청 정보", required = true, schema = Schema(implementation = RegisterAddressRequestV1::class))
        @Valid
        @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Received request to register address for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId))
        val addressId: AddressId = registerAddressCommandHandler.registerAddress(command)

        val location =
            ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{addressId}")
                .buildAndExpand(addressId.value)
                .toUri()

        return ResponseEntity.created(location).body(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address registered successfully. Address ID: ${addressId.value}",
            ),
        )
    }

    @PutMapping("/{addressId}")
    @Operation(
        summary = "사용자 주소 수정",
        description = "특정 사용자의 기존 주소 정보를 수정합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden) - 다른 사용자의 주소 수정 시도 등",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun updateAddress(
        @Parameter(description = "주소를 수정할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "수정할 주소의 ID", required = true, example = "b2c3d4e5-f6a7-8901-2345-67890abcdef1")
        @PathVariable addressId: UUID,
        @Parameter(description = "주소 수정 요청 정보", required = true, schema = Schema(implementation = UpdateAddressRequestV1::class))
        @Valid
        @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Received request to update address ID: $addressId for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), AddressId.of(addressId))
        updateAddressCommandHandler.updateAddress(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address updated successfully.",
            ),
        )
    }

    @DeleteMapping("/{addressId}")
    @Operation(
        summary = "사용자 주소 삭제",
        description = "특정 사용자의 주소를 삭제합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden) - 다른 사용자의 주소 삭제 시도 등",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun deleteAddress(
        @Parameter(description = "주소를 삭제할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "삭제할 주소의 ID", required = true, example = "b2c3d4e5-f6a7-8901-2345-67890abcdef1")
        @PathVariable addressId: UUID,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Received request to delete address ID: $addressId for user ID: $userId" }
        val command =
            DeleteAddressCommand(
                userId = UserId.of(userId).value.toString(),
                addressId = AddressId.of(addressId).value.toString(),
            )
        deleteAddressCommandHandler.deleteAddress(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address deleted successfully.",
            ),
        )
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.controller

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.command.IChangePasswordCommandHandler
import com.restaurant.user.application.command.IDeleteUserCommandHandler
import com.restaurant.user.application.command.ILoginCommandHandler
import com.restaurant.user.application.command.IRegisterUserCommandHandler
import com.restaurant.user.application.command.IUpdateProfileCommandHandler
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.command.extensions.dto.request.toCommand
import com.restaurant.user.presentation.v1.query.dto.response.LoginResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PatchMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.servlet.support.ServletUriComponentsBuilder
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(name = "User Commands", description = "사용자 계정 관리 API")
@RestController
@RequestMapping("/api/v1/users")
class UserController(
    private val registerUserCommandHandler: IRegisterUserCommandHandler,
    private val loginCommandHandler: ILoginCommandHandler,
    private val updateProfileCommandHandler: IUpdateProfileCommandHandler,
    private val changePasswordCommandHandler: IChangePasswordCommandHandler,
    private val deleteUserCommandHandler: IDeleteUserCommandHandler,
) {
    @PostMapping("/register")
    @Operation(
        summary = "사용자 회원가입",
        description = "새로운 사용자 계정을 생성합니다.",
        security = [], // 회원가입은 인증이 필요 없음
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "회원가입 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun registerUser(
        @Parameter(description = "회원가입 요청 정보", required = true, schema = Schema(implementation = RegisterUserRequestV1::class))
        @Valid
        @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand()
        val userId: UserId = registerUserCommandHandler.register(command)

        val location =
            ServletUriComponentsBuilder
                .fromCurrentContextPath()
                .path("/api/v1/users/{userId}/profile")
                .buildAndExpand(userId.value)
                .toUri()

        return ResponseEntity.created(location).body(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User registered successfully.",
            ),
        )
    }

    @PostMapping("/login")
    @Operation(
        summary = "사용자 로그인",
        description = "이메일과 비밀번호로 사용자 인증을 수행합니다.",
        security = [], // 로그인은 인증이 필요 없음
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그인 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = LoginResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증 실패 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun login(
        @Parameter(description = "로그인 요청 정보", required = true, schema = Schema(implementation = LoginRequestV1::class))
        @Valid
        @RequestBody request: LoginRequestV1,
    ): ResponseEntity<LoginResponseV1> {
        val command = request.toCommand()
        val loginResult = loginCommandHandler.login(command)
        return ResponseEntity.ok(
            LoginResponseV1(
                id = loginResult.id,
                username = loginResult.username,
                accessToken = loginResult.accessToken,
                refreshToken = loginResult.refreshToken,
            ),
        )
    }

    @PutMapping("/{userId}/profile")
    @Operation(
        summary = "사용자 프로필 수정",
        description = "기존 사용자의 프로필 정보를 수정합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun updateProfile(
        @Parameter(description = "수정할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "프로필 수정 요청 정보", required = true, schema = Schema(implementation = UpdateProfileRequestV1::class))
        @Valid
        @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        updateProfileCommandHandler.updateProfile(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User profile updated successfully.",
            ),
        )
    }

    @PatchMapping("/{userId}/password")
    @Operation(
        summary = "사용자 비밀번호 변경",
        description = "기존 비밀번호를 확인한 후 새로운 비밀번호로 변경합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "비밀번호 변경 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 또는 현재 비밀번호 불일치 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun changePassword(
        @Parameter(description = "비밀번호를 변경할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "비밀번호 변경 요청 정보", required = true, schema = Schema(implementation = ChangePasswordRequestV1::class))
        @Valid
        @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        changePasswordCommandHandler.changePassword(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User password changed successfully.",
            ),
        )
    }

    @DeleteMapping("/{userId}")
    @Operation(
        summary = "사용자 계정 삭제",
        description = "사용자 계정을 영구적으로 삭제합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "계정 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun deleteUser(
        @Parameter(description = "삭제할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(
            description = "계정 삭제 요청 정보 (필요시 현재 비밀번호 등)",
            required = true,
            schema = Schema(implementation = DeleteUserRequestV1::class),
        )
        @Valid
        @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        deleteUserCommandHandler.deleteUser(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User deleted successfully.",
            ),
        )
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/ChangePasswordRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/ChangePasswordRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 비밀번호 변경 요청")
data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/DeleteUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/DeleteUserRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 계정 삭제 요청")
data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/LoginRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/LoginRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

@Schema(description = "사용자 로그인 요청")
data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterAddressRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 주소 등록 요청")
data class RegisterAddressRequestV1(
    @field:Schema(description = "주소 이름", example = "집")
    @field:NotBlank(message = "주소 이름은 필수 입력 항목입니다.")
    val name: String,
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "도시", example = "서울시")
    @field:NotBlank(message = "도시는 필수 입력 항목입니다.")
    val city: String,
    @field:Schema(description = "주/도", example = "서울특별시")
    @field:NotBlank(message = "주/도는 필수 입력 항목입니다.")
    val state: String,
    @field:Schema(description = "국가", example = "대한민국")
    @field:NotBlank(message = "국가는 필수 입력 항목입니다.")
    val country: String,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false", defaultValue = "false")
    val isDefault: Boolean? = false,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterUserRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
/**
 * 사용자 등록 요청 DTO
 *
 * Contains validation and schema annotations for user registration API.
 *
 * @author junoko
 */
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

@Schema(description = "사용자 등록 요청")
data class RegisterUserRequestV1(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser")
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    @Schema(description = "전화번호 (선택)", example = "010-1234-5678")
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateAddressRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 주소 수정 요청")
data class UpdateAddressRequestV1(
    @field:Schema(description = "주소 이름", example = "회사")
    @field:NotBlank(message = "주소 이름은 필수 입력 항목입니다.")
    val name: String,
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "도시", example = "서울시")
    @field:NotBlank(message = "도시는 필수 입력 항목입니다.")
    val city: String,
    @field:Schema(description = "주/도", example = "서울특별시")
    @field:NotBlank(message = "주/도는 필수 입력 항목입니다.")
    val state: String,
    @field:Schema(description = "국가", example = "대한민국")
    @field:NotBlank(message = "국가는 필수 입력 항목입니다.")
    val country: String,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true", defaultValue = "false")
    val isDefault: Boolean? = false,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateProfileRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateProfileRequestV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern

@Schema(description = "사용자 프로필 수정 요청")
data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:Schema(description = "전화번호 (선택)", example = "010-1234-5678", nullable = true)
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/extensions/dto/request/UserCommandRequestExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/extensions/dto/request/UserCommandRequestExtensions.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.command.extensions.dto.request

import com.restaurant.user.application.command.dto.ChangePasswordCommand
import com.restaurant.user.application.command.dto.DeleteUserCommand
import com.restaurant.user.application.command.dto.LoginCommand
import com.restaurant.user.application.command.dto.RegisterAddressCommand
import com.restaurant.user.application.command.dto.RegisterUserCommand
import com.restaurant.user.application.command.dto.UpdateAddressCommand
import com.restaurant.user.application.command.dto.UpdateProfileCommand
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1

fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
        username = this.username,
        phoneNumber = this.phoneNumber,
    )

fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

fun UpdateProfileRequestV1.toCommand(userId: UserId): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId.value.toString(),
        name = this.name,
        phoneNumber = this.phoneNumber,
    )

fun ChangePasswordRequestV1.toCommand(userId: UserId): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId.value.toString(),
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

fun DeleteUserRequestV1.toCommand(userId: UserId): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId.value.toString(),
        password = this.currentPassword,
    )

fun RegisterAddressRequestV1.toCommand(userId: UserId): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId.value.toString(),
        name = this.name,
        street = this.street,
        detail = this.detail ?: "",
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

fun UpdateAddressRequestV1.toCommand(
    userId: UserId,
    addressId: AddressId,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId.value.toString(),
        addressId = addressId.value.toString(),
        name = this.name,
        street = this.street,
        detail = this.detail ?: "",
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserAddressQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserAddressQueryController.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.controller

import com.restaurant.user.application.query.GetAddressByIdQueryHandler
import com.restaurant.user.application.query.GetUserAddressesQueryHandler
import com.restaurant.user.application.query.dto.GetAddressByIdQuery
import com.restaurant.user.application.query.dto.GetUserAddressesQuery
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.query.dto.response.AddressDetailResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toDetailResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.ArraySchema
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
@Tag(name = "User Address Queries", description = "사용자 주소 조회 API")
class UserAddressQueryController(
    private val getUserAddressesQueryHandler: GetUserAddressesQueryHandler,
    private val getAddressByIdQueryHandler: GetAddressByIdQueryHandler,
) {
    @GetMapping
    @Operation(
        summary = "사용자 주소 목록 조회",
        description = "특정 사용자의 모든 주소를 조회합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 목록 조회 성공",
                content = [
                    Content(
                        mediaType = "application/json",
                        array = ArraySchema(schema = Schema(implementation = AddressResponseV1::class)),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserAddresses(
        @Parameter(description = "주소를 조회할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
    ): ResponseEntity<List<AddressResponseV1>> {
        log.info { "Received request to get addresses for user ID: $userId" }
        val query = GetUserAddressesQuery(userId = UserId.of(userId).value.toString())
        val addresses = getUserAddressesQueryHandler.getUserAddresses(query)
        val responseList = addresses.map { it.toResponseV1() }

        log.info { "Returning ${responseList.size} addresses for user ID: $userId" }
        return ResponseEntity.ok(responseList)
    }

    @GetMapping("/{addressId}")
    @Operation(
        summary = "특정 주소 상세 조회",
        description = "사용자의 특정 주소 상세 정보를 조회합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 상세 조회 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = AddressDetailResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getAddressById(
        @Parameter(description = "주소를 조회할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "조회할 주소의 ID", required = true, example = "b2c3d4e5-f6a7-8901-2345-67890abcdef1")
        @PathVariable addressId: UUID,
    ): ResponseEntity<AddressDetailResponseV1> {
        log.info { "Received request to get address ID: $addressId for user ID: $userId" }
        val query =
            GetAddressByIdQuery(
                userId = UserId.of(userId).value.toString(),
                addressId = AddressId.of(addressId).value.toString(),
            )
        val address = getAddressByIdQueryHandler.getAddressById(query)
        val response = address.toDetailResponseV1()

        log.info { "Returning address details for address ID: $addressId" }
        return ResponseEntity.ok(response)
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserQueryController.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.controller

import com.restaurant.user.application.query.GetUserProfileQueryHandler
import com.restaurant.user.application.query.dto.GetUserProfileByIdQuery
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.query.dto.response.UserProfileResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Queries", description = "사용자 정보 조회 API")
class UserQueryController(
    private val getUserProfileQueryHandler: GetUserProfileQueryHandler,
) {
    @GetMapping("/{userId}/profile")
    @Operation(
        summary = "사용자 프로필 조회",
        description = "사용자 ID로 프로필 정보를 조회합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 조회 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = UserProfileResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 UUID 형식",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "조회할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
    ): ResponseEntity<UserProfileResponseV1> {
        log.info { "Received request to get profile for user ID: $userId" }
        val query = GetUserProfileByIdQuery(userId = UserId.of(userId).value.toString())
        val userProfileDto = getUserProfileQueryHandler.getUserProfile(query)
        val responseDto = userProfileDto.toResponseV1()

        log.info { "Returning user profile for ID: $userId" }
        return ResponseEntity.ok(responseDto)
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressDetailResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressDetailResponseV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import java.time.Instant

@Schema(description = "사용자 주소 상세 응답")
data class AddressDetailResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "주소 이름", example = "집")
    val name: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val streetAddress: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detailAddress: String?,
    @Schema(description = "도시", example = "서울시")
    val city: String,
    @Schema(description = "주/도", example = "서울특별시")
    val state: String,
    @Schema(description = "국가", example = "대한민국")
    val country: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "주소 생성 시간", example = "2023-01-01T12:00:00.000000000Z")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "주소 최종 수정 시간", example = "2023-01-01T12:00:00.000000000Z")
    val updatedAt: Instant,
    @Schema(description = "엔티티 버전 (낙관적 락)", example = "1")
    val version: Long,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressResponseV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "사용자 주소 응답")
data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "주소 이름", example = "집")
    val name: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val streetAddress: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detailAddress: String?,
    @Schema(description = "도시", example = "서울시")
    val city: String,
    @Schema(description = "주/도", example = "서울특별시")
    val state: String,
    @Schema(description = "국가", example = "대한민국")
    val country: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/LoginResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/LoginResponseV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "로그인 응답 V1")
data class LoginResponseV1(
    @Schema(description = "사용자 ID (UUID)")
    val id: String,
    @Schema(description = "사용자 이름")
    val username: String,
    @Schema(description = "액세스 토큰")
    val accessToken: String,
    @Schema(description = "리프레시 토큰")
    val refreshToken: String
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/UserProfileResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/UserProfileResponseV1.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import java.time.Instant

/**
 * 사용자 프로필 정보 응답 DTO (Rule 1.4, 39)
 */
@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "사용자 아이디", example = "testuser") val username: String,
    @Schema(description = "전화번호", example = "010-1234-5678", nullable = true) val phoneNumber: String?,
    @Schema(description = "사용자 타입", example = "CUSTOMER") val userType: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 생성 시간", example = "2023-01-01T12:00:00.000000000Z")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01T12:00:00.000000000Z")
    val updatedAt: Instant,
    @Schema(description = "계정 상태", example = "ACTIVE", allowableValues = ["ACTIVE", "INACTIVE", "SUSPENDED"])
    val status: String,
    @Schema(description = "엔티티 버전 (낙관적 락)", example = "1")
    val version: Long,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserAddressQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserAddressQueryResponseExtensions.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.extensions.dto.response

import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.presentation.v1.query.dto.response.AddressDetailResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1

fun AddressDto.toDetailResponseV1(): AddressDetailResponseV1 =
    AddressDetailResponseV1(
        id = this.id,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )

fun AddressDto.toResponseV1(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserQueryResponseExtensions.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.user.presentation.v1.query.extensions.dto.response

import com.restaurant.user.application.query.dto.UserProfileDto
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.UserProfileResponseV1

fun UserProfileDto.toResponseV1(): UserProfileResponseV1 =
    UserProfileResponseV1(
        id = this.id,
        email = this.email,
        name = this.name,
        username = this.username,
        phoneNumber = this.phoneNumber,
        userType = this.userType,
        addresses = this.addresses.map { it.toResponseV1() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        status = this.status,
        version = this.version,
    )

fun UserProfileDto.AddressDto.toResponseV1(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

====================================================================


====================================================================
 File: independent/outbox/build.gradle.kts
 Path: independent/outbox/build.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0"
    kotlin("plugin.allopen") version "2.1.0"
    kotlin("plugin.serialization") version "2.1.0"
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    // Spring Boot & JPA
    implementation("org.springframework.boot:spring-boot-starter:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0")
    
    // Spring Kafka (KafkaTemplate 사용)
    implementation("org.springframework.kafka:spring-kafka:4.0.0-M2")
    
    // Confluent Schema Registry for JSON Schema support
    implementation("io.confluent:kafka-json-schema-serializer:7.5.1")
    implementation("io.confluent:kafka-schema-registry-client:7.5.1")
    
    // kotlinx.serialization for UserEvent (de)serialization
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.0")

    // UserEvent 정의를 참조하기 위한 의존성 (제거)
    // implementation(project(":domains:user:domain"))
    
    // Database migration
    implementation("org.flywaydb:flyway-core:11.8.2")
    
    // Jackson for JSON processing
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.19.0")
    
    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    
    // Logging
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    // Database drivers
    runtimeOnly("org.postgresql:postgresql:42.7.5")
    runtimeOnly("com.h2database:h2:2.3.232")
    
    // Test dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("org.springframework.kafka:spring-kafka-test:4.0.0-M2")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.testcontainers:testcontainers:1.21.0")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:postgresql:1.21.0")
    testImplementation("org.testcontainers:kafka:1.21.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessage.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessage.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.dto

import java.time.Instant

/**
 * Outbox 메시지를 나타내는 도메인 모델
 */
data class OutboxMessage(
    val id: Long? = null,
    val payload: Any,
    val topic: String,
    val headers: Map<String, String>,
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String,
    val createdAt: Instant = Instant.now(),
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val lastAttemptAt: Instant? = null,
    val errorMessage: String? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (payload != other.payload) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (eventType != other.eventType) return false
        if (createdAt != other.createdAt) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (lastAttemptAt != other.lastAttemptAt) return false
        if (errorMessage != other.errorMessage) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + payload.hashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + eventType.hashCode()
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + (lastAttemptAt?.hashCode() ?: 0)
        result = 31 * result + (errorMessage?.hashCode() ?: 0)
        return result
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageRepository.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.dto

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.application.dto.OutboxMessageStatus

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * @param message 저장할 메시지
     * @return 저장된 메시지
     */
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     */
    fun saveAll(messages: List<OutboxMessage>) // 반환 타입 Unit (없음)

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: Long): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     *
     * @param status 조회할 메시지 상태
     * @return 조회된 메시지 목록
     */
    fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다. (OutboxMessageStatus enum 사용)
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID (Long)
     * @param newStatus 새로운 상태 (OutboxMessageStatus)
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 상태의 메시지를 조회하여 처리 중(PROCESSING) 상태로 변경합니다.
     * 동시성 제어를 위해 적절한 잠금 메커니즘을 사용해야 합니다.
     *
     * @param status 조회 및 처리할 메시지의 현재 상태 (일반적으로 PENDING)
     * @param limit 조회할 최대 메시지 수
     * @return 처리 대상으로 표시된 메시지 목록
     */
    fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 특정 상태의 메시지 개수를 반환합니다.
     * @param status 조회할 메시지 상태
     * @return 해당 상태의 메시지 개수
     */
    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 메시지의 재시도 횟수를 1 증가시킵니다.
     * lastAttemptTime과 updatedAt도 현재 시간으로 업데이트합니다.
     * @param id 메시지 ID
     * @return 업데이트된 메시지 또는 null (메시지를 찾지 못한 경우)
     */
    fun incrementRetryCount(id: Long): OutboxMessage?

    /**
     * 처리되지 않은 메시지를 조회합니다. (FOR UPDATE SKIP LOCKED 사용 가능성 고려)
     * @param batchSize 조회할 최대 메시지 수
     * @return 처리되지 않은 OutboxMessage 목록
     */
    fun findUnprocessedMessages(batchSize: Int): List<OutboxMessage>

    /**
     * 메시지 상태를 업데이트합니다. (이 메서드는 updateStatus(id, newStatus, incrementRetry)로 대체될 수 있음)
     * @param messageId 업데이트할 메시지 ID
     * @param status 새로운 상태 (OutboxMessageStatus)
     * @param retryCount 재시도 횟수
     */
    fun updateMessageStatus( // status 타입을 OutboxMessageStatus로 변경
        messageId: Long,
        status: OutboxMessageStatus,
        retryCount: Int,
    )

    /**
     * 특정 상태이고 재시도 횟수가 지정된 값 미만인 메시지 목록을 조회합니다.
     * 주로 재시도할 실패(FAILED) 메시지를 찾는데 사용됩니다.
     *
     * @param status 조회할 메시지의 상태
     * @param maxRetries 이 횟수 미만으로 재시도된 메시지만 조회
     * @param limit 조회할 최대 메시지 수
     * @return 조건에 맞는 OutboxMessage 목록
     */
    fun findByStatusAndRetryCountLessThan(
        status: OutboxMessageStatus,
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageStatus.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageStatus.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.dto

/** Outbox 메시지 상태 enum */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,

    /**
     * 더 이상 처리하지 않을 메시지
     */
    DISCARDED,
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxMetricsHandler.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxMetricsHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.handler

import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.outbox.application.dto.OutboxMessageStatus
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component

/**
 * Outbox 메트릭 및 모니터링 컴포넌트
 * Rule VII.2.23: 모니터링 설정 구축
 * Rule 80: 독립 모듈의 Application 레이어에 위치
 */
@Component
@ConditionalOnProperty(
    name = ["outbox.polling.enabled"],
    havingValue = "true",
    matchIfMissing = false,
)
class OutboxMetricsHandler(
    private val outboxMessageRepository: OutboxMessageRepository,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)

    /**
     * Outbox 메시지 상태별 통계를 주기적으로 로깅합니다.
     * Rule VII.2.23: 저장된 메시지 수, 전송 실패 수 등 메트릭 모니터링
     */
    @Scheduled(fixedRate = 60000) // 1분마다 실행
    fun logOutboxMetrics() {
        try {
            val pendingCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.PENDING)
            val processingCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.PROCESSING)
            val sentCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.SENT)
            val failedCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.FAILED)
            val deadLetteredCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.DEAD_LETTERED)

            logger.info(
                "Outbox Metrics - PENDING: {}, PROCESSING: {}, SENT: {}, FAILED: {}, DEAD_LETTERED: {}",
                pendingCount,
                processingCount,
                sentCount,
                failedCount,
                deadLetteredCount,
            )

            // 경고 조건 체크
            if (failedCount > 100) {
                logger.warn("High number of failed messages detected: {}", failedCount)
            }

            if (deadLetteredCount > 0) {
                logger.warn("Dead lettered messages detected: {}", deadLetteredCount)
            }

            if (pendingCount > 1000) {
                logger.warn("High number of pending messages detected: {}", pendingCount)
            }
        } catch (e: Exception) {
            logger.error("Failed to collect outbox metrics", e)
        }
    }

    /**
     * 오래된 성공 메시지 정리를 위한 통계 로깅
     * 운영 환경에서 정리 작업 계획 수립을 위한 정보 제공
     */
    @Scheduled(fixedRate = 3600000) // 1시간마다 실행
    fun logCleanupCandidates() {
        try {
            val sentCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.SENT)
            logger.info("Cleanup candidates - SENT messages: {}", sentCount)

            if (sentCount > 10000) {
                logger.info("Consider implementing cleanup job for sent messages")
            }
        } catch (e: Exception) {
            logger.error("Failed to collect cleanup metrics", e)
        }
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxPoller.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxPoller.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.handler

import com.restaurant.outbox.application.usecase.ProcessOutboxEventsUseCase
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component

/**
 * Outbox 폴링/전송 컴포넌트
 * Rule 86: Outbox 모듈의 Application 레이어에 위치하는 폴링 컴포넌트
 * Rule 87: 동시성 제어를 위한 데이터베이스 수준 잠금 사용
 */
@Component
@ConditionalOnProperty(
    name = ["outbox.polling.enabled"],
    havingValue = "true",
    matchIfMissing = false,
)
class OutboxPoller(
    private val processOutboxEventsUseCase: ProcessOutboxEventsUseCase,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)
    private val batchSize = 100
    private val maxRetries = 3

    /**
     * 대기 중인 메시지를 주기적으로 폴링하여 처리합니다.
     * Rule 86: 주기적인 조회 및 메시지 브로커 전송 처리
     */
    @Scheduled(fixedRate = 1000) // 1초마다 실행
    fun pollAndProcessMessages() {
        try {
            val processedCount = processOutboxEventsUseCase.processPendingMessages(batchSize)
            if (processedCount > 0) {
                logger.debug("Processed {} pending messages", processedCount)
            }
        } catch (e: Exception) {
            logger.error("Error in outbox polling process", e)
        }
    }

    /**
     * 실패한 메시지를 주기적으로 재시도합니다.
     * Rule 90: 재시도 정책에 따른 실패 메시지 처리
     */
    @Scheduled(fixedRate = 300000) // 5분마다 실행
    fun retryFailedMessages() {
        try {
            val retryCount = processOutboxEventsUseCase.retryFailedMessages(maxRetries, batchSize)
            if (retryCount > 0) {
                logger.debug("Marked {} failed messages for retry", retryCount)
            }
        } catch (e: Exception) {
            logger.error("Error in failed message retry process", e)
        }
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/ProcessOutboxEventsUseCaseHandler.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/ProcessOutboxEventsUseCaseHandler.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.handler

import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.application.usecase.ProcessOutboxEventsUseCase
import com.restaurant.outbox.infrastructure.exception.OutboxException
import com.restaurant.outbox.infrastructure.messaging.OutboxMessageSender
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox 이벤트 처리 Use Case 구현체
 * Rule 80: 독립 모듈의 Application Layer Use Case 구현체
 */
@Service
open class ProcessOutboxEventsUseCaseHandler(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSender,
) : ProcessOutboxEventsUseCase {
    private val logger = LoggerFactory.getLogger(this::class.java)

    @Transactional
    override fun process(outboxMessage: OutboxMessage) {
        try {
            outboxMessageSender.processAndSendMessage(outboxMessage)
            outboxMessage.id?.let { id ->
                outboxMessageRepository.updateStatus(id, OutboxMessageStatus.SENT)
                logger.debug("Successfully processed outbox message with ID: {}", id)
            }
        } catch (e: OutboxException.KafkaSendFailedException) {
            logger.error("Kafka send failed for message: {}, Error: {}", outboxMessage.id, e.message)
            outboxMessage.id?.let { id ->
                outboxMessageRepository.updateStatus(id, OutboxMessageStatus.FAILED, true)
            }
            throw e
        } catch (e: Exception) {
            logger.error("Unexpected error processing message: {}, Error: {}", outboxMessage.id, e.message, e)
            outboxMessage.id?.let { id ->
                outboxMessageRepository.updateStatus(id, OutboxMessageStatus.FAILED, true)
            }
            throw OutboxException.MessageProcessingFailedException(
                "Failed to process outbox message with ID ${outboxMessage.id}",
                e,
            )
        }
    }

    @Transactional
    override fun processPendingMessages(batchSize: Int): Int {
        try {
            val pendingMessages =
                outboxMessageRepository.findAndMarkForProcessing(
                    OutboxMessageStatus.PENDING,
                    batchSize,
                )

            if (pendingMessages.isEmpty()) {
                return 0
            }

            logger.debug("Found {} pending messages to process", pendingMessages.size)

            pendingMessages.forEach { message ->
                try {
                    process(message)
                } catch (e: Exception) {
                    logger.error("Failed to process message ID: {}", message.id, e)
                    // 개별 메시지 실패는 전체 배치를 중단시키지 않음
                }
            }

            return pendingMessages.size
        } catch (e: Exception) {
            logger.error("Error in processing pending messages", e)
            throw OutboxException.MessageProcessingFailedException(
                "Failed to process pending messages",
                e,
            )
        }
    }

    @Transactional
    override fun retryFailedMessages(
        maxRetries: Int,
        batchSize: Int,
    ): Int {
        try {
            val failedMessages =
                outboxMessageRepository.findByStatusAndRetryCountLessThan(
                    status = OutboxMessageStatus.FAILED,
                    maxRetries = maxRetries,
                    limit = batchSize,
                )

            if (failedMessages.isEmpty()) {
                return 0
            }

            logger.debug("Found {} failed messages for retry", failedMessages.size)

            var retryCount = 0
            failedMessages.forEach { message ->
                try {
                    message.id?.let { id ->
                        outboxMessageRepository.updateStatus(id, OutboxMessageStatus.PENDING, false)
                        retryCount++
                        logger.info("Message ID {} marked as PENDING for retry", id)
                    }
                } catch (e: Exception) {
                    logger.error("Error resetting failed message to PENDING: {}", message.id, e)
                }
            }

            return retryCount
        } catch (e: Exception) {
            logger.error("Error in failed message retry process", e)
            throw OutboxException.MessageProcessingFailedException(
                "Failed to retry failed messages",
                e,
            )
        }
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/usecase/ProcessOutboxEventsUseCase.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/usecase/ProcessOutboxEventsUseCase.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.application.usecase

import com.restaurant.outbox.application.dto.OutboxMessage

/**
 * Outbox 이벤트 처리를 위한 Use Case 인터페이스
 * Rule 80: 독립 모듈의 Application Layer Use Case 인터페이스
 */
interface ProcessOutboxEventsUseCase {
    /**
     * 단일 Outbox 메시지를 처리합니다.
     * @param outboxMessage 처리할 Outbox 메시지
     */
    fun process(outboxMessage: OutboxMessage)

    /**
     * 대기 중인 Outbox 메시지들을 배치로 처리합니다.
     * @param batchSize 처리할 최대 메시지 수
     * @return 처리된 메시지 수
     */
    fun processPendingMessages(batchSize: Int = 100): Int

    /**
     * 실패한 Outbox 메시지들을 재시도합니다.
     * @param maxRetries 최대 재시도 횟수
     * @param batchSize 처리할 최대 메시지 수
     * @return 재시도 대상으로 표시된 메시지 수
     */
    fun retryFailedMessages(
        maxRetries: Int = 3,
        batchSize: Int = 100,
    ): Int
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/config/OutboxKafkaConfig.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/config/OutboxKafkaConfig.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Outbox 모듈의 Kafka 설정
 * Rule 88: KafkaTemplate Bean 정의
 * Schema Registry 엄격한 호환성 검사 활성화
 */
@Configuration
open class OutboxKafkaConfig {
    /**
     * KafkaTemplate for Outbox message sending
     * Rule 88: OutboxMessageSender에서 사용할 KafkaTemplate Bean
     * StringSerializer를 사용하여 JSON 문자열 전송
     */
    @Bean
    open fun outboxKafkaTemplate(outboxProducerFactory: ProducerFactory<String, String>): KafkaTemplate<String, String> =
        KafkaTemplate(outboxProducerFactory)

    /**
     * Producer Factory for Outbox
     * StringSerializer 사용 (JSON 문자열 전송)
     */
    @Bean
    open fun outboxProducerFactory(): ProducerFactory<String, String> {
        val props = mutableMapOf<String, Any>()

        // 기본 설정 - application.yml에서 오버라이드 가능
        props[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = "localhost:9092"
        props[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java

        // String Serializer 사용 (JSON 문자열 전송)
        props[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java

        // Producer 최적화 설정
        props[ProducerConfig.ACKS_CONFIG] = "all"
        props[ProducerConfig.RETRIES_CONFIG] = 3
        props[ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG] = true
        props[ProducerConfig.BATCH_SIZE_CONFIG] = 16384
        props[ProducerConfig.BUFFER_MEMORY_CONFIG] = 33554432
        props[ProducerConfig.COMPRESSION_TYPE_CONFIG] = "lz4"
        props[ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG] = 120000
        props[ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG] = 30000
        props[ProducerConfig.MAX_BLOCK_MS_CONFIG] = 60000
        props[ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION] = 1

        return DefaultKafkaProducerFactory(props)
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/converter/StringMapConverter.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/converter/StringMapConverter.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.converter

import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.ObjectMapper
import jakarta.persistence.AttributeConverter
import jakarta.persistence.Converter

/**
 * Map<String, String>을 JSON 문자열로 변환하는 JPA Converter
 * Rule 83: Outbox 모듈의 Infrastructure 레이어 내 converter 패키지에 위치
 */
@Converter
class StringMapConverter : AttributeConverter<Map<String, String>, String> {
    private val objectMapper = ObjectMapper()

    override fun convertToDatabaseColumn(attribute: Map<String, String>?): String =
        if (attribute == null) {
            "{}"
        } else {
            try {
                objectMapper.writeValueAsString(attribute)
            } catch (e: Exception) {
                throw IllegalArgumentException("Error converting map to JSON", e)
            }
        }

    override fun convertToEntityAttribute(dbData: String?): Map<String, String> =
        if (dbData.isNullOrBlank()) {
            emptyMap()
        } else {
            try {
                objectMapper.readValue(dbData, object : TypeReference<Map<String, String>>() {})
            } catch (e: Exception) {
                throw IllegalArgumentException("Error converting JSON to map", e)
            }
        }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.entity

import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.converter.StringMapConverter
import jakarta.persistence.Column
import jakarta.persistence.Convert
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Lob
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant

/** Outbox 메시지 JPA Entity */
@Entity
@Table(name = "outbox_events")
class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "aggregate_type", nullable = false)
    val aggregateType: String,
    @Column(name = "aggregate_id", nullable = false)
    val aggregateId: String,
    @Column(nullable = false)
    val topic: String,
    @Lob
    @Column(nullable = false, columnDefinition = "text")
    val payload: String,
    @Convert(converter = StringMapConverter::class)
    @Column(nullable = false, columnDefinition = "text")
    val headers: Map<String, String>,
    @Column(name = "event_type", nullable = false)
    val eventType: String,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at")
    var updatedAt: Instant? = Instant.now(), // 추가된 필드, 생성 시 현재 시간으로 초기화
    @Column(name = "last_attempt_time")
    var lastAttemptTime: Instant? = null,
    @Column(name = "retry_count", nullable = false)
    var retryCount: Int = 0,
    @Version
    var version: Long = 0,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventEntity

        if (id != other.id) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (topic != other.topic) return false
        if (payload != other.payload) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false // 추가된 필드 비교
        if (lastAttemptTime != other.lastAttemptTime) return false
        if (retryCount != other.retryCount) return false
        if (eventType != other.eventType) return false
        if (version != other.version) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + payload.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + (updatedAt?.hashCode() ?: 0) // 추가된 필드 해시코드
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        result = 31 * result + retryCount
        result = 31 * result + eventType.hashCode()
        result = 31 * result + version.hashCode()
        return result
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.error

enum class OutboxErrorCodes(
    val code: String,
    val message: String,
) {
    MESSAGE_NOT_FOUND("OUTBOX-001", "Outbox message not found"),
    MESSAGE_PROCESSING_FAILED("OUTBOX-002", "Failed to process outbox message"),
    KAFKA_SEND_FAILED("OUTBOX-003", "Failed to send message to Kafka"),
    MAX_RETRIES_EXCEEDED("OUTBOX-004", "Maximum retry attempts exceeded"),
    INVALID_MESSAGE_STATUS("OUTBOX-005", "Invalid message status transition"),
    DATABASE_ERROR("OUTBOX-006", "Database operation failed"), 
    SERIALIZATION_ERROR("OUTBOX-007", "Message serialization failed"),
    DATABASE_OPERATION_FAILED("OUTBOX-008", "Database operation failed"), 
    UNEXPECTED_INFRA_ERROR("OUTBOX-009", "An unexpected infrastructure error occurred")
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.exception

import com.restaurant.outbox.infrastructure.error.OutboxErrorCodes

/** Outbox 예외 베이스 클래스 */
sealed class OutboxException(
    val errorCode: OutboxErrorCodes,
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message ?: errorCode.message, cause) {
    class MessageNotFoundException(
        messageId: Long,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MESSAGE_NOT_FOUND,
        "Message not found with id: $messageId",
        cause,
    )

    class MessageProcessingFailedException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MESSAGE_PROCESSING_FAILED,
        message,
        cause,
    )

    class KafkaSendFailedException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.KAFKA_SEND_FAILED,
        message,
        cause,
    )

    class MaxRetriesExceededException(
        messageId: Long,
        maxRetries: Int,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MAX_RETRIES_EXCEEDED,
        "Maximum retry attempts ($maxRetries) exceeded for message: $messageId",
        cause,
    )

    class InvalidMessageStatusException(
        currentStatus: String,
        newStatus: String,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.INVALID_MESSAGE_STATUS,
        "Invalid status transition from $currentStatus to $newStatus",
        cause,
    )

    class DatabaseException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.DATABASE_ERROR,
        message,
        cause,
    )

    class SerializationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.SERIALIZATION_ERROR,
        message,
        cause,
    )

    class DatabaseOperationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.DATABASE_OPERATION_FAILED, message, cause)


    class UnexpectedInfrastructureException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.UNEXPECTED_INFRA_ERROR, message, cause)
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/extensions/OutboxEventEntityExtensions.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/extensions/OutboxEventEntityExtensions.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.extensions

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity

fun OutboxEventEntity.toDomain(): OutboxMessage {
    // DB에서 읽은 JSON 문자열 payload를 OutboxMessage.payload (String 또는 ByteArray)로 전달합니다.
    // OutboxEventEntity.payload는 String이므로, 여기서는 String으로 전달됩니다.
    return OutboxMessage(
        id = this.id,
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.eventType,
        payload = this.payload, // DB의 String payload를 그대로 전달
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        lastAttemptAt = this.lastAttemptTime,
        createdAt = this.createdAt,
        errorMessage = null,
    )
}

fun OutboxMessage.toEntity(): OutboxEventEntity {
    // OutboxMessage.payload (String 또는 ByteArray)를 OutboxEventEntity.payload (String)로 변환합니다.
    val payloadAsString: String =
        when (this.payload) {
            is String -> this.payload
            is ByteArray -> this.payload.toString(Charsets.UTF_8)
            else -> {
                // Rule 81에 따라 OutboxMessage.payload는 String 또는 ByteArray이어야 합니다.
                // 이 외의 타입이 들어오면 로직 또는 설정 오류입니다.
                throw IllegalArgumentException(
                    "OutboxMessage.payload must be a JSON String or ByteArray. Found: ${this.payload::class.simpleName}",
                )
            }
        }

    return OutboxEventEntity(
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.eventType,
        payload = payloadAsString, // 변환된 String payload
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        lastAttemptTime = this.lastAttemptAt,
        createdAt = this.createdAt,
        updatedAt = java.time.Instant.now(),
    )
}

fun OutboxMessage.toExistingEntity(existingEntity: OutboxEventEntity): OutboxEventEntity {
    existingEntity.status = this.status
    existingEntity.retryCount = this.retryCount
    existingEntity.lastAttemptTime = this.lastAttemptAt
    existingEntity.updatedAt = java.time.Instant.now()
    // payload는 일반적으로 변경되지 않음
    return existingEntity
}

fun OutboxMessage.updateFromDomain(existingEntity: OutboxEventEntity): OutboxEventEntity = this.toExistingEntity(existingEntity)

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/messaging/OutboxMessageSender.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/messaging/OutboxMessageSender.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.messaging

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.infrastructure.exception.OutboxException
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.common.header.internals.RecordHeader
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.support.SendResult
import org.springframework.stereotype.Component
import java.util.concurrent.CompletableFuture

/**
 * Outbox 메시지 전송 컴포넌트
 * Rule 88: KafkaTemplate을 사용하여 OutboxMessage를 Kafka로 전송
 * Rule VII.1.3.4: spring-kafka KafkaTemplate 기반 메시지 발행
 * Rule 80: 독립 모듈의 Infrastructure 레이어 내 messaging 패키지에 위치
 */
@Component
class OutboxMessageSender(
    private val kafkaTemplate: KafkaTemplate<String, String>,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)

    /**
     * Outbox 메시지를 처리하고 Kafka로 전송합니다.
     * Rule 88: 객체를 KafkaTemplate을 통해 메시지 브로커로 전송
     * Rule VII.1.3.4: KafkaJsonSchemaSerializer를 통한 JSON 직렬화 및 Schema Registry 활용 (이제 StringSerializer 사용)
     * 
     * @param messageDto 전송할 Outbox 메시지
     * @throws OutboxException.KafkaSendFailedException Kafka 전송 실패 시
     */
    fun processAndSendMessage(messageDto: OutboxMessage) {
        try {
            val producerRecord = createProducerRecord(messageDto)

            // KafkaTemplate을 사용하여 비동기 전송
            val future: CompletableFuture<SendResult<String, String>> = kafkaTemplate.send(producerRecord)
            
            // 비동기 콜백 설정
            future.whenComplete { result, exception ->
                if (exception != null) {
                    logger.error(
                        "Failed to send message to Kafka. MessageId: {}, Topic: {}, AggregateId: {}, Error: {}",
                        messageDto.id,
                        messageDto.topic,
                        messageDto.aggregateId,
                        exception.message,
                        exception
                    )
                    throw OutboxException.KafkaSendFailedException(
                        message = "Failed to send message to Kafka for OutboxMessage ID ${messageDto.id} (Topic: ${messageDto.topic}, AggregateId: ${messageDto.aggregateId}): ${exception.message}",
                        cause = exception
                    )
                } else {
                    logger.info(
                        "Successfully sent message to Kafka. Topic: {}, Partition: {}, Offset: {}, MessageId: {}, AggregateId: {}",
                        result.recordMetadata.topic(),
                        result.recordMetadata.partition(),
                        result.recordMetadata.offset(),
                        messageDto.id,
                        messageDto.aggregateId
                    )
                }
            }

        } catch (e: Exception) {
            logger.error(
                "Failed to send message to Kafka. MessageId: {}, Topic: {}, AggregateId: {}, Error: {}",
                messageDto.id,
                messageDto.topic,
                messageDto.aggregateId,
                e.message,
                e
            )
            throw OutboxException.KafkaSendFailedException(
                message = "Failed to send message to Kafka for OutboxMessage ID ${messageDto.id} (Topic: ${messageDto.topic}, AggregateId: ${messageDto.aggregateId}): ${e.message}",
                cause = e
            )
        }
    }

    /**
     * OutboxMessage를 Kafka ProducerRecord로 변환합니다.
     * Rule 88: Outbox Event Entity에 저장된 정보를 메시지 헤더에 포함
     * Rule VII.2.6: 토픽명 및 헤더 정보 설정
     * Rule VII.1.3.4: 객체 페이로드 및 Schema Registry 헤더 처리
     * 
     * @param messageDto 변환할 Outbox 메시지
     * @return Kafka 전송용 ProducerRecord
     */
    private fun createProducerRecord(messageDto: OutboxMessage): ProducerRecord<String, String> {
        // OutboxMessage.payload는 이미 kotlinx.serialization으로 직렬화된 JSON 문자열.
        // 이를 그대로 Kafka에 전송 (StringSerializer 사용).
        val payloadAsString: String = when (val p = messageDto.payload) {
            is String -> p
            is ByteArray -> {
                // ByteArray의 경우, UTF-8 문자열로 변환. (CI/CD에서 스키마 검증 시 이 변환을 고려해야 함)
                logger.warn(
                    "ByteArray payload received. Converting to UTF-8 string. OutboxMessage ID: {}",
                    messageDto.id
                )
                p.toString(Charsets.UTF_8)
            }
            else -> {
                logger.error(
                    "Unsupported payload type: {}. Expected String or ByteArray. OutboxMessage ID: {}",
                    p::class.simpleName, messageDto.id
                )
                throw OutboxException.KafkaSendFailedException(
                    message = "Unsupported payload type for OutboxMessage ID ${messageDto.id}: ${p::class.simpleName}"
                )
            }
        }

        val record = ProducerRecord<String, String>(
            messageDto.topic,
            messageDto.aggregateId, // Rule 88: Aggregate ID를 메시지 키로 사용
            payloadAsString // JSON 문자열 직접 전송
        )

        // Rule 88: Outbox Event Entity에 저장된 헤더 정보 포함
        messageDto.headers.forEach { (key, value) ->
            record.headers().add(RecordHeader(key, value.toByteArray()))
        }

        // 추가 메타데이터 헤더
        record.headers().add(RecordHeader("outbox-message-id", (messageDto.id?.toString() ?: "unknown").toByteArray()))
        record.headers().add(RecordHeader("aggregate-type", messageDto.aggregateType.toByteArray()))
        record.headers().add(RecordHeader("event-type", messageDto.eventType.toByteArray()))
        record.headers().add(RecordHeader("created-at", messageDto.createdAt.toString().toByteArray()))

        return record
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxEventRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxEventRepository.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

@Repository
interface JpaOutboxEventRepository : JpaRepository<OutboxEventEntity, Long> {
    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    fun findTopByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    fun findByStatusAndRetryCountGreaterThanEqual(
        status: OutboxMessageStatus,
        retryCount: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 특정 상태의 메시지들을 조회하되, 재시도 횟수가 특정 값 미만인 메시지들만 조회합니다.
     * 이 메서드는 주로 실패한 메시지 중 아직 재시도 한도에 도달하지 않은 메시지를 찾는데 사용될 수 있습니다.
     */
    @Query(
        "SELECT oe FROM OutboxEventEntity oe WHERE oe.status = :status AND oe.retryCount < :maxRetries ORDER BY oe.createdAt ASC",
    )
    fun findByStatusAndRetryCountLessThan(
        @Param("status") status: OutboxMessageStatus, // OutboxMessageStatus로 수정
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    /**
     * 처리되지 않은 이벤트를 조회하며 비관적 잠금을 사용합니다. (SKIP LOCKED 사용)
     * 데이터베이스에 따라 @QueryHint 사용이 필요할 수 있습니다.
     * 예시: PostgreSQL의 경우 FOR UPDATE SKIP LOCKED
     * Spring Data JPA 3.x 이상에서는 @Lock(LockModeType.PESSIMISTIC_WRITE)와 함께
     * spring.jpa.properties.jakarta.persistence.lock.timeout=0 (또는 DB 특화 힌트) 설정 고려.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        "SELECT e FROM OutboxEventEntity e WHERE e.status = com.restaurant.outbox.application.dto.OutboxMessageStatus.PENDING ORDER BY e.createdAt ASC",
    )
    fun findUnprocessedEventsWithLock(pageable: Pageable): List<OutboxEventEntity>
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxMessageRepository.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.time.Instant

interface JpaOutboxMessageRepository : JpaRepository<OutboxEventEntity, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND (e.lastAttemptTime IS NULL OR e.lastAttemptTime < :cutoffTime)
        AND e.retryCount < :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findMessagesToProcess(
        @Param("status") status: OutboxMessageStatus,
        @Param("cutoffTime") cutoffTime: Instant,
        @Param("maxRetries") maxRetries: Int = 3,
    ): List<OutboxEventEntity>

    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    fun findTopByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    @Query("SELECT COUNT(e) FROM OutboxEventEntity e WHERE e.status = :status")
    fun countByStatus(
        @Param("status") status: OutboxMessageStatus,
    ): Long

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND e.retryCount >= :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findByStatusAndRetryCountGreaterThanEqual(
        @Param("status") status: OutboxMessageStatus,
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    @Query(
        "SELECT oe FROM OutboxEventEntity oe WHERE oe.status = :status AND oe.retryCount < :maxRetries ORDER BY oe.createdAt ASC",
    )
    fun findByStatusAndRetryCountLessThan(
        @Param("status") status: OutboxMessageStatus,
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        "SELECT e FROM OutboxEventEntity e WHERE e.status = com.restaurant.outbox.application.dto.OutboxMessageStatus.PENDING ORDER BY e.createdAt ASC",
    )
    fun findUnprocessedEventsWithLock(pageable: Pageable): List<OutboxEventEntity>
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/OutboxMessageRepositoryImpl.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/OutboxMessageRepositoryImpl.kt
 Timestamp: 2025-06-09 13:05:17
====================================================================
package com.restaurant.outbox.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import com.restaurant.outbox.infrastructure.exception.OutboxException
import com.restaurant.outbox.infrastructure.extensions.toDomain
import com.restaurant.outbox.infrastructure.extensions.toEntity
import org.slf4j.LoggerFactory
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant

/**
 * Outbox 메시지 저장 Repository 구현체
 * Rule 82: Outbox 모듈의 Infrastructure 레이어 내 repository 패키지에 위치
 * Rule 87: 동시성 제어를 위한 데이터베이스 수준 잠금 사용
 */
@Repository
open class OutboxMessageRepositoryImpl(
    private val jpaOutboxEventRepository: JpaOutboxEventRepository,
) : OutboxMessageRepository {
    private val logger = LoggerFactory.getLogger(this::class.java)

    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        try {
            val entity = message.toEntity()
            val savedEntity = jpaOutboxEventRepository.save(entity)
            return savedEntity.toDomain()
        } catch (e: Exception) {
            logger.error("Failed to save outbox message", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to save outbox message",
                e,
            )
        }
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>) {
        try {
            val entities = messages.map { it.toEntity() }
            jpaOutboxEventRepository.saveAll(entities)
            logger.debug("Successfully saved {} outbox messages", messages.size)
        } catch (e: Exception) {
            logger.error("Failed to save {} outbox messages", messages.size, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to save outbox messages",
                e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: Long): OutboxMessage? =
        try {
            jpaOutboxEventRepository.findById(id).map { it.toDomain() }.orElse(null)
        } catch (e: Exception) {
            logger.error("Failed to find outbox message by id: {}", id, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find outbox message by id: $id",
                e,
            )
        }

    @Transactional(readOnly = true)
    override fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage> =
        try {
            jpaOutboxEventRepository.findByStatus(status).map { it.toDomain() }
        } catch (e: Exception) {
            logger.error("Failed to find outbox messages by status: {}", status, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find outbox messages by status: $status",
                e,
            )
        }

    @Transactional
    override fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        return try {
            val entity = jpaOutboxEventRepository.findById(id).orElse(null) ?: return null
            entity.status = newStatus
            if (incrementRetry) {
                entity.retryCount += 1
            }
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()
            val savedEntity = jpaOutboxEventRepository.save(entity)
            savedEntity.toDomain()
        } catch (e: Exception) {
            logger.error("Failed to update status for message id: {}", id, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to update status for message id: $id",
                e,
            )
        }
    }

    /**
     * Rule 87: 동시성 제어를 위한 데이터베이스 수준 잠금 사용
     * PESSIMISTIC_WRITE 잠금과 함께 SKIP LOCKED 기능 활용
     */
    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> =
        try {
            val pageable: Pageable = PageRequest.of(0, limit)
            val entitiesToProcess =
                when (status) {
                    OutboxMessageStatus.PENDING -> {
                        // Rule 87: SKIP LOCKED를 사용한 동시성 제어
                        jpaOutboxEventRepository.findUnprocessedEventsWithLock(pageable)
                    }
                    else -> {
                        jpaOutboxEventRepository.findTopByStatusOrderByCreatedAtAsc(status, pageable)
                    }
                }

            val processedMessages =
                entitiesToProcess.mapNotNull { entity: OutboxEventEntity ->
                    try {
                        entity.status = OutboxMessageStatus.PROCESSING
                        entity.lastAttemptTime = Instant.now()
                        entity.updatedAt = Instant.now()
                        val savedEntity = jpaOutboxEventRepository.save(entity)
                        savedEntity.toDomain()
                    } catch (e: Exception) {
                        logger.warn("Failed to mark message {} for processing", entity.id, e)
                        null
                    }
                }

            logger.debug("Marked {} messages for processing", processedMessages.size)
            processedMessages
        } catch (e: Exception) {
            logger.error("Failed to find and mark messages for processing", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find and mark messages for processing",
                e,
            )
        }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long =
        try {
            jpaOutboxEventRepository.countByStatus(status)
        } catch (e: Exception) {
            logger.error("Failed to count messages by status: {}", status, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to count messages by status: $status",
                e,
            )
        }

    @Transactional
    override fun incrementRetryCount(id: Long): OutboxMessage? {
        return try {
            val entity = jpaOutboxEventRepository.findById(id).orElse(null) ?: return null
            entity.retryCount += 1
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()
            val savedEntity = jpaOutboxEventRepository.save(entity)
            savedEntity.toDomain()
        } catch (e: Exception) {
            logger.error("Failed to increment retry count for message id: {}", id, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to increment retry count for message id: $id",
                e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findUnprocessedMessages(batchSize: Int): List<OutboxMessage> =
        try {
            jpaOutboxEventRepository
                .findTopByStatusOrderByCreatedAtAsc(OutboxMessageStatus.PENDING, PageRequest.of(0, batchSize))
                .map { it.toDomain() }
        } catch (e: Exception) {
            logger.error("Failed to find unprocessed messages", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find unprocessed messages",
                e,
            )
        }

    @Transactional
    override fun updateMessageStatus(
        messageId: Long,
        status: OutboxMessageStatus,
        retryCount: Int,
    ) {
        try {
            val entity =
                jpaOutboxEventRepository.findById(messageId).orElseThrow {
                    OutboxException.MessageNotFoundException(messageId)
                }

            entity.status = status
            entity.retryCount = retryCount
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()

            jpaOutboxEventRepository.save(entity)
        } catch (e: OutboxException) {
            throw e
        } catch (e: Exception) {
            logger.error("Failed to update message status for id: {}", messageId, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to update message status for id: $messageId",
                e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findByStatusAndRetryCountLessThan(
        status: OutboxMessageStatus,
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        try {
            val pageable: Pageable = PageRequest.of(0, limit)
            jpaOutboxEventRepository
                .findByStatusAndRetryCountLessThan(status, maxRetries, pageable)
                .map { it.toDomain() }
        } catch (e: Exception) {
            logger.error("Failed to find messages by status and retry count", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find messages by status and retry count",
                e,
            )
        }
}

====================================================================


====================================================================
 File: settings.gradle.kts
 Path: settings.gradle.kts
 Timestamp: 2025-06-09 13:05:17
====================================================================
import org.gradle.api.initialization.resolve.RepositoriesMode

/**
 * settings.gradle.kts for the project.
 *
 * Configures plugin repositories and project structure for Gradle.
 *
 * @author junoko
 */

rootProject.name = "restaurant"

pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

@Suppress("UnstableApiUsage")
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)
    repositories { 
        mavenCentral()
        maven { url = uri("https://maven.pkg.jetbrains.space/public/p/kotlinx-html/maven") }  // Add JetBrains repo for Kotlin
        maven { url = uri("https://packages.confluent.io/maven/") }
        // Spring Milestones and Snapshots for Spring Cloud compatibility if needed in the future
        // maven { url = uri("https://repo.spring.io/milestone") }
    }
}

// Common modules
include(":domains:common:domain")
include(":domains:common:application")
include(":domains:common:infrastructure")
include(":domains:common:presentation")

// User modules
include(":domains:user:domain")
include(":domains:user:application")
include(":domains:user:infrastructure")
include(":domains:user:presentation")

// Independent modules
include(":independent:outbox")

// Application modules
include(":apps:user-app")

====================================================================

==============================================================
 File Collection Completed: 2025-06-09 22:05:17 
==============================================================
