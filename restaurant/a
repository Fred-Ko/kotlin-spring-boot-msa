이 문서는
```
#!/bin/bash

# File to store the output
OUTPUT_FILE="a"

# Run Gradle clean
./gradlew clean 2>&1 | tee $OUTPUT_FILE

echo -e "\n--------------------------------------------------------------------\n\n" >> $OUTPUT_FILE

# Run Gradle build for specified modules, excluding tests
./gradlew :domains:user:application:build \
  :apps:user-app:build \
  :domains:user:domain:build \
  :domains:user:infrastructure:build \
  :domains:user:presentation:build \
  :independent:outbox:build \
  -x test 2>&1 | tee -a $OUTPUT_FILE

# Add a section separator
echo -e "\n\n==============================================================" >>$OUTPUT_FILE
echo -e " Gradle Build Completed: $(date '+%Y-%m-%d %H:%M:%S') " >>$OUTPUT_FILE
echo -e "==============================================================\n" >>$OUTPUT_FILE

# Run ktlintFormat
./gradlew ktlintFormat 2>&1 | tee -a $OUTPUT_FILE

# Add another section separator
echo -e "\n\n==============================================================" >>$OUTPUT_FILE
echo -e " ktlintFormat Completed: $(date '+%Y-%m-%d %H:%M:%S') " >>$OUTPUT_FILE
echo -e "==============================================================\n" >>$OUTPUT_FILE

echo -e "\n==============================================================" >>$OUTPUT_FILE
echo -e "\n# Project Structure\n" >>$OUTPUT_FILE
tree domains independent \
  -I 'build|bin|test' \
  -P '*.kt|*.kts|*.gradle' \
  >>$OUTPUT_FILE
echo -e "==============================================================\n\n" >>$OUTPUT_FILE

# Collect and append Kotlin/Gradle files with enhanced separators
find domains/user domains/common independent \
  -type d \( -name build -o -name bin -o -name test \) -prune -o \
  -type f \( -name "*.kt" -o -name "*.kts" -o -name "*.gradle" \) -print |
  sort -u |
  while read -r file; do
    {
      echo -e "\n\n===================================================================="
      echo -e " File: $file"
      echo -e " Path: $(realpath --relative-to=. "$file")"
      echo -e " Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
      echo -e "===================================================================="
      cat "$file"
      echo -e "\n--------------------------------------------------------------------\n"
    } >> "$OUTPUT_FILE"
  done

# Final footer
echo -e "\n==============================================================" >>$OUTPUT_FILE
echo -e " File Collection Completed: $(date '+%Y-%m-%d %H:%M:%S') " >>$OUTPUT_FILE
echo -e "==============================================================" >>$OUTPUT_FILE
```
명령어의 결과이다.

즉 모듈들의 전체 코드가 첨부되어있다.
코드를 보면 불완전 한 부분도 있고 규칙을 지키지 않는 부분도 있다.
따라서 코드에 기준으로 작업을 완료하려고 하면 완성이 안될꺼다. 왜냐하면 코드가 정말 엉망이기 떄문이다. 어떤 요구사항인지 잘생각해서 수정계획을 해야한다.
그래서 이를 수정하기 위한 작업 지시서가 필요하다. 작업 지시서를 만들어라.
- tree 구조를 보고 규칙에 맞지않는 부분을 찾아서 삭제할 파일, 이동할 파일에 대한 작업지시서는 최우선이다. 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 규칙을 지키지 않는 부분에 대한 작업지시서를 작성하라
- 프로그램이 정상적으로 동작하기위해 추가적으로 작업해야하는 작업지시서를 작성하라
- 작업지시서는 단계가 명확하게 표현되어야 한다. 하지만 작업의 순서를 잘생각해서 먼저되어야 하는건 꼭 먼저하도록 단계를 잘 생각하라.
- build.gradle.kts는 최상위 파일에 공통부분을 최대한 모아놓고 각 모듈별로 필요한 부분은 모듈 내부에 작성한다.
- 작업지시서에서는 Gradle 의존성에 대한 버전에 대해서 지적하지 않는다. 모두 최신버전으로 팀내에서 직접 관리하는 영역이다.
- 필요없는 파일은 삭제하도록 지시하라.
- 필요없는 코드는 주석보단 삭제를 하도록 지시하라.
- 현재 코드를 유지하는 경우는 작업지시서에 굳이 명시하지 않아도 된다.
- 작업지시서는 ~을 확인해라. 같은 모호한 문장은 절대로 안된다. ~을 어떻게 고쳐라 같이 매우 명시적이여야 한다.
- 작업지시서는 어떤 파일이 어떤 부분이 잘못작성되었고 어떻게 고쳐야한다. 그리고 근거는 무엇이다 라는 명시적 문장이 있어야 한다.
- 작업지시서 제일 하단에는 모든 작업이 끝나고 확인해야할 체크리스트를 작성한다.
- 이프로젝트는 Kotlin 으로 작성되어있다. Java는 사용하지 않는다.

작업 지시서에 항상 상단에 첨부할 문구
```
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.

작업시 항상 기억해야할 규칙
- 파일을 수정할때는 import 구문이 완벽한지 한번씩 더 체크하도록 한다. 만약 확인이 필요하다면 다른 파일을 조회할 수 있다.
- 작업을 진행하는 도중에 작업지시서에 없는 수정사항은 일단 보류하고 작업지시서를 최우선으로 수정한다.
- 이런식의 참조는 금지한다. ( ex -> event: com.restaurant.domains.common.domain.event.DomainEvent ) 항상 import 구문을 추가해서 참조하도록 한다.
- com.restaurant.domains.common.* 과 같은 import는 절대로 금지한다.
- 공통으로 수정해야할 패턴이 확실하다면 커맨드 명령어로 한번에 처리한다. 단, 프로젝트 내부에 build,bin 같은 제외할 경로는 명확히 명시한다.
- 필요없는 코드는 주석처리 하지 말고 삭제하도록 하라.
- 파일을 생성 할때는 위치가 올바른지 확인하기 위해서 파일 구조도를 참고하도록 한다.
- 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 의존성 버전은 항상 tools 이용해서 최신 스테이블 버전을 활용하도록 한다.
```

--------------------------------------------------------------------


Discovered module: :config
Discovered module: :domains:user:domain
Discovered module: :domains:user:presentation
Discovered module: :domains:user:infrastructure:messaging
Discovered module: :domains:user:infrastructure:persistence
Discovered module: :domains:user:application
Discovered module: :domains:common
Discovered module: :domains:common:infrastructure
Discovered module: :temp:delivery:domain
Discovered module: :temp:delivery:presentation
Discovered module: :temp:delivery:infrastructure
Discovered module: :temp:delivery:application
Discovered module: :temp:delivery:apps
Discovered module: :temp:restaurant:domain
Discovered module: :temp:restaurant:presentation
Discovered module: :temp:restaurant:infrastructure
Discovered module: :temp:restaurant:application
Discovered module: :temp:restaurant:apps
Discovered module: :temp:payment:domain
Discovered module: :temp:payment:presentation
Discovered module: :temp:payment:infrastructure
Discovered module: :temp:payment:application
Discovered module: :temp:payment:apps
Discovered module: :temp:order:domain
Discovered module: :temp:order:presentation
Discovered module: :temp:order:infrastructure
Discovered module: :temp:order:application
Discovered module: :temp:order:apps
Discovered module: :apps:user-app
> Task :domains:common:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:port:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:messaging:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:persistence:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:application:check
> Task :config:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :config:processResources
> Task :apps:user-app:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :apps:user-app:processResources
> Task :domains:common:processResources
> Task :domains:common:infrastructure:processResources
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:presentation:processResources NO-SOURCE
> Task :independent:outbox:port:processResources NO-SOURCE
> Task :domains:user:infrastructure:messaging:processResources NO-SOURCE
> Task :domains:user:infrastructure:persistence:processResources NO-SOURCE
> Task :apps:user-app:check
> Task :domains:user:domain:check
> Task :domains:user:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:compileKotlin NO-SOURCE
> Task :domains:user:infrastructure:compileJava NO-SOURCE
> Task :domains:user:infrastructure:processResources NO-SOURCE
> Task :domains:user:infrastructure:classes UP-TO-DATE
> Task :domains:user:infrastructure:jar
> Task :domains:user:infrastructure:assemble
> Task :domains:user:infrastructure:check
> Task :domains:user:infrastructure:build
> Task :domains:user:presentation:check
> Task :independent:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:compileKotlin NO-SOURCE
> Task :independent:outbox:compileJava NO-SOURCE
> Task :independent:outbox:processResources NO-SOURCE
> Task :independent:outbox:classes UP-TO-DATE
> Task :independent:outbox:jar
> Task :independent:outbox:assemble
> Task :independent:outbox:check
> Task :independent:outbox:build
> Task :domains:common:infrastructure:compileKotlin
> Task :domains:common:infrastructure:compileJava NO-SOURCE
> Task :domains:common:infrastructure:classes
> Task :domains:common:infrastructure:jar
> Task :domains:common:compileKotlin
> Task :domains:common:compileJava NO-SOURCE
> Task :independent:outbox:port:compileKotlin
> Task :independent:outbox:port:compileJava NO-SOURCE
> Task :domains:common:classes
> Task :domains:common:jar
> Task :independent:outbox:port:classes UP-TO-DATE
> Task :independent:outbox:port:jar

> Task :config:compileKotlin FAILED
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:7:23 Unresolved reference 'outbox'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:8:16 Unresolved reference 'persistence'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:10:11 Unresolved reference 'github'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:26:19 Unresolved reference 'KotlinLogging'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:43:35 Unresolved reference 'Validation'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:63:23 Unresolved reference 'OutboxException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:63:23 Annotation argument must be a compile-time constant.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:65:13 Unresolved reference 'OutboxException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:68:74 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:70:42 Argument type mismatch: actual type is 'Int', but 'String?' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:71:64 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:71:102 Argument type mismatch: actual type is 'Int', but 'String?' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:76:23 Unresolved reference 'OptimisticLockException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:76:23 Annotation argument must be a compile-time constant.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:78:13 Unresolved reference 'OptimisticLockException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:81:57 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/GlobalExceptionHandler.kt:181:38 Unresolved reference 'reasonPhrase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:6:28 Unresolved reference 'security'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:7:28 Unresolved reference 'security'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:8:28 Unresolved reference 'security'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:9:28 Unresolved reference 'security'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:10:28 Unresolved reference 'security'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:11:28 Unresolved reference 'security'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:14:2 Unresolved reference 'EnableWebSecurity'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:17:28 Unresolved reference 'PasswordEncoder'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:17:46 Unresolved reference 'BCryptPasswordEncoder'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:20:27 Unresolved reference 'HttpSecurity'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:20:42 Unresolved reference 'SecurityFilterChain'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:22:14 Unresolved reference 'csrf'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:22:21 Unresolved reference 'it'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:23:34 Unresolved reference 'it'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:23:59 Unresolved reference 'SessionCreationPolicy'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:24:38 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:26:23 Unresolved reference 'requestMatchers'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:27:23 Unresolved reference 'requestMatchers'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:30:23 Unresolved reference 'requestMatchers'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:33:23 Unresolved reference 'requestMatchers'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:36:23 Unresolved reference 'anyRequest'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/config/src/main/kotlin/com/restaurant/config/SecurityConfig.kt:42:21 Unresolved reference 'build'.

> Task :domains:user:domain:compileKotlin FAILED
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:70:33 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:70:51 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:70:122 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:74:75 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:74:130 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:77:23 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:101:46 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:101:142 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:103:57 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:111:33 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:114:42 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:114:75 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:121:24 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:145:52 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:151:60 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:216:77 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:217:53 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:220:27 Unresolved reference 'id'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt:4:8 Unresolved reference 'io'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt:6:19 Unresolved reference 'KotlinLogging'.

FAILURE: Build completed with 2 failures.

1: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':config:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.
==============================================================================

2: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':domains:user:domain:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.
==============================================================================

BUILD FAILED in 4s
14 actionable tasks: 14 executed


==============================================================
 Gradle Build Completed: 2025-04-28 05:25:53 
==============================================================

Discovered module: :config
Discovered module: :domains:user:domain
Discovered module: :domains:user:presentation
Discovered module: :domains:user:infrastructure:messaging
Discovered module: :domains:user:infrastructure:persistence
Discovered module: :domains:user:application
Discovered module: :domains:common
Discovered module: :domains:common:infrastructure
Discovered module: :temp:delivery:domain
Discovered module: :temp:delivery:presentation
Discovered module: :temp:delivery:infrastructure
Discovered module: :temp:delivery:application
Discovered module: :temp:delivery:apps
Discovered module: :temp:restaurant:domain
Discovered module: :temp:restaurant:presentation
Discovered module: :temp:restaurant:infrastructure
Discovered module: :temp:restaurant:application
Discovered module: :temp:restaurant:apps
Discovered module: :temp:payment:domain
Discovered module: :temp:payment:presentation
Discovered module: :temp:payment:infrastructure
Discovered module: :temp:payment:application
Discovered module: :temp:payment:apps
Discovered module: :temp:order:domain
Discovered module: :temp:order:presentation
Discovered module: :temp:order:infrastructure
Discovered module: :temp:order:application
Discovered module: :temp:order:apps
Discovered module: :apps:user-app
[Incubating] Problems report is available at: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/build/reports/problems/problems-report.html

FAILURE: Build failed with an exception.

* What went wrong:
Task 'ktlintFormat' not found in root project 'restaurant' and its subprojects.

* Try:
> Run gradlew tasks to get a list of available tasks.
> For more on name expansion, please refer to https://docs.gradle.org/8.11.1/userguide/command_line_interface.html#sec:name_abbreviation in the Gradle documentation.
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 1s


==============================================================
 ktlintFormat Completed: 2025-04-28 05:25:54 
==============================================================


==============================================================

# Project Structure

domains
├── common
│   ├── build.gradle.kts
│   ├── infrastructure
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           ├── kotlin
│   │           │   └── com
│   │           │       └── restaurant
│   │           │           └── common
│   │           │               └── infrastructure
│   │           │                   └── avro
│   │           │                       └── dto
│   │           │                           └── Envelope.kt
│   │           └── resources
│   │               └── avro
│   └── src
│       └── main
│           ├── kotlin
│           │   └── com
│           │       └── restaurant
│           │           └── common
│           │               └── core
│           │                   ├── aggregate
│           │                   │   └── AggregateRoot.kt
│           │                   ├── domain
│           │                   │   └── event
│           │                   │       └── DomainEvent.kt
│           │                   ├── error
│           │                   │   ├── CommonSystemErrorCode.kt
│           │                   │   └── ErrorCode.kt
│           │                   └── exception
│           │                       ├── ApplicationException.kt
│           │                       └── DomainException.kt
│           └── resources
└── user
    ├── application
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── application
    │                               ├── dto
    │                               │   ├── command
    │                               │   │   ├── ChangePasswordCommand.kt
    │                               │   │   ├── DeleteAddressCommand.kt
    │                               │   │   ├── DeleteUserCommand.kt
    │                               │   │   ├── LoginCommand.kt
    │                               │   │   ├── RegisterAddressCommand.kt
    │                               │   │   ├── RegisterUserCommand.kt
    │                               │   │   ├── UpdateAddressCommand.kt
    │                               │   │   └── UpdateProfileCommand.kt
    │                               │   └── query
    │                               │       ├── GetUserProfileByIdQuery.kt
    │                               │       ├── LoginResult.kt
    │                               │       └── UserProfileDto.kt
    │                               ├── error
    │                               │   └── UserApplicationErrorCode.kt
    │                               ├── exception
    │                               │   └── UserApplicationException.kt
    │                               ├── handler
    │                               │   ├── ChangePasswordCommandHandler.kt
    │                               │   ├── DeleteAddressCommandHandler.kt
    │                               │   ├── DeleteUserCommandHandler.kt
    │                               │   ├── GetUserProfileQueryHandler.kt
    │                               │   ├── LoginCommandHandler.kt
    │                               │   ├── RegisterAddressCommandHandler.kt
    │                               │   ├── RegisterUserCommandHandler.kt
    │                               │   ├── UpdateAddressCommandHandler.kt
    │                               │   └── UpdateProfileCommandHandler.kt
    │                               └── port
    │                                   └── in
    │                                       ├── ChangePasswordUseCase.kt
    │                                       ├── DeleteAddressUseCase.kt
    │                                       ├── DeleteUserUseCase.kt
    │                                       ├── GetUserProfileQuery.kt
    │                                       ├── LoginUseCase.kt
    │                                       ├── RegisterAddressUseCase.kt
    │                                       ├── RegisterUserUseCase.kt
    │                                       ├── UpdateAddressUseCase.kt
    │                                       └── UpdateProfileUseCase.kt
    ├── domain
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── domain
    │                               ├── aggregate
    │                               │   ├── User.kt
    │                               │   ├── UserStatus.kt
    │                               │   └── UserType.kt
    │                               ├── entity
    │                               │   └── Address.kt
    │                               ├── error
    │                               │   └── UserDomainErrorCodes.kt
    │                               ├── event
    │                               │   └── UserEvents.kt
    │                               ├── exception
    │                               │   └── UserDomainException.kt
    │                               ├── repository
    │                               │   └── UserRepository.kt
    │                               └── vo
    │                                   ├── AddressId.kt
    │                                   ├── Email.kt
    │                                   ├── Name.kt
    │                                   ├── Password.kt
    │                                   ├── PhoneNumber.kt
    │                                   ├── UserId.kt
    │                                   └── Username.kt
    ├── infrastructure
    │   ├── messaging
    │   │   ├── build.gradle.kts
    │   │   └── src
    │   │       └── main
    │   │           ├── kotlin
    │   │           │   └── com
    │   │           │       └── restaurant
    │   │           │           └── user
    │   │           │               └── infrastructure
    │   │           │                   ├── avro
    │   │           │                   │   └── dto
    │   │           │                   │       └── UserEventDtos.kt
    │   │           │                   ├── messaging
    │   │           │                   │   └── serialization
    │   │           │                   │       └── OutboxMessageFactory.kt
    │   │           │                   └── serialization
    │   │           │                       └── OutboxMessageFactory.kt
    │   │           └── resources
    │   └── persistence
    │       ├── build.gradle.kts
    │       └── src
    │           └── main
    │               ├── kotlin
    │               │   └── com
    │               │       └── restaurant
    │               │           └── user
    │               │               └── infrastructure
    │               │                   ├── extensions
    │               │                   └── persistence
    │               │                       ├── entity
    │               │                       │   ├── AddressEntity.kt
    │               │                       │   └── UserEntity.kt
    │               │                       ├── extensions
    │               │                       │   ├── AddressEntityExtensions.kt
    │               │                       │   └── UserEntityExtensions.kt
    │               │                       └── repository
    │               │                           ├── SpringDataJpaUserRepository.kt
    │               │                           └── UserRepositoryImpl.kt
    │               └── resources
    └── presentation
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── user
                                └── presentation
                                    └── v1
                                        ├── controller
                                        │   ├── UserAddressController.kt
                                        │   ├── UserController.kt
                                        │   └── UserQueryController.kt
                                        ├── dto
                                        │   ├── request
                                        │   │   ├── ChangePasswordRequestV1.kt
                                        │   │   ├── DeleteUserRequestV1.kt
                                        │   │   ├── LoginRequestV1.kt
                                        │   │   ├── RegisterAddressRequestV1.kt
                                        │   │   ├── RegisterUserRequestV1.kt
                                        │   │   ├── UpdateAddressRequestV1.kt
                                        │   │   └── UpdateProfileRequestV1.kt
                                        │   └── response
                                        │       ├── AddressResponseV1.kt
                                        │       ├── LoginResponseV1.kt
                                        │       └── UserProfileResponseV1.kt
                                        └── extensions
                                            ├── request
                                            │   └── UserCommandRequestExtensions.kt
                                            └── response
                                                └── UserQueryResponseExtensions.kt
independent
└── outbox
    ├── build.gradle.kts
    ├── infrastructure
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           ├── kotlin
    │           │   └── com
    │           │       └── restaurant
    │           │           └── outbox
    │           │               └── infrastructure
    │           │                   ├── config
    │           │                   ├── error
    │           │                   │   └── OutboxErrorCodes.kt
    │           │                   ├── exception
    │           │                   │   └── OutboxException.kt
    │           │                   ├── kafka
    │           │                   │   ├── OutboxMessageSender.kt
    │           │                   │   └── config
    │           │                   │       └── KafkaOutboxProducerConfig.kt
    │           │                   └── persistence
    │           │                       ├── JpaOutboxMessageRepository.kt
    │           │                       ├── converter
    │           │                       │   └── StringMapConverter.kt
    │           │                       ├── entity
    │           │                       │   └── OutboxEventEntity.kt
    │           │                       └── extensions
    │           │                           └── OutboxMessageExtensions.kt
    │           └── resources
    └── port
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── outbox
                                └── port
                                    ├── OutboxMessageRepository.kt
                                    └── dto
                                        ├── OutboxMessage.kt
                                        └── OutboxMessageStatus.kt

133 directories, 98 files
==============================================================




====================================================================
 File: build.gradle.kts
 Path: build.gradle.kts
 Timestamp: 2025-04-28 05:25:54
====================================================================
import io.spring.gradle.dependencymanagement.dsl.DependencyManagementExtension
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.springframework.boot.gradle.plugin.SpringBootPlugin
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.gradle.api.artifacts.DependencySet
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.VersionCatalogsExtension

plugins {
    alias(libs.plugins.kotlin.jvm) apply false
    alias(libs.plugins.kotlin.spring) apply false
    alias(libs.plugins.kotlin.jpa) apply false
    alias(libs.plugins.kotlin.serialization) apply false
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management) apply false
    alias(libs.plugins.ktlint) apply false
}

apply(plugin = "io.spring.dependency-management")
// apply(plugin = "org.jlleitschuh.gradle.ktlint")

// Root dependencies - comment out ktlint dependency
/* // Comment out ktlint dependency block
dependencies {
    add("ktlint", "com.pinterest.ktlint:ktlint-cli:12.1.1")
}
*/

// Resolve ktlint version string at root level - Comment out
// val ktlintVersion = libs.versions.ktlintGradle.get()

configure<DependencyManagementExtension> {
    imports {
        mavenBom(SpringBootPlugin.BOM_COORDINATES)
        mavenBom(libs.testcontainers.bom.get().toString())
        mavenBom(libs.kotest.bom.get().toString())
    }
}

tasks.register("printSubprojects") {
    doLast {
        println("Root project: ${project.name}")
        subprojects.forEach {
            println("  Subproject: ${it.name} (Path: ${it.path})")
        }
    }
}

// Comment out ktlint tasks
/*
tasks.register("ktlintCheckAll") {
    group = "verification"
    description = "Runs ktlint checks on all projects."
    dependsOn(allprojects.mapNotNull { p -> p.tasks.findByName("ktlintCheck")?.path })
}

tasks.register("ktlintFormatAll") {
    group = "formatting"
    description = "Runs ktlint formatting on all projects."
    dependsOn(allprojects.mapNotNull { p -> p.tasks.findByName("ktlintFormat")?.path })
}
*/

// Configure all projects (including root) individually
allprojects {
    // Apply common plugins to all projects
    plugins.apply("org.jetbrains.kotlin.jvm")
    plugins.apply("java-library")
    // plugins.apply("org.jlleitschuh.gradle.ktlint") // Comment out ktlint plugin apply

    // Apply group and version only to subprojects
    if (project != rootProject) {
    group = "com.restaurant"
    version = "0.0.1-SNAPSHOT"
    }

    // Comment out ktlint configuration
    /*
    configure<org.jlleitschuh.gradle.ktlint.KtlintExtension> {
        version.set(ktlintVersion) // ktlintVersion is commented out
        debug.set(true)
        verbose.set(true)
        android.set(false)
        outputToConsole.set(true)
        filter {
            // EXPLICITLY REMOVE CONTENT INSIDE filter {}
        }
    }
    */

    // Configure tasks for all projects
    tasks.withType<KotlinCompile> {
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_17)
            freeCompilerArgs.add("-Xjsr305=strict")
        }
    }

    tasks.withType<Test> {
        useJUnitPlatform()
        testLogging {
            events("passed", "skipped", "failed")
        }
    }

    // Default task configurations for subprojects (can be overridden)
    if (project != rootProject) {
    tasks.withType<org.springframework.boot.gradle.tasks.bundling.BootJar> {
        enabled = false
    }
    tasks.withType<Jar> {
        enabled = true
        }
    }
}

// Configure common dependencies for subprojects individually AFTER applying plugins
subprojects.forEach { subproject ->
    subproject.dependencies {
        add("api", libs.kotlin.stdlib)
        add("api", libs.kotlin.reflect)
        add("api", libs.slf4j.api)
        add("implementation", libs.kotlin.logging.jvm)
        add("implementation", libs.jackson.module.kotlin)
        add("implementation", libs.jackson.datatype.jsr310)

        add("testImplementation", libs.kotest.runner.junit5)
        add("testImplementation", libs.kotest.assertions.core)
        add("testImplementation", libs.mockk)
        add("testImplementation", libs.mockito.kotlin)
        add("testImplementation", libs.assertj.core)
        add("testImplementation", libs.kotlin.test)
        add("testImplementation", libs.spring.boot.starter.test)
    }

    subproject.configurations.getByName("testImplementation").withDependencies {
        val dependencySet = this as DependencySet
        dependencySet.filterIsInstance<ExternalModuleDependency>().forEach { dependency ->
            if (dependency.group == "org.springframework.boot" && dependency.name == "spring-boot-starter-test") {
                dependency.exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
            }
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/build.gradle.kts
 Path: domains/common/build.gradle.kts
 Timestamp: 2025-04-28 05:25:54
====================================================================
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    // kotlin("jvm") // Provided by subprojects block
}

dependencies {
    // api("org.jetbrains.kotlin:kotlin-stdlib") // Provided by subprojects block
    // api("org.slf4j:slf4j-api") // Provided by subprojects block
    api(libs.jakarta.validation.api) // Keep API dependencies
    // api("io.github.microutils:kotlin-logging-jvm") // Provided by subprojects block

    // Test dependencies are handled by subprojects block
    // testImplementation("io.kotest:kotest-runner-junit5")
    // testImplementation("io.kotest:kotest-assertions-core")
    // testImplementation("io.mockk:mockk")
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/infrastructure/build.gradle.kts
 Path: domains/common/infrastructure/build.gradle.kts
 Timestamp: 2025-04-28 05:25:54
====================================================================
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
// import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar // REMOVED: Unused import

plugins {
    // kotlin("jvm") // Provided by subprojects block
    alias(libs.plugins.kotlin.serialization) // Apply serialization plugin here
    // REMOVED: Removed unused shadow plugin import
    // REMOVED: Removed Avro plugin attempts
    // REMOVED: Removed common dependency (self)
}

dependencies {
    // Keep necessary dependencies
    // implementation(libs.kotlin.stdlib) // Provided by subprojects
    // implementation(libs.kotlin.reflect) // Provided by subprojects
    implementation(libs.kotlinx.serialization.core) // Use alias
    implementation(libs.kotlinx.serialization.json) // Use alias
    api(libs.kotlinx.datetime) // Use alias

    // Update avro4k dependency with correct group ID and latest version
    // implementation(libs.avro4k.core) // Remove old alias/dependency
    implementation("com.github.avro-kotlin.avro4k:avro4k-core:2.3.0") // Use correct group ID and latest version

    // REMOVED: Dependency on avro-generated module
    // implementation(project(":domains:common:avro-generated"))

    // Add other necessary dependencies for common infrastructure
    // testImplementation(libs.kotlin.test) // Provided by subprojects
}

// REMOVED: All configurations related to avro4k and davidmc24 avro plugin
// REMOVED: SourceSets modifications
--------------------------------------------------------------------



====================================================================
 File: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/avro/dto/Envelope.kt
 Path: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/avro/dto/Envelope.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.infrastructure.avro.dto

import kotlinx.serialization.Serializable
import kotlinx.serialization.Contextual // Add import
import java.time.Instant

/**
 * Common Envelope structure for Kafka messages.
 * Rule 113
 */
@Serializable
data class Envelope(
    val schemaVersion: String, // Rule 114
    val eventId: String, // Rule 115 (Correlation ID)
    @Contextual val timestamp: Instant, // Rule 116 (Use @Contextual for Instant)
    val source: String, // Rule 117
    val aggregateType: String, // Rule 118
    val aggregateId: String // Rule 119
    // payload: ByteArray // REMOVED - Rule 113, 120
) 
--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/core/aggregate/AggregateRoot.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/core/aggregate/AggregateRoot.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.core.aggregate

import com.restaurant.common.core.domain.event.DomainEvent

/**
 * Base class for all Aggregate Roots.
 * Provides methods to manage domain events.
 * Rule 17, 18
 */
abstract class AggregateRoot {
    /**
     * Returns the list of recorded domain events.
     */
    abstract fun getDomainEvents(): List<DomainEvent>

    /**
     * Clears the list of recorded domain events.
     */
    abstract fun clearDomainEvents()

    // REMOVED: Internal addDomainEvent abstract or concrete method
    // Subclasses (like User) can implement their own internal helper (e.g., addDomainEventInternal)
    // or directly manage the event list (if mutable) ensuring proper cloning in copy().
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/core/domain/event/DomainEvent.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/core/domain/event/DomainEvent.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.core.domain.event

import java.time.Instant
import java.util.UUID

/**
 * Base interface for domain events. (Rule 32)
 */
interface DomainEvent {
    val eventId: UUID
        get() = UUID.randomUUID()

    val occurredAt: Instant
        get() = Instant.now()

    val aggregateId: String
    val aggregateType: String
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/core/error/CommonSystemErrorCode.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/core/error/CommonSystemErrorCode.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.core.error

/**
 * Common system-level error codes.
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    INTERNAL_ERROR("COMMON-SYS-001", "An internal system error occurred"),
    INVALID_REQUEST("COMMON-SYS-002", "The request is invalid"),
    RESOURCE_NOT_FOUND("COMMON-SYS-003", "The requested resource was not found"),
    UNAUTHORIZED("COMMON-SYS-004", "Unauthorized access"),
    FORBIDDEN("COMMON-SYS-005", "Access forbidden"),
    VALIDATION_ERROR("COMMON-SYS-006", "Validation error"),
    OPTIMISTIC_LOCK_ERROR("COMMON-SYS-007", "The resource was modified by another request"),
    OUTBOX_ERROR("COMMON-SYS-008", "Error processing outbox message"),
    EXTERNAL_SERVICE_ERROR("COMMON-SYS-009", "External service error"),
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/core/error/ErrorCode.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/core/error/ErrorCode.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.core.error

/**
 * Base interface for all error codes in the system.
 * Error codes should follow the format: {DOMAIN}-{LAYER}-{CODE}
 */
interface ErrorCode {
    /**
     * The unique code for this error.
     * Format: {DOMAIN}-{LAYER}-{CODE}
     * Example: USER-DOMAIN-001, USER-APP-002
     */
    val code: String

    /**
     * A human-readable message describing this error.
     */
    val message: String
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/core/exception/ApplicationException.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/core/exception/ApplicationException.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * Base class for all custom application exceptions.
 * Represents errors occurring in the application layer (e.g., use case execution failures).
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class ApplicationException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this application exception.
     */
    abstract val errorCode: ErrorCode

    /**
     * Secondary constructor to initialize with an ErrorCode.
     * The message defaults to the errorCode's message.
     */
    constructor(
        errorCode: ErrorCode,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : this(message, cause) {
        // Note: abstract val 'errorCode' must be overridden in subclasses.
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/core/exception/DomainException.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/core/exception/DomainException.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * Base class for all custom domain exceptions.
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class DomainException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this domain exception.
     */
    abstract val errorCode: ErrorCode

    /**
     * Secondary constructor to initialize with an ErrorCode.
     * The message defaults to the errorCode's message.
     */
    constructor(
        errorCode: ErrorCode,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : this(message, cause) {
        // Note: abstract val 'errorCode' must be overridden in subclasses.
        // It cannot be assigned here in the abstract class constructor.
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/build.gradle.kts
 Path: domains/user/application/build.gradle.kts
 Timestamp: 2025-04-28 05:25:54
====================================================================
plugins {
    // kotlin("jvm") // Provided by subprojects block
    `java-library`
    // Common plugins (jvm, spring, dependency-management, java-library) applied via subprojects
}

dependencies {
    // Keep specific API dependencies
    api(project(":domains:user:domain"))
    api(project(":domains:common"))
    // Keep implementation dependencies
    // implementation(project(":domains:user:infrastructure")) // Remove unified infra dependency
    implementation(project(":domains:user:infrastructure:persistence")) // Add persistence dependency for Query Handlers

    // Keep application-specific dependencies
    implementation(libs.spring.boot.starter) // Use alias
    implementation(libs.spring.tx) // Use alias
    implementation(libs.spring.context) // Use alias
    implementation(libs.spring.boot.starter.security) // Use alias
    implementation(libs.resilience4j.spring.boot3) // Use alias
    implementation(libs.spring.boot.starter.aop) // Use alias

    // Spring Security Crypto for PasswordEncoder
    implementation(libs.spring.security.crypto) // Use alias

    // Common dependencies (kotlin, slf4j, jackson, test deps) are handled by subprojects block

    // Test dependencies specific to Application layer
    testImplementation(project(":domains:user:domain")) { isTransitive = false } // For testing with domain classes
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.spring.boot.starter.test)
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5") // Use string notation
}

// Disable Java compile task as no Java code is expected
tasks.withType<JavaCompile> {
    enabled = false
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

// Application 레이어의 Command DTO (Rule App-Struct)
@Schema(description = "사용자 삭제 요청 DTO")
data class DeleteUserCommand(
    @Schema(description = "삭제할 사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val userId: String, // UUID String
    @Schema(description = "계정 확인을 위한 현재 비밀번호", example = "currentpassword123")
    @field:NotBlank(message = "비밀번호 확인은 필수입니다.")
    val password: String, // 수정: passwordConfirmation -> password
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

data class LoginCommand(
    val email: String,
    val password: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size
import jakarta.validation.constraints.Email as JakartaEmail // Alias to avoid conflict

/**
 * Command DTO for registering a new user.
 * Rule App-Struct (dto/command)
 */
@Schema(description = "사용자 등록 요청 커맨드")
data class RegisterUserCommand(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:JakartaEmail(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.") // Add password complexity rules if needed
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser123") // Rule 6.3
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String, // Rule 6.3: Added username field
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
    val phoneNumber: String?,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.query

data class GetUserProfileByIdQuery(
    val userId: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.query

/**
 * 로그인 결과 DTO (Application Layer)
 */
data class LoginResult(
    val userId: String,
    val username: String,
    val accessToken: String,
    val refreshToken: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.dto.query

import java.time.Instant // Instant 사용 권장

// Application 레이어의 Query Result DTO (Rule App-Struct)
data class UserProfileDto(
    val id: String, // UUID String
    val email: String,
    val name: String,
    val username: String, // 추가됨
    val phoneNumber: String?,
    val userType: String, // Enum 이름 등
    val addresses: List<AddressDto>,
    val createdAt: Instant,
    val updatedAt: Instant,
) {
    data class AddressDto(
        val id: String, // UUID String
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.error

import com.restaurant.common.core.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    BAD_REQUEST("USER-APPLICATION-001", "Bad request received by application."),
    INVALID_INPUT("USER-APPLICATION-002", "Invalid input provided to application."),
    AUTHENTICATION_FAILED("USER-APPLICATION-003", "Authentication failed."),
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-004", "External service communication error."),
    UNEXPECTED_ERROR("USER-APPLICATION-500", "An unexpected error occurred in the application."),
    USER_NOT_FOUND_BY_EMAIL("USER-APPLICATION-005", "User not found by email"),
    INVALID_CREDENTIALS("USER-APPLICATION-006", "Invalid username or password"),
    USER_INACTIVE("USER-APPLICATION-007", "User account is inactive"),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.exception

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.user.application.error.UserApplicationErrorCode

/**
 * User Application 레이어 관련 예외 정의 (Rule 68)
 */
sealed class UserApplicationException(
    final override val errorCode: ErrorCode,
    message: String? = null,
    cause: Throwable? = null,
) : ApplicationException(errorCode, message ?: errorCode.message, cause) {
    /**
     * 인증 실패 관련 예외
     */
    class AuthenticationFailed(
        message: String? = UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.AUTHENTICATION_FAILED, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - e.g., Invalid UUID format
     */
    class BadRequest(
        message: String? = UserApplicationErrorCode.BAD_REQUEST.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.BAD_REQUEST, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - more specific than BadRequest
     */
    class InvalidInput(
        message: String? = UserApplicationErrorCode.INVALID_INPUT.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.INVALID_INPUT, message, cause)

    /**
     * 외부 서비스 연동 오류
     */
    class ExternalServiceError(
        message: String? = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR, message, cause)

    /**
     * 예상치 못한 시스템 오류 (Application 레벨)
     */
    class UnexpectedError(
        message: String? = UserApplicationErrorCode.UNEXPECTED_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.UNEXPECTED_ERROR, message, cause)

    /**
     * Login specific exceptions
     */
    class UserNotFound(
        errorCode: ErrorCode,
        identifier: String,
    ) : UserApplicationException(errorCode, "User not found with identifier: $identifier")

    class InvalidCredentials(
        errorCode: ErrorCode,
    ) : UserApplicationException(errorCode)

    class UserInactive(
        errorCode: ErrorCode,
        userId: String,
    ) : UserApplicationException(errorCode, "User is inactive: $userId")
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/ChangePasswordCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/ChangePasswordCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.common.command.CommandHandler
import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.port.`in`.ChangePasswordUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : CommandHandler<ChangePasswordCommand, Unit>,
    ChangePasswordUseCase {
    @Transactional
    override fun handle(command: ChangePasswordCommand) {
        val userId = UserId.fromUUID(command.userId)
        log.info { "Attempting to change password for user: $userId" }

        val user =
            userRepository.findById(userId)
                ?: throw UserDomainException.User.NotFound(command.userId.toString())

        if (!passwordEncoder.matches(command.currentPassword, user.password.value)) {
            val e = UserDomainException.User.PasswordMismatch()
            log.warn(e) { "Password change failed for userId ${command.userId}: Incorrect current password, errorCode=${e.errorCode.code}" }
            throw e
        }

        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.of(encodedNewPassword)

        val updatedUser = user.changePassword(newPasswordVo)

        userRepository.save(updatedUser)
        log.info { "Password changed successfully for user: $userId" }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/DeleteAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/DeleteAddressCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.`in`.DeleteAddressUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) : DeleteAddressUseCase {
    @Transactional
    override fun deleteAddress(command: DeleteAddressCommand) {
        log.info { "Deleting address for userId=${command.userId}, addressId=${command.addressId}" }

        try {
            val userIdVo = UserId.fromString(command.userId)
            val addressIdVo = AddressId.fromString(command.addressId)
            val user = userRepository.findByIdOrThrow(userIdVo)

            val updatedUser = user.deleteAddress(addressIdVo)
            userRepository.save(updatedUser)

            log.info { "Address deleted successfully. userId=${userIdVo.value}, addressId=${addressIdVo.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address deletion for user ${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid ID format during address deletion: userId=${command.userId}, addressId=${command.addressId}" }
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error deleting address for user ${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError("Failed to delete address due to an unexpected error.", e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/DeleteUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/DeleteUserCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.common.command.CommandHandler
import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.port.`in`.DeleteUserUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : CommandHandler<DeleteUserCommand, Unit>,
    DeleteUserUseCase {
    @Transactional
    override fun handle(command: DeleteUserCommand) {
        val userId = UserId.fromUUID(command.userId)
        log.info { "Attempting to delete user: $userId" }

        val user =
            userRepository.findById(userId)
                ?: throw UserDomainException.User.NotFound(command.userId.toString())

        if (!passwordEncoder.matches(command.password, user.password.value)) {
            val e = UserDomainException.User.PasswordMismatch()
            log.warn(e) { "User deletion failed for userId ${command.userId}: Incorrect password, errorCode=${e.errorCode.code}" }
            throw e
        }

        val withdrawnUser = user.withdraw()
        userRepository.save(withdrawnUser)
        log.info { "User deleted (withdrawn) successfully: $userId" }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/GetUserProfileQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/GetUserProfileQueryHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.`in`.GetUserProfileQuery
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.infrastructure.persistence.repository.SpringDataJpaUserRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class GetUserProfileQueryHandler(
    private val userJpaRepository: SpringDataJpaUserRepository,
) : GetUserProfileQuery {
    @Transactional(readOnly = true)
    override fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto {
        log.debug { "Fetching user profile for userId=${query.userId}" }

        try {
            val userIdVo = UserId.fromUUID(query.userId)
            val userEntity = userJpaRepository.findByUserIdOrThrow(userIdVo.value)

            val dto =
                UserProfileDto(
                    id = userEntity.userId.toString(),
                    email = userEntity.email,
                    name = userEntity.name,
                    username = userEntity.username,
                    phoneNumber = userEntity.phoneNumber,
                    userType = userEntity.userType.name,
                    userStatus = userEntity.status.name,
                    addresses =
                        userEntity.addresses.map { addr ->
                            UserProfileDto.AddressDto(
                                id = addr.addressId.toString(),
                                street = addr.street,
                                detail = addr.detail,
                                zipCode = addr.zipCode,
                                isDefault = addr.isDefault,
                            )
                        },
                    createdAt = userEntity.createdAt,
                    updatedAt = userEntity.updatedAt,
                    version = userEntity.version,
                )

            log.info { "User profile fetched successfully, userId=${userIdVo.value}" }
            return dto
        } catch (de: UserDomainException.User.NotFound) {
            log.warn { "User profile query failed, user not found: userId=${query.userId}" }
            throw de
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain validation error during profile query for user ${query.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid user ID format for query: ${query.userId}" }
            throw UserApplicationException.BadRequest("Invalid user ID format", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during profile query for user ${query.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError(cause = e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/LoginCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/LoginCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult
import com.restaurant.user.application.error.UserApplicationErrorCode
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.`in`.LoginUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    // private val jwtTokenProvider: JwtTokenProvider // Assuming JWT provider exists
) : LoginUseCase {
    @Transactional(readOnly = true)
    override fun login(command: LoginCommand): LoginResult {
        log.info { "Processing login command for email: ${command.email}" }

        val email = Email.of(command.email) // DomainException.Validation can occur here and should propagate

        val user =
            userRepository.findByEmail(email)
                ?: throw UserApplicationException.UserNotFound(UserApplicationErrorCode.USER_NOT_FOUND_BY_EMAIL, command.email)

        // Validate password using PasswordEncoder (Application layer responsibility)
        if (!passwordEncoder.matches(command.password, user.password.value)) {
            log.warn { "Invalid password attempt for email: ${command.email}" }
            throw UserApplicationException.InvalidCredentials(UserApplicationErrorCode.INVALID_CREDENTIALS)
        }

        if (!user.isActive()) {
            log.warn { "Attempt to login with inactive user: ${command.email}" }
            throw UserApplicationException.UserInactive(UserApplicationErrorCode.USER_INACTIVE, user.id.value.toString())
        }

        // Generate Token (Example - Assuming JwtTokenProvider)
        // val token = jwtTokenProvider.generateToken(user.id.value.toString(), user.userType)
        val fakeToken = "fake-jwt-token-for-${user.id.value}" // Placeholder

        log.info { "User logged in successfully: ${user.email.value}" }
        return LoginResult(
            userId = user.id.value.toString(),
            username = user.username.value,
            email = user.email.value,
            token = fakeToken, // token
        )
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/RegisterAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/RegisterAddressCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.`in`.RegisterAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) : RegisterAddressUseCase {
    @Transactional
    override fun registerAddress(command: RegisterAddressCommand): AddressId {
        log.info { "Registering address for userId=${command.userId}, street=${command.street}, zipCode=${command.zipCode}" }

        try {
            val userIdVo = UserId.fromString(command.userId)
            val user = userRepository.findByIdOrThrow(userIdVo)

            val address =
                Address.create(
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )
            val updatedUser = user.addAddress(address)
            userRepository.save(updatedUser)

            val addedAddressId = updatedUser.addresses.first { it.addressId == address.addressId }.addressId
            log.info { "Address registered successfully. userId=${userIdVo.value}, addressId=${addedAddressId.value}" }
            return addedAddressId
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address registration for userId=${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid user ID format for address registration: ${command.userId}" }
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during address registration: userId=${command.userId}" }
            throw UserApplicationException.UnexpectedError("Failed to register address due to an unexpected error.", e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/RegisterUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/RegisterUserCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
    Not a valid Kotlin file (6:45 qualified name must be a '.'-separated identifier list)
Now, trying to read the input as Kotlin Script.
    Not a valid Kotlin file (6:45 qualified name must be a '.'-separated identifier list)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/UpdateAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/UpdateAddressCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.`in`.UpdateAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) : UpdateAddressUseCase {
    @Transactional
    override fun updateAddress(command: UpdateAddressCommand) {
        log.info { "Updating address for userId=${command.userId}, addressId=${command.addressId}" }

        try {
            val userIdVo = UserId.fromString(command.userId)
            val addressIdVo = AddressId.fromString(command.addressId)
            val user = userRepository.findByIdOrThrow(userIdVo)

            val addressToUpdate =
                Address.create(
                    addressId = addressIdVo,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            val updatedUser = user.updateAddress(addressIdVo, addressToUpdate)

            userRepository.save(updatedUser)
            log.info { "Address updated successfully. userId=${userIdVo.value}, addressId=${addressIdVo.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address update for user ${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid ID format during address update: userId=${command.userId}, addressId=${command.addressId}" }
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error updating address for user ${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError("Failed to update address due to an unexpected error.", e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/UpdateProfileCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/handler/UpdateProfileCommandHandler.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.handler

import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.`in`.UpdateProfileUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) : UpdateProfileUseCase {
    @Transactional
    override fun updateProfile(command: UpdateProfileCommand) {
        log.info { "Attempting to update profile for userId=${command.userId}" }

        try {
            val userId = UserId.fromString(command.userId)
            val user = userRepository.findByIdOrThrow(userId)

            val updatedName = Name.of(command.name)
            val updatedPhoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }

            val updatedUser =
                user.updateProfile(
                    newName = updatedName,
                    newPhoneNumber = updatedPhoneNumber,
                )

            userRepository.save(updatedUser)
            log.info { "Profile updated successfully for userId=${userId.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during profile update for userId=${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid data during profile update for userId=${command.userId}: ${iae.message}" }
            throw UserApplicationException.BadRequest("Invalid profile data format: ${iae.message}", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during profile update for userId=${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError(cause = e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/ChangePasswordUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/ChangePasswordUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.ChangePasswordCommand

interface ChangePasswordUseCase {
    fun changePassword(command: ChangePasswordCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/DeleteAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/DeleteAddressUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.DeleteAddressCommand // Command DTO 임포트 추가

/**
 * 주소 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteAddressUseCase {
    fun deleteAddress(command: DeleteAddressCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/DeleteUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/DeleteUserUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.DeleteUserCommand

/**
 * 사용자 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteUserUseCase {
    fun deleteUser(command: DeleteUserCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/GetUserProfileQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/GetUserProfileQuery.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto

/**
 * 사용자 프로필 조회 Query UseCase 인터페이스 (Rule App-Struct)
 */
interface GetUserProfileQuery {
    fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/LoginUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/LoginUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult // Corrected import path for Query Result DTO

/**
 * 로그인 유스케이스 인터페이스 (Rule App-Struct)
 * 로그인 결과를 반환하도록 수정 (LoginResult 사용)
 */
interface LoginUseCase {
    fun login(command: LoginCommand): LoginResult // 반환 타입 LoginResult로 명시
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/RegisterAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/RegisterAddressUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.domain.vo.AddressId

/**
 * 주소 등록 유스케이스 인터페이스 (Rule App-Struct)
 */
interface RegisterAddressUseCase {
    fun registerAddress(command: RegisterAddressCommand): AddressId
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/RegisterUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/RegisterUserUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.RegisterUserCommand // Command DTO 임포트 추가 (Package 변경됨)
import com.restaurant.user.domain.vo.UserId // UserId import

/**
 * 사용자 등록 유스케이스 인터페이스 (Rule App-Struct)
 * 사용자 ID(UserId)를 반환하도록 수정
 */
interface RegisterUserUseCase {
    fun register(command: RegisterUserCommand): UserId // 반환 타입 UserId로 명시
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/UpdateAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/UpdateAddressUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.UpdateAddressCommand // Command DTO 임포트 추가

/**
 * 주소 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateAddressUseCase {
    fun updateAddress(command: UpdateAddressCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/UpdateProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/in/UpdateProfileUseCase.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.UpdateProfileCommand

/**
 * 프로필 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateProfileUseCase {
    fun updateProfile(command: UpdateProfileCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/build.gradle.kts
 Path: domains/user/domain/build.gradle.kts
 Timestamp: 2025-04-28 05:25:54
====================================================================
plugins {
    // kotlin("jvm") // Provided by subprojects block
    `java-library`
    // Common plugins (jvm, java-library) applied via subprojects
}

dependencies {
    // Keep specific API dependency
    api(project(":domains:common"))

    // Common dependencies (kotlin, slf4j, test deps) are handled by subprojects block
}

// REMOVED: Comment about Jar task configuration

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.domain.aggregate

import com.restaurant.common.core.aggregate.AggregateRoot
import com.restaurant.common.core.domain.event.DomainEvent
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.*
import java.time.Instant
import java.util.UUID
import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType

/**
 * User Aggregate Root
 */
data class User(
    val id: UserId, // Rule 11.5: val, public
    val username: Username,
    val password: Password, // Assume this is the encoded password
    val email: Email,
    val name: Name,
    val phoneNumber: PhoneNumber?,
    val userType: UserType, // Use imported type
    val status: UserStatus, // Use imported type
    val addresses: List<Address> = listOf(),
    val defaultAddressId: AddressId? = null,
    val version: Long,
    val createdAt: Instant,
    val updatedAt: Instant,
    // Rule 18: Manage events internally, ensure copy handles it
    private val eventsInternal: MutableList<DomainEvent> = mutableListOf()
) : AggregateRoot() {

    init {
        // Validation moved to factory methods or specific action methods
    }

    fun changePassword(newPassword: Password): User {
        // Check status etc.
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser = this.copy(
            password = newPassword, // Assume newPassword is already encoded if needed
            version = this.version + 1,
            updatedAt = Instant.now(),
            eventsInternal = this.eventsInternal.toMutableList() // Rule 18: Copy events
        )
        updatedUser.addDomainEventInternal(UserEvent.PasswordChanged(userId = this.id, changedAt = updatedUser.updatedAt))
        return updatedUser
    }

    fun updateProfile(newName: Name, newPhoneNumber: PhoneNumber?): User {
         if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser = this.copy(
            name = newName,
            phoneNumber = newPhoneNumber,
            version = this.version + 1,
            updatedAt = Instant.now(),
            eventsInternal = this.eventsInternal.toMutableList() // Rule 18: Copy events
        )
        updatedUser.addDomainEventInternal(UserEvent.ProfileUpdated(userId = this.id, name = newName.value, phoneNumber = newPhoneNumber?.value, updatedAt = updatedUser.updatedAt))
        return updatedUser
    }

     fun addAddress(addressData: Address): User {
         if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
         if (addresses.size >= MAX_ADDRESSES) throw UserDomainException.Address.LimitExceeded(MAX_ADDRESSES)
         if (addresses.any { it.id == addressData.id }) throw UserDomainException.Address.DuplicateAddressId(addressData.id.value.toString())

         val newAddresses = addresses + addressData
         // If new address is default, unset others. If no default exists, set new one as default.
         val newDefaultAddressId = if (addressData.isDefault) addressData.id else if (this.defaultAddressId == null) addressData.id else this.defaultAddressId

         val finalAddresses = newAddresses.map { addr ->
             if (addr.id == newDefaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
         }


         val updatedUser = this.copy(
             addresses = finalAddresses,
             defaultAddressId = newDefaultAddressId,
             version = this.version + 1,
             updatedAt = Instant.now(),
             eventsInternal = this.eventsInternal.toMutableList() // Rule 18: Copy events
         )

         updatedUser.addDomainEventInternal(
             UserEvent.AddressAdded(
                 userId = this.id,
                 address = addressData.toData(), // Assuming toData() exists in Address Entity
                 addedAt = updatedUser.updatedAt
             )
         )
         return updatedUser
     }

     fun updateAddress(addressId: AddressId, updatedAddressData: Address): User {
         if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
         if (addressId != updatedAddressData.id) throw UserDomainException.Address.IdMismatch(addressId.value.toString(), updatedAddressData.id.value.toString())

         val addressIndex = addresses.indexOfFirst { it.id == addressId }
         if (addressIndex == -1) throw UserDomainException.Address.NotFound(addressId.value.toString())

         val newAddresses = addresses.toMutableList()
         newAddresses[addressIndex] = updatedAddressData

         // Determine the new default ID
         val newDefaultAddressId = if (updatedAddressData.isDefault) {
             updatedAddressData.id // New one is default
         } else if (defaultAddressId == addressId) {
             // Default is being updated and is no longer default, pick another if possible
             newAddresses.filterNot { it.id == addressId }.firstOrNull()?.id
         } else {
             defaultAddressId // Keep the old default
         }

         // Ensure only one default address
          val finalAddresses = newAddresses.map { addr ->
              if (addr.id == newDefaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
          }

         val updatedUser = this.copy(
             addresses = finalAddresses.toList(),
             defaultAddressId = newDefaultAddressId,
             version = this.version + 1,
             updatedAt = Instant.now(),
             eventsInternal = this.eventsInternal.toMutableList() // Rule 18: Copy events
         )

         updatedUser.addDomainEventInternal(
             UserEvent.AddressUpdated(
                 userId = this.id,
                 address = updatedAddressData.toData(), // Assuming toData() exists
                 updatedAt = updatedUser.updatedAt
             )
         )
         return updatedUser
     }


     fun deleteAddress(addressId: AddressId): User {
         if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
         val addressToRemove = addresses.find { it.id == addressId }
             ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

         if (addresses.size == 1) throw UserDomainException.Address.CannotDeleteLast()
         if (addressToRemove.isDefault) throw UserDomainException.Address.CannotDeleteDefault()

         val remainingAddresses = addresses.filterNot { it.id == addressId }

         val updatedUser = this.copy(
             addresses = remainingAddresses,
             // defaultAddressId remains the same as we cannot delete the default
             version = this.version + 1,
             updatedAt = Instant.now(),
             eventsInternal = this.eventsInternal.toMutableList() // Rule 18: Copy events
         )
         updatedUser.addDomainEventInternal(
             UserEvent.AddressDeleted(
                 userId = this.id,
                 addressId = addressId.value.toString(),
                 deletedAt = updatedUser.updatedAt
             )
         )
         return updatedUser
     }

    fun withdraw(): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (userType == UserType.ADMIN) throw UserDomainException.User.AdminCannotBeWithdrawn()

        val updatedUser = this.copy(
            status = UserStatus.WITHDRAWN,
            version = this.version + 1,
            updatedAt = Instant.now(),
            eventsInternal = this.eventsInternal.toMutableList() // Rule 18: Copy events
        )
        updatedUser.addDomainEventInternal(UserEvent.Withdrawn(userId = this.id, withdrawnAt = updatedUser.updatedAt))
        return updatedUser
    }

    fun isActive(): Boolean {
        return this.status == UserStatus.ACTIVE
    }

    // Rule 18: Internal helper to add events
    internal fun addDomainEventInternal(event: DomainEvent) {
        this.eventsInternal.add(event)
    }

    // Rule 18: Implementation for AggregateRoot interface
    override fun getDomainEvents(): List<DomainEvent> = eventsInternal.toList()
    override fun clearDomainEvents() = eventsInternal.clear()

    companion object {
        private const val MAX_ADDRESSES = 5

        // Rule 16: Create factory method
        fun create(
            id: UserId,
            username: Username,
            password: Password, // Assume this is the encoded password
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType = UserType.CUSTOMER,
            initialAddresses: List<Address> = emptyList()
        ): User {
             val now = Instant.now()
             // Validate initial addresses
             if (initialAddresses.count { it.isDefault } > 1) {
                 throw UserDomainException.Address.MultipleDefaultsOnInit()
             }
             val defaultAddressId = initialAddresses.find { it.isDefault }?.id
                 ?: initialAddresses.firstOrNull()?.id // If no default, make the first one default

             val finalAddresses = initialAddresses.map { addr ->
                 if (addr.id == defaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
             }


            val user = User(
                id = id,
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = UserStatus.ACTIVE, // Initial status
                addresses = finalAddresses,
                defaultAddressId = defaultAddressId,
                createdAt = now,
                updatedAt = now,
                version = 0L // Initial version
            )
            // Rule 16, 18: Add creation event
            user.addDomainEventInternal(UserEvent.Created(
                userId = id,
                username = username.value,
                email = email.value,
                name = name.value,
                phoneNumber = phoneNumber?.value,
                userType = userType.name, // Send enum name
                registeredAt = user.createdAt
                // address data can be added if needed
            ))
            return user
        }

        // Rule 16: Reconstitute factory method
        fun reconstitute(
            id: UserId,
            username: Username,
            password: Password,
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
            status: UserStatus,
            addresses: List<Address>,
            defaultAddressId: AddressId?,
            version: Long,
            createdAt: Instant,
            updatedAt: Instant
        ): User {
            return User(
                id = id,
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = status,
                addresses = addresses,
                defaultAddressId = defaultAddressId,
                version = version,
                createdAt = createdAt,
                updatedAt = updatedAt,
                eventsInternal = mutableListOf() // Rule 16: Events are cleared on reconstitution
            )
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserStatus.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserStatus.kt
 Timestamp: 2025-04-28 05:25:54
====================================================================
package com.restaurant.user.domain.aggregate

/**
 * Represents the status of a user account.
 */
enum class UserStatus {
    ACTIVE, // Normal, active state
    INACTIVE, // Temporarily inactive, e.g., not logged in for a long time
    WITHDRAWN, // User has withdrawn from the service
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserType.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserType.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.aggregate

/**
 * Represents the type of user.
 */
enum class UserType {
    CUSTOMER,
    ADMIN,
    // Add other types as needed
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.entity

import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import java.time.Instant

/**
 * Address Domain Entity (Rule 11)
 * User Aggregate에 속하지만 자체 식별자를 가짐.
 */
data class Address private constructor(
    val addressId: AddressId,
    val street: String,
    val detail: String,
    val zipCode: String,
    var isDefault: Boolean,
    val createdAt: Instant,
    var updatedAt: Instant,
    var version: Long = 0L
) {
    init {
        // Basic validation
        if (street.isBlank()) {
             throw UserDomainException.Validation.InvalidAddressFormat("Street cannot be blank.")
        }
        // Zip code validation moved to companion object helper
    }

    fun updateDetails(
        street: String,
        detail: String,
        zipCode: String,
        isDefault: Boolean
    ): Address {
        validateZipCode(zipCode) // Use helper for validation
        if (this.street == street && this.detail == detail && this.zipCode == zipCode && this.isDefault == isDefault) {
            return this // No change
        }
        return this.copy(
            street = street,
            detail = detail,
            zipCode = zipCode,
            isDefault = isDefault,
            updatedAt = Instant.now(),
            version = this.version + 1
        )
    }

    /**
     * Converts Address entity to AddressData DTO for domain events.
     */
    fun toData(): UserEvent.AddressData = // Added as per instruction
        UserEvent.AddressData(
            addressId = this.addressId.value.toString(),
            street = this.street,
            detail = this.detail,
            zipCode = this.zipCode,
            isDefault = this.isDefault
        )

    companion object {
        // Simplified ZIP code validation
        private fun validateZipCode(zipCode: String) {
            if (zipCode.isBlank() || zipCode.length != 5 || !zipCode.all { it.isDigit() }) {
                throw UserDomainException.Validation.InvalidAddressFormat("Zip code must be 5 digits.")
            }
        }

        fun create(
            addressId: AddressId,
            street: String,
            detail: String,
            zipCode: String,
            isDefault: Boolean,
            version: Long = 0L // Pass initial version
        ): Address {
            validateZipCode(zipCode) // Validate on creation
            val now = Instant.now()
            return Address(
                addressId = addressId,
                street = street,
                detail = detail,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = now,
                updatedAt = now,
                version = version
            )
        }

        fun reconstitute(
            addressId: AddressId,
            street: String,
            detail: String,
            zipCode: String,
            isDefault: Boolean,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long
        ): Address {
            // No validation needed on reconstitute, assuming data is valid
            return Address(addressId, street, detail, zipCode, isDefault, createdAt, updatedAt, version)
        }
    }

    fun markAsDefault(): Address {
        if (this.isDefault) return this
        return this.copy(
            isDefault = true,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun markAsNonDefault(): Address {
        if (!this.isDefault) return this
        return this.copy(
            isDefault = false,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.error

// import com.restaurant.domains.common.domain.error.ErrorCode // Remove this
import com.restaurant.common.core.error.ErrorCode // Add this

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum (Rule 67)
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    DUPLICATE_USERNAME("USER-DOMAIN-003", "이미 사용중인 사용자 이름입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-004", "비밀번호가 일치하지 않습니다."),
    USER_ALREADY_WITHDRAWN("USER-DOMAIN-005", "이미 탈퇴한 사용자입니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-006", "주소를 찾을 수 없습니다."),
    DUPLICATE_ADDRESS_ID("USER-DOMAIN-007", "이미 존재하는 주소 ID 입니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-008", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-009", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-010", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_EMAIL_FORMAT("USER-DOMAIN-101", "잘못된 이메일 형식입니다."),
    INVALID_USERNAME_FORMAT("USER-DOMAIN-102", "사용자 이름 형식이 올바르지 않습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-103", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_NAME_FORMAT("USER-DOMAIN-104", "잘못된 이름 형식입니다."),
    INVALID_ADDRESS_FORMAT("USER-DOMAIN-105", "잘못된 주소 형식입니다."),
    INVALID_PHONE_NUMBER_FORMAT("USER-DOMAIN-106", "잘못된 전화번호 형식입니다."),
    INVALID_USER_ID_FORMAT("USER-DOMAIN-107", "잘못된 사용자 ID 형식입니다."),
    INVALID_ADDRESS_ID_FORMAT("USER-DOMAIN-108", "잘못된 주소 ID 형식입니다."),
    ADDRESS_ID_MISMATCH("USER-DOMAIN-201", "주소 ID가 일치하지 않습니다."),
    INVALID_CREDENTIALS("USER-DOMAIN-056", "Invalid credentials"),
    ADMIN_CANNOT_BE_WITHDRAWN("USER-DOMAIN-057", "Admin user cannot be withdrawn"),
    MULTIPLE_DEFAULT_ADDRESSES("USER-DOMAIN-107", "Cannot have multiple default addresses"),
    DEFAULT_ADDRESS_NOT_FOUND("USER-DOMAIN-108", "Default address not found"),
    PERSISTENCE_ERROR("USER-DOMAIN-901", "Persistence error occurred"),
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvents.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvents.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.event

import com.restaurant.common.core.domain.event.DomainEvent
import com.restaurant.user.domain.vo.*
import java.time.Instant
import java.util.UUID

/**
 * Sealed class grouping all domain events related to the User aggregate. (Rule 34)
 */
sealed class UserEvent(open val userId: UserId) : DomainEvent {
    override val aggregateId: String get() = userId.value.toString()
    override val aggregateType: String = "User"
    override val occurredAt: Instant = Instant.now()

    /**
     * User Created Event
     */
    data class Created(
        override val userId: UserId,
        val username: String,
        val email: String,
        val name: String,
        val phoneNumber: String?,
        val userType: String,
        val registeredAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = registeredAt // Use registration time
    }

    /**
     * User Password Changed Event
     */
    data class PasswordChanged(
        override val userId: UserId,
        val changedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = changedAt
    }

    /**
     * User Profile Updated Event
     */
    data class ProfileUpdated(
        override val userId: UserId,
        val name: String,
        val phoneNumber: String?,
        val updatedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = updatedAt
    }

    /**
     * Represents address data within user events.
     */
    data class AddressData(
        val addressId: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )

    /**
     * User Address Added Event
     */
    data class AddressAdded(
        override val userId: UserId,
        val address: AddressData,
        val addedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = addedAt
    }

    /**
     * User Address Updated Event
     */
    data class AddressUpdated(
        override val userId: UserId,
        val address: AddressData,
        val updatedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = updatedAt
    }

    /**
     * User Address Deleted Event (Renamed from Removed)
     */
    data class AddressDeleted(
        override val userId: UserId,
        val addressId: String,
        val deletedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = deletedAt
    }

    /**
     * User Withdrawn Event (Renamed from UserWithdrawn)
     */
    data class Withdrawn(
        override val userId: UserId,
        val withdrawnAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = withdrawnAt
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.exception

import com.restaurant.common.core.exception.DomainException
import com.restaurant.user.domain.error.UserDomainErrorCodes

/**
 * Sealed class representing all possible domain exceptions for the User aggregate. (Rule 68)
 */
sealed class UserDomainException(
    override val errorCode: UserDomainErrorCodes,
    message: String? = errorCode.message,
    cause: Throwable? = null,
) : DomainException(errorCode, message, cause) {
    /**
     * Validation-related exceptions
     */
    sealed class Validation(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class InvalidEmailFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_EMAIL_FORMAT,
                "Invalid email format: $value",
            )

        class InvalidUsernameFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USERNAME_FORMAT,
                "Invalid username format: $value",
            )

        class InvalidUserIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USER_ID_FORMAT,
                "Invalid user ID format: $value",
            )

        class InvalidPasswordFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
                message,
            )

        class InvalidNameFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_NAME_FORMAT,
                "Invalid name format: $value",
            )

        class InvalidPhoneNumberFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PHONE_NUMBER_FORMAT,
                "Invalid phone number format: $value",
            )

        class InvalidAddressFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                message,
            )

        class InvalidAddressIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_ID_FORMAT,
                "Invalid address ID format: $value",
            )
    }

    /**
     * User-related exceptions
     */
    sealed class User(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            userId: String,
        ) : User(
                UserDomainErrorCodes.USER_NOT_FOUND,
                "User not found with ID: $userId",
            )

        class DuplicateUsername(
            username: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_USERNAME,
                "Username already exists: $username",
            )

        class DuplicateEmail(
            email: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_EMAIL,
                "Email already exists: $email",
            )

        class PasswordMismatch : User(UserDomainErrorCodes.PASSWORD_MISMATCH)

        class AlreadyWithdrawn : User(UserDomainErrorCodes.USER_ALREADY_WITHDRAWN)

        class InvalidCredentials(
            username: String,
        ) : User(
                UserDomainErrorCodes.INVALID_CREDENTIALS,
                "Invalid credentials for username: $username",
            )

        class AdminCannotBeWithdrawn :
            User(
                UserDomainErrorCodes.ADMIN_CANNOT_BE_WITHDRAWN,
                "Admin user cannot be withdrawn.",
            )
    }

    /**
     * Address-related exceptions
     */
    sealed class Address(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_NOT_FOUND,
                "Address not found with ID: $addressId",
            )

        class DefaultAddressNotFound(
            message: String = "Default address ID does not exist in the address list.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_NOT_FOUND,
                message,
            )

        class DuplicateAddressId(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.DUPLICATE_ADDRESS_ID,
                "Address ID already exists: $addressId",
            )

        class IdMismatch(
            existingId: String,
            newId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_ID_MISMATCH,
                "Address ID mismatch: expected $existingId, got $newId",
            )

        class LimitExceeded(
            limit: Int,
        ) : Address(
                UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
                "Cannot add more addresses, limit is $limit",
            )

        class CannotDeleteDefault(
            message: String = "Cannot remove the default address.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
                message,
            )

        class CannotDeleteLast(
            message: String = "Cannot remove the last address.",
        ) : Address(
                UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
                message,
            )

        class MultipleDefaultsOnInit(
            val reason: String = "Cannot initialize user with multiple default addresses.",
        ) : Address(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                reason,
            )
    }

    class PersistenceError(
        message: String,
        cause: Throwable? = null,
    ) : UserDomainException(
            UserDomainErrorCodes.PERSISTENCE_ERROR,
            message,
            cause,
        )
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username

/**
 * 사용자 도메인 리포지토리 Port (Domain Layer).
 * 애플리케이션 코어 로직은 이 인터페이스에 의존한다.
 * 실제 구현은 Infrastructure 레이어에서 제공한다.
 */
interface UserRepository {
    /**
     * 사용자를 저장하거나 업데이트한다.
     * @param user 저장 또는 업데이트할 User Aggregate
     * @return 저장된 User Aggregate (Immutable Aggregate 패턴 고려 시 새 인스턴스)
     */
    fun save(user: User): User

    /**
     * 사용자 ID로 사용자를 찾는다.
     * @param id 사용자 ID (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findById(id: UserId): User?

    /**
     * 사용자 이름으로 사용자를 찾는다.
     * @param username 사용자 이름 (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findByUsername(username: Username): User?

    /**
     * 이메일로 사용자를 찾는다.
     * @param email 이메일 (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun existsByUsername(username: Username): Boolean

    fun delete(user: User)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

@JvmInline
value class AddressId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun fromString(value: String): AddressId =
            try {
                AddressId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidAddressIdFormat(value)
            }

        fun of(value: UUID): AddressId = AddressId(value)

        fun fromUUID(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * Value object representing an email address.
 * This class ensures that the email address is valid according to a basic pattern.
 */
@JvmInline
value class Email private constructor(
    val value: String,
) {
    companion object {
        private val EMAIL_PATTERN =
            Regex(
                "[a-zA-Z0-9+._%\\-]{1,256}" +
                    "@" +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
                    "(" +
                    "\\." +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
                    ")+",
            )

        /**
         * Creates a new Email from a string value.
         * @throws UserDomainException.Validation if the email format is invalid
         */
        fun of(value: String): Email {
            if (!EMAIL_PATTERN.matches(value)) {
                throw UserDomainException.Validation.InvalidEmailFormat(value)
            }
            return Email(value.lowercase())
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Name private constructor(
    val value: String,
) : Serializable {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        private const val MIN_LENGTH = 2
        private const val MAX_LENGTH = 50

        fun of(value: String): Name {
            if (value.isBlank() || value.length < MIN_LENGTH || value.length > MAX_LENGTH) {
                throw UserDomainException.Validation.InvalidNameFormat(
                    "이름은 $MIN_LENGTH 자 이상 $MAX_LENGTH 자 이하이어야 하며, 공백일 수 없습니다: '$value'",
                )
            }
            return Name(value)
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import io.github.oshai.kotlinlogging.KotlinLogging

private val log = KotlinLogging.logger {}

/**
 * 비밀번호 Value Object
 */
@JvmInline
value class Password private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password cannot be blank.")
        }
        // Example: Add more checks for encoded format if applicable
        // if (!value.startsWith("{bcrypt}")) { // Example check
        //     throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password format is invalid.")
        // }
    }

    override fun toString(): String = "********"

    companion object {
        /**
         * Creates a Password VO from a pre-encoded password string.
         * Basic validation is done in the init block.
         */
        fun of(encodedPassword: String): Password {
            // Validation moved to init block
            return Password(encodedPassword)
        }

        // encode method removed - responsibility of Application layer
        // fun encode(rawPassword: String, passwordEncoder: PasswordEncoder): Password { ... }

        // matches method removed - responsibility of Application layer
        // fun matches(rawPassword: String, passwordEncoder: PasswordEncoder): Boolean { ... }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class PhoneNumber private constructor(
    val value: String,
) : Serializable {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        // 대한민국 휴대폰 번호 형식 (010-xxxx-xxxx 또는 010xxxxxxxx)
        private val PHONE_NUMBER_REGEX = Regex("^010-?\\d{4}-?\\d{4}$")

        fun of(value: String): PhoneNumber {
            val normalizedValue = value.replace("-", "") // 하이픈 제거하여 검증
            if (!PHONE_NUMBER_REGEX.matches(value)) {
                throw UserDomainException.Validation.InvalidPhoneNumberFormat("휴대폰 번호 형식이 올바르지 않습니다: $value")
            }
            // 저장 시 하이픈 포함 또는 미포함 선택 가능 (여기서는 미포함 저장)
            return PhoneNumber(normalizedValue)
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

/**
 * Value object representing a unique user identifier.
 * This class wraps a UUID and provides type safety and validation.
 */
@JvmInline
value class UserId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        /**
         * Creates a new UserId from a UUID.
         */
        fun of(uuid: UUID): UserId = UserId(uuid)

        /**
         * Creates a new UserId from a string representation of a UUID.
         * @throws UserDomainException.Validation if the string is not a valid UUID
         */
        fun ofString(value: String): UserId =
            try {
                UserId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUserIdFormat(value)
            }

        /**
         * Generates a new random UserId.
         */
        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromUUID(value: UUID): UserId = UserId(value)
    }

    override fun toString(): String = value.toString()
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Username private constructor(
    val value: String,
) : Serializable {
    init {
        // Add validation logic here if needed (e.g., length, characters)
        if (value.isBlank() || value.length < 3 || value.length > 20) {
            throw UserDomainException.Validation.InvalidUsernameFormat("Username must be between 3 and 20 characters: '$value'")
        }
        // Example: Allow only alphanumeric characters
        // if (!value.matches(Regex("^[a-zA-Z0-9]*$"))) {
        //    throw UserDomainException.Validation.InvalidUsernameFormat("Username must be alphanumeric: '$value'")
        // }
    }

    companion object {
        fun of(value: String): Username {
            // Perform validation before creating
            try {
                // Reuse init block validation implicitly by calling private constructor
                return Username(value)
            } catch (e: UserDomainException.Validation.InvalidUsernameFormat) {
                // Re-throw specific exception if caught from init
                throw e
            } catch (e: IllegalArgumentException) {
                // Catch potential issues from require/check if used in init
                throw UserDomainException.Validation.InvalidUsernameFormat("Invalid username format: ${e.message}")
            }
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/build.gradle.kts
 Path: domains/user/infrastructure/messaging/build.gradle.kts
 Timestamp: 2025-04-28 05:25:55
====================================================================
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.gradle.api.tasks.compile.JavaCompile

plugins {
    // Common plugins (jvm, spring, dependency-management, java-library) applied via subprojects block in root
    id("org.jetbrains.kotlin.plugin.serialization") // Required for Avro DTOs
}

dependencies {
    // Module dependencies
    api(project(":domains:user:domain")) // Expose domain events if needed? Use implementation.
    implementation(project(":domains:common")) // For common exceptions, ErrorCode interface etc.
    implementation(project(":domains:common:infrastructure")) // For Envelope DTO
    implementation(project(":independent:outbox:port")) // To create OutboxMessage DTO

    // Serialization
    implementation(libs.avro4k.core)
    implementation(libs.kotlinx.serialization.core)
    implementation(libs.kotlinx.serialization.json) // If JSON is used by converter/factory

    // Spring
    implementation(libs.spring.context) // For @Component, @Value etc.
    // implementation(libs.spring.kafka) // Only if using KafkaTemplate directly here

    // Common libs (kotlin, slf4j, jackson, test libs) provided by root subprojects block
}

// Disable Java compile task if no Java sources are present
tasks.withType<JavaCompile> {
    enabled = false
}

// Ensure Kotlin compiler settings if not fully covered by root
tasks.withType<KotlinCompile>().configureEach {
    kotlinOptions {
        jvmTarget = "17" // Match root build.gradle.kts setting
    }
} 
--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/avro/dto/UserEventDtos.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/avro/dto/UserEventDtos.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.avro.dto

import kotlinx.serialization.Contextual // Import Contextual
import kotlinx.serialization.Serializable
import java.time.Instant // Import Instant

// Rule 109, 111: @Serializable Kotlin DTO 직접 작성

@Serializable
data class AddressAvroDto( // AddressData 에 대응
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

@Serializable
data class UserCreatedEventDtoV1(
    val userId: String,
    val username: String,
    val email: String,
    val name: String,
    val phoneNumber: String?, // Nullable
    val userType: String, // Enum name as String
    // @Contextual // Temporarily removed
    @Contextual
    val registeredAt: Instant,
    // addresses 필드는 필요시 AddressAvroDto 리스트로 추가
    // val addresses: List<AddressAvroDto> = emptyList()
)

@Serializable
data class UserPasswordChangedEventDtoV1(
    val userId: String,
    // @Contextual // Temporarily removed
    @Contextual
    val changedAt: Instant,
)

@Serializable
data class UserProfileUpdatedEventDtoV1(
    val userId: String,
    val name: String,
    val phoneNumber: String?, // Nullable
    // @Contextual // Temporarily removed
    @Contextual
    val updatedAt: Instant,
)

@Serializable
data class UserAddressAddedEventDtoV1(
    val userId: String,
    val address: AddressAvroDto,
    // @Contextual // Temporarily removed
    @Contextual
    val addedAt: Instant,
)

@Serializable
data class UserAddressUpdatedEventDtoV1(
    val userId: String,
    val address: AddressAvroDto,
    // @Contextual // Temporarily removed
    val updatedAt: Instant,
)

@Serializable
data class UserAddressDeletedEventDtoV1( // Renamed from Removed
    val userId: String,
    val addressId: String,
    // @Contextual // Temporarily removed
    val deletedAt: Instant,
)

@Serializable
data class UserWithdrawnEventDtoV1( // Renamed from UserWithdrawn
    val userId: String,
    // @Contextual // Temporarily removed
    val withdrawnAt: Instant,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.messaging.serialization

import com.restaurant.common.config.filter.CorrelationIdFilter
import com.restaurant.common.core.domain.event.DomainEvent
import com.restaurant.common.infrastructure.avro.dto.Envelope
import com.restaurant.outbox.port.dto.OutboxMessage
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.infrastructure.avro.dto.* // Import all user Avro DTOs
import io.github.avro4k.Avro
import io.github.oshai.kotlinlogging.KotlinLogging
import kotlinx.serialization.serializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component
import java.util.*

private val log = KotlinLogging.logger {}

@Component
class OutboxMessageFactory(
    // Inject Kafka topic name from application properties
    @Value("\${kafka.topics.user-event:dev.user.domain-event.user.v1}") private val userEventTopic: String
) {
    // Default Avro instance configured for avro4k
    private val avro = Avro.default

    /**
     * Creates a list of OutboxMessage objects from a single DomainEvent.
     * Typically, one event results in one message, but allows for future flexibility.
     */
    fun createMessagesFromEvent(event: DomainEvent, correlationId: String): List<OutboxMessage> {
        // Ensure the event is a UserEvent before processing
        val userEvent = event as? UserEvent ?: run {
            log.warn { "Received non-UserEvent domain event type: ${event::class.simpleName}. Skipping outbox message creation." }
            return emptyList()
        }

        // 1. Map DomainEvent to specific Avro Payload DTO
        val payloadDto: Any = mapToAvroPayloadDto(userEvent) ?: run {
             log.error { "Failed to map domain event to Avro DTO for event: ${userEvent::class.simpleName}, aggregateId: ${userEvent.aggregateId}" }
             return emptyList() // Or handle error appropriately
        }

        // 2. Serialize the specific Avro Payload DTO to ByteArray
        val payloadBytes: ByteArray = serializePayload(payloadDto) ?: run {
            log.error { "Failed to serialize Avro payload DTO for event: ${userEvent::class.simpleName}, aggregateId: ${userEvent.aggregateId}" }
             return emptyList() // Or handle error appropriately
        }

        // 3. Create the Envelope DTO (without payload initially)
        // Note: Envelope schema version might need a more robust strategy
        val schemaVersion = payloadDto::class.simpleName + "_V1" // Example versioning
        val envelope = Envelope(
            schemaVersion = schemaVersion,
            eventId = correlationId, // Use correlationId as eventId for tracing
            timestamp = userEvent.occurredAt, // From DomainEvent
            source = "user", // Hardcoded domain source for this factory
            aggregateType = userEvent.aggregateType, // From DomainEvent
            aggregateId = userEvent.aggregateId // From DomainEvent (usually String UUID)
            // payload = payloadBytes // Payload is NOT part of the Avro Envelope DTO itself per Rule 113
        )

        // 4. Serialize the Envelope DTO to ByteArray (this will be the final Kafka message payload)
        // This step seems redundant if the goal is to send the *payloadBytes* created in step 2
        // wrapped in an OUTBOX message structure.
        // Rule 85 says: "Envelope DTO와 이벤트 DTO를 조합하여 ... 최종 Kafka 메시지가 될 raw payload bytes (ByteArray)를 생성합니다"
        // Rule 83 OutboxEventEntity: "이벤트 payload (바이트 배열 ByteArray)"
        // Rule 81 OutboxMessage DTO: "raw payload bytes ByteArray"
        // This implies the Outbox stores the *payload* bytes (step 2), NOT the envelope bytes.
        // The Envelope information should likely go into the OutboxMessage/Entity headers/metadata.
        // Let's store payloadBytes from step 2 in OutboxMessage.payload.
        // val finalPayloadBytes = avro.encodeToByteArray(Envelope.serializer(), envelope) // Incorrect based on re-read rules

        // 5. Determine the target Kafka topic
        val targetTopic = determineTopic(userEvent)

        // 6. Create Kafka message headers (including Envelope metadata)
        val headers = createHeaders(userEvent, correlationId, envelope)

        // 7. Create the OutboxMessage DTO
        val outboxMessage = OutboxMessage(
            aggregateId = userEvent.aggregateId,
            aggregateType = userEvent.aggregateType,
            eventType = userEvent::class.simpleName ?: "UnknownEvent",
            payload = payloadBytes, // Use the serialized DTO bytes (Step 2)
            targetTopic = targetTopic,
            headers = headers // Include Envelope info here
        )

        return listOf(outboxMessage)
    }

    // Maps specific UserEvent subtypes to their corresponding Avro DTOs
    private fun mapToAvroPayloadDto(event: UserEvent): Any? = try {
        when (event) {
            is UserEvent.Created -> UserCreatedEventDtoV1(event.userId.value.toString(), event.username, event.email, event.name, event.phoneNumber, event.userType, event.registeredAt)
            is UserEvent.PasswordChanged -> UserPasswordChangedEventDtoV1(event.userId.value.toString(), event.changedAt)
            is UserEvent.ProfileUpdated -> UserProfileUpdatedEventDtoV1(event.userId.value.toString(), event.name, event.phoneNumber, event.updatedAt)
            is UserEvent.AddressAdded -> UserAddressAddedEventDtoV1(event.userId.value.toString(), event.address.toAvroDto(), event.addedAt)
            is UserEvent.AddressUpdated -> UserAddressUpdatedEventDtoV1(event.userId.value.toString(), event.address.toAvroDto(), event.updatedAt)
            is UserEvent.AddressDeleted -> UserAddressDeletedEventDtoV1(event.userId.value.toString(), event.addressId, event.deletedAt)
            is UserEvent.Withdrawn -> UserWithdrawnEventDtoV1(event.userId.value.toString(), event.withdrawnAt)
            // Add cases for other UserEvent subtypes if they exist
        }
    } catch (e: Exception) {
         log.error(e) { "Error mapping UserEvent to Avro DTO: ${event::class.simpleName}" }
         null
    }


    // Serializes the provided Avro DTO object into a ByteArray
    private fun serializePayload(payloadDto: Any): ByteArray? = try {
        when(payloadDto) {
            // Use kx.serialization's serializer() function
            is UserCreatedEventDtoV1 -> avro.encodeToByteArray(UserCreatedEventDtoV1.serializer(), payloadDto)
            is UserPasswordChangedEventDtoV1 -> avro.encodeToByteArray(UserPasswordChangedEventDtoV1.serializer(), payloadDto)
            is UserProfileUpdatedEventDtoV1 -> avro.encodeToByteArray(UserProfileUpdatedEventDtoV1.serializer(), payloadDto)
            is UserAddressAddedEventDtoV1 -> avro.encodeToByteArray(UserAddressAddedEventDtoV1.serializer(), payloadDto)
            is UserAddressUpdatedEventDtoV1 -> avro.encodeToByteArray(UserAddressUpdatedEventDtoV1.serializer(), payloadDto)
            is UserAddressDeletedEventDtoV1 -> avro.encodeToByteArray(UserAddressDeletedEventDtoV1.serializer(), payloadDto)
            is UserWithdrawnEventDtoV1 -> avro.encodeToByteArray(UserWithdrawnEventDtoV1.serializer(), payloadDto)
            // Add other DTO types here
            else -> throw IllegalArgumentException("Cannot serialize unknown Avro DTO type: ${payloadDto::class.simpleName}")
        }
    } catch (e: Exception) {
        log.error(e) { "Failed to serialize Avro payload DTO: ${payloadDto::class.simpleName}" }
        null
    }

    // Determines the Kafka topic based on the event type (simple example)
    private fun determineTopic(event: UserEvent): String {
        // Can be more sophisticated based on event type if needed
        return userEventTopic
    }

    // Creates the headers map for the Kafka message, including Envelope data
    private fun createHeaders(event: UserEvent, correlationId: String, envelope: Envelope): Map<String, String> {
        return mapOf(
            CorrelationIdFilter.CORRELATION_ID_MDC_KEY to correlationId, // Use constant
            "aggregateId" to event.aggregateId,
            "aggregateType" to event.aggregateType,
            "eventType" to (event::class.simpleName ?: "UnknownEvent"),
            // Include Envelope fields in headers
            "envelope_schemaVersion" to envelope.schemaVersion,
            "envelope_eventId" to envelope.eventId, // This is correlationId again
            "envelope_timestamp" to envelope.timestamp.toString(), // Convert Instant to String
            "envelope_source" to envelope.source,
            "envelope_aggregateType" to envelope.aggregateType, // Duplicates aggregateType?
            "envelope_aggregateId" to envelope.aggregateId // Duplicates aggregateId?
            // Consider if duplicating envelope fields in headers is necessary
        ).filterValues { it != null } // Ensure no null values if any fields are optional
    }

    // Extension function to convert AddressData (from UserEvent) to AddressAvroDto
    // This should be private or internal to this factory/module
    private fun UserEvent.AddressData.toAvroDto() = com.restaurant.user.infrastructure.avro.dto.AddressAvroDto(
        addressId = this.addressId,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault
    )
} 
--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/serialization/OutboxMessageFactory.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/serialization/OutboxMessageFactory.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.serialization

import com.restaurant.outbox.port.dto.OutboxMessage
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Component

private val log = KotlinLogging.logger {}

/**
 * Factory to create OutboxMessage DTOs.
 * Rule 81, 85, 139
 */
@Component
class OutboxMessageFactory {

    /**
     * Creates an OutboxMessage.
     */
    fun createOutboxMessage(
        aggregateId: String,
        aggregateType: String,
        eventType: String,
        payload: ByteArray, // Expect serialized payload (e.g., Envelope bytes)
        targetTopic: String,
        correlationId: String,
        headers: Map<String, String> // Expect pre-built headers
    ): OutboxMessage {

        log.debug {
            "Creating OutboxMessage: topic=$targetTopic, eventType=$eventType, aggregateId=$aggregateId, correlationId=$correlationId, payloadSize=${payload.size}"
        }

        return OutboxMessage(
            aggregateId = aggregateId,
            aggregateType = aggregateType,
            payload = payload,
            topic = targetTopic,
            headers = headers,
        )
    }

    // REMOVED: serializer dependency
    // REMOVED: getTargetTopic method
    // REMOVED: getAggregateType method
    // REMOVED: getAggregateId method
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/build.gradle.kts
 Path: domains/user/infrastructure/persistence/build.gradle.kts
 Timestamp: 2025-04-28 05:25:55
====================================================================
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.gradle.api.tasks.compile.JavaCompile

plugins {
    // Common plugins (jvm, spring, dependency-management, java-library) applied via subprojects block in root
    id("org.jetbrains.kotlin.plugin.jpa") // Required for JPA entities
    id("org.jetbrains.kotlin.plugin.allopen") // Required for JPA entities
}

// Configure allopen for JPA entities
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    // Module dependencies
    api(project(":domains:user:domain")) // Expose domain types if needed by application layer through this module? Use implementation if not.
    implementation(project(":domains:common")) // For common exceptions, ErrorCode interface etc.
    implementation(project(":independent:outbox:port")) // To save OutboxMessage DTOs
    implementation(project(":domains:user:infrastructure:messaging")) // To use OutboxMessageFactory

    // Spring and JPA
    implementation(libs.spring.boot.starter.data.jpa)
    implementation(libs.spring.tx) // For @Transactional
    implementation(libs.spring.context) // For @Repository, @Value etc.

    // Database Driver (example H2)
    runtimeOnly(libs.h2)

    // Common libs (kotlin, slf4j, jackson, test libs) provided by root subprojects block
}

// Disable Java compile task if no Java sources are present
tasks.withType<JavaCompile> {
    enabled = false
}

// Ensure Kotlin compiler settings if not fully covered by root
tasks.withType<KotlinCompile>().configureEach {
    kotlinOptions {
        jvmTarget = "17" // Match root build.gradle.kts setting
    }
} 
--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import com.restaurant.common.infrastructure.persistence.entity.BaseEntity
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID
import java.util.Objects
import jakarta.persistence.Version

@Entity
@Table(name = "addresses")
class AddressEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(name = "address_id", unique = true, nullable = false, updatable = false)
    val addressId: UUID = UUID.randomUUID(),

    @Column(nullable = false)
    var street: String,

    @Column(nullable = false)
    var detail: String,

    @Column(nullable = false, length = 10)
    var zipCode: String,

    @Column(nullable = false)
    var isDefault: Boolean = false,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null,

    @Version
    @Column(nullable = false)
    val version: Long = 0L,

    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),

    @Column(name = "updated_at", nullable = false)
    var updatedAt: Instant = Instant.now(),
) : BaseEntity() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as AddressEntity
        return Objects.equals(id, that.id) &&
            addressId == that.addressId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: addressId)
    }

    override fun toString(): String {
        return "AddressEntity(id=$id, addressId=$addressId, street='$street', detail='$detail', zipCode='$zipCode', isDefault=$isDefault, userId=${user?.id}, version=$version)"
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType
import jakarta.persistence.*
import java.time.Instant
import java.util.UUID
import java.util.Objects

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false, length = 50)
    val username: String,
    @Column(nullable = false)
    val passwordHash: String,
    @Column(unique = true, nullable = false)
    val email: String,
    @Column(nullable = false, length = 50)
    val name: String,
    @Column(length = 20)
    val phoneNumber: String?,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val userType: UserType,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val status: UserStatus = UserStatus.ACTIVE,
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY, mappedBy = "user")
    val addresses: List<AddressEntity> = listOf(),
    @Version
    @Column(nullable = false)
    val version: Long = 0L,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: Instant = Instant.now(),
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as UserEntity
        return Objects.equals(id, that.id) &&
            domainId == that.domainId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: domainId)
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, username='$username', email='$email', userType=$userType, createdAt=$createdAt, updatedAt=$updatedAt, addresses=${addresses.size}, version=$version)"
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.entity.Address // Import Address domain entity
import com.restaurant.user.domain.vo.AddressId // Import AddressId VO
import com.restaurant.user.infrastructure.persistence.entity.AddressEntity
import com.restaurant.user.infrastructure.persistence.entity.UserEntity // Added import for user property in toEntity

/**
 * Extension functions for mapping between Address domain entity and AddressEntity.
 * Rule 24, 25, 60
 */

// AddressEntity -> Address Domain
fun AddressEntity.toDomain(): Address {
    return Address.reconstitute(
        addressId = AddressId.fromUUID(this.addressId), // Ensure AddressId has fromUUID
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        version = this.version // Add version mapping
    )
}

// Address Domain -> AddressEntity
fun Address.toEntity(userEntity: UserEntity? = null): AddressEntity {
    // Note: Passing userEntity here might be less common than setting it from the UserEntity side.
    // If userEntity is null, it assumes the relationship is managed elsewhere.
    return AddressEntity(
        addressId = this.addressId.value,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        version = this.version, // Add version mapping
        user = userEntity // Set user relationship if provided
        // id = null // Let JPA handle the Long id
    )
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.vo.*
import com.restaurant.user.infrastructure.persistence.entity.AddressEntity
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import java.util.stream.Collectors

/**
 * Extension functions for mapping between User domain aggregate and UserEntity.
 * Rule 24, 25, 60
 */

// UserEntity -> User Domain
fun UserEntity.toDomain(): User {
    return User.reconstitute(
        id = UserId.fromUUID(this.userId),
        username = Username.of(this.username),
        password = Password.of(this.passwordHash),
        email = Email.of(this.email),
        name = this.name,
        phoneNumber = this.phoneNumber?.let { PhoneNumber.of(it) },
        userType = this.userType,
        userStatus = this.status,
        addresses = this.addresses.stream().map { it.toDomain() }.collect(Collectors.toList()),
        defaultAddressId = this.addresses.find { it.isDefault }?.let { AddressId.fromUUID(it.addressId) },
        version = this.version
    )
}

// User Domain -> UserEntity
fun User.toEntity(): UserEntity {
    val userEntity = UserEntity(
        userId = this.id.value,
        username = this.username.value,
        passwordHash = this.password.value,
        email = this.email.value,
        name = this.name,
        phoneNumber = this.phoneNumber?.value,
        userType = this.userType,
        status = this.userStatus,
        addresses = mutableListOf(),
        version = this.version,
    )

    val addressEntities = this.addresses.map { address ->
        address.toEntity(userEntity)
    }
    userEntity.addresses.addAll(addressEntities)

    this.defaultAddressId?.let { defId ->
        userEntity.addresses.find { it.addressId == defId.value }?.isDefault = true
    }

    return userEntity
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Modifying
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository
import java.util.*
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByUserId(userId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByUsername(username: String): UserEntity?

    fun existsByEmail(email: String): Boolean

    fun existsByUsername(username: String): Boolean

    @Modifying
    @Query("DELETE FROM UserEntity u WHERE u.domainId = :domainId")
    fun deleteByDomainId(@Param("domainId") domainId: UUID)

    fun findByUserIdOrThrow(userId: UUID): UserEntity =
        findByUserId(userId) ?: throw UserDomainException.User.NotFound(userId.toString())
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.common.config.filter.CorrelationIdFilter
import com.restaurant.outbox.port.OutboxMessageRepository
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import com.restaurant.user.infrastructure.persistence.extensions.toDomain
import com.restaurant.user.infrastructure.persistence.extensions.toEntity
import com.restaurant.user.infrastructure.persistence.repository.SpringDataJpaUserRepository
import com.restaurant.user.infrastructure.messaging.serialization.OutboxMessageFactory
import io.github.oshai.kotlinlogging.KotlinLogging
import org.slf4j.MDC
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.util.*

private val log = KotlinLogging.logger {}

@Repository
class UserRepositoryImpl(
    private val springDataJpaUserRepository: SpringDataJpaUserRepository,
    private val outboxRepository: OutboxMessageRepository,
    private val outboxMessageFactory: OutboxMessageFactory
) : UserRepository {
    @Transactional
    override fun save(user: User): User {
        val isNew = user.version == 0L
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "SYSTEM-${UUID.randomUUID()}"
        log.debug { "Attempting to save user: ${user.id.value}, isNew=$isNew, correlationId=$correlationId" }

        val entity: UserEntity = user.toEntity()
        val savedEntity: UserEntity = try {
            springDataJpaUserRepository.saveAndFlush(entity)
        } catch (e: DataIntegrityViolationException) {
            log.warn(e) { "Data integrity violation while saving user ${user.id.value}" }
            val message = e.mostSpecificCause.message ?: ""
            when {
                message.contains("uc_users_email", ignoreCase = true) || message.contains("users_email_key") || message.contains("uk_user_email") ->
                    throw UserDomainException.User.DuplicateEmail(user.email.value)
                message.contains("uc_users_username", ignoreCase = true) || message.contains("users_username_key") || message.contains("uk_user_username") ->
                    throw UserDomainException.User.DuplicateUsername(user.username.value)
                else -> throw UserDomainException.PersistenceError("Data integrity violation", e)
            }
        } catch (e: Exception) {
            log.error(e) { "Failed to save user ${user.id.value}" }
            throw UserDomainException.PersistenceError("Failed to save user", e)
        }

        val events = user.getDomainEvents()
        if (events.isNotEmpty()) {
            log.info { "Processing ${events.size} domain event(s) for aggregate ${user.id.value} with correlationId $correlationId" }
            try {
                val outboxMessages = events.flatMap { event ->
                    outboxMessageFactory.createMessagesFromEvent(event, correlationId)
                }

                if (outboxMessages.isNotEmpty()) {
                    outboxRepository.save(outboxMessages)
                    log.info { "Saved ${outboxMessages.size} message(s) to outbox for aggregate ${user.id.value}" }
                }
            } catch (ex: Exception) {
                log.error(ex) {
                    "Failed to process/save ${events.size} event(s) to outbox for aggregate ${user.id.value}. Rethrowing for transaction rollback."
                }
                throw UserDomainException.PersistenceError("Failed to save domain events to outbox", ex)
            } finally {
                user.clearDomainEvents()
            }
        }

        return savedEntity.toDomain()
    }

    @Transactional(readOnly = true)
    override fun findById(id: UserId): User? {
        log.debug { "Finding user by ID: ${id.value}" }
        return springDataJpaUserRepository
            .findByDomainId(id.value)
            ?.toDomain()
            .also { if (it == null) log.warn { "User not found for ID: ${id.value}" } }
    }

    @Transactional(readOnly = true)
    override fun findByUsername(username: Username): User? {
        log.debug { "Finding user by username: ${username.value}" }
        return springDataJpaUserRepository
            .findByUsername(username.value)
            ?.toDomain()
            .also { if (it == null) log.warn { "User not found for Username: ${username.value}" } }
    }

    @Transactional(readOnly = true)
    override fun findByEmail(email: Email): User? {
        log.debug { "Finding user by email: ${email.value}" }
        return springDataJpaUserRepository
            .findByEmailValue(email.value)
            ?.toDomain()
            .also { if (it == null) log.warn { "User not found for Email: ${email.value}" } }
    }

    @Transactional(readOnly = true)
    override fun existsByUsername(username: Username): Boolean {
        log.debug { "Checking existence by username: ${username.value}" }
        return springDataJpaUserRepository.existsByUsername(username.value)
    }

    @Transactional(readOnly = true)
    override fun existsByEmail(email: Email): Boolean {
        log.debug { "Checking existence by email: ${email.value}" }
        return springDataJpaUserRepository.existsByEmailValue(email.value)
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/build.gradle.kts
 Path: domains/user/presentation/build.gradle.kts
 Timestamp: 2025-04-28 05:25:55
====================================================================
plugins {
    // kotlin("jvm") // Provided by subprojects block
    alias(libs.plugins.kotlin.spring) // Apply spring plugin
}

dependencies {
    // Keep module-specific dependencies
    implementation(project(":domains:user:application"))
    implementation(project(":config"))

    // Keep presentation-specific dependencies
    implementation(libs.spring.boot.starter.web) // Use alias
    implementation(libs.spring.boot.starter.hateoas) // Use alias
    implementation(libs.spring.boot.starter.validation) // Use alias
    implementation(libs.springdoc.openapi.starter.webmvc.ui) // Use alias

    // Common dependencies (kotlin, slf4j, jackson, test deps) are handled by subprojects block
    // implementation(libs.kotlin.stdlib)
    // implementation(libs.kotlin.logging.jvm)
    // implementation(libs.jackson.module.kotlin)
    // implementation(libs.jackson.datatype.jsr310)
    // implementation(libs.jakarta.validation.api)
    // implementation(libs.jakarta.servlet.api)

    // Test dependencies handled by subprojects block
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/controller/UserAddressController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/controller/UserAddressController.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.controller

import com.restaurant.config.dto.response.CommandResultResponse
import com.restaurant.config.filter.CorrelationIdFilter
import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.port.`in`.DeleteAddressUseCase
import com.restaurant.user.application.port.`in`.RegisterAddressUseCase
import com.restaurant.user.application.port.`in`.UpdateAddressUseCase
import com.restaurant.user.presentation.extensions.v1.request.toCommand
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import mu.KotlinLogging
import org.slf4j.MDC
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

private val log = KotlinLogging.logger {}

@Tag(name = "사용자 주소 관리 API V1", description = "사용자 주소 등록, 수정, 삭제 API")
@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
class UserAddressController(
    private val registerAddressUseCase: RegisterAddressUseCase,
    private val updateAddressUseCase: UpdateAddressUseCase,
    private val deleteAddressUseCase: DeleteAddressUseCase,
) {
    @Operation(summary = "주소 등록")
    @PostMapping
    fun registerAddress(
        @Parameter(description = "사용자 ID") @PathVariable userId: String,
        @Valid @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Registering address for userId: $userId" }
        val command = request.toCommand(userId)
        registerAddressUseCase.handle(command)

        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "unknown"
        val response = CommandResultResponse(
            message = "주소 등록 성공",
            correlationId = correlationId,
        )

        response.add(linkTo(methodOn(UserAddressController::class.java).registerAddress(userId, request)).withSelfRel())

        log.info { "Address registered for userId: $userId" }
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "주소 수정")
    @PutMapping("/{addressId}")
    fun updateAddress(
        @Parameter(description = "사용자 ID") @PathVariable userId: String,
        @Parameter(description = "주소 ID") @PathVariable addressId: String,
        @Valid @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "N/A"
        log.info { "Updating address $addressId for userId: $userId" }

        val command = request.toCommand(userId, addressId)
        updateAddressUseCase.handle(command)

        val response = CommandResultResponse(
            message = "주소 수정 성공",
            correlationId = correlationId,
        )
        response.add(linkTo(methodOn(UserAddressController::class.java).updateAddress(userId, addressId, request)).withSelfRel())

        log.info { "Address $addressId updated for userId: $userId" }
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "주소 삭제")
    @DeleteMapping("/{addressId}")
    fun deleteAddress(
        @Parameter(description = "사용자 ID") @PathVariable userId: String,
        @Parameter(description = "주소 ID") @PathVariable addressId: String,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "N/A"
        log.info { "Deleting address $addressId for userId: $userId" }

        val command = DeleteAddressCommand(userId = userId, addressId = addressId)
        deleteAddressUseCase.handle(command)

        val response = CommandResultResponse(
            message = "주소 삭제 성공",
            correlationId = correlationId,
        )
        response.add(linkTo(methodOn(UserAddressController::class.java).deleteAddress(userId, addressId)).withSelfRel())

        log.info { "Address $addressId deleted for userId: $userId" }
        return ResponseEntity.ok(response)
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/controller/UserController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/controller/UserController.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.controller

import com.restaurant.config.dto.response.CommandResultResponse
import com.restaurant.config.filter.CorrelationIdFilter
// Command Use Cases
import com.restaurant.user.application.port.`in`.ChangePasswordUseCase
import com.restaurant.user.application.port.`in`.DeleteAddressUseCase
import com.restaurant.user.application.port.`in`.DeleteUserUseCase
import com.restaurant.user.application.port.`in`.RegisterAddressUseCase
import com.restaurant.user.application.port.`in`.RegisterUserUseCase
import com.restaurant.user.application.port.`in`.UpdateAddressUseCase
import com.restaurant.user.application.port.`in`.UpdateProfileUseCase
// Query Use Cases
import com.restaurant.user.application.port.`in`.GetUserAddressesQuery
import com.restaurant.user.application.port.`in`.GetUserProfileQuery
// DTOs
import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.dto.query.AddressDto
import com.restaurant.user.application.dto.query.GetUserAddressesQuery as AppGetUserAddressesQuery
import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.presentation.v1.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
// Extensions
import com.restaurant.user.presentation.v1.extensions.request.toCommand
import com.restaurant.user.presentation.v1.extensions.response.toResponse
import com.restaurant.user.presentation.v1.extensions.response.toResponseV1
// Other imports
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.MDC
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(name = "User Commands", description = "API for user account management (registration, login, profile updates, password change, deletion)")
@RestController
@RequestMapping("/api/v1/users")
class UserController(
    private val registerUserUseCase: RegisterUserUseCase,
    private val loginUseCase: LoginUseCase,
    private val updateProfileUseCase: UpdateProfileUseCase,
    private val changePasswordUseCase: ChangePasswordUseCase,
    private val deleteUserUseCase: DeleteUserUseCase,
    // Remove Address Use Cases - Moved to UserAddressController
    // private val registerAddressUseCase: RegisterAddressUseCase,
    // private val updateAddressUseCase: UpdateAddressUseCase,
    // private val deleteAddressUseCase: DeleteAddressUseCase
) {

    @PostMapping
    @Operation(summary = "Register a new user")
    @ApiResponse(responseCode = "201", description = "User registered successfully")
    fun registerUser(@Valid @RequestBody request: RegisterUserRequestV1): ResponseEntity<CommandResultResponse> {
        log.info("Register user request received: {}", request.username)
        val command = request.toCommand()
        val userId = registerUserUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "User registered successfully",
        ).apply {
            add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.value.toString())).withSelfRel())
            add(linkTo(methodOn(UserController::class.java).loginUser(null)).withRel("login")) // Pass null for request body placeholder
        }
        return ResponseEntity.created(response.getRequiredLink("self").toUri()).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "Login a user")
    @ApiResponse(responseCode = "200", description = "User logged in successfully")
    fun loginUser(@Valid @RequestBody request: LoginRequestV1): ResponseEntity<Any> { // Return type can be more specific
        log.info("Login request received for email: {}", request.email)
        val command = request.toCommand()
        val loginResult = loginUseCase.login(command)
        // Login response usually includes the token directly, maybe not CommandResultResponse
        // HATEOAS for login might link to profile, logout etc.
        val response = mapOf(
             "status" to "SUCCESS",
             "message" to "Login successful",
             "data" to loginResult
        ) // Example - Adapt response as needed
        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "Update user profile")
    @ApiResponse(responseCode = "200", description = "Profile updated successfully")
    fun updateProfile(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: UpdateProfileRequestV1
    ): ResponseEntity<CommandResultResponse> {
        log.info("Update profile request received for user: {}", userId)
        val command = request.toCommand(userId)
        updateProfileUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "Profile updated successfully",
        ).apply {
            add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withSelfRel())
        }
        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "Change user password")
    @ApiResponse(responseCode = "200", description = "Password changed successfully")
    fun changePassword(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: ChangePasswordRequestV1
    ): ResponseEntity<CommandResultResponse> {
        log.info("Change password request received for user: {}", userId)
        val command = request.toCommand(userId)
        changePasswordUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "Password changed successfully",
        ).apply {
            add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withRel("view-profile"))
        }
        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "Delete user account")
    @ApiResponse(responseCode = "200", description = "User deleted successfully")
    fun deleteUser(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: DeleteUserRequestV1 // Assuming password needed for deletion
    ): ResponseEntity<CommandResultResponse> {
        log.info("Delete user request received for user: {}", userId)
        val command = request.toCommand(userId)
        deleteUserUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "User deleted successfully",
        )
        // No HATEOAS links usually for deletion confirmation
        return ResponseEntity.ok(response)
    }

    // Remove Address related endpoints
    // @PostMapping("/{userId}/addresses") ...
    // @PutMapping("/{userId}/addresses/{addressId}") ...
    // @DeleteMapping("/{userId}/addresses/{addressId}") ...

    // Remove Query related endpoints (moved to UserQueryController)
    // @GetMapping("/{userId}/profile") ...
    // @GetMapping("/{userId}/addresses") ...
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/controller/UserQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/controller/UserQueryController.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.controller

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.port.`in`.GetUserProfileQuery
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
import com.restaurant.user.presentation.v1.extensions.response.toResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Queries", description = "API for querying user information")
class UserQueryController(
    private val getUserProfileQueryUseCase: GetUserProfileQuery,
) {
    @GetMapping("/{userId}/profile")
    @Operation(summary = "Get user profile", description = "Retrieves user profile information by User ID.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Profile retrieved successfully",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = UserProfileResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "Invalid UUID format",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "User not found",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "User ID (UUID)", required = true) @PathVariable userId: String,
    ): ResponseEntity<UserProfileResponseV1> {
        log.info { "Received request to get user profile for ID: $userId" }

        val query = GetUserProfileByIdQuery(userId = userId)
        val userProfileDto = getUserProfileQueryUseCase.getUserProfile(query)

        val responseDto = userProfileDto.toResponseV1()

        val userUuid = UUID.fromString(userId)
        responseDto.add(
            linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId)).withSelfRel(),
            linkTo(methodOn(UserController::class.java).updateProfile(userUuid, null)).withRel("update-profile"),
            linkTo(methodOn(UserController::class.java).changePassword(userUuid, null)).withRel("change-password"),
        )
        log.info { "Returning user profile for ID: $userId" }
        return ResponseEntity.ok(responseDto)
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/ChangePasswordRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/ChangePasswordRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/DeleteUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/DeleteUserRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/LoginRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/LoginRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterAddressRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterUserRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

@Schema(description = "사용자 등록 요청")
data class RegisterUserRequestV1(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser")
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    @Schema(description = "전화번호 (선택)", example = "010-1234-5678")
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateAddressRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateProfileRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateProfileRequestV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/AddressResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/AddressResponseV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/LoginResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/LoginResponseV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답 V1")
data class LoginResponseV1(
    @Schema(description = "사용자 ID (UUID)")
    val userId: String,
    @Schema(description = "사용자 이름")
    val username: String,
    @Schema(description = "사용자 이메일")
    val email: String,
    @Schema(description = "액세스 토큰")
    val accessToken: String,
    @Schema(description = "리프레시 토큰")
    val refreshToken: String,
) : RepresentationModel<LoginResponseV1>()

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/UserProfileResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/UserProfileResponseV1.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import org.springframework.hateoas.server.core.Relation
import java.time.Instant

@Schema(description = "주소 응답")
data class AddressResponseV1(
    @Schema(description = "주소 ID") val addressId: String,
    @Schema(description = "도로명 주소") val street: String,
    @Schema(description = "상세 주소") val detail: String,
    @Schema(description = "우편번호") val zipCode: String,
    @Schema(description = "기본 주소 여부") val isDefault: Boolean,
)

/**
 * 사용자 프로필 정보 응답 DTO (Rule 1.4, 39)
 */
@Relation(collectionRelation = "users", itemRelation = "user") // For HATEOAS collection relation
@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "사용자 아이디", example = "testuser") val username: String,
    @Schema(description = "전화번호", example = "010-1234-5678", nullable = true) val phoneNumber: String?,
    @Schema(description = "사용자 타입", example = "CUSTOMER") val userType: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: Instant,
) : RepresentationModel<UserProfileResponseV1>() // Inherit from RepresentationModel

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/request/UserCommandRequestExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/request/UserCommandRequestExtensions.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.extensions.request

import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.domain.aggregate.UserType
import com.restaurant.user.presentation.v1.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateProfileRequestV1
import java.util.UUID

// RegisterUserRequestV1 -> RegisterUserCommand 변환
fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        username = this.username,
        password = this.password,
        email = this.email,
        name = this.name,
        phoneNumber = this.phoneNumber,
        userType = this.userType ?: UserType.CUSTOMER, // Default to CUSTOMER if null
    )

// LoginRequestV1 -> LoginCommand 변환
fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

// UpdateProfileRequestV1 -> UpdateProfileCommand 변환
fun UpdateProfileRequestV1.toCommand(userId: UUID): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId,
        name = this.name,
        phoneNumber = this.phoneNumber,
    )

// ChangePasswordRequestV1 -> ChangePasswordCommand 변환
fun ChangePasswordRequestV1.toCommand(userId: UUID): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId,
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

// DeleteUserRequestV1 -> DeleteUserCommand 변환
fun DeleteUserRequestV1.toCommand(userId: UUID): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId,
        password = this.password,
    )

// RegisterAddressRequestV1 -> RegisterAddressCommand 변환
fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// UpdateAddressRequestV1 -> UpdateAddressCommand 변환
fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/response/UserQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/response/UserQueryResponseExtensions.kt
 Timestamp: 2025-04-28 05:25:55
====================================================================
package com.restaurant.user.presentation.v1.extensions.response

import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.presentation.v1.controller.UserController
import com.restaurant.user.presentation.v1.controller.UserQueryController
import com.restaurant.user.presentation.v1.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import java.util.UUID

// UserProfileDto -> UserProfileResponseV1 변환
fun UserProfileDto.toResponseV1(): UserProfileResponseV1 {
    val userId = this.id // Assuming UserProfileDto has 'id' which is the UUID string
    val userUuid = UUID.fromString(userId)

    // Use correct Controller classes for links
    val selfLink = linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId)).withSelfRel()
    // Assuming addresses are handled by UserAddressController or UserQueryController
    // val addressesLink = linkTo(methodOn(UserAddressController::class.java).getUserAddresses(userUuid)).withRel("addresses")
    val updateProfileLink =
        linkTo(methodOn(UserController::class.java).updateProfile(userUuid, null)).withRel("update-profile")
    val changePasswordLink =
        linkTo(methodOn(UserController::class.java).changePassword(userUuid, null)).withRel("change-password")
    val deleteUserLink = linkTo(methodOn(UserController::class.java).deleteUser(userUuid, null)).withRel("delete-user")

    return UserProfileResponseV1(
        id = this.id,
        username = this.username,
        email = this.email,
        name = this.name,
        phoneNumber = this.phoneNumber,
        userType = this.userType,
        status = this.userStatus, // Map userStatus field added in Query DTO
        createdAt = this.createdAt, // Keep as Instant or format as needed
        updatedAt = this.updatedAt, // Keep as Instant or format as needed
        version = this.version, // Map version field added in Query DTO
        addresses = this.addresses.map { it.toResponseV1() }, // Use correct function name
    ).apply {
        // Add relevant links
        add(selfLink, updateProfileLink, changePasswordLink, deleteUserLink)
        // if (addressesLink != null) add(addressesLink) // Add address link if implemented
    }
}

// UserProfileDto.AddressDto -> AddressResponseV1 변환
fun UserProfileDto.AddressDto.toResponseV1(): AddressResponseV1 {
    // Add links if needed, e.g., link to update/delete this specific address
    // val updateLink = linkTo(methodOn(UserAddressController::class.java).updateAddress(userId, addressId, null)).withRel("update")
    // val deleteLink = linkTo(methodOn(UserAddressController::class.java).deleteAddress(userId, addressId)).withRel("delete")
    return AddressResponseV1(
        id = this.id, // Use correct field name 'id' from DTO
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    ) // .apply { add(updateLink, deleteLink) }
}

// List extension (can be useful)
fun List<UserProfileDto.AddressDto>.toResponseV1(): List<AddressResponseV1> = map { it.toResponseV1() }

--------------------------------------------------------------------



====================================================================
 File: settings.gradle.kts
 Path: settings.gradle.kts
 Timestamp: 2025-04-28 05:25:55
====================================================================
import java.net.URI
import java.io.File

pluginManagement {
    repositories {
        gradlePluginPortal()
        mavenCentral()
        maven { url = uri("https://repo.spring.io/milestone") }
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        mavenCentral()
        maven { url = uri("https://packages.confluent.io/maven/") }
    }
}

rootProject.name = "restaurant"

include(
    ":domains:common",
    ":domains:common:infrastructure",
    ":domains:user:presentation",
    ":domains:user:application",
    ":domains:user:domain",
    ":domains:user:infrastructure:messaging",
    ":domains:user:infrastructure:persistence",
    ":independent:outbox",
    ":independent:outbox:port",
    ":independent:outbox:infrastructure",
    ":config",
    ":apps:user-app"
)

fun includeGradleBuilds(vararg paths: String) {
    paths.forEach { path ->
        val moduleName = path.substring(1).replace("/", ":")
        includeBuild(path) {
            dependencySubstitution {
                substitute(module(moduleName)).using(project(":"))
            }
        }
    }
}

fun isCiServer(): Boolean {
    return System.getenv("CI") != null
}

fun shouldIncludeBuild(modulePath: String): Boolean {
    val ci = isCiServer()
    val requestedPath = System.getProperty("includeBuild")

    return when {
        !ci && requestedPath == null -> true // Local build, no specific request: include all
        !ci && requestedPath != null -> modulePath == requestedPath // Local build, specific request: include only requested
        else -> false // CI build: never include builds
    }
}

// Recursively find all subprojects with build.gradle.kts excluding certain paths
file(".").walkTopDown().forEach { file ->
    if (file.name == "build.gradle.kts" && file.parentFile != settings.rootDir) {
        val modulePath = file.parentFile.relativeTo(settings.rootDir).path.replace(File.separatorChar, ':')
        val cleanModulePath = ":$modulePath"

        // Exclude paths containing build, out, .gradle, .idea, etc. and ensure it's a valid subproject path
        if (!file.parent.contains("build") &&
            !file.parent.contains("out") &&
            !file.parent.contains(".gradle") &&
            !file.parent.contains(".idea") &&
            !file.parent.contains(".run") &&
            cleanModulePath.startsWith(":") // Basic validation
           ) {
            println("Discovered module: $cleanModulePath")
            // You might need further logic here if you intended to use shouldIncludeBuild
        }
    }
}

--------------------------------------------------------------------


==============================================================
 File Collection Completed: 2025-04-28 05:25:55 
==============================================================
