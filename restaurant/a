모듈들의 전체 코드가 첨부되어있다.
코드를 보면 불완전 한 부분도 있고 규칙을 지키지 않는 부분도 있다.
따라서 코드에 기준으로 작업을 완료하려고 하면 완성이 안될꺼다. 왜냐하면 코드가 정말 엉망이기 떄문이다. 어떤 요구사항인지 잘생각해서 수정계획을 해야한다.
그래서 이를 수정하기 위한 작업 지시서가 필요하다. 작업 지시서를 만들어라.
- tree 구조를 보고 규칙에 맞지않는 부분을 찾아서 삭제할 파일, 이동할 파일에 대한 작업지시서는 최우선이다. 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 규칙을 지키지 않는 부분에 대한 작업지시서를 작성하라
- 프로그램이 정상적으로 동작하기위해 추가적으로 작업해야하는 작업지시서를 작성하라
- 작업지시서는 단계가 명확하게 표현되어야 한다. 하지만 작업의 순서를 잘생각해서 먼저되어야 하는건 꼭 먼저하도록 단계를 잘 생각하라.
- build.gradle.kts는 최상위 파일에 공통부분을 최대한 모아놓고 각 모듈별로 필요한 부분은 모듈 내부에 작성한다.
- 작업지시서에서는 Gradle 의존성에 대한 버전에 대해서 지적하지 않는다. 모두 최신버전으로 팀내에서 직접 관리하는 영역이다.
- 필요없는 파일은 삭제하도록 지시하라.
- 필요없는 코드는 주석보단 삭제를 하도록 지시하라.
- 현재 코드를 유지하는 경우는 작업지시서에 굳이 명시하지 않아도 된다.
- 작업지시서는 ~을 확인해라. 같은 모호한 문장은 절대로 안된다. ~을 어떻게 고쳐라 같이 매우 명시적이여야 한다.
- 작업지시서는 어떤 파일이 어떤 부분이 잘못작성되었고 어떻게 고쳐야한다. 그리고 근거는 무엇이다 라는 명시적 문장이 있어야 한다.
- 작업지시서에 코드 레벨을 너무 자세하게 설명하지 않아도 된다.
- 작업지시서 제일 하단에는 모든 작업이 끝나고 확인해야할 체크리스트를 작성한다.
- 이프로젝트는 Kotlin 으로 작성되어있다. Java는 사용하지 않는다.
- 최신 스테이블 버전 목록은 작업지시서에 생략하지 않고 꼭 기입한다.

작업 지시서에 항상 상단에 첨부할 문구
```
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.

작업시 항상 기억해야할 규칙
- 파일을 수정할때는 import 구문이 완벽한지 한번씩 더 체크하도록 한다. 만약 확인이 필요하다면 다른 파일을 조회할 수 있다.
- 작업을 진행하는 도중에 작업지시서에 없는 수정사항은 일단 보류하고 작업지시서를 최우선으로 수정한다.
- 이런식의 참조는 금지한다. ( ex -> event: com.restaurant.domains.common.domain.event.DomainEvent ) 항상 import 구문을 추가해서 참조하도록 한다.
- com.restaurant.domains.common.* 과 같은 import는 절대로 금지한다.
- 공통으로 수정해야할 패턴이 확실하다면 커맨드 명령어로 한번에 처리한다. 단, 프로젝트 내부에 build,bin 같은 제외할 경로는 명확히 명시한다.
- 필요없는 코드는 주석처리 하지 말고 삭제하도록 하라.
- 파일을 생성 할때는 위치가 올바른지 확인하기 위해서 파일 구조도를 참고하도록 한다.
- 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 의존성 버전은 항상 tools 이용해서 최신 스테이블 버전을 활용하도록 한다.
- 확인하고 싶은 디렉토리 구조가 있다면 tree 명령어로 최대한 효율적이게 진행하라. 단 bin,build 는 제외한다.
- 패키지나 폴더 경로에 in은 예약어이니 input이나 이런걸로 피하라.
```

====================================================================n

> Task :independent:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:check
> Task :apps:user-app:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:application:processResources NO-SOURCE
> Task :domains:common:domain:processResources NO-SOURCE
> Task :domains:common:infrastructure:processResources NO-SOURCE
> Task :domains:common:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:presentation:processResources NO-SOURCE
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:processResources NO-SOURCE
> Task :domains:user:infrastructure:messaging:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:processResources
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:infrastructure:messaging:processResources
> Task :domains:user:infrastructure:persistence:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:persistence:processResources NO-SOURCE
> Task :apps:user-app:processResources
> Task :apps:user-app:check
> Task :domains:user:domain:check

> Task :domains:user:infrastructure:buildEnvironment
Daemon JVM: Eclipse Temurin JDK 21.0.7+6-LTS
  | Location:           /home/junoko/.sdkman/candidates/java/21.0.7-tem
  | Language Version:   21
  | Vendor:             Eclipse Temurin
  | Architecture:       amd64
  | Is JDK:             true


------------------------------------------------------------
Project ':domains:user:infrastructure'
------------------------------------------------------------

classpath
No dependencies

A web-based, searchable dependency report is available by adding the --scan option.

> Task :domains:user:presentation:check
> Task :independent:outbox:check
> Task :domains:common:domain:compileKotlin
> Task :domains:common:domain:compileJava NO-SOURCE
> Task :independent:outbox:compileKotlin
> Task :independent:outbox:compileJava NO-SOURCE
> Task :domains:common:domain:classes UP-TO-DATE
> Task :domains:common:domain:jar
> Task :independent:outbox:classes
> Task :independent:outbox:jar
> Task :independent:outbox:assemble
> Task :independent:outbox:build

> Task :domains:user:domain:compileKotlin
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:19:17 Non-public primary constructor is exposed via the generated 'copy()' method of the 'data' class.

The generated 'copy()' will change its visibility in future releases.

To suppress the warning do one of the following:
- Annotate the data class with the '@ConsistentCopyVisibility' annotation.
- Use the '-Xconsistent-data-class-copy-visibility' compiler flag.
- Annotate the data class with the '@ExposedCopyVisibility' annotation 
  (Discouraged, but can be used to keep binary compatibility).

To learn more, see the documentation of the '@ConsistentCopyVisibility' and '@ExposedCopyVisibility' annotations.

This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:95:81 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:100:62 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:125:133 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:130:62 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:222:66 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:222:99 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt:12:20 Non-public primary constructor is exposed via the generated 'copy()' method of the 'data' class.

The generated 'copy()' will change its visibility in future releases.

To suppress the warning do one of the following:
- Annotate the data class with the '@ConsistentCopyVisibility' annotation.
- Use the '-Xconsistent-data-class-copy-visibility' compiler flag.
- Annotate the data class with the '@ExposedCopyVisibility' annotation 
  (Discouraged, but can be used to keep binary compatibility).

To learn more, see the documentation of the '@ConsistentCopyVisibility' and '@ExposedCopyVisibility' annotations.

This will become an error in Kotlin 2.2.

> Task :domains:user:domain:compileJava NO-SOURCE
> Task :domains:user:domain:classes UP-TO-DATE
> Task :domains:user:domain:jar
> Task :domains:user:domain:assemble
> Task :domains:user:domain:build
> Task :domains:common:application:compileKotlin
> Task :domains:common:application:compileJava NO-SOURCE
> Task :domains:common:application:classes UP-TO-DATE
> Task :domains:common:application:jar
> Task :domains:common:infrastructure:generateAvroProtocol NO-SOURCE
> Task :domains:common:infrastructure:generateAvroJava NO-SOURCE
> Task :domains:common:infrastructure:compileKotlin
> Task :domains:common:infrastructure:compileJava NO-SOURCE
> Task :domains:common:infrastructure:classes UP-TO-DATE
> Task :domains:common:infrastructure:jar
> Task :domains:user:infrastructure:messaging:generateAvroProtocol NO-SOURCE
> Task :domains:common:presentation:compileKotlin
> Task :domains:user:infrastructure:messaging:generateAvroJava
> Task :domains:common:presentation:compileJava NO-SOURCE
> Task :domains:common:presentation:classes UP-TO-DATE
> Task :domains:common:presentation:jar
> Task :domains:user:application:compileKotlin
> Task :domains:user:application:compileJava NO-SOURCE
> Task :domains:user:application:classes UP-TO-DATE
> Task :domains:user:application:jar
> Task :domains:user:application:assemble
> Task :domains:user:application:build
> Task :domains:user:infrastructure:messaging:compileKotlin

> Task :domains:user:presentation:compileKotlin FAILED
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:12:45 Unresolved reference 'input'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:13:45 Unresolved reference 'input'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:14:45 Unresolved reference 'input'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:15:45 Unresolved reference 'input'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:16:45 Unresolved reference 'input'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:39:38 Unresolved reference 'RegisterUserUseCase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:40:31 Unresolved reference 'LoginUseCase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:41:39 Unresolved reference 'UpdateProfileUseCase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:42:40 Unresolved reference 'ChangePasswordUseCase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:43:36 Unresolved reference 'DeleteUserUseCase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:54:50 Unresolved reference 'register'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:80:40 Unresolved reference 'login'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:100:30 Unresolved reference 'updateProfile'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:120:31 Unresolved reference 'changePassword'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt:140:27 Unresolved reference 'deleteUser'.

> Task :domains:user:infrastructure:messaging:compileJava

[Incubating] Problems report is available at: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/build/reports/problems/problems-report.html

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':domains:user:presentation:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

Deprecated Gradle features were used in this build, making it incompatible with Gradle 9.0.

You can use '--warning-mode all' to show the individual deprecation warnings and determine if they come from your own scripts or plugins.

For more on this, please refer to https://docs.gradle.org/8.14/userguide/command_line_interface.html#sec:command_line_warnings in the Gradle documentation.

BUILD FAILED in 8s
22 actionable tasks: 22 executed


==============================================================
 Gradle Build Completed: 2025-05-14 04:28:11 
==============================================================


[Incubating] Problems report is available at: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/build/reports/problems/problems-report.html

FAILURE: Build failed with an exception.

* What went wrong:
Task 'ktlintFormat' not found in root project 'restaurant' and its subprojects.

* Try:
> Run gradlew tasks to get a list of available tasks.
> For more on name expansion, please refer to https://docs.gradle.org/8.14/userguide/command_line_interface.html#sec:name_abbreviation in the Gradle documentation.
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 449ms


==============================================================
 ktlintFormat Completed: 2025-05-14 04:28:11 
==============================================================


==============================================================

# Project Structure

domains
├── common
│   ├── application
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── application
│   │                               └── exception
│   │                                   └── ApplicationException.kt
│   ├── domain
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── domain
│   │                               ├── aggregate
│   │                               │   └── AggregateRoot.kt
│   │                               ├── error
│   │                               │   ├── CommonSystemErrorCode.kt
│   │                               │   └── ErrorCode.kt
│   │                               ├── event
│   │                               │   └── DomainEvent.kt
│   │                               └── exception
│   │                                   └── DomainException.kt
│   ├── infrastructure
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           ├── kotlin
│   │           │   └── com
│   │           │       └── restaurant
│   │           │           └── common
│   │           │               └── infrastructure
│   │           │                   └── persistence
│   │           │                       └── entity
│   │           │                           └── BaseEntity.kt
│   │           └── resources
│   └── presentation
│       ├── build.gradle.kts
│       └── src
│           └── main
│               ├── kotlin
│               │   └── com
│               │       └── restaurant
│               │           └── common
│               │               └── presentation
│               │                   ├── GlobalExceptionHandler.kt
│               │                   ├── config
│               │                   │   └── SecurityConfig.kt
│               │                   ├── dto
│               │                   │   └── response
│               │                   │       └── CommandResultResponse.kt
│               │                   └── filter
│               │                       └── CorrelationIdFilter.kt
│               └── resources
└── user
    ├── application
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── application
    │                               ├── dto
    │                               │   ├── command
    │                               │   │   ├── ChangePasswordCommand.kt
    │                               │   │   ├── DeleteAddressCommand.kt
    │                               │   │   ├── DeleteUserCommand.kt
    │                               │   │   ├── LoginCommand.kt
    │                               │   │   ├── RegisterAddressCommand.kt
    │                               │   │   ├── RegisterUserCommand.kt
    │                               │   │   ├── UpdateAddressCommand.kt
    │                               │   │   └── UpdateProfileCommand.kt
    │                               │   └── query
    │                               │       ├── GetUserProfileByIdQuery.kt
    │                               │       ├── LoginResult.kt
    │                               │       └── UserProfileDto.kt
    │                               ├── error
    │                               │   └── UserApplicationErrorCode.kt
    │                               ├── exception
    │                               │   └── UserApplicationException.kt
    │                               ├── port
    │                               │   ├── ChangePasswordUseCase.kt
    │                               │   ├── DeleteAddressUseCase.kt
    │                               │   ├── DeleteUserUseCase.kt
    │                               │   ├── GetUserProfileQuery.kt
    │                               │   ├── LoginUseCase.kt
    │                               │   ├── RegisterAddressUseCase.kt
    │                               │   ├── RegisterUserUseCase.kt
    │                               │   ├── UpdateAddressUseCase.kt
    │                               │   └── UpdateProfileUseCase.kt
    │                               └── usecase
    │                                   ├── ChangePasswordCommandHandler.kt
    │                                   ├── DeleteAddressCommandHandler.kt
    │                                   ├── DeleteUserCommandHandler.kt
    │                                   ├── GetUserProfileQueryHandler.kt
    │                                   ├── LoginCommandHandler.kt
    │                                   ├── RegisterAddressCommandHandler.kt
    │                                   ├── RegisterUserCommandHandler.kt
    │                                   ├── UpdateAddressCommandHandler.kt
    │                                   └── UpdateProfileCommandHandler.kt
    ├── domain
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── domain
    │                               ├── aggregate
    │                               │   └── User.kt
    │                               ├── entity
    │                               │   └── Address.kt
    │                               ├── error
    │                               │   └── UserDomainErrorCodes.kt
    │                               ├── event
    │                               │   └── UserEvent.kt
    │                               ├── exception
    │                               │   └── UserDomainException.kt
    │                               ├── repository
    │                               │   └── UserRepository.kt
    │                               └── vo
    │                                   ├── AddressId.kt
    │                                   ├── Email.kt
    │                                   ├── Name.kt
    │                                   ├── Password.kt
    │                                   ├── PhoneNumber.kt
    │                                   ├── UserId.kt
    │                                   ├── UserStatus.kt
    │                                   ├── UserType.kt
    │                                   └── Username.kt
    ├── infrastructure
    │   ├── messaging
    │   │   ├── build.gradle.kts
    │   │   └── src
    │   │       └── main
    │   │           ├── kotlin
    │   │           │   └── com
    │   │           │       └── restaurant
    │   │           │           └── user
    │   │           │               └── infrastructure
    │   │           │                   └── messaging
    │   │           │                       └── serialization
    │   │           │                           └── OutboxMessageFactory.kt
    │   │           └── resources
    │   │               └── avro
    │   │                   ├── user-address-added-event-v1.avsc
    │   │                   ├── user-address-deleted-event-v1.avsc
    │   │                   ├── user-address-updated-event-v1.avsc
    │   │                   ├── user-created-event-v1.avsc
    │   │                   ├── user-domain-event-v1.avsc
    │   │                   ├── user-password-changed-event-v1.avsc
    │   │                   ├── user-profile-updated-event-v1.avsc
    │   │                   └── user-withdrawn-event-v1.avsc
    │   └── persistence
    │       ├── build.gradle.kts
    │       └── src
    │           └── main
    │               ├── kotlin
    │               │   └── com
    │               │       └── restaurant
    │               │           └── user
    │               │               └── infrastructure
    │               │                   └── persistence
    │               │                       ├── entity
    │               │                       │   ├── AddressEntity.kt
    │               │                       │   └── UserEntity.kt
    │               │                       ├── extensions
    │               │                       │   ├── AddressEntityExtensions.kt
    │               │                       │   └── UserEntityExtensions.kt
    │               │                       └── repository
    │               │                           ├── SpringDataJpaUserRepository.kt
    │               │                           └── UserRepositoryImpl.kt
    │               └── resources
    └── presentation
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── user
                                └── presentation
                                    └── v1
                                        ├── command
                                        │   ├── controller
                                        │   │   ├── UserAddressController.kt
                                        │   │   └── UserController.kt
                                        │   ├── dto
                                        │   │   └── request
                                        │   │       ├── ChangePasswordRequestV1.kt
                                        │   │       ├── DeleteUserRequestV1.kt
                                        │   │       ├── LoginRequestV1.kt
                                        │   │       ├── RegisterAddressRequestV1.kt
                                        │   │       ├── RegisterUserRequestV1.kt
                                        │   │       ├── UpdateAddressRequestV1.kt
                                        │   │       └── UpdateProfileRequestV1.kt
                                        │   └── extensions
                                        │       └── dto
                                        │           └── request
                                        │               └── UserCommandRequestExtensions.kt
                                        └── query
                                            ├── controller
                                            │   └── UserQueryController.kt
                                            ├── dto
                                            │   └── response
                                            │       ├── AddressResponseV1.kt
                                            │       ├── LoginResponseV1.kt
                                            │       └── UserProfileResponseV1.kt
                                            └── extensions
                                                └── dto
                                                    └── response
                                                        └── UserQueryResponseExtensions.kt
independent
└── outbox
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── outbox
            │               ├── application
            │               │   ├── OutboxPoller.kt
            │               │   └── port
            │               │       ├── OutboxMessageRepository.kt
            │               │       └── model
            │               │           ├── OutboxMessage.kt
            │               │           └── OutboxMessageStatus.kt
            │               └── infrastructure
            │                   ├── entity
            │                   │   └── OutboxEventEntity.kt
            │                   ├── error
            │                   │   └── OutboxErrorCodes.kt
            │                   ├── exception
            │                   │   └── OutboxException.kt
            │                   ├── kafka
            │                   │   ├── OutboxMessageSender.kt
            │                   │   └── config
            │                   │       └── KafkaOutboxProducerConfig.kt
            │                   └── persistence
            │                       ├── converter
            │                       │   └── StringMapConverter.kt
            │                       ├── extensions
            │                       │   └── OutboxEventEntityExtensions.kt
            │                       └── repository
            │                           ├── JpaOutboxEventRepository.kt
            │                           ├── JpaOutboxMessageRepository.kt
            │                           └── OutboxMessageRepositoryImpl.kt
            └── resources
                └── db
                    └── migration
apps
└── user-app
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── apps
            │               └── user
            │                   └── UserApplication.kt
            └── resources
gradle
└── wrapper

163 directories, 113 files
==============================================================




====================================================================
 File: apps/user-app/build.gradle.kts
 Path: apps/user-app/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":domains:common:infrastructure"))
    implementation(project(":domains:common:presentation"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:infrastructure:persistence"))
    implementation(project(":domains:user:infrastructure:messaging"))
    implementation(project(":domains:user:presentation"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework.boot:spring-boot-starter-web:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-actuator:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.2.3")
    implementation("org.springframework.kafka:spring-kafka:3.1.1")
    implementation("org.flywaydb:flyway-core:9.22.3")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.16.1")
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:1.9.22")

    runtimeOnly("org.postgresql:postgresql:42.7.2")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.3")
    testImplementation("org.springframework.kafka:spring-kafka-test:3.1.1")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.testcontainers:testcontainers:1.19.6")
    testImplementation("org.testcontainers:junit-jupiter:1.19.6")
    testImplementation("org.testcontainers:postgresql:1.19.6")
    testImplementation("org.testcontainers:kafka:1.19.6")
}

tasks.bootJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

====================================================================n


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
/**
 * UserApplication entry point for the user service.
 *
 * Configures component scanning and enables scheduling for Outbox Poller.
 *
 * @author junoko
 */
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.scheduling.annotation.EnableScheduling // For Outbox Poller @Scheduled

@SpringBootApplication
// Scan components in config, outbox.infra, user.presentation, user.application, user.infra
@ComponentScan(
    basePackages = [
        "com.restaurant.common.presentation",
        "com.restaurant.user.presentation",
        "com.restaurant.user.application",
        "com.restaurant.user.infrastructure",
        "com.restaurant.outbox.application",
        "com.restaurant.outbox.infrastructure"
    ],
)
// Explicitly enable JPA repositories if not found by default scan
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.user.infrastructure.persistence.repository",
        "com.restaurant.outbox.infrastructure.persistence"
    ],
)
@EnableScheduling // Enable @Scheduled tasks (for Outbox Poller)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

====================================================================n


====================================================================
 File: build.gradle.kts
 Path: build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
/**
 * build.gradle.kts for the root project.
 *
 * Configures plugins, dependency management, and global build settings.
 *
 * @author junoko
 */

plugins {
    // Only versions are declared here for subprojects
    id("org.jetbrains.kotlin.jvm") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.spring") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.jpa") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.allopen") version "2.1.20" apply false
    id("org.springframework.boot") version "3.2.3" apply false
    id("io.spring.dependency-management") version "1.1.4" apply false
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" apply false
    id("org.jlleitschuh.gradle.ktlint") version "11.6.1" apply false
}
====================================================================n


====================================================================
 File: domains/common/application/build.gradle.kts
 Path: domains/common/application/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    `java-library`
    kotlin("jvm")
    kotlin("plugin.spring")
    id("io.spring.dependency-management")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.2.3")
    }
}

dependencies {
    api(project(":domains:common:domain"))
    
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.2.0")
    implementation("io.github.resilience4j:resilience4j-kotlin:2.2.0")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter")
    testImplementation("org.assertj:assertj-core")
}

====================================================================n


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.application.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom application exceptions.
 * Represents errors occurring in the application layer (e.g., use case execution failures).
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class ApplicationException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this application exception.
     */
    abstract val errorCode: ErrorCode
}

====================================================================n


====================================================================
 File: domains/common/domain/build.gradle.kts
 Path: domains/common/domain/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") // Kotlin 플러그인 추가
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}
dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("jakarta.validation:jakarta.validation-api:3.1.1")
    implementation("com.fasterxml.uuid:java-uuid-generator:4.3.0")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter")
    testImplementation("org.assertj:assertj-core")
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

/**
 * Base class for all Aggregate Roots.
 * Provides methods to manage domain events.
 * Rule 17, 18
 */
abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    /**
     * Returns the list of recorded domain events.
     */
    open fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    /**
     * Clears the list of recorded domain events.
     */
    open fun clearDomainEvents() {
        domainEvents.clear()
    }

    /**
     * Adds a domain event to the list of recorded events.
     * This method is internal to ensure it's only called within the Aggregate implementation.
     */
    internal fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.domain.error

/**
 * Common system-level error codes.
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    INTERNAL_SERVER_ERROR("COMMON-001", "Internal server error"),
    INVALID_REQUEST("COMMON-002", "Invalid request"),
    RESOURCE_NOT_FOUND("COMMON-003", "Resource not found"),
    UNAUTHORIZED("COMMON-004", "Unauthorized"),
    FORBIDDEN("COMMON-005", "Forbidden"),
    VALIDATION_ERROR("COMMON-006", "Validation error"),
    CONFLICT("COMMON-007", "Conflict"),
    TOO_MANY_REQUESTS("COMMON-008", "Too many requests"),
    SERVICE_UNAVAILABLE("COMMON-009", "Service unavailable"),
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.domain.error

/**
 * Base interface for all error codes in the system.
 * Error codes should follow the format: {DOMAIN}-{LAYER}-{CODE}
 */
interface ErrorCode {
    /**
     * The unique code for this error.
     * Format: {DOMAIN}-{LAYER}-{CODE}
     * Example: USER-DOMAIN-001, USER-APP-002
     */
    val code: String

    /**
     * A human-readable message describing this error.
     */
    val message: String
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.domain.event

import java.time.Instant
import java.util.UUID

/**
 * Base interface for domain events. (Rule 32)
 */
interface DomainEvent {
    val eventId: UUID
    val occurredAt: Instant
    val aggregateId: String
    val aggregateType: String
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.domain.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom domain exceptions.
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
open class DomainException(
    val errorCode: ErrorCode,
    override val message: String = errorCode.message,
    cause: Throwable? = null,
) : RuntimeException(message, cause)

====================================================================n


====================================================================
 File: domains/common/infrastructure/build.gradle.kts
 Path: domains/common/infrastructure/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("plugin.allopen")
    id("com.github.davidmc24.gradle.plugin.avro")
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.2.3")
    implementation("org.springframework.kafka:spring-kafka:3.1.1")
    implementation("org.apache.avro:avro:1.11.3")
    implementation("io.confluent:kafka-avro-serializer:7.6.0")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.16.1")
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:1.9.22")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.3")
    testImplementation("org.springframework.kafka:spring-kafka-test:3.1.1")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.testcontainers:testcontainers:1.19.6")
    testImplementation("org.testcontainers:junit-jupiter:1.19.6")
    testImplementation("org.testcontainers:kafka:1.19.6")
}

====================================================================n


====================================================================
 File: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/persistence/entity/BaseEntity.kt
 Path: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/persistence/entity/BaseEntity.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.infrastructure.persistence.entity

import jakarta.persistence.Column
import jakarta.persistence.MappedSuperclass
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import java.time.Instant

/**
 * Base entity class for JPA entities providing common fields like
 * creation and update timestamps.
 */
@MappedSuperclass
abstract class BaseEntity {
    @Column(name = "created_at", nullable = false, updatable = false)
    var createdAt: Instant = Instant.now()
        protected set

    @Column(name = "updated_at", nullable = false)
    var updatedAt: Instant = Instant.now()
        protected set

    @PrePersist
    protected fun onCreate() {
        createdAt = Instant.now()
        updatedAt = Instant.now()
    }

    @PreUpdate
    protected fun onUpdate() {
        updatedAt = Instant.now()
    }
}

====================================================================n


====================================================================
 File: domains/common/presentation/build.gradle.kts
 Path: domains/common/presentation/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))

    implementation("org.springframework.boot:spring-boot-starter-web:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-security:3.2.3") // Spring Security 추가
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.2.3") // JPA 추가
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.16.1")
    implementation("io.github.microutils:kotlin-logging-jvm:3.0.5") // Kotlin Logging 추가

    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:1.9.22")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.3")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.assertj:assertj-core:3.25.3")
}

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.presentation

import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.common.domain.exception.DomainException
import jakarta.persistence.OptimisticLockException
import mu.KotlinLogging
import org.slf4j.MDC
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler
import java.time.OffsetDateTime
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestControllerAdvice
@Order(Ordered.HIGHEST_PRECEDENCE)
class GlobalExceptionHandler : ResponseEntityExceptionHandler() {
    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValid(ex: MethodArgumentNotValidException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST)
        problemDetail.title = "Validation Failed"
        problemDetail.detail = ex.bindingResult.fieldErrors.joinToString(", ") { it.defaultMessage ?: it.field }
        problemDetail.setProperty(
            "invalid-params",
            ex.bindingResult.fieldErrors.map { fieldError ->
                mapOf(
                    "field" to fieldError.field,
                    "rejectedValue" to fieldError.rejectedValue,
                    "message" to (fieldError.defaultMessage ?: ""),
                )
            },
        )
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException::class)
    fun handleTypeMismatch(ex: MethodArgumentTypeMismatchException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST)
        problemDetail.title = "Type Mismatch"
        problemDetail.detail = ex.message ?: ""
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(ex: DomainException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(mapDomainExceptionToStatus(ex))
        problemDetail.title = ex.errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", ex.errorCode.code)
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(ex: ApplicationException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(mapApplicationExceptionToStatus(ex))
        problemDetail.title = ex.errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", ex.errorCode.code)
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(OptimisticLockException::class)
    fun handleOptimisticLockException(ex: OptimisticLockException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(HttpStatus.CONFLICT)
        problemDetail.title = "Optimistic Lock Error"
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", "COMMON-SYSTEM-OPTIMISTIC-LOCK-ERROR")
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception): ProblemDetail {
        log.error(ex) { "Unhandled exception: ${ex.message}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR)
        problemDetail.title = "Internal Server Error"
        problemDetail.detail = ex.message ?: ""
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    private fun setCommonProblemProperties(problemDetail: ProblemDetail) {
        problemDetail.setProperty("timestamp", OffsetDateTime.now().toString())
        problemDetail.setProperty("correlationId", getCorrelationId())
    }

    private fun getCorrelationId(): String =
        try {
            val mdc = org.slf4j.MDC.getCopyOfContextMap()
            mdc?.get("correlationId") ?: UUID.randomUUID().toString()
        } catch (e: Exception) {
            UUID.randomUUID().toString()
        }

    private fun mapDomainExceptionToStatus(ex: DomainException): HttpStatus =
        when (ex.errorCode.code) {
            "USER-DOMAIN-NOT-FOUND" -> HttpStatus.NOT_FOUND
            "USER-DOMAIN-VALIDATION" -> HttpStatus.BAD_REQUEST
            else -> HttpStatus.BAD_REQUEST
        }

    private fun mapApplicationExceptionToStatus(ex: ApplicationException): HttpStatus =
        when (ex.errorCode.code) {
            "USER-APPLICATION-BAD-REQUEST" -> HttpStatus.BAD_REQUEST
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }
}

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/SecurityConfig.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/SecurityConfig.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.presentation.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpMethod
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.config.annotation.web.invoke
import org.springframework.security.web.util.matcher.AntPathRequestMatcher


@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests { authz ->
                authz.requestMatchers(HttpMethod.POST, "/api/v1/users/register").permitAll()
                authz.requestMatchers(HttpMethod.POST, "/api/v1/users/login").permitAll()
                authz.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                authz.requestMatchers("/actuator/**").permitAll()
                authz.anyRequest().authenticated()
            }
        return http.build()
    }
}

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.presentation.dto.response

import org.springframework.hateoas.RepresentationModel
import java.util.UUID

/**
 * Standard response for command results, including status, message, and correlation ID.
 */
data class CommandResultResponse(
    val status: String = "SUCCESS",
    val message: String,
    val correlationId: String = UUID.randomUUID().toString(),
) : RepresentationModel<CommandResultResponse>()

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/filter/CorrelationIdFilter.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/filter/CorrelationIdFilter.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.common.presentation.filter

import jakarta.servlet.Filter
import jakarta.servlet.FilterChain
import jakarta.servlet.ServletRequest
import jakarta.servlet.ServletResponse
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.slf4j.MDC
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import org.springframework.stereotype.Component
import java.util.UUID

/**
 * A servlet filter that extracts or generates correlation IDs for requests.
 * The correlation ID is used for request tracing across services.
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
class CorrelationIdFilter : Filter {
    companion object {
        const val CORRELATION_ID_HEADER = "X-Correlation-Id"
        const val CORRELATION_ID_MDC_KEY = "correlationId"
    }

    override fun doFilter(
        request: ServletRequest,
        response: ServletResponse,
        chain: FilterChain,
    ) {
        val httpRequest = request as HttpServletRequest
        val httpResponse = response as HttpServletResponse

        try {
            val correlationId = httpRequest.getHeader(CORRELATION_ID_HEADER) ?: UUID.randomUUID().toString()

            MDC.put(CORRELATION_ID_MDC_KEY, correlationId)

            httpResponse.setHeader(CORRELATION_ID_HEADER, correlationId)

            chain.doFilter(request, response)
        } finally {
            MDC.remove(CORRELATION_ID_MDC_KEY)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/build.gradle.kts
 Path: domains/user/application/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    `java-library`
    kotlin("jvm")
    kotlin("plugin.spring")
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.2.3")
    }
}

dependencies {
    implementation("io.github.microutils:kotlin-logging-jvm:4.0.0-beta-2")
    implementation("org.springframework.security:spring-security-crypto:6.4.5")
    api(project(":domains:common:application"))
    api(project(":domains:user:domain"))
    implementation(project(":domains:common:domain"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework:spring-tx") // 트랜잭션 의존성 추가
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.2.0")
    implementation("io.github.resilience4j:resilience4j-kotlin:2.2.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter")
    testImplementation("org.assertj:assertj-core")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
        jvmTarget = "21"
    }
}

// Remove explicit task dependencies to avoid circular dependency
tasks.named("compileKotlin") {
    mustRunAfter(tasks.named("processResources"))
}

tasks.named("compileTestKotlin") {
    mustRunAfter(tasks.named("processTestResources"))
}

// Ensure test tasks use JUnit Platform
tasks.withType<Test> {
    useJUnitPlatform()
}

// Make jar task enabled
tasks.withType<Jar> {
    enabled = true
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

import jakarta.validation.constraints.NotBlank

data class DeleteUserCommand(
    val userId: String,
    val reason: String? = null,
    @field:NotBlank(message = "비밀번호 확인은 필수입니다.")
    val password: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

data class LoginCommand(
    val email: String,
    val password: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

data class RegisterAddressCommand(
    val userId: String,
    val name: String,
    val street: String,
    val detail: String,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size
import jakarta.validation.constraints.Email as JakartaEmail

/**
 * Command DTO for registering a new user.
 * Rule App-Struct (dto/command)
 */
data class RegisterUserCommand(
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:JakartaEmail(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val name: String,
    val street: String,
    val detail: String,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
    val phoneNumber: String?,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.query

data class GetUserProfileByIdQuery(
    val userId: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.query

/**
 * 로그인 결과 DTO (Application Layer)
 */
data class LoginResult(
    val userId: String,
    val username: String,
    val accessToken: String,
    val refreshToken: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.dto.query

import java.time.Instant

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val username: String,
    val phoneNumber: String?,
    val userType: String,
    val addresses: List<AddressDto>,
    val createdAt: Instant,
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) {
    data class AddressDto(
        val id: String,
        val street: String?, // Nullable로 변경
        val detail: String?, // Nullable로 변경
        val zipCode: String?, // Nullable로 변경
        val isDefault: Boolean,
    )
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    BAD_REQUEST("USER-APPLICATION-001", "Bad request received by application."),
    INVALID_INPUT("USER-APPLICATION-002", "Invalid input provided to application."),
    AUTHENTICATION_FAILED("USER-APPLICATION-003", "Authentication failed."),
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-004", "External service communication error."),
    UNEXPECTED_ERROR("USER-APPLICATION-500", "An unexpected error occurred in the application."),
    USER_NOT_FOUND_BY_EMAIL("USER-APPLICATION-005", "User not found by email"),
    INVALID_CREDENTIALS("USER-APPLICATION-006", "Invalid username or password"),
    USER_INACTIVE("USER-APPLICATION-007", "User account is inactive"),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.exception

import com.restaurant.common.domain.error.ErrorCode
import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.user.application.error.UserApplicationErrorCode

/**
 * User Application 레이어 관련 예외 정의 (Rule 68)
 */
sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    message: String? = null,
    cause: Throwable? = null,
) : ApplicationException(message ?: errorCode.message, cause) {
    /**
     * 인증 실패 관련 예외
     */
    class AuthenticationFailed(
        message: String? = UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.AUTHENTICATION_FAILED, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - e.g., Invalid UUID format
     */
    class BadRequest(
        message: String? = UserApplicationErrorCode.BAD_REQUEST.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.BAD_REQUEST, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - more specific than BadRequest
     */
    class InvalidInput(
        message: String? = UserApplicationErrorCode.INVALID_INPUT.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.INVALID_INPUT, message, cause)

    /**
     * 외부 서비스 연동 오류
     */
    class ExternalServiceError(
        message: String? = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR, message, cause)

    /**
     * 예상치 못한 시스템 오류 (Application 레벨)
     */
    class UnexpectedError(
        message: String? = UserApplicationErrorCode.UNEXPECTED_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.UNEXPECTED_ERROR, message, cause)

    /**
     * Login specific exceptions
     */
    class UserNotFound(
        errorCode: ErrorCode,
        identifier: String,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, "User not found with identifier: $identifier", cause)

    class InvalidCredentials(
        errorCode: ErrorCode,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, cause = cause)

    class UserInactive(
        errorCode: ErrorCode,
        userId: String,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, "User is inactive: $userId", cause)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/ChangePasswordUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/ChangePasswordUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.ChangePasswordCommand

interface ChangePasswordUseCase {
    fun changePassword(command: ChangePasswordCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteAddressUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.DeleteAddressCommand

/**
 * 주소 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteAddressUseCase {
    fun deleteAddress(command: DeleteAddressCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteUserUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.DeleteUserCommand

/**
 * 사용자 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteUserUseCase {
    fun deleteUser(command: DeleteUserCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/GetUserProfileQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/GetUserProfileQuery.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto

/**
 * 사용자 프로필 조회 Query UseCase 인터페이스 (Rule App-Struct)
 */
interface GetUserProfileQuery {
    fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/LoginUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/LoginUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult

/**
 * 로그인 유스케이스 인터페이스 (Rule App-Struct)
 * 로그인 결과를 반환하도록 수정 (LoginResult 사용)
 */
interface LoginUseCase {
    fun login(command: LoginCommand): LoginResult
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterAddressUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.domain.vo.AddressId

/**
 * 주소 등록 유스케이스 인터페이스 (Rule App-Struct)
 */
interface RegisterAddressUseCase {
    fun registerAddress(command: RegisterAddressCommand): AddressId
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterUserUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.domain.vo.UserId

/**
 * 사용자 등록 유스케이스 인터페이스 (Rule App-Struct)
 * 사용자 ID(UserId)를 반환하도록 수정
 */
interface RegisterUserUseCase {
    fun register(command: RegisterUserCommand): UserId
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateAddressUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.UpdateAddressCommand

/**
 * 주소 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateAddressUseCase {
    fun updateAddress(command: UpdateAddressCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateProfileUseCase.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.port

import com.restaurant.user.application.dto.command.UpdateProfileCommand

/**
 * 프로필 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateProfileUseCase {
    fun updateProfile(command: UpdateProfileCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.ChangePasswordUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : ChangePasswordUseCase {
    @Transactional
    override fun changePassword(command: ChangePasswordCommand) {
        try {
            val userId = UserId.ofString(command.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(command.userId)

            val newPassword = Password.of(passwordEncoder.encode(command.newPassword))
            val updatedUser = user.changePassword(newPassword)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid password data format: ${iae.message}", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to change password due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.DeleteAddressUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) : DeleteAddressUseCase {
    @Transactional
    override fun deleteAddress(command: DeleteAddressCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.deleteAddress(addressIdVo)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to delete address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.DeleteUserUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
) : DeleteUserUseCase {
    @Transactional
    override fun deleteUser(command: DeleteUserCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.withdraw()

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to delete user due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.GetUserProfileQuery
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) : GetUserProfileQuery {
    @Transactional(readOnly = true)
    override fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto {
        try {
            val userId = UserId.ofString(query.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(userId.toString())

            return UserProfileDto(
                id = user.id.value.toString(),
                username = user.username.value,
                email = user.email.value,
                name = user.name.value,
                phoneNumber = user.phoneNumber?.value,
                addresses =
                user.addresses.map { address ->
                    UserProfileDto.AddressDto(
                        id = address.addressId.value.toString(),
                        street = address.streetAddress, // ?: "" 제거
                        detail = address.detailAddress, // ?: "" 제거
                        zipCode = address.zipCode, // ?: "" 제거
                        isDefault = address.isDefault,
                    )
                },
                userType = user.userType.name,
                status = user.status.name,
                createdAt = user.createdAt,
                updatedAt = user.updatedAt,
                version = user.version,
            )
        } catch (de: UserDomainException.User.NotFound) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to fetch profile due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.LoginUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email // Username 대신 Email import
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : LoginUseCase {
    @Transactional(readOnly = true)
    override fun login(command: LoginCommand): LoginResult {
        try {
            // username 대신 email 사용
            val emailVo = Email.of(command.email)
            // findByUsername 대신 findByEmail 사용 (UserRepository에 해당 메소드 필요)
            val user = userRepository.findByEmail(emailVo)
                ?: throw UserDomainException.User.InvalidCredentials(command.email)

            if (!passwordEncoder.matches(command.password, user.password.value)) {
                throw UserDomainException.User.InvalidCredentials(command.email)
            }

            // 실제 토큰 생성 로직은 여기에 구현되어야 합니다.
            // 임시로 빈 문자열을 사용합니다.
            val accessToken = "dummy-access-token"
            val refreshToken = "dummy-refresh-token"

            return LoginResult(
                userId = user.id.value.toString(),
                username = user.username.value,
                accessToken = accessToken,
                refreshToken = refreshToken,
            )
        } catch (de: UserDomainException.User.InvalidCredentials) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid email or password format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Login failed due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.RegisterAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) : RegisterAddressUseCase {
    @Transactional
    override fun registerAddress(command: RegisterAddressCommand): AddressId {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val addressId = AddressId.generate()
            val address =
                Address.create(
                    addressId = addressId,
                    name = command.name,
                    streetAddress = command.street,
                    detailAddress = command.detail,
                    city = command.city,
                    state = command.state,
                    country = command.country,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )
            val updatedUser = user.addAddress(address)
            userRepository.save(updatedUser)

            // 저장된 주소의 ID를 반환하도록 수정
            return updatedUser.addresses.first { it.addressId == address.addressId }.addressId
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to register address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.application.port.RegisterUserUseCase
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : RegisterUserUseCase {
    @Transactional
    override fun register(command: RegisterUserCommand): UserId {
        val username = Username.of(command.username)
        val email = Email.of(command.email)
        val name = Name.of(command.name)
        val password = Password.of(passwordEncoder.encode(command.password))
        val user =
            User.create(
                id = UserId.generate(),
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = null, // phoneNumber는 선택 사항이므로 null로 설정
            )
        userRepository.save(user)
        return user.id
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.UpdateAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) : UpdateAddressUseCase {
    @Transactional
    override fun updateAddress(command: UpdateAddressCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val addressToUpdate =
                Address.create( // create로 새 주소 객체를 만들지만, ID는 기존 것을 사용합니다.
                    addressId = addressIdVo,
                    name = command.name,
                    streetAddress = command.street,
                    detailAddress = command.detail,
                    city = command.city,
                    state = command.state,
                    country = command.country,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            val updatedUser = user.updateAddress(addressToUpdate)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to update address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.UpdateProfileUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) : UpdateProfileUseCase {
    @Transactional
    override fun updateProfile(command: UpdateProfileCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val name = Name.of(command.name)
            val phoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }

            val updatedUser = user.updateProfile(name, phoneNumber)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid input format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to update profile due to an unexpected error.", cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/build.gradle.kts
 Path: domains/user/domain/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("java-library")
}

dependencies {
    api(project(":domains:common:domain"))
    
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("jakarta.validation:jakarta.validation-api:3.1.1")
    implementation("com.fasterxml.uuid:java-uuid-generator:4.3.0")
    
    testImplementation("org.junit.jupiter:junit-jupiter")
    testImplementation("org.assertj:assertj-core")
    testImplementation("io.mockk:mockk:1.13.9")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

tasks {
    withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        kotlinOptions {
            freeCompilerArgs = listOf("-Xjsr305=strict")
            jvmTarget = "17"
        }
    }

    withType<Test> {
        useJUnitPlatform()
    }

}

sourceSets {
    main {
        kotlin.srcDirs("src/main/kotlin")
    }
    test {
        kotlin.srcDirs("src/test/kotlin")
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.UserStatus
import com.restaurant.user.domain.vo.UserType
import com.restaurant.user.domain.vo.Username
import java.time.Instant

data class User private constructor(
    val id: UserId,
    val username: Username,
    val password: Password,
    val email: Email,
    val name: Name,
    val phoneNumber: PhoneNumber?,
    val userType: UserType,
    val status: UserStatus,
    val addresses: List<Address> = listOf(),
    val defaultAddressId: AddressId? = null,
    val version: Long,
    val createdAt: Instant,
    val updatedAt: Instant,
    private val eventsInternal: MutableList<DomainEvent> = mutableListOf(),
) : AggregateRoot() {
    internal fun addDomainEventInternal(event: DomainEvent) {
        this.eventsInternal.add(event)
    }

    override fun getDomainEvents(): List<DomainEvent> = eventsInternal.toList()

    override fun clearDomainEvents() = eventsInternal.clear()

    fun changePassword(newPassword: Password): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser =
            copy(
                password = newPassword,
                version = this.version + 1,
                updatedAt = Instant.now(),
                eventsInternal = this.eventsInternal.toMutableList(),
            )
        updatedUser.addDomainEventInternal(
            UserEvent.PasswordChanged(
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun updateProfile(
        newName: Name,
        newPhoneNumber: PhoneNumber?,
    ): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser =
            copy(
                name = newName,
                phoneNumber = newPhoneNumber,
                version = this.version + 1,
                updatedAt = Instant.now(),
                eventsInternal = this.eventsInternal.toMutableList(),
            )
        updatedUser.addDomainEventInternal(
            UserEvent.ProfileUpdated(
                name = newName.value,
                phoneNumber = newPhoneNumber?.value,
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun addAddress(addressData: Address): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (addresses.size >= MAX_ADDRESSES) throw UserDomainException.Address.LimitExceeded(MAX_ADDRESSES)
        if (addresses.any { it.addressId == addressData.addressId }) {
            throw UserDomainException.Address.DuplicateAddressId(addressData.addressId.value.toString())
        }
        val newAddresses = addresses.toMutableList()
        if (addressData.isDefault) {
            newAddresses.forEachIndexed { idx, addr -> newAddresses[idx] = addr.copy(isDefault = false) }
        }
        newAddresses.add(addressData)
        val currentDefault = newAddresses.find { it.isDefault }
        val finalDefaultAddressId = currentDefault?.addressId ?: newAddresses.firstOrNull()?.addressId
        val finalAddresses = newAddresses.map { addr -> addr.copy(isDefault = addr.addressId == finalDefaultAddressId) }
        val updatedUser = copy(
            addresses = finalAddresses,
            defaultAddressId = finalDefaultAddressId,
            version = this.version + 1,
            updatedAt = Instant.now(),
            eventsInternal = this.eventsInternal.toMutableList(),
        )

        updatedUser.addDomainEventInternal(
            UserEvent.AddressRegistered(
                address = addressData.toData(),
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun updateAddress(updatedAddressData: Address): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        val addressIndex = addresses.indexOfFirst { it.addressId == updatedAddressData.addressId }
        if (addressIndex == -1) throw UserDomainException.Address.NotFound(updatedAddressData.addressId.value.toString())
        val newAddresses = addresses.toMutableList()
        if (updatedAddressData.isDefault) {
            newAddresses.forEachIndexed { idx, addr -> if (addr.addressId != updatedAddressData.addressId) newAddresses[idx] = addr.copy(isDefault = false) }
        }
        newAddresses[addressIndex] = updatedAddressData
        val currentDefault = newAddresses.find { it.isDefault }
        val finalDefaultAddressId = currentDefault?.addressId ?: if (newAddresses.isNotEmpty()) newAddresses.first().addressId else null
        val finalAddresses = newAddresses.map { addr -> addr.copy(isDefault = addr.addressId == finalDefaultAddressId) }
        val updatedUser = copy(
            addresses = finalAddresses,
            defaultAddressId = finalDefaultAddressId,
            version = this.version + 1,
            updatedAt = Instant.now(),
            eventsInternal = this.eventsInternal.toMutableList(),
        )

        updatedUser.addDomainEventInternal(
            UserEvent.AddressUpdated(
                address = updatedAddressData.toData(),
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun deleteAddress(addressId: AddressId): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        val addressToRemove =
            addresses.find { it.addressId == addressId }
                ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        if (addresses.size == 1) throw UserDomainException.Address.CannotDeleteLast()
        if (addressToRemove.isDefault) throw UserDomainException.Address.CannotDeleteDefault()

        val remainingAddresses = addresses.filterNot { it.addressId == addressId }

        val updatedUser =
            copy(
                addresses = remainingAddresses,
                version = this.version + 1,
                updatedAt = Instant.now(),
                eventsInternal = this.eventsInternal.toMutableList(),
            )
        updatedUser.addDomainEventInternal(
            UserEvent.AddressDeleted(
                addressId = addressId.value.toString(),
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun withdraw(): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (userType == UserType.ADMIN) throw UserDomainException.User.AdminCannotBeWithdrawn()

        val updatedUser =
            copy(
                status = UserStatus.WITHDRAWN,
                version = this.version + 1,
                updatedAt = Instant.now(),
                eventsInternal = this.eventsInternal.toMutableList(),
            )
        updatedUser.addDomainEventInternal(
            UserEvent.Withdrawn(
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun isActive(): Boolean = this.status == UserStatus.ACTIVE

    companion object {
        const val MAX_ADDRESSES = 5

        fun create(
            id: UserId,
            username: Username,
            password: Password,
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType = UserType.CUSTOMER,
            initialAddresses: List<Address> = emptyList(),
        ): User {
            val now = Instant.now()
            if (initialAddresses.count { it.isDefault } > 1) {
                throw UserDomainException.Address.MultipleDefaultsOnInit()
            }
            val defaultAddressId =
                initialAddresses.find { it.isDefault }?.addressId
                    ?: initialAddresses.firstOrNull()?.addressId

            val finalAddresses =
                initialAddresses.map { addr ->
                    if (addr.addressId == defaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
                }

            val user =
                User(
                    id = id,
                    username = username,
                    password = password,
                    email = email,
                    name = name,
                    phoneNumber = phoneNumber,
                    userType = userType,
                    status = UserStatus.ACTIVE,
                    addresses = finalAddresses,
                    defaultAddressId = defaultAddressId,
                    createdAt = now,
                    updatedAt = now,
                    version = 0L,
                )
            user.addDomainEventInternal(
                UserEvent.Created(
                    username = username.value,
                    email = email.value,
                    name = name.value,
                    phoneNumber = phoneNumber?.value,
                    userType = userType.toString(),
                    userId = id,
                    occurredAt = now,
                ),
            )
            return user
        }

        fun reconstitute(
            id: UserId,
            username: Username,
            password: Password,
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
            addresses: List<Address>,
            status: UserStatus,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): User {
            val defaultAddrId = addresses.find { it.isDefault }?.addressId
            return User(
                id = id,
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = status,
                addresses = addresses,
                defaultAddressId = defaultAddrId,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
                eventsInternal = mutableListOf() // 재구성 시에는 이벤트 목록을 비웁니다.
            )
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.entity

import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import java.time.Instant

/**
 * Address Domain Entity (Rule 11)
 * User Aggregate에 속하지만 자체 식별자를 가짐.
 */
data class Address private constructor(
    val addressId: AddressId,
    val name: String,
    val streetAddress: String,
    val detailAddress: String?,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
    val version: Long = 0L,
) {
    init {
        if (streetAddress.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Street address cannot be blank.")
        }
        validateZipCode(zipCode)
        if (name.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Name cannot be blank.")
        }
        if (city.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("City cannot be blank.")
        }
        if (state.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("State cannot be blank.")
        }
        if (country.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Country cannot be blank.")
        }
    }

    fun updateDetails(
        name: String,
        streetAddress: String,
        detailAddress: String?,
        city: String,
        state: String,
        country: String,
        zipCode: String,
        isDefault: Boolean,
    ): Address {
        validateZipCode(zipCode)
        if (this.name == name &&
            this.streetAddress == streetAddress &&
            this.detailAddress == detailAddress &&
            this.city == city &&
            this.state == state &&
            this.country == country &&
            this.zipCode == zipCode &&
            this.isDefault == isDefault
        ) {
            return this
        }
        return this.copy(
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun toData(): UserEvent.AddressData =
        UserEvent.AddressData(
            id = addressId.value.toString(),
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
        )

    companion object {
        private fun validateZipCode(zipCode: String) {
            if (zipCode.isBlank() || zipCode.length != 5 || !zipCode.all { it.isDigit() }) {
                throw UserDomainException.Validation.InvalidAddressFormat("Zip code must be 5 digits.")
            }
        }

        fun create(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
        ): Address {
            validateZipCode(zipCode)
            val now = Instant.now()
            return Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = now,
                updatedAt = now,
                version = 0L,
            )
        }

        fun reconstitute(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): Address =
            Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
    }

    fun markAsDefault(): Address {
        if (this.isDefault) return this
        return this.copy(
            isDefault = true,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun markAsNonDefault(): Address {
        if (!this.isDefault) return this
        return this.copy(
            isDefault = false,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum (Rule 67)
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    DUPLICATE_USERNAME("USER-DOMAIN-003", "이미 사용중인 사용자 이름입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-004", "비밀번호가 일치하지 않습니다."),
    USER_ALREADY_WITHDRAWN("USER-DOMAIN-005", "이미 탈퇴한 사용자입니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-006", "주소를 찾을 수 없습니다."),
    DUPLICATE_ADDRESS_ID("USER-DOMAIN-007", "이미 존재하는 주소 ID 입니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-008", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-009", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-010", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_EMAIL_FORMAT("USER-DOMAIN-101", "잘못된 이메일 형식입니다."),
    INVALID_USERNAME_FORMAT("USER-DOMAIN-102", "사용자 이름 형식이 올바르지 않습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-103", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_NAME_FORMAT("USER-DOMAIN-104", "잘못된 이름 형식입니다."),
    INVALID_ADDRESS_FORMAT("USER-DOMAIN-105", "잘못된 주소 형식입니다."),
    INVALID_PHONE_NUMBER_FORMAT("USER-DOMAIN-106", "잘못된 전화번호 형식입니다."),
    INVALID_USER_ID_FORMAT("USER-DOMAIN-107", "잘못된 사용자 ID 형식입니다."),
    INVALID_ADDRESS_ID_FORMAT("USER-DOMAIN-108", "잘못된 주소 ID 형식입니다."),
    ADDRESS_ID_MISMATCH("USER-DOMAIN-201", "주소 ID가 일치하지 않습니다."),
    INVALID_CREDENTIALS("USER-DOMAIN-056", "Invalid credentials"),
    ADMIN_CANNOT_BE_WITHDRAWN("USER-DOMAIN-057", "Admin user cannot be withdrawn"),
    MULTIPLE_DEFAULT_ADDRESSES("USER-DOMAIN-109", "Cannot have multiple default addresses"),
    DEFAULT_ADDRESS_NOT_FOUND("USER-DOMAIN-108", "Default address not found"),
    PERSISTENCE_ERROR("USER-DOMAIN-901", "Persistence error occurred"),
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.vo.UserId
import java.time.Instant
import java.util.UUID

/**
 * Sealed class grouping all domain events related to the User aggregate. (Rule 34)
 */
sealed class UserEvent(
    override val eventId: UUID = UUID.randomUUID(),
    override val occurredAt: Instant,
    open val userId: UserId,
) : DomainEvent {
    override val aggregateId: String
        get() = userId.value.toString()
    override val aggregateType: String
        get() = "User"

    /**
     * User Created Event
     */
    data class Created(
        val username: String,
        val email: String,
        val name: String,
        val phoneNumber: String?,
        val userType: String,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Password Changed Event
     */
    data class PasswordChanged(
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Profile Updated Event
     */
    data class ProfileUpdated(
        val name: String,
        val phoneNumber: String?,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * Represents address data within user events.
     */
    data class AddressData(
        val id: String,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
    )

    /**
     * User Address Added Event
     */
    data class AddressRegistered(
        val address: AddressData,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Address Updated Event
     */
    data class AddressUpdated(
        val address: AddressData,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Address Deleted Event (Renamed from Removed)
     */
    data class AddressDeleted(
        val addressId: String,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Withdrawn Event (Renamed from UserWithdrawn)
     */
    data class Withdrawn(
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.exception

import com.restaurant.common.domain.exception.DomainException
import com.restaurant.user.domain.error.UserDomainErrorCodes

/**
 * Sealed class representing all possible domain exceptions for the User aggregate. (Rule 68)
 */
sealed class UserDomainException(
    errorCode: UserDomainErrorCodes,
    message: String? = errorCode.message, // String? 타입으로 변경하고, null일 경우 errorCode.message 사용
    cause: Throwable? = null,
) : DomainException(errorCode, message ?: errorCode.message, cause) { // message가 null이면 errorCode.message 사용
    /**
     * Validation-related exceptions
     */
    sealed class Validation(
        errorCode: UserDomainErrorCodes,
        message: String = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class InvalidEmailFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_EMAIL_FORMAT,
                message,
            )

        class InvalidUsernameFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USERNAME_FORMAT,
                message,
            )

        class InvalidUserIdFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USER_ID_FORMAT,
                message,
            )

        class InvalidPasswordFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
                message,
            )

        class InvalidNameFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_NAME_FORMAT,
                message,
            )

        class InvalidPhoneNumberFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PHONE_NUMBER_FORMAT,
                message,
            )

        class InvalidAddressFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                message,
            )

        class InvalidAddressIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_ID_FORMAT,
                "Invalid address ID format: $value",
            )
    }

    /**
     * User-related exceptions
     */
    sealed class User(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            userId: String,
        ) : User(
                UserDomainErrorCodes.USER_NOT_FOUND,
                "User not found with ID: $userId",
            )

        class DuplicateUsername(
            username: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_USERNAME,
                "Username already exists: $username",
            )

        class DuplicateEmail(
            email: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_EMAIL,
                "Email already exists: $email",
            )

        class PasswordMismatch : User(UserDomainErrorCodes.PASSWORD_MISMATCH)

        class AlreadyWithdrawn : User(UserDomainErrorCodes.USER_ALREADY_WITHDRAWN)

        class InvalidCredentials(
            username: String,
        ) : User(
                UserDomainErrorCodes.INVALID_CREDENTIALS,
                "Invalid credentials for username: $username",
            )

        class AdminCannotBeWithdrawn :
            User(
                UserDomainErrorCodes.ADMIN_CANNOT_BE_WITHDRAWN,
                "Admin user cannot be withdrawn.",
            )
    }

    /**
     * Address-related exceptions
     */
    sealed class Address(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_NOT_FOUND,
                "Address not found with ID: $addressId",
            )

        class DefaultAddressNotFound(
            message: String = "Default address ID does not exist in the address list.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_NOT_FOUND,
                message,
            )

        class DuplicateAddressId(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.DUPLICATE_ADDRESS_ID,
                "Address ID already exists: $addressId",
            )

        class IdMismatch(
            existingId: String,
            newId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_ID_MISMATCH,
                "Address ID mismatch: expected $existingId, got $newId",
            )

        class LimitExceeded(
            limit: Int,
        ) : Address(
                UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
                "Cannot add more addresses, limit is $limit",
            )

        class CannotDeleteDefault(
            message: String = "Cannot remove the default address.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
                message,
            )

        class CannotDeleteLast(
            message: String = "Cannot remove the last address.",
        ) : Address(
                UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
                message,
            )

        class MultipleDefaultsOnInit(
            val reason: String = "Cannot initialize user with multiple default addresses.",
        ) : Address(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                reason,
            )
    }

    class PersistenceError(
        message: String,
        cause: Throwable? = null,
    ) : UserDomainException(
            UserDomainErrorCodes.PERSISTENCE_ERROR,
            message,
            cause,
        )
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username

interface UserRepository {
    fun findById(id: UserId): User?

    fun findByUsername(username: Username): User?

    fun findByEmail(email: Email): User? // findByEmail 메서드 추가
    fun existsByUsername(username: Username): Boolean

    fun existsByEmail(email: Email): Boolean

    fun save(user: User): User

    fun delete(user: User)
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

@JvmInline
value class AddressId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun ofString(value: String): AddressId =
            try {
                AddressId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidAddressIdFormat(value)
            }

        fun of(value: UUID): AddressId = AddressId(value)

        fun fromUUID(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * Value object representing an email address.
 * This class ensures that the email address is valid according to a basic pattern.
 */
@JvmInline
value class Email private constructor(
    val value: String,
) {
    companion object {
        private val EMAIL_PATTERN =
            Regex(
                "[a-zA-Z0-9+._%\\-]{1,256}" +
                    "@" +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
                    "(" +
                    "\\." +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
                    ")+",
            )

        /**
         * Creates a new Email from a string value.
         * @throws UserDomainException.Validation if the email format is invalid
         */
        fun of(value: String): Email {
            if (!EMAIL_PATTERN.matches(value)) {
                throw UserDomainException.Validation.InvalidEmailFormat("Invalid email format: $value")
            }
            return Email(value.lowercase())
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Name private constructor(
    val value: String,
) : Serializable {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat("Invalid name format: $value")
        }
    }

    companion object {
        private const val MIN_LENGTH = 2
        private const val MAX_LENGTH = 50

        fun of(value: String): Name {
            if (value.isBlank() || value.length < MIN_LENGTH || value.length > MAX_LENGTH) {
                throw UserDomainException.Validation.InvalidNameFormat("이름은 $MIN_LENGTH 자 이상 $MAX_LENGTH 자 이하이어야 하며, 공백일 수 없습니다: '$value'")
            }
            return Name(value)
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * 비밀번호 Value Object
 */
@JvmInline
value class Password private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password cannot be blank.")
        }
    }

    override fun toString(): String = "********"

    companion object {
        /**
         * Creates a Password VO from a pre-encoded password string.
         * Basic validation is done in the init block.
         */
        fun of(encodedPassword: String): Password = Password(encodedPassword)
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class PhoneNumber private constructor(
    val value: String,
) : Serializable {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^010-?\\d{4}-?\\d{4}$")

        fun of(value: String): PhoneNumber {
            val normalizedValue = value.replace("-", "")
            if (!PHONE_NUMBER_REGEX.matches(value)) {
                throw UserDomainException.Validation.InvalidPhoneNumberFormat("휴대폰 번호 형식이 올바르지 않습니다: $value")
            }

            return PhoneNumber(normalizedValue)
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

/**
 * Value object representing a unique user identifier.
 * This class wraps a UUID and provides type safety and validation.
 */
@JvmInline
value class UserId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        /**
         * Creates a new UserId from a UUID.
         */
        fun of(uuid: UUID): UserId = UserId(uuid)

        /**
         * Creates a new UserId from a string representation of a UUID.
         * @throws UserDomainException.Validation if the string is not a valid UUID
         */
        fun ofString(value: String): UserId =
            try {
                UserId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUserIdFormat(value)
            }

        /**
         * Generates a new random UserId.
         */
        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromUUID(value: UUID): UserId = UserId(value)
    }

    override fun toString(): String = value.toString()
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserStatus.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserStatus.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo

/**
 * Represents the status of a user account.
 */
enum class UserStatus {
    ACTIVE,
    INACTIVE,
    WITHDRAWN,
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserType.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserType.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo

/**
 * Represents the type of user.
 */
enum class UserType {
    CUSTOMER,
    ADMIN,
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Username private constructor(
    val value: String,
) : Serializable {
    init {

        if (value.isBlank() || value.length < 3 || value.length > 20) {
            throw UserDomainException.Validation.InvalidUsernameFormat(value)
        }
    }

    companion object {
        fun of(value: String): Username {
            try {
                return Username(value)
            } catch (e: UserDomainException.Validation.InvalidUsernameFormat) {
                throw e
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUsernameFormat(value)
            }
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/build.gradle.kts
 Path: domains/user/infrastructure/messaging/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1"
    id("org.springframework.boot") apply false
    id("io.spring.dependency-management")
}


the<io.spring.gradle.dependencymanagement.dsl.DependencyManagementExtension>().apply {
    imports {
        mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
    }
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:infrastructure"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.apache.avro:avro:1.11.3")
    implementation("io.github.oshai:kotlin-logging-jvm:5.1.0")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

avro {
    stringType.set("String")
    outputCharacterEncoding.set("UTF-8")
    isCreateSetters.set(true)
    isCreateOptionalGetters.set(false)
    isGettersReturnOptional.set(false)
    fieldVisibility.set("PRIVATE")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
    sourceSets {
        main {
            java {
                srcDir("build/generated-main-avro-java")
            }
        }
    }
}

kotlin {
    jvmToolchain(21)
    sourceSets.main {
        kotlin.srcDirs(
            "src/main/kotlin",
            "build/generated-main-avro-java"
        )
    }
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<Copy> {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

tasks.named<com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask>("generateAvroJava") {
    source("src/main/resources/avro")
    setOutputDir(file("build/generated-main-avro-java"))
}

tasks.named("compileKotlin") {
    dependsOn("generateAvroJava")
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Timestamp: 2025-05-13 19:28:11
====================================================================
package com.restaurant.user.infrastructure.messaging.serialization

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.infrastructure.messaging.avro.event.UserAddressAdded
import com.restaurant.user.infrastructure.messaging.avro.event.UserAddressDeleted
import com.restaurant.user.infrastructure.messaging.avro.event.UserAddressUpdated
import com.restaurant.user.infrastructure.messaging.avro.event.UserCreated
import com.restaurant.user.infrastructure.messaging.avro.event.UserPasswordChanged
import com.restaurant.user.infrastructure.messaging.avro.event.UserProfileUpdated
import com.restaurant.user.infrastructure.messaging.avro.event.UserWithdrawn
import io.github.oshai.kotlinlogging.KotlinLogging
import org.apache.avro.io.BinaryEncoder
import org.apache.avro.io.DatumWriter
import org.apache.avro.io.EncoderFactory
import org.apache.avro.specific.SpecificDatumWriter
import org.apache.avro.specific.SpecificRecordBase
import org.slf4j.MDC
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component
import java.io.ByteArrayOutputStream

private val log = KotlinLogging.logger {}

@Component
class OutboxMessageFactory(
    @Value("\${kafka.topics.user-event:dev.user-event}")
    private val userEventTopic: String,
) {
    companion object {
        private const val AGGREGATE_TYPE = "User"
    }

    fun createMessagesFromEvent(userEvent: UserEvent): List<OutboxMessage> {
        val domainEventPayloadDto: SpecificRecordBase =
            mapToAvroPayloadDto(userEvent) ?: run {
                log.error { "Failed to map UserEvent to Avro DTO: ${userEvent::class.simpleName}" }
                return emptyList()
            }

        val domainPayloadBytes: ByteArray =
            serializeRecord(domainEventPayloadDto) ?: run {
                log.error { "Failed to serialize Avro DTO: ${domainEventPayloadDto::class.simpleName}" }
                return emptyList()
            }

        val eventTypeString = userEvent::class.simpleName ?: "UnknownEvent"

        val headers =
            mutableMapOf(
                "correlationId" to (MDC.get("correlationId") ?: userEvent.eventId.toString()),
                "eventType" to eventTypeString,
                "aggregateId" to userEvent.aggregateId,
                "aggregateType" to AGGREGATE_TYPE,
            )

        val outboxMessage =
            OutboxMessage(
                payload = domainPayloadBytes,
                topic = determineTopic(userEvent),
                headers = headers,
                aggregateId = userEvent.aggregateId,
                aggregateType = AGGREGATE_TYPE,
                eventType = eventTypeString,
            )

        return listOf(outboxMessage)
    }

    private fun mapToAvroPayloadDto(event: UserEvent): SpecificRecordBase? =
        try {
            when (event) {
                is UserEvent.Created -> {
                    UserCreated
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setUsername(event.username)
                        .setEmail(event.email)
                        .setName(event.name)
                        .setPhoneNumber(event.phoneNumber)
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
                is UserEvent.PasswordChanged -> {
                    UserPasswordChanged
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
                is UserEvent.ProfileUpdated -> {
                    UserProfileUpdated
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setName(event.name)
                        .setPhoneNumber(event.phoneNumber)
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
                is UserEvent.AddressRegistered -> {
                    UserAddressAdded
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setAddressId(event.address.id)
                        .setName(event.address.name)
                        .setStreetAddress(event.address.streetAddress)
                        .setDetailAddress(event.address.detailAddress)
                        .setCity(event.address.city)
                        .setState(event.address.state)
                        .setCountry(event.address.country)
                        .setZipCode(event.address.zipCode)
                        .setIsDefault(event.address.isDefault)
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
                is UserEvent.AddressUpdated -> {
                    UserAddressUpdated
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setAddressId(event.address.id)
                        .setName(event.address.name)
                        .setStreetAddress(event.address.streetAddress)
                        .setDetailAddress(event.address.detailAddress)
                        .setCity(event.address.city)
                        .setState(event.address.state)
                        .setCountry(event.address.country)
                        .setZipCode(event.address.zipCode)
                        .setIsDefault(event.address.isDefault)
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
                is UserEvent.AddressDeleted -> {
                    UserAddressDeleted
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setAddressId(event.addressId)
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
                is UserEvent.Withdrawn -> {
                    UserWithdrawn
                        .newBuilder()
                        .setUserId(event.userId.toString())
                        .setOccurredAt(event.occurredAt.toEpochMilli())
                        .build()
                }
            }
        } catch (e: Exception) {
            log.error(e) { "Error mapping UserEvent to Avro DTO: ${event::class.simpleName}" }
            null
        }

    private fun <T : SpecificRecordBase> serializeRecord(record: T): ByteArray? =
        try {
            val writer: DatumWriter<T> = SpecificDatumWriter(record.schema)
            val out = ByteArrayOutputStream()
            val encoder: BinaryEncoder = EncoderFactory.get().binaryEncoder(out, null)
            writer.write(record, encoder)
            encoder.flush()
            out.toByteArray()
        } catch (e: Exception) {
            log.error(e) { "Failed to serialize Avro record: ${record::class.simpleName}" }
            null
        }

    private fun determineTopic(event: UserEvent): String = userEventTopic
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-address-added-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-address-added-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserAddressAdded",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "addressId", "type": "string"},
    {"name": "name", "type": "string"},
    {"name": "streetAddress", "type": "string"},
    {"name": "detailAddress", "type": ["null", "string"], "default": null},
    {"name": "city", "type": "string"},
    {"name": "state", "type": "string"},
    {"name": "country", "type": "string"},
    {"name": "zipCode", "type": "string"},
    {"name": "isDefault", "type": "boolean"},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-address-deleted-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-address-deleted-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserAddressDeleted",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "addressId", "type": "string"},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-address-updated-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-address-updated-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserAddressUpdated",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "addressId", "type": "string"},
    {"name": "name", "type": "string"},
    {"name": "streetAddress", "type": "string"},
    {"name": "detailAddress", "type": ["null", "string"], "default": null},
    {"name": "city", "type": "string"},
    {"name": "state", "type": "string"},
    {"name": "country", "type": "string"},
    {"name": "zipCode", "type": "string"},
    {"name": "isDefault", "type": "boolean"},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-created-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-created-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserCreated",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "username", "type": "string"},
    {"name": "email", "type": "string"},
    {"name": "name", "type": "string"},
    {"name": "phoneNumber", "type": ["null", "string"], "default": null},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-domain-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-domain-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserDomainEvent",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {
      "name": "eventType",
      "type": {
        "type": "enum",
        "name": "UserEventType",
        "symbols": [
          "USER_CREATED",
          "USER_UPDATED",
          "USER_DELETED",
          "USER_NAME_CHANGED",
          "USER_EMAIL_CHANGED",
          "USER_PASSWORD_CHANGED",
          "USER_PROFILE_UPDATED",
          "USER_ADDRESS_ADDED",
          "USER_ADDRESS_UPDATED",
          "USER_ADDRESS_DELETED",
          "USER_WITHDRAWN"
        ]
      }
    },
    {
      "name": "userId",
      "type": "string"
    },
    {
      "name": "username",
      "type": ["null", "string"],
      "default": null
    },
    {
      "name": "email",
      "type": ["null", "string"],
      "default": null
    },
    {
      "name": "name",
      "type": ["null", "string"],
      "default": null
    },
    {
      "name": "phoneNumber",
      "type": ["null", "string"],
      "default": null
    },
    {
      "name": "status",
      "type": {
        "type": "enum",
        "name": "UserStatus",
        "symbols": ["ACTIVE", "INACTIVE", "SUSPENDED"]
      }
    },
    {
      "name": "createdAt",
      "type": "long"
    },
    {
      "name": "updatedAt",
      "type": ["null", "long"],
      "default": null
    }
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-password-changed-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-password-changed-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserPasswordChanged",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-profile-updated-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-profile-updated-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserProfileUpdated",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "name", "type": "string"},
    {"name": "phoneNumber", "type": ["null", "string"], "default": null},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/resources/avro/user-withdrawn-event-v1.avsc
 Path: domains/user/infrastructure/messaging/src/main/resources/avro/user-withdrawn-event-v1.avsc
 Timestamp: 2025-05-13 19:28:11
====================================================================
{
  "type": "record",
  "name": "UserWithdrawn",
  "namespace": "com.restaurant.user.infrastructure.messaging.avro.event",
  "fields": [
    {"name": "userId", "type": "string"},
    {"name": "occurredAt", "type": "long"}
  ]
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/build.gradle.kts
 Path: domains/user/infrastructure/persistence/build.gradle.kts
 Timestamp: 2025-05-13 19:28:11
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("plugin.allopen")
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:infrastructure"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application"))
    implementation(project(":independent:outbox"))
    
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.2.3")
    implementation("org.flywaydb:flyway-core:9.22.3")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.16.1")
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:1.9.22")
    
    runtimeOnly("org.postgresql:postgresql:42.7.2")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.3")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.testcontainers:testcontainers:1.19.6")
    testImplementation("org.testcontainers:junit-jupiter:1.19.6")
    testImplementation("org.testcontainers:postgresql:1.19.6")
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "addresses")
class AddressEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, unique = true) // domainId는 unique해야 할 가능성이 높습니다.
    val domainId: UUID,
    @Column(nullable = false)
    val name: String,
    @Column(nullable = false)
    val streetAddress: String,
    @Column(nullable = true)
    val detailAddress: String?,
    @Column(nullable = false)
    val city: String,
    @Column(nullable = false)
    val state: String,
    @Column(nullable = false)
    val country: String,
    @Column(nullable = false)
    val zipCode: String,
    @Column(nullable = false)
    val isDefault: Boolean,
    @Column(nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(nullable = false)
    val updatedAt: Instant = Instant.now(),
    @Column(nullable = false)
    val version: Long = 0L,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null // UserEntity와의 관계 추가
)

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import com.restaurant.user.domain.vo.UserStatus
import com.restaurant.user.domain.vo.UserType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.CascadeType
import java.time.Instant
import java.util.Objects
import java.util.UUID

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false, length = 50)
    val username: String,
    @Column(nullable = false)
    val passwordHash: String,
    @Column(unique = true, nullable = false)
    val email: String,
    @Column(nullable = false, length = 50)
    val name: String,
    @Column(length = 20)
    val phoneNumber: String?,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val userType: UserType,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val status: UserStatus = UserStatus.ACTIVE,
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY, mappedBy = "user")
    var addresses: MutableList<AddressEntity> = mutableListOf(), // MutableList로 변경
    @Version
    @Column(nullable = false)
    val version: Long = 0L,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: Instant = Instant.now(),
    // UserEntity에는 defaultAddressId 필드가 없습니다.
) {
    // AddressEntity 추가를 위한 편의 메서드 (선택적, 양방향 관계 설정 시 유용)
    fun addAddress(address: AddressEntity) {
        addresses.add(address)
        address.user = this // AddressEntity에 user 필드가 있다고 가정
    }

    fun removeAddress(address: AddressEntity) {
        addresses.remove(address)
        address.user = null // AddressEntity에 user 필드가 있다고 가정
    }


    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as UserEntity
        return Objects.equals(id, that.id) &&
            domainId == that.domainId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: domainId)
    }

    override fun toString(): String {
        val defaultAddressDomainId = addresses.find { it.isDefault }?.domainId?.toString() ?: "N/A"
        return "UserEntity(id=$id, domainId=$domainId, username='$username', email='$email', userType=$userType, defaultAddressDomainId=${defaultAddressDomainId}, addresses=${addresses.size}, createdAt=$createdAt, updatedAt=$updatedAt, version=$version)"
    }
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.vo.AddressId
// UserId는 Address.reconstitute에서 사용하지 않는다고 가정하고 제거
import com.restaurant.user.infrastructure.persistence.entity.AddressEntity
// UserEntity import는 toEntity에서 사용하지 않으므로 제거 가능 (만약 AddressEntity가 UserEntity를 참조하지 않는다면)
// import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import java.time.Instant
import java.util.UUID

// Address.reconstitute에서 userId를 사용하지 않는다고 가정
fun AddressEntity.toDomain(): Address {
    return Address.reconstitute(
        addressId = AddressId.of(this.domainId),
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version
    )
}

// AddressEntity 생성 시 UserEntity를 받지 않음
// UserEntity의 addresses 컬렉션에 추가될 때 관계가 설정됨
fun Address.toEntity(): AddressEntity {
    return AddressEntity(
        // id는 DB 자동 생성
        domainId = this.addressId.value,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt, // Address 도메인 객체에 해당 필드가 있다고 가정
        updatedAt = this.updatedAt, // Address 도메인 객체에 해당 필드가 있다고 가정
        version = this.version      // Address 도메인 객체에 해당 필드가 있다고 가정
        // user 필드는 UserEntity에서 AddressEntity를 추가하면서 설정
    )
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.persistence.entity.UserEntity

fun UserEntity.toDomain(): User {
    val userDomainId = UserId.of(this.domainId)
    val domainAddresses =
        this.addresses.map { addressEntity ->
            addressEntity.toDomain() // userId 인자 제거됨
        }.toList()

    // User.reconstitute에서 defaultAddressId를 사용하지 않거나,
    // User 도메인 객체가 addresses 리스트 내 isDefault 플래그로 관리한다고 가정
    return User.reconstitute(
        id = userDomainId,
        username = Username.of(this.username),
        password = Password.of(this.passwordHash),
        email = Email.of(this.email),
        name = Name.of(this.name),
        phoneNumber = this.phoneNumber?.let { PhoneNumber.of(it) },
        userType = this.userType,
        status = this.status,
        addresses = domainAddresses,
        // defaultAddressId = domainAddresses.find { it.isDefault }?.addressId, // User.kt에 defaultAddressId 파라미터가 없을 수 있으므로 주석 처리
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version
    )
}

fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            domainId = this.id.value,
            username = this.username.value,
            passwordHash = this.password.value,
            email = this.email.value,
            name = this.name.value,
            phoneNumber = this.phoneNumber?.value,
            userType = this.userType,
            status = this.status,
            version = this.version,
            createdAt = this.createdAt,
            updatedAt = this.updatedAt
            // UserEntity 생성자에서 defaultAddressId 제거됨
        )

    val addressEntities =
        this.addresses.map { address ->
            val addressEntity = address.toEntity()
            // AddressEntity에 user 필드가 있고, UserEntity의 addAddress 메서드 등을 통해 관계가 설정된다고 가정
            // 만약 AddressEntity에 user: UserEntity? = null var 필드가 있다면
            // addressEntity.user = entity // 와 같이 설정할 수 있음
            addressEntity
        }.toMutableList()
    entity.addresses = addressEntities
    return entity
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import org.springframework.data.jpa.repository.JpaRepository
import java.util.UUID

interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    fun findByDomainId(domainId: UUID): UserEntity?

    fun findByUsernameValue(username: String): UserEntity?

    fun findByEmailValue(email: String): UserEntity? // findByEmailValue 메서드 추가

    fun existsByUsernameValue(username: String): Boolean

    fun existsByEmailValue(email: String): Boolean
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.persistence.extensions.toDomain
import com.restaurant.user.infrastructure.persistence.extensions.toEntity
import org.springframework.stereotype.Repository

@Repository
class UserRepositoryImpl(
    private val springDataJpaUserRepository: SpringDataJpaUserRepository,
    // private val outboxMessageRepository: OutboxMessageRepository, // Outbox 관련 의존성은 Rule 84, 139에 따라 필요시 주입
) : UserRepository {
    override fun findById(id: UserId): User? {
        return springDataJpaUserRepository.findByDomainId(id.value)?.toDomain()
    }

    override fun findByUsername(username: Username): User? {
        return springDataJpaUserRepository.findByUsernameValue(username.value)?.toDomain()
    }

    override fun findByEmail(email: Email): User? {
        return springDataJpaUserRepository.findByEmailValue(email.value)?.toDomain()
    }

    override fun existsByUsername(username: Username): Boolean {
        return springDataJpaUserRepository.existsByUsernameValue(username.value)
    }

    override fun existsByEmail(email: Email): Boolean {
        return springDataJpaUserRepository.existsByEmailValue(email.value)
    }

    override fun save(user: User): User {
        val userEntity = user.toEntity()
        val savedEntity = springDataJpaUserRepository.save(userEntity)

        // Rule 85, 139: 도메인 이벤트 처리 및 Outbox 저장 로직 (아래는 예시이며, 실제 구현 필요)
        // val domainEvents = user.getDomainEvents()
        // if (domainEvents.isNotEmpty()) {
        //     val outboxMessages = domainEvents.map { event ->
        //         // DomainEventAvroSerializer, OutboxMessageFactory 등을 사용하여 OutboxMessage 생성
        //         // 예: OutboxMessage(payload = serialize(event), topic = "user-events", headers = mapOf(...))
        //     }
        //     outboxMessageRepository.saveAll(outboxMessages) // Outbox 저장
        //     user.clearDomainEvents() // 이벤트 클리어
        // }
        return savedEntity.toDomain()
    }

    override fun delete(user: User) {
        springDataJpaUserRepository.delete(user.toEntity())
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/build.gradle.kts
 Path: domains/user/presentation/build.gradle.kts
 Timestamp: 2025-05-13 19:28:12
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common:presentation"))
    implementation(project(":domains:user:application"))
    
    implementation("org.springframework.boot:spring-boot-starter-web:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.2.3")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.16.1")
    implementation("org.jetbrains.kotlin:kotlin-reflect:1.9.22")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:1.9.22")
    implementation("io.github.oshai:kotlin-logging-jvm:5.1.0")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.3")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.assertj:assertj-core:3.25.3")
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserAddressController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserAddressController.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.controller

import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.command.extensions.dto.request.toCommand

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.port.DeleteAddressUseCase
import com.restaurant.user.application.port.RegisterAddressUseCase
import com.restaurant.user.application.port.UpdateAddressUseCase
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId

import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.servlet.support.ServletUriComponentsBuilder
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
class UserAddressController(
    private val registerAddressUseCase: RegisterAddressUseCase,
    private val updateAddressUseCase: UpdateAddressUseCase,
    private val deleteAddressUseCase: DeleteAddressUseCase
) {

    @PostMapping
    fun registerAddress(
        @PathVariable userId: UUID,
        @Valid @RequestBody request: RegisterAddressRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to register address for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), correlationId)
        val addressId: AddressId = registerAddressUseCase.registerAddress(command)

        val location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{addressId}")
            .buildAndExpand(addressId.value)
            .toUri()

        return ResponseEntity.created(location).body(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address registered successfully.",
                correlationId = correlationId
            )
        )
    }

    @PutMapping("/{addressId}")
    fun updateAddress(
        @PathVariable userId: UUID,
        @PathVariable addressId: UUID,
        @Valid @RequestBody request: UpdateAddressRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to update address ID: $addressId for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), AddressId.of(addressId), correlationId)
        updateAddressUseCase.updateAddress(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address updated successfully.",
                correlationId = correlationId
            )
        )
    }

    @DeleteMapping("/{addressId}")
    fun deleteAddress(
        @PathVariable userId: UUID,
        @PathVariable addressId: UUID,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to delete address ID: $addressId for user ID: $userId" }
        val command = DeleteAddressCommand(
            userId = UserId.of(userId).value.toString(),
            addressId = AddressId.of(addressId).value.toString()
        )
        deleteAddressUseCase.deleteAddress(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address deleted successfully.",
                correlationId = correlationId
            )
        )
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.controller

import com.restaurant.user.presentation.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1

import com.restaurant.user.presentation.v1.command.extensions.dto.request.toCommand

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.port.input.ChangePasswordUseCase
import com.restaurant.user.application.port.input.DeleteUserUseCase
import com.restaurant.user.application.port.input.LoginUseCase
import com.restaurant.user.application.port.input.RegisterUserUseCase
import com.restaurant.user.application.port.input.UpdateProfileUseCase
import com.restaurant.user.domain.vo.UserId

import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.servlet.support.ServletUriComponentsBuilder
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(
    name = "User Commands",
    description = "API for user account management (registration, login, profile updates, password change, deletion)",
)
@RestController
@RequestMapping("/api/v1/users")
class UserController(
    private val registerUserUseCase: RegisterUserUseCase,
    private val loginUseCase: LoginUseCase,
    private val updateProfileUseCase: UpdateProfileUseCase,
    private val changePasswordUseCase: ChangePasswordUseCase,
    private val deleteUserUseCase: DeleteUserUseCase
) {
    @PostMapping("/register")
    @Operation(summary = "Register a new user")
    @ApiResponse(responseCode = "201", description = "User registered successfully")
    fun registerUser(
        @Valid @RequestBody request: RegisterUserRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to register user: ${request.username}" }
        val command = request.toCommand(correlationId)
        val userId: UserId = registerUserUseCase.register(command)

        val location = ServletUriComponentsBuilder
            .fromCurrentContextPath()
            .path("/api/v1/users/{userId}/profile")
            .buildAndExpand(userId.value)
            .toUri()

        return ResponseEntity.created(location).body(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User registered successfully.",
                correlationId = correlationId
            )
        )
    }

    @PostMapping("/login")
    @Operation(summary = "Login a user")
    @ApiResponse(responseCode = "200", description = "User logged in successfully")
    fun login(
        @Valid @RequestBody request: LoginRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received login request for user: ${request.email}" }
        val command = request.toCommand(correlationId)
        val loginResult = loginUseCase.login(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Login successful. Token: ${loginResult.accessToken}",
                correlationId = correlationId
            )
        )
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "Update user profile")
    @ApiResponse(responseCode = "200", description = "Profile updated successfully")
    fun updateProfile(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: UpdateProfileRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to update profile for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), correlationId)
        updateProfileUseCase.updateProfile(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User profile updated successfully.",
                correlationId = correlationId
            )
        )
    }

    @PatchMapping("/{userId}/password")
    @Operation(summary = "Change user password")
    @ApiResponse(responseCode = "200", description = "Password changed successfully")
    fun changePassword(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: ChangePasswordRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to change password for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), correlationId)
        changePasswordUseCase.changePassword(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User password changed successfully.",
                correlationId = correlationId
            )
        )
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "Delete user account")
    @ApiResponse(responseCode = "200", description = "User deleted successfully")
    fun deleteUser(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: DeleteUserRequestV1,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<CommandResultResponse> {
        log.info { "[Correlation ID: $correlationId] Received request to delete user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), correlationId)
        deleteUserUseCase.deleteUser(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User deleted successfully.",
                correlationId = correlationId
            )
        )
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/ChangePasswordRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/ChangePasswordRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/DeleteUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/DeleteUserRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/LoginRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/LoginRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterAddressRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterUserRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
/**
 * 사용자 등록 요청 DTO
 *
 * Contains validation and schema annotations for user registration API.
 *
 * @author junoko
 */
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

@Schema(description = "사용자 등록 요청")
data class RegisterUserRequestV1(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser")
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    @Schema(description = "전화번호 (선택)", example = "010-1234-5678")
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateAddressRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateProfileRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateProfileRequestV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/extensions/dto/request/UserCommandRequestExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/extensions/dto/request/UserCommandRequestExtensions.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.command.extensions.dto.request

import com.restaurant.user.application.dto.command.*
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateAddressRequestV1
// import java.util.UUID // Controller에서 UUID를 받지만 Command DTO는 String ID를 사용

fun RegisterUserRequestV1.toCommand(correlationId: String): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
        username = this.username
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

fun LoginRequestV1.toCommand(correlationId: String): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

fun UpdateProfileRequestV1.toCommand(userId: UserId, correlationId: String): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId.value.toString(),
        name = this.name,
        phoneNumber = null // Request DTO에 phoneNumber 필드 추가 필요 또는 기본값 처리
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

fun ChangePasswordRequestV1.toCommand(userId: UserId, correlationId: String): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId.value.toString(),
        currentPassword = this.currentPassword,
        newPassword = this.newPassword
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

fun DeleteUserRequestV1.toCommand(userId: UserId, correlationId: String): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId.value.toString(),
        password = this.currentPassword
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

// RegisterAddressRequestV1에는 name, city, state, country 필드가 없음.
// Command DTO의 해당 필드들은 임시로 빈 문자열 또는 기본값으로 채우거나, nullable로 변경 필요.
fun RegisterAddressRequestV1.toCommand(userId: UserId, correlationId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId.value.toString(),
        name = "Default Address Name", // 임시값, Request DTO에 필드 추가 필요
        street = this.street,
        detail = this.detail ?: "",
        city = "Default City", // 임시값, Request DTO에 필드 추가 필요
        state = "Default State", // 임시값, Request DTO에 필드 추가 필요
        country = "Default Country", // 임시값, Request DTO에 필드 추가 필요
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

// UpdateAddressRequestV1에는 name, city, state, country 필드가 없음.
fun UpdateAddressRequestV1.toCommand(
    userId: UserId,
    addressId: AddressId,
    correlationId: String
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId.value.toString(),
        addressId = addressId.value.toString(),
        name = "Default Address Name", // 임시값, Request DTO에 필드 추가 필요
        street = this.street,
        detail = this.detail ?: "",
        city = "Default City", // 임시값, Request DTO에 필드 추가 필요
        state = "Default State", // 임시값, Request DTO에 필드 추가 필요
        country = "Default Country", // 임시값, Request DTO에 필드 추가 필요
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false
        // correlationId = correlationId // Command DTO에 필드 추가 필요
    )

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserQueryController.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.query.controller

import com.restaurant.user.presentation.v1.query.dto.response.UserProfileResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toResponseV1

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.port.GetUserProfileQuery
import com.restaurant.user.domain.vo.UserId
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Queries", description = "API for querying user information")
class UserQueryController(
    private val getUserProfileQuery: GetUserProfileQuery
) {
    @GetMapping("/{userId}/profile")
    @Operation(summary = "Get user profile", description = "Retrieves user profile information by User ID.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Profile retrieved successfully",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = UserProfileResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "Invalid UUID format",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "User not found",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserProfile(
        @PathVariable userId: UUID,
        @RequestHeader("X-Correlation-Id") correlationId: String
    ): ResponseEntity<UserProfileResponseV1> {
        log.info { "[Correlation ID: $correlationId] Received request to get profile for user ID: $userId" }
        val query = GetUserProfileByIdQuery(userId = UserId.of(userId).value.toString())
        val userProfileDto = getUserProfileQuery.getUserProfile(query)
        val responseDto = userProfileDto.toResponseV1(correlationId)

        responseDto.add(
            linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId, correlationId)).withSelfRel()
            // TODO: Add update-profile and change-password links if needed, ensure UserController is imported and available
        )
        log.info { "Returning user profile for ID: $userId" }
        return ResponseEntity.ok(responseDto)
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressResponseV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/LoginResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/LoginResponseV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답 V1")
data class LoginResponseV1(
    @Schema(description = "사용자 ID (UUID)")
    val userId: String,
    @Schema(description = "사용자 이름")
    val username: String,
    @Schema(description = "액세스 토큰")
    val accessToken: String,
    @Schema(description = "리프레시 토큰")
    val refreshToken: String,
) : RepresentationModel<LoginResponseV1>()

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/UserProfileResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/UserProfileResponseV1.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import org.springframework.hateoas.server.core.Relation
import java.time.Instant

/**
 * 사용자 프로필 정보 응답 DTO (Rule 1.4, 39)
 */
@Relation(collectionRelation = "users", itemRelation = "user")
@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "사용자 아이디", example = "testuser") val username: String,
    @Schema(description = "전화번호", example = "010-1234-5678", nullable = true) val phoneNumber: String?,
    @Schema(description = "사용자 타입", example = "CUSTOMER") val userType: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) : RepresentationModel<UserProfileResponseV1>()

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserQueryResponseExtensions.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.user.presentation.v1.query.extensions.dto.response

import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.presentation.v1.command.controller.UserAddressController
import com.restaurant.user.presentation.v1.command.controller.UserController
import com.restaurant.user.presentation.v1.query.controller.UserQueryController
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.UserProfileResponseV1
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import java.util.UUID

fun UserProfileDto.toResponseV1(correlationId: String): UserProfileResponseV1 {
    val userIdAsUuid = UUID.fromString(this.id)
    val response =
        UserProfileResponseV1(
            id = this.id,
            email = this.email,
            username = this.username,
            name = this.name,
            phoneNumber = this.phoneNumber,
            userType = this.userType,
            addresses = this.addresses.map { addressDto: UserProfileDto.AddressDto -> addressDto.toResponseV1() },
            createdAt = this.createdAt,
            updatedAt = this.updatedAt,
            status = this.status,
            version = this.version,
        )

    response.add(
        linkTo(methodOn(UserQueryController::class.java).getUserProfile(userIdAsUuid, correlationId)).withSelfRel(),
        linkTo(
            methodOn(
                UserController::class.java,
            ).updateProfile(
                userIdAsUuid,
                UpdateProfileRequestV1(name = "dummyName"),
                correlationId,
            ),
        ).withRel("update-profile"),
        linkTo(
            methodOn(
                UserController::class.java,
            ).changePassword(
                userIdAsUuid,
                ChangePasswordRequestV1(currentPassword = "dummyPassword", newPassword = "dummyNewPassword"),
                correlationId,
            ),
        ).withRel("change-password"),
        linkTo(
            methodOn(UserController::class.java).deleteUser(
                userIdAsUuid,
                DeleteUserRequestV1(currentPassword = "dummyPassword"),
                correlationId,
            ),
        ).withRel("delete-user"),
        linkTo(
            methodOn(
                UserAddressController::class.java,
            ).registerAddress(
                userIdAsUuid,
                RegisterAddressRequestV1(
                    street = "dummy street",
                    detail = "dummy detail",
                    zipCode = "00000",
                    isDefault = false,
                ),
                correlationId,
            ),
        ).withRel("register-address"),
    )
    return response
}

fun UserProfileDto.AddressDto.toResponseV1(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        street = this.street ?: "",
        detail = this.detail ?: "",
        zipCode = this.zipCode ?: "",
        isDefault = this.isDefault,
    )

====================================================================n


====================================================================
 File: independent/outbox/build.gradle.kts
 Path: independent/outbox/build.gradle.kts
 Timestamp: 2025-05-13 19:28:12
====================================================================
plugins {
    id("java-library")
    kotlin("jvm")
    kotlin("plugin.jpa")
    kotlin("plugin.allopen")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter:3.2.3")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.2.3")
    implementation("org.springframework.kafka:spring-kafka:3.1.1")
    implementation("org.flywaydb:flyway-core:9.22.3")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.16.1")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.20")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.20")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    runtimeOnly("org.postgresql:postgresql:42.7.2")
    runtimeOnly("com.h2database:h2")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.3")
    testImplementation("org.springframework.kafka:spring-kafka-test:3.1.1")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.testcontainers:testcontainers:1.19.6")
    testImplementation("org.testcontainers:junit-jupiter:1.19.6")
    testImplementation("org.testcontainers:postgresql:1.19.6")
    testImplementation("org.testcontainers:kafka:1.19.6")
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/OutboxPoller.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/OutboxPoller.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.application

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.application.port.OutboxMessageRepository
import com.restaurant.outbox.infrastructure.kafka.OutboxMessageSender
import org.slf4j.LoggerFactory
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import com.restaurant.outbox.infrastructure.exception.OutboxException

@Component
class OutboxPoller(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSender,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)
    private val batchSize = 100
    private val maxRetries = 3

    @Scheduled(fixedRate = 1000) 
    @Transactional
    fun pollAndProcessMessages() {
        try {
            val unprocessedMessages: List<OutboxMessage> =
                outboxMessageRepository.findAndMarkForProcessing(OutboxMessageStatus.PENDING, batchSize)

            if (unprocessedMessages.isEmpty()) {
                return
            }

            logger.debug("Found {} unprocessed messages to process", unprocessedMessages.size)

            unprocessedMessages.forEach { message ->
                try {
                    outboxMessageSender.processAndSendMessage(message)
                    message.id?.let {
                        outboxMessageRepository.updateStatus(it, OutboxMessageStatus.SENT)
                    }
                } catch (e: OutboxException.KafkaSendFailedException) {
                    logger.error(
                        "Kafka send failed for message: {}, Error: {}. Incrementing retry count.",
                        message.id,
                        e.message,
                    )
                    message.id?.let {
                        
                        outboxMessageRepository.updateStatus(it, OutboxMessageStatus.PENDING, true)
                    }
                } catch (e: Exception) { 
                    logger.error(
                        "Unexpected error processing message: {}, Error: {}",
                        message.id,
                        e.message,
                        e,
                    )
                    message.id?.let {
                        
                        outboxMessageRepository.updateStatus(it, OutboxMessageStatus.FAILED, true)
                    }
                }
            }
        } catch (e: Exception) {
            logger.error("Error in outbox polling process", e)
        }
    }

    @Scheduled(fixedRate = 300000) 
    @Transactional
    fun retryFailedMessages() {
        try {
            
            val failedMessages: List<OutboxMessage> = outboxMessageRepository.findByStatusAndRetryCountLessThan(
                status = OutboxMessageStatus.FAILED,
                maxRetries = maxRetries,
                limit = batchSize
            )

            if (failedMessages.isEmpty()) {
                return
            }

            logger.debug("Found {} failed messages for retry", failedMessages.size)

            failedMessages.forEach { message: OutboxMessage ->
                try {
                    message.id?.let {
                        
                        outboxMessageRepository.updateStatus(it, OutboxMessageStatus.PENDING, false)
                        logger.info("Message ID {} marked as PENDING for retry.", it)
                    }
                } catch (e: Exception) {
                    logger.error(
                        "Error resetting failed message to PENDING: {}, Error: {}",
                        message.id,
                        e.message,
                        e,
                    )
                }
            }
        } catch (e: Exception) {
            logger.error("Error in failed message retry process", e)
        }
    }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/OutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/OutboxMessageRepository.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.application.port

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.application.port.model.OutboxMessageStatus

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * @param message 저장할 메시지
     * @return 저장된 메시지
     */
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     */
    fun saveAll(messages: List<OutboxMessage>) // 반환 타입 Unit (없음)

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: Long): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     *
     * @param status 조회할 메시지 상태
     * @return 조회된 메시지 목록
     */
    fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다. (OutboxMessageStatus enum 사용)
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID (Long)
     * @param newStatus 새로운 상태 (OutboxMessageStatus)
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 시간 이전에 생성된 실패 상태의 메시지들을 조회합니다. (이름 변경 또는 삭제 고려)
     * 이름이 역할과 맞지 않을 수 있음: 실제로는 재시도 횟수가 maxRetries *미만*인 것을 찾아야 함.
     * findMessagesToRetryByStatusAndRetryCountLessThan 로 대체 예정.
     *
     * @param maxRetries 최대 재시도 횟수 (이 값 *미만*인 것을 찾음)
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findFailedMessagesExceedingRetryCount( // 이 메서드는 이름이 오해의 소지가 있음.
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 특정 상태의 메시지를 조회하여 처리 중(PROCESSING) 상태로 변경합니다.
     * 동시성 제어를 위해 적절한 잠금 메커니즘을 사용해야 합니다.
     *
     * @param status 조회 및 처리할 메시지의 현재 상태 (일반적으로 PENDING)
     * @param limit 조회할 최대 메시지 수
     * @return 처리 대상으로 표시된 메시지 목록
     */
    fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 특정 상태의 메시지 개수를 반환합니다.
     * @param status 조회할 메시지 상태
     * @return 해당 상태의 메시지 개수
     */
    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 메시지의 재시도 횟수를 1 증가시킵니다.
     * lastAttemptTime과 updatedAt도 현재 시간으로 업데이트합니다.
     * @param id 메시지 ID
     * @return 업데이트된 메시지 또는 null (메시지를 찾지 못한 경우)
     */
    fun incrementRetryCount(id: Long): OutboxMessage?

    /**
     * 처리되지 않은 메시지를 조회합니다. (FOR UPDATE SKIP LOCKED 사용 가능성 고려)
     * @param batchSize 조회할 최대 메시지 수
     * @return 처리되지 않은 OutboxMessage 목록
     */
    fun findUnprocessedMessages(batchSize: Int): List<OutboxMessage>

    /**
     * 메시지 상태를 업데이트합니다. (이 메서드는 updateStatus(id, newStatus, incrementRetry)로 대체될 수 있음)
     * @param messageId 업데이트할 메시지 ID
     * @param status 새로운 상태 (OutboxMessageStatus)
     * @param retryCount 재시도 횟수
     */
    fun updateMessageStatus( // status 타입을 OutboxMessageStatus로 변경
        messageId: Long,
        status: OutboxMessageStatus,
        retryCount: Int,
    )

    /**
     * 특정 상태이고 재시도 횟수가 지정된 값 미만인 메시지 목록을 조회합니다.
     * 주로 재시도할 실패(FAILED) 메시지를 찾는데 사용됩니다.
     *
     * @param status 조회할 메시지의 상태
     * @param maxRetries 이 횟수 미만으로 재시도된 메시지만 조회
     * @param limit 조회할 최대 메시지 수
     * @return 조건에 맞는 OutboxMessage 목록
     */
    fun findByStatusAndRetryCountLessThan(
        status: OutboxMessageStatus,
        maxRetries: Int,
        limit: Int
    ): List<OutboxMessage>
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessage.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessage.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.application.port.model

import java.time.Instant

/** Outbox에 저장되는 메시지 데이터 모델 */
data class OutboxMessage(
    val id: Long? = null,
    val payload: ByteArray,
    val topic: String,
    val headers: Map<String, String>,
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String,
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val createdAt: Instant = Instant.now(),
    val updatedAt: Instant? = Instant.now(), // 타입을 Instant? 로 변경
    val lastAttemptTime: Instant? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (eventType != other.eventType) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + eventType.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + (updatedAt?.hashCode() ?: 0) // nullable 처리
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String =
        "OutboxMessage(" +
            "id=$id, " +
            "topic='$topic', " +
            "headers=$headers, " +
            "aggregateId='$aggregateId', " +
            "aggregateType='$aggregateType', " +
            "eventType='$eventType', " +
            "status=$status, " +
            "retryCount=$retryCount, " +
            "createdAt=$createdAt, " +
            "updatedAt=$updatedAt, " +
            "lastAttemptTime=$lastAttemptTime" +
            ")"
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessageStatus.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessageStatus.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.application.port.model

/** Outbox 메시지 상태 enum */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,

    /**
     * 더 이상 처리하지 않을 메시지
     */
    DISCARDED,
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.entity

import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.persistence.converter.StringMapConverter
import jakarta.persistence.Column
import jakarta.persistence.Convert
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Lob
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant

/** Outbox 메시지 JPA Entity */
@Entity
@Table(name = "outbox_events")
class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "aggregate_type", nullable = false)
    val aggregateType: String,
    @Column(name = "aggregate_id", nullable = false)
    val aggregateId: String,
    @Column(nullable = false)
    val topic: String,
    @Lob
    @Column(nullable = false)
    val payload: ByteArray,
    @Convert(converter = StringMapConverter::class)
    @Column(nullable = false, columnDefinition = "text")
    val headers: Map<String, String>,
    @Column(name = "event_type", nullable = false)
    val eventType: String,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at")
    var updatedAt: Instant? = Instant.now(), // 추가된 필드, 생성 시 현재 시간으로 초기화
    @Column(name = "last_attempt_time")
    var lastAttemptTime: Instant? = null,
    @Column(name = "retry_count", nullable = false)
    var retryCount: Int = 0,
    @Version
    var version: Long = 0,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventEntity

        if (id != other.id) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (topic != other.topic) return false
        if (!payload.contentEquals(other.payload)) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false // 추가된 필드 비교
        if (lastAttemptTime != other.lastAttemptTime) return false
        if (retryCount != other.retryCount) return false
        if (eventType != other.eventType) return false
        if (version != other.version) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + (updatedAt?.hashCode() ?: 0) // 추가된 필드 해시코드
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        result = 31 * result + retryCount
        result = 31 * result + eventType.hashCode()
        result = 31 * result + version.hashCode()
        return result
    }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.error

enum class OutboxErrorCodes(
    val code: String,
    val message: String,
) {
    MESSAGE_NOT_FOUND("OUTBOX-001", "Outbox message not found"),
    MESSAGE_PROCESSING_FAILED("OUTBOX-002", "Failed to process outbox message"),
    KAFKA_SEND_FAILED("OUTBOX-003", "Failed to send message to Kafka"),
    MAX_RETRIES_EXCEEDED("OUTBOX-004", "Maximum retry attempts exceeded"),
    INVALID_MESSAGE_STATUS("OUTBOX-005", "Invalid message status transition"),
    DATABASE_ERROR("OUTBOX-006", "Database operation failed"), 
    SERIALIZATION_ERROR("OUTBOX-007", "Message serialization failed"),
    DATABASE_OPERATION_FAILED("OUTBOX-008", "Database operation failed"), 
    UNEXPECTED_INFRA_ERROR("OUTBOX-009", "An unexpected infrastructure error occurred"),
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.exception

import com.restaurant.outbox.infrastructure.error.OutboxErrorCodes

/** Outbox 예외 베이스 클래스 */
sealed class OutboxException(
    val errorCode: OutboxErrorCodes,
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message ?: errorCode.message, cause) {
    class MessageNotFoundException(
        messageId: Long,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MESSAGE_NOT_FOUND,
        "Message not found with id: $messageId",
        cause,
    )

    class MessageProcessingFailedException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MESSAGE_PROCESSING_FAILED,
        message,
        cause,
    )

    class KafkaSendFailedException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.KAFKA_SEND_FAILED,
        message,
        cause,
    )

    class MaxRetriesExceededException(
        messageId: Long,
        maxRetries: Int,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MAX_RETRIES_EXCEEDED,
        "Maximum retry attempts ($maxRetries) exceeded for message: $messageId",
        cause,
    )

    class InvalidMessageStatusException(
        currentStatus: String,
        newStatus: String,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.INVALID_MESSAGE_STATUS,
        "Invalid status transition from $currentStatus to $newStatus",
        cause,
    )

    class DatabaseException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.DATABASE_ERROR,
        message,
        cause,
    )

    class SerializationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.SERIALIZATION_ERROR,
        message,
        cause,
    )

    class DatabaseOperationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.DATABASE_OPERATION_FAILED, message, cause)


    class UnexpectedInfrastructureException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.UNEXPECTED_INFRA_ERROR, message, cause)
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/OutboxMessageSender.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/OutboxMessageSender.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.kafka

import com.restaurant.outbox.application.port.model.OutboxMessage 
import com.restaurant.outbox.infrastructure.exception.OutboxException
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.support.KafkaHeaders
import org.springframework.messaging.Message
import org.springframework.messaging.support.MessageBuilder
import org.springframework.stereotype.Component





@Component
class OutboxMessageSender(
    private val kafkaTemplate: KafkaTemplate<String, ByteArray>,
    
) {
    private val logger = LoggerFactory.getLogger(this::class.java)
    

    
    fun processAndSendMessage(messageDto: OutboxMessage) { 
        try {
            
            

            val kafkaMessage = createKafkaMessage(messageDto)
            val sendResult = kafkaTemplate.send(kafkaMessage).get() 

            logger.info(
                "Successfully sent message to Kafka. Topic: {}, Partition: {}, Offset: {}, MessageId: {}",
                messageDto.topic,
                sendResult.recordMetadata.partition(),
                sendResult.recordMetadata.offset(),
                messageDto.id,
            )
            

        } catch (e: Exception) {
            
            logger.error(
                "Failed to send message to Kafka. MessageId: {}, Error: {}",
                messageDto.id,
                e.message,
                e,
            )
            throw OutboxException.KafkaSendFailedException(
                message = "Failed to send message to Kafka for OutboxMessage ID ${messageDto.id}: ${e.message}",
                cause = e,
            )
        }
    }

    private fun createKafkaMessage(messageDto: OutboxMessage): Message<ByteArray> =
        MessageBuilder
            .withPayload(messageDto.payload)
            .setHeader(KafkaHeaders.TOPIC, messageDto.topic)
            .setHeader(KafkaHeaders.KEY, messageDto.aggregateId) 
            .also { builder ->
                messageDto.headers.forEach { (key, value) ->
                    builder.setHeader(key, value)
                }
            }.build()

    
    
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/config/KafkaOutboxProducerConfig.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/config/KafkaOutboxProducerConfig.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.kafka.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Kafka Producer Configuration specifically for the Outbox module.
 * Configures KafkaTemplate to send raw byte arrays (Rule 129).
 */
@Configuration
class KafkaOutboxProducerConfig(
    @Value("\${spring.kafka.bootstrap-servers}")
    private val bootstrapServers: String,
) {
    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> {
        val configProps =
            mapOf(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG to true,
                ProducerConfig.ACKS_CONFIG to "all",
                ProducerConfig.RETRIES_CONFIG to 3,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1,
            )
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun kafkaTemplate(producerFactory: ProducerFactory<String, ByteArray>): KafkaTemplate<String, ByteArray> =
        KafkaTemplate(producerFactory)
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/converter/StringMapConverter.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/converter/StringMapConverter.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.persistence.converter

import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.ObjectMapper
import jakarta.persistence.AttributeConverter
import jakarta.persistence.Converter

@Converter
class StringMapConverter : AttributeConverter<Map<String, String>, String> {
    private val objectMapper = ObjectMapper()

    override fun convertToDatabaseColumn(attribute: Map<String, String>?): String =
        if (attribute == null) {
            "{}"
        } else {
            try {
                objectMapper.writeValueAsString(attribute)
            } catch (e: Exception) {
                throw IllegalArgumentException("Error converting map to JSON", e)
            }
        }

    override fun convertToEntityAttribute(dbData: String?): Map<String, String> =
        if (dbData.isNullOrBlank()) {
            emptyMap()
        } else {
            try {
                objectMapper.readValue(dbData, object : TypeReference<Map<String, String>>() {})
            } catch (e: Exception) {
                throw IllegalArgumentException("Error converting JSON to map", e)
            }
        }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/extensions/OutboxEventEntityExtensions.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/extensions/OutboxEventEntityExtensions.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.persistence.extensions

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity

fun OutboxEventEntity.toDomain(): OutboxMessage =
    OutboxMessage(
        id = this.id, // dbId 대신 id 사용, nullable이므로 그대로 전달
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.eventType, // eventType 추가
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        lastAttemptTime = this.lastAttemptTime,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

fun OutboxMessage.toNewEntity(): OutboxEventEntity =
    OutboxEventEntity(
        // id는 DB에서 자동 생성되므로 null
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.eventType, // eventType 추가
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        lastAttemptTime = this.lastAttemptTime,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt ?: java.time.Instant.now(), // updatedAt이 null이면 현재 시간 사용
    )

fun OutboxMessage.toExistingEntity(existingEntity: OutboxEventEntity): OutboxEventEntity {
    existingEntity.status = this.status
    existingEntity.retryCount = this.retryCount
    existingEntity.lastAttemptTime = this.lastAttemptTime
    existingEntity.updatedAt = this.updatedAt ?: java.time.Instant.now()
    // payload, topic, headers, aggregateId, aggregateType, eventType, createdAt 등은 일반적으로 변경되지 않음
    return existingEntity
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/JpaOutboxEventRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/JpaOutboxEventRepository.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.persistence.repository

import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

@Repository
interface JpaOutboxEventRepository : JpaRepository<OutboxEventEntity, Long> {
    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    fun findTopByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    fun findByStatusAndRetryCountGreaterThanEqual(
        status: OutboxMessageStatus,
        retryCount: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 특정 상태의 메시지들을 조회하되, 재시도 횟수가 특정 값 미만인 메시지들만 조회합니다.
     * 이 메서드는 주로 실패한 메시지 중 아직 재시도 한도에 도달하지 않은 메시지를 찾는데 사용될 수 있습니다.
     */
    @Query(
        "SELECT oe FROM OutboxEventEntity oe WHERE oe.status = :status AND oe.retryCount < :maxRetries ORDER BY oe.createdAt ASC",
    )
    fun findByStatusAndRetryCountLessThan(
        @Param("status") status: OutboxMessageStatus, // OutboxMessageStatus로 수정
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    /**
     * 처리되지 않은 이벤트를 조회하며 비관적 잠금을 사용합니다. (SKIP LOCKED 사용)
     * 데이터베이스에 따라 @QueryHint 사용이 필요할 수 있습니다.
     * 예시: PostgreSQL의 경우 FOR UPDATE SKIP LOCKED
     * Spring Data JPA 3.x 이상에서는 @Lock(LockModeType.PESSIMISTIC_WRITE)와 함께
     * spring.jpa.properties.jakarta.persistence.lock.timeout=0 (또는 DB 특화 힌트) 설정 고려.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT e FROM OutboxEventEntity e WHERE e.status = com.restaurant.outbox.application.port.model.OutboxMessageStatus.PENDING ORDER BY e.createdAt ASC")
    fun findUnprocessedEventsWithLock(pageable: Pageable): List<OutboxEventEntity>
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/JpaOutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/JpaOutboxMessageRepository.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.persistence.repository

import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.time.Instant

interface JpaOutboxMessageRepository : JpaRepository<OutboxEventEntity, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND (e.lastAttemptTime IS NULL OR e.lastAttemptTime < :cutoffTime)
        AND e.retryCount < :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findMessagesToProcess(
        @Param("status") status: OutboxMessageStatus,
        @Param("cutoffTime") cutoffTime: Instant,
        @Param("maxRetries") maxRetries: Int = 3,
    ): List<OutboxEventEntity>

    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    @Query("SELECT COUNT(e) FROM OutboxEventEntity e WHERE e.status = :status")
    fun countByStatus(
        @Param("status") status: OutboxMessageStatus,
    ): Long

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND e.retryCount >= :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findFailedMessagesExceedingRetryCount(
        @Param("status") status: OutboxMessageStatus,
        @Param("maxRetries") maxRetries: Int,
        @Param("limit") limit: Int,
    ): List<OutboxEventEntity>
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/OutboxMessageRepositoryImpl.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/OutboxMessageRepositoryImpl.kt
 Timestamp: 2025-05-13 19:28:12
====================================================================
package com.restaurant.outbox.infrastructure.persistence.repository

import com.restaurant.outbox.application.port.OutboxMessageRepository
import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.persistence.extensions.toDomain
import com.restaurant.outbox.infrastructure.persistence.extensions.toNewEntity
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant

@Repository
class OutboxMessageRepositoryImpl(
    private val jpaOutboxEventRepository: JpaOutboxEventRepository,
) : OutboxMessageRepository {

    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        val entity = message.toNewEntity() 
        val savedEntity = jpaOutboxEventRepository.save(entity)
        return savedEntity.toDomain() 
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>) { 
        val entities = messages.map { it.toNewEntity() } 
        jpaOutboxEventRepository.saveAll(entities)
    }

    @Transactional(readOnly = true)
    override fun findById(id: Long): OutboxMessage? {
        return jpaOutboxEventRepository.findById(id).map { it.toDomain() }.orElse(null) 
    }

    @Transactional(readOnly = true)
    override fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage> {
        return jpaOutboxEventRepository.findByStatus(status).map { it.toDomain() } 
    }

    @Transactional
    override fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean, 
    ): OutboxMessage? {
        val entity = jpaOutboxEventRepository.findById(id).orElse(null) ?: return null
        entity.status = newStatus
        if (incrementRetry) {
            entity.retryCount += 1
        }
        entity.lastAttemptTime = Instant.now()
        entity.updatedAt = Instant.now()
        val savedEntity = jpaOutboxEventRepository.save(entity)
        return savedEntity.toDomain() 
    }

    @Transactional(readOnly = true)
    override fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> {
        return jpaOutboxEventRepository.findByStatusAndRetryCountGreaterThanEqual(
            OutboxMessageStatus.FAILED,
            maxRetries,
            PageRequest.of(0, limit)
        ).map { it.toDomain() } 
    }

    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> {
        val pageable: Pageable = PageRequest.of(0, limit)
        val entitiesToProcess = if (status == OutboxMessageStatus.PENDING) {
            jpaOutboxEventRepository.findUnprocessedEventsWithLock(pageable)
        } else {
            jpaOutboxEventRepository.findTopByStatusOrderByCreatedAtAsc(status, pageable)
        }

        return entitiesToProcess.mapNotNull { entity: OutboxEventEntity ->
            try {
                entity.status = OutboxMessageStatus.PROCESSING
                entity.lastAttemptTime = Instant.now()
                entity.updatedAt = Instant.now()
                val savedEntity = jpaOutboxEventRepository.save(entity)
                savedEntity.toDomain() 
            } catch (e: Exception) {
                
                null
            }
        }
    }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long {
        return jpaOutboxEventRepository.countByStatus(status)
    }

    @Transactional
    override fun incrementRetryCount(id: Long): OutboxMessage? {
        val entity = jpaOutboxEventRepository.findById(id).orElse(null) ?: return null
        entity.retryCount += 1
        entity.lastAttemptTime = Instant.now()
        entity.updatedAt = Instant.now()
        val savedEntity = jpaOutboxEventRepository.save(entity)
        return savedEntity.toDomain() 
    }

    @Transactional(readOnly = true)
    override fun findUnprocessedMessages(batchSize: Int): List<OutboxMessage> {
        return jpaOutboxEventRepository
            .findTopByStatusOrderByCreatedAtAsc(OutboxMessageStatus.PENDING, PageRequest.of(0, batchSize))
            .map { it.toDomain() } 
    }

    @Transactional
    override fun updateMessageStatus(
        messageId: Long,
        status: OutboxMessageStatus,
        retryCount: Int,
    ) {
        val entity =
            jpaOutboxEventRepository.findById(messageId).orElseThrow {
                IllegalArgumentException("Message not found with id: $messageId")
            }

        entity.status = status
        entity.retryCount = retryCount
        entity.lastAttemptTime = Instant.now()
        entity.updatedAt = Instant.now()

        jpaOutboxEventRepository.save(entity)
    }

    @Transactional(readOnly = true)
    override fun findByStatusAndRetryCountLessThan(
        status: OutboxMessageStatus,
        maxRetries: Int,
        limit: Int
    ): List<OutboxMessage> {
        val pageable: Pageable = PageRequest.of(0, limit)
        return jpaOutboxEventRepository.findByStatusAndRetryCountLessThan(status, maxRetries, pageable)
            .map { it.toDomain() } 
    }
}

====================================================================n


====================================================================
 File: settings.gradle.kts
 Path: settings.gradle.kts
 Timestamp: 2025-05-13 19:28:12
====================================================================
import org.gradle.api.initialization.resolve.RepositoriesMode

/**
 * settings.gradle.kts for the project.
 *
 * Configures plugin repositories and project structure for Gradle.
 *
 * @author junoko
 */

rootProject.name = "restaurant"

pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

@Suppress("UnstableApiUsage")
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)
    repositories { 
        mavenCentral()
        maven { url = uri("https://maven.pkg.jetbrains.space/public/p/kotlinx-html/maven") }  // Add JetBrains repo for Kotlin
        maven { url = uri("https://packages.confluent.io/maven/") }
        // Spring Milestones and Snapshots for Spring Cloud compatibility if needed in the future
        // maven { url = uri("https://repo.spring.io/milestone") }
    }
}

// Common modules
include(":domains:common:domain")
include(":domains:common:application")
include(":domains:common:infrastructure")
include(":domains:common:presentation")

// User modules
include(":domains:user:domain")
include(":domains:user:application")
include(":domains:user:infrastructure:persistence")
include(":domains:user:infrastructure:messaging")
include(":domains:user:presentation")

// Independent modules
include(":independent:outbox")

// Application modules
include(":apps:user-app")

====================================================================n

==============================================================
 File Collection Completed: 2025-05-14 04:28:12 
==============================================================
