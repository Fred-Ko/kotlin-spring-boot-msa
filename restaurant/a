모듈들의 전체 코드가 첨부되어있다.
코드를 보면 불완전 한 부분도 있고 규칙을 지키지 않는 부분도 있다.
따라서 코드에 기준으로 작업을 완료하려고 하면 완성이 안될꺼다. 왜냐하면 코드가 정말 엉망이기 떄문이다. 어떤 요구사항인지 잘생각해서 수정계획을 해야한다.
그래서 이를 수정하기 위한 작업 지시서가 필요하다. 작업 지시서를 만들어라.
- tree 구조를 보고 규칙에 맞지않는 부분을 찾아서 삭제할 파일, 이동할 파일에 대한 작업지시서는 최우선이다. 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 규칙을 지키지 않는 부분에 대한 작업지시서를 작성하라
- 프로그램이 정상적으로 동작하기위해 추가적으로 작업해야하는 작업지시서를 작성하라
- 작업지시서는 단계가 명확하게 표현되어야 한다. 하지만 작업의 순서를 잘생각해서 먼저되어야 하는건 꼭 먼저하도록 단계를 잘 생각하라.
- build.gradle.kts는 최상위 파일에 공통부분을 최대한 모아놓고 각 모듈별로 필요한 부분은 모듈 내부에 작성한다.
- 작업지시서에서는 Gradle 의존성에 대한 버전에 대해서 지적하지 않는다. 모두 최신버전으로 팀내에서 직접 관리하는 영역이다.
- 필요없는 파일은 삭제하도록 지시하라.
- 필요없는 코드는 주석보단 삭제를 하도록 지시하라.
- 현재 코드를 유지하는 경우는 작업지시서에 굳이 명시하지 않아도 된다.
- 작업지시서는 ~을 확인해라. 같은 모호한 문장은 절대로 안된다. ~을 어떻게 고쳐라 같이 매우 명시적이여야 한다.
- 작업지시서는 어떤 파일이 어떤 부분이 잘못작성되었고 어떻게 고쳐야한다. 그리고 근거는 무엇이다 라는 명시적 문장이 있어야 한다.
- 작업지시서에 코드 레벨을 너무 자세하게 설명하지 않아도 된다.
- 작업지시서 제일 하단에는 모든 작업이 끝나고 확인해야할 체크리스트를 작성한다.
- 이프로젝트는 Kotlin 으로 작성되어있다. Java는 사용하지 않는다.
- 최신 스테이블 버전 목록은 작업지시서에 생략하지 않고 꼭 기입한다.

작업 지시서에 항상 상단에 첨부할 문구
```
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.

작업시 항상 기억해야할 규칙
- 파일을 수정할때는 import 구문이 완벽한지 한번씩 더 체크하도록 한다. 만약 확인이 필요하다면 다른 파일을 조회할 수 있다.
- 작업을 진행하는 도중에 작업지시서에 없는 수정사항은 일단 보류하고 작업지시서를 최우선으로 수정한다.
- 이런식의 참조는 금지한다. ( ex -> event: com.restaurant.domains.common.domain.event.DomainEvent ) 항상 import 구문을 추가해서 참조하도록 한다.
- com.restaurant.domains.common.* 과 같은 import는 절대로 금지한다.
- 공통으로 수정해야할 패턴이 확실하다면 커맨드 명령어로 한번에 처리한다. 단, 프로젝트 내부에 build,bin 같은 제외할 경로는 명확히 명시한다.
- 필요없는 코드는 주석처리 하지 말고 삭제하도록 하라.
- 파일을 생성 할때는 위치가 올바른지 확인하기 위해서 파일 구조도를 참고하도록 한다.
- 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 의존성 버전은 항상 tools 이용해서 최신 스테이블 버전을 활용하도록 한다.
- 확인하고 싶은 디렉토리 구조가 있다면 tree 명령어로 최대한 효율적이게 진행하라. 단 bin,build 는 제외한다.
- 패키지나 폴더 경로에 in은 예약어이니 input이나 이런걸로 피하라.
```

====================================================================n


[Incubating] Problems report is available at: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/build/reports/problems/problems-report.html

FAILURE: Build failed with an exception.

* What went wrong:
Invalid catalog definition:
  - Problem: In version catalog libs, you can only call the 'from' method a single time.
    
    Reason: The method was called more than once.
    
    Possible solution: Remove further usages of the method call.
    
    For more information, please refer to https://docs.gradle.org/8.14/userguide/version_catalog_problems.html#too_many_import_invocation in the Gradle documentation.

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 278ms


==============================================================
 Gradle Build Completed: 2025-05-11 20:28:27 
==============================================================


[Incubating] Problems report is available at: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/build/reports/problems/problems-report.html

FAILURE: Build failed with an exception.

* What went wrong:
Invalid catalog definition:
  - Problem: In version catalog libs, you can only call the 'from' method a single time.
    
    Reason: The method was called more than once.
    
    Possible solution: Remove further usages of the method call.
    
    For more information, please refer to https://docs.gradle.org/8.14/userguide/version_catalog_problems.html#too_many_import_invocation in the Gradle documentation.

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 254ms


==============================================================
 ktlintFormat Completed: 2025-05-11 20:28:28 
==============================================================


==============================================================

# Project Structure

domains
├── common
│   ├── application
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── application
│   │                               └── exception
│   │                                   └── ApplicationException.kt
│   ├── domain
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── domain
│   │                               ├── aggregate
│   │                               │   └── AggregateRoot.kt
│   │                               ├── error
│   │                               │   ├── CommonSystemErrorCode.kt
│   │                               │   └── ErrorCode.kt
│   │                               ├── event
│   │                               │   └── DomainEvent.kt
│   │                               └── exception
│   │                                   └── DomainException.kt
│   ├── infrastructure
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           ├── avro
│   │           │   └── com
│   │           │       └── restaurant
│   │           │           └── common
│   │           │               └── infrastructure
│   │           │                   └── avro
│   │           ├── kotlin
│   │           │   └── com
│   │           │       └── restaurant
│   │           │           └── common
│   │           │               └── infrastructure
│   │           │                   └── persistence
│   │           │                       └── entity
│   │           │                           └── BaseEntity.kt
│   │           └── resources
│   └── presentation
│       ├── build.gradle.kts
│       └── src
│           └── main
│               ├── kotlin
│               │   └── com
│               │       └── restaurant
│               │           └── common
│               │               └── presentation
│               │                   ├── GlobalExceptionHandler.kt
│               │                   ├── config
│               │                   │   └── SecurityConfig.kt
│               │                   ├── dto
│               │                   │   └── response
│               │                   │       └── CommandResultResponse.kt
│               │                   └── filter
│               │                       └── CorrelationIdFilter.kt
│               └── resources
└── user
    ├── application
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── application
    │                               ├── dto
    │                               │   ├── command
    │                               │   │   ├── ChangePasswordCommand.kt
    │                               │   │   ├── DeleteAddressCommand.kt
    │                               │   │   ├── DeleteUserCommand.kt
    │                               │   │   ├── LoginCommand.kt
    │                               │   │   ├── RegisterAddressCommand.kt
    │                               │   │   ├── RegisterUserCommand.kt
    │                               │   │   ├── UpdateAddressCommand.kt
    │                               │   │   └── UpdateProfileCommand.kt
    │                               │   └── query
    │                               │       ├── GetUserProfileByIdQuery.kt
    │                               │       ├── LoginResult.kt
    │                               │       └── UserProfileDto.kt
    │                               ├── error
    │                               │   └── UserApplicationErrorCode.kt
    │                               ├── exception
    │                               │   └── UserApplicationException.kt
    │                               ├── port
    │                               │   └── input
    │                               │       ├── ChangePasswordUseCase.kt
    │                               │       ├── DeleteAddressUseCase.kt
    │                               │       ├── DeleteUserUseCase.kt
    │                               │       ├── GetUserProfileQuery.kt
    │                               │       ├── LoginUseCase.kt
    │                               │       ├── RegisterAddressUseCase.kt
    │                               │       ├── RegisterUserUseCase.kt
    │                               │       ├── UpdateAddressUseCase.kt
    │                               │       └── UpdateProfileUseCase.kt
    │                               └── usecase
    │                                   ├── ChangePasswordCommandHandler.kt
    │                                   ├── DeleteAddressCommandHandler.kt
    │                                   ├── DeleteUserCommandHandler.kt
    │                                   ├── GetUserProfileQueryHandler.kt
    │                                   ├── LoginCommandHandler.kt
    │                                   ├── RegisterAddressCommandHandler.kt
    │                                   ├── RegisterUserCommandHandler.kt
    │                                   ├── UpdateAddressCommandHandler.kt
    │                                   └── UpdateProfileCommandHandler.kt
    ├── domain
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── domain
    │                               ├── aggregate
    │                               │   ├── User.kt
    │                               │   ├── UserStatus.kt
    │                               │   └── UserType.kt
    │                               ├── entity
    │                               │   └── Address.kt
    │                               ├── error
    │                               │   └── UserDomainErrorCodes.kt
    │                               ├── event
    │                               │   └── UserEvent.kt
    │                               ├── exception
    │                               │   └── UserDomainException.kt
    │                               ├── repository
    │                               │   └── UserRepository.kt
    │                               └── vo
    │                                   ├── AddressId.kt
    │                                   ├── Email.kt
    │                                   ├── Name.kt
    │                                   ├── Password.kt
    │                                   ├── PhoneNumber.kt
    │                                   ├── UserId.kt
    │                                   └── Username.kt
    ├── infrastructure
    │   ├── messaging
    │   │   ├── build.gradle.kts
    │   │   └── src
    │   │       └── main
    │   │           ├── avro
    │   │           │   └── com
    │   │           │       └── restaurant
    │   │           │           └── user
    │   │           │               └── infrastructure
    │   │           │                   └── messaging
    │   │           │                       └── avro
    │   │           │                           └── event
    │   │           ├── kotlin
    │   │           │   └── com
    │   │           │       └── restaurant
    │   │           │           └── user
    │   │           │               └── infrastructure
    │   │           │                   └── messaging
    │   │           │                       └── serialization
    │   │           │                           └── OutboxMessageFactory.kt
    │   │           └── resources
    │   └── persistence
    │       ├── build.gradle.kts
    │       └── src
    │           └── main
    │               ├── kotlin
    │               │   └── com
    │               │       └── restaurant
    │               │           └── user
    │               │               └── infrastructure
    │               │                   └── persistence
    │               │                       ├── entity
    │               │                       │   ├── AddressEntity.kt
    │               │                       │   └── UserEntity.kt
    │               │                       ├── extensions
    │               │                       │   ├── AddressEntityExtensions.kt
    │               │                       │   └── UserEntityExtensions.kt
    │               │                       └── repository
    │               │                           ├── SpringDataJpaUserRepository.kt
    │               │                           └── UserRepositoryImpl.kt
    │               └── resources
    └── presentation
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── user
                                └── presentation
                                    └── v1
                                        ├── api
                                        │   ├── UserAddressController.kt
                                        │   ├── UserController.kt
                                        │   └── UserQueryController.kt
                                        ├── dto
                                        │   ├── request
                                        │   │   ├── ChangePasswordRequestV1.kt
                                        │   │   ├── DeleteUserRequestV1.kt
                                        │   │   ├── LoginRequestV1.kt
                                        │   │   ├── RegisterAddressRequestV1.kt
                                        │   │   ├── RegisterUserRequestV1.kt
                                        │   │   ├── UpdateAddressRequestV1.kt
                                        │   │   └── UpdateProfileRequestV1.kt
                                        │   └── response
                                        │       ├── AddressResponseV1.kt
                                        │       ├── LoginResponseV1.kt
                                        │       └── UserProfileResponseV1.kt
                                        └── extensions
                                            ├── command
                                            │   └── dto
                                            │       └── request
                                            │           └── UserCommandRequestExtensions.kt
                                            └── query
                                                └── dto
                                                    └── response
                                                        └── UserQueryResponseExtensions.kt
independent
└── outbox
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── outbox
            │               ├── OutboxApplication.kt
            │               ├── application
            │               │   ├── OutboxPoller.kt
            │               │   └── port
            │               │       ├── OutboxMessageRepository.kt
            │               │       └── model
            │               │           ├── OutboxMessage.kt
            │               │           └── OutboxMessageStatus.kt
            │               ├── infrastructure
            │               │   ├── entity
            │               │   │   └── OutboxEventEntity.kt
            │               │   ├── error
            │               │   │   └── OutboxErrorCodes.kt
            │               │   ├── exception
            │               │   │   └── OutboxException.kt
            │               │   ├── kafka
            │               │   │   ├── OutboxMessageSender.kt
            │               │   │   └── config
            │               │   │       └── KafkaOutboxProducerConfig.kt
            │               │   └── persistence
            │               │       ├── OutboxMessageRepositoryImpl.kt
            │               │       ├── converter
            │               │       │   └── StringMapConverter.kt
            │               │       ├── extensions
            │               │       │   └── OutboxEventEntityExtensions.kt
            │               │       └── repository
            │               │           └── JpaOutboxMessageRepository.kt
            │               └── port
            │                   └── model
            └── resources
                └── db
                    └── migration
apps
└── user-app
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── apps
            │               └── user
            │                   └── UserApplication.kt
            └── resources
gradle
└── wrapper

176 directories, 105 files
==============================================================




====================================================================
 File: apps/user-app/build.gradle.kts
 Path: apps/user-app/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
/*
 * Copyright (c) 2025 junoko. All rights reserved.
 *
 * This file is part of the user-app module.
 */

plugins {
    alias(libs.plugins.spring.boot)
    alias(libs.plugins.spring.dependency.management)
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.kotlin.jpa)
    alias(libs.plugins.kotlin.allopen)
}


dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:infrastructure:persistence"))
    implementation(project(":domains:user:infrastructure:messaging"))
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:common:application"))
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:infrastructure"))
    implementation(project(":domains:common:presentation"))
    implementation(project(":independent:outbox"))

    implementation(libs.spring.boot.starter.web)
    implementation(libs.spring.boot.starter.data.jpa)
    implementation(libs.spring.kafka)
    implementation(libs.spring.boot.starter.security)
    implementation(libs.resilience4j)
    implementation(libs.spring.boot.starter.aop)
    implementation(libs.spring.boot.starter.validation)
    implementation(libs.spring.boot.starter.actuator)
    implementation(libs.springdoc.openapi)

    runtimeOnly(libs.postgresql)

    testImplementation(libs.spring.boot.starter.test) {
        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
    }
    testImplementation(libs.bundles.testcontainers)
}

====================================================================n


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
/**
 * UserApplication entry point for the user service.
 *
 * Configures component scanning and enables scheduling for Outbox Poller.
 *
 * @author junoko
 */
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.scheduling.annotation.EnableScheduling // For Outbox Poller @Scheduled

@SpringBootApplication
// Scan components in config, outbox.infra, user.presentation, user.application, user.infra
@ComponentScan(
    basePackages = [
        "com.restaurant.common.presentation",
        "com.restaurant.user.presentation",
        "com.restaurant.user.application",
        "com.restaurant.user.infrastructure",
        "com.restaurant.outbox.application",
        "com.restaurant.outbox.infrastructure"
    ],
)
// Explicitly enable JPA repositories if not found by default scan
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.user.infrastructure.persistence.repository",
        "com.restaurant.outbox.infrastructure.persistence"
    ],
)
@EnableScheduling // Enable @Scheduled tasks (for Outbox Poller)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

====================================================================n


====================================================================
 File: build.gradle.kts
 Path: build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
/**
 * build.gradle.kts for the root project.
 *
 * Configures plugins, dependency management, and global build settings.
 *
 * @author junoko
 */

plugins {
    alias(libs.plugins.kotlin.jvm) apply false
    alias(libs.plugins.kotlin.spring) apply false
    alias(libs.plugins.kotlin.jpa) apply false
    alias(libs.plugins.kotlin.allopen) apply false
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management) apply false
    alias(libs.plugins.ktlint) apply false
    alias(libs.plugins.avro) apply false
}

allprojects {
    group = "com.restaurant"
    version = "1.0.0-SNAPSHOT"
}

subprojects {
    repositories {
        mavenCentral()
        maven {
            url = uri("https://packages.confluent.io/maven/")
        }
    }

    apply(plugin = libs.plugins.ktlint.get().pluginId)
}

====================================================================n


====================================================================
 File: domains/common/application/build.gradle.kts
 Path: domains/common/application/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
}


dependencies {
    implementation(project(":domains:common:domain"))

    implementation(libs.bundles.kotlin.base)
    implementation(libs.kotlin.logging)
    implementation(libs.spring.boot.starter)
    implementation(libs.resilience4j)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
}




====================================================================n


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.application.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom application exceptions.
 * Represents errors occurring in the application layer (e.g., use case execution failures).
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class ApplicationException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this application exception.
     */
    abstract val errorCode: ErrorCode
}

====================================================================n


====================================================================
 File: domains/common/domain/build.gradle.kts
 Path: domains/common/domain/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
}



dependencies {
    implementation(libs.bundles.kotlin.base)
    implementation(libs.kotlin.logging)
    implementation(libs.jakarta.validation.api)
    implementation(libs.jakarta.persistence.api)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
}


====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

/**
 * Base class for all Aggregate Roots.
 * Provides methods to manage domain events.
 * Rule 17, 18
 */
abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    /**
     * Returns the list of recorded domain events.
     */
    fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    /**
     * Clears the list of recorded domain events.
     */
    fun clearDomainEvents() {
        domainEvents.clear()
    }

    /**
     * Adds a domain event to the list of recorded events.
     * This method is internal to ensure it's only called within the Aggregate implementation.
     */
    internal fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.domain.error

/**
 * Common system-level error codes.
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    INTERNAL_SERVER_ERROR("COMMON-001", "Internal server error"),
    INVALID_REQUEST("COMMON-002", "Invalid request"),
    RESOURCE_NOT_FOUND("COMMON-003", "Resource not found"),
    UNAUTHORIZED("COMMON-004", "Unauthorized"),
    FORBIDDEN("COMMON-005", "Forbidden"),
    VALIDATION_ERROR("COMMON-006", "Validation error"),
    CONFLICT("COMMON-007", "Conflict"),
    TOO_MANY_REQUESTS("COMMON-008", "Too many requests"),
    SERVICE_UNAVAILABLE("COMMON-009", "Service unavailable"),
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.domain.error

/**
 * Base interface for all error codes in the system.
 * Error codes should follow the format: {DOMAIN}-{LAYER}-{CODE}
 */
interface ErrorCode {
    /**
     * The unique code for this error.
     * Format: {DOMAIN}-{LAYER}-{CODE}
     * Example: USER-DOMAIN-001, USER-APP-002
     */
    val code: String

    /**
     * A human-readable message describing this error.
     */
    val message: String
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.domain.event

import java.time.Instant
import java.util.UUID

/**
 * Base interface for domain events. (Rule 32)
 */
interface DomainEvent {
    val eventId: UUID
    val occurredAt: Instant
    val aggregateId: String
    val aggregateType: String
}

====================================================================n


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.domain.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom domain exceptions.
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
open class DomainException(
    val errorCode: ErrorCode,
    override val message: String = errorCode.message,
    cause: Throwable? = null,
) : RuntimeException(message, cause)

====================================================================n


====================================================================
 File: domains/common/infrastructure/build.gradle.kts
 Path: domains/common/infrastructure/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    kotlin("jvm")
    
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("plugin.allopen")
    alias(libs.plugins.avro)
}



dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    
    implementation("org.jetbrains.kotlin:kotlin-stdlib")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("io.github.microutils:kotlin-logging-jvm:3.0.5")
    
    // Spring
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework:spring-tx")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    
    // Database
    implementation("org.postgresql:postgresql")
    implementation("com.zaxxer:HikariCP")
    
    // Kafka & Avro
    implementation("org.apache.kafka:kafka-clients")
    implementation("org.apache.avro:avro")
    implementation("io.confluent:kafka-avro-serializer:7.6.3")
    
    // Test
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.kotest:kotest-runner-junit5:5.9.1")
    testImplementation("io.kotest:kotest-assertions-core:5.9.1")
    testImplementation("io.mockk:mockk:1.13.9")
    testImplementation("org.testcontainers:postgresql:1.20.2")
    testImplementation("org.testcontainers:kafka:1.20.2")
    testImplementation("org.testcontainers:junit-jupiter:1.20.2")
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}







// Configure Avro plugin
avro {
    setCreateSetters(false)
    setFieldVisibility("PRIVATE")
    setOutputCharacterEncoding("UTF-8")
    stringType = "String"
}

sourceSets {
    main {
        kotlin.srcDirs("src/main/kotlin", "build/generated-src/avro/main/java")
    }
}

====================================================================n


====================================================================
 File: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/persistence/entity/BaseEntity.kt
 Path: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/persistence/entity/BaseEntity.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.infrastructure.persistence.entity

import jakarta.persistence.Column
import jakarta.persistence.MappedSuperclass
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import java.time.Instant

/**
 * Base entity class for JPA entities providing common fields like
 * creation and update timestamps.
 */
@MappedSuperclass
abstract class BaseEntity {
    @Column(name = "created_at", nullable = false, updatable = false)
    var createdAt: Instant = Instant.now()
        protected set

    @Column(name = "updated_at", nullable = false)
    var updatedAt: Instant = Instant.now()
        protected set

    @PrePersist
    protected fun onCreate() {
        createdAt = Instant.now()
        updatedAt = Instant.now()
    }

    @PreUpdate
    protected fun onUpdate() {
        updatedAt = Instant.now()
    }
}

====================================================================n


====================================================================
 File: domains/common/presentation/build.gradle.kts
 Path: domains/common/presentation/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
}



dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))

    implementation(libs.bundles.kotlin.base)
    implementation(libs.kotlin.logging)
    implementation(libs.spring.boot.starter.web)
    implementation(libs.spring.boot.starter.validation)
    implementation(libs.spring.boot.starter.hateoas)
    implementation(libs.spring.boot.starter.security)
    implementation(libs.jakarta.persistence.api)
    implementation(libs.kotlin.logging)
    implementation(libs.springdoc.openapi)
    implementation(libs.jackson.kotlin)
    implementation(libs.jackson.jsr310)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
}

kotlin {
    jvmToolchain(21)
    compilerOptions {
        freeCompilerArgs.add("-Xjsr305=strict")
    }
}







====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.presentation

import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.common.domain.exception.DomainException
import jakarta.persistence.OptimisticLockException
import mu.KotlinLogging
import org.slf4j.MDC
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler
import java.time.OffsetDateTime
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestControllerAdvice
@Order(Ordered.HIGHEST_PRECEDENCE)
class GlobalExceptionHandler : ResponseEntityExceptionHandler() {
    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValid(ex: MethodArgumentNotValidException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST)
        problemDetail.title = "Validation Failed"
        problemDetail.detail = ex.bindingResult.fieldErrors.joinToString(", ") { it.defaultMessage ?: it.field }
        problemDetail.setProperty(
            "invalid-params",
            ex.bindingResult.fieldErrors.map { fieldError ->
                mapOf(
                    "field" to fieldError.field,
                    "rejectedValue" to fieldError.rejectedValue,
                    "message" to (fieldError.defaultMessage ?: ""),
                )
            },
        )
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException::class)
    fun handleTypeMismatch(ex: MethodArgumentTypeMismatchException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST)
        problemDetail.title = "Type Mismatch"
        problemDetail.detail = ex.message ?: ""
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(ex: DomainException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(mapDomainExceptionToStatus(ex))
        problemDetail.title = ex.errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", ex.errorCode.code)
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(ex: ApplicationException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(mapApplicationExceptionToStatus(ex))
        problemDetail.title = ex.errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", ex.errorCode.code)
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(OptimisticLockException::class)
    fun handleOptimisticLockException(ex: OptimisticLockException): ProblemDetail {
        val problemDetail = ProblemDetail.forStatus(HttpStatus.CONFLICT)
        problemDetail.title = "Optimistic Lock Error"
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", "COMMON-SYSTEM-OPTIMISTIC-LOCK-ERROR")
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception): ProblemDetail {
        log.error(ex) { "Unhandled exception: ${ex.message}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR)
        problemDetail.title = "Internal Server Error"
        problemDetail.detail = ex.message ?: ""
        setCommonProblemProperties(problemDetail)
        return problemDetail
    }

    private fun setCommonProblemProperties(problemDetail: ProblemDetail) {
        problemDetail.setProperty("timestamp", OffsetDateTime.now().toString())
        problemDetail.setProperty("correlationId", getCorrelationId())
    }

    private fun getCorrelationId(): String =
        try {
            val mdc = org.slf4j.MDC.getCopyOfContextMap()
            mdc?.get("correlationId") ?: UUID.randomUUID().toString()
        } catch (e: Exception) {
            UUID.randomUUID().toString()
        }

    private fun mapDomainExceptionToStatus(ex: DomainException): HttpStatus =
        when (ex.errorCode.code) {
            "USER-DOMAIN-NOT-FOUND" -> HttpStatus.NOT_FOUND
            "USER-DOMAIN-VALIDATION" -> HttpStatus.BAD_REQUEST
            else -> HttpStatus.BAD_REQUEST
        }

    private fun mapApplicationExceptionToStatus(ex: ApplicationException): HttpStatus =
        when (ex.errorCode.code) {
            "USER-APPLICATION-BAD-REQUEST" -> HttpStatus.BAD_REQUEST
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }
}

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/SecurityConfig.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/SecurityConfig.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.presentation.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpMethod
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.config.annotation.web.invoke
import org.springframework.security.web.util.matcher.AntPathRequestMatcher


@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) }
            .authorizeHttpRequests { authz ->
                authz.requestMatchers(HttpMethod.POST, "/api/v1/users/register").permitAll()
                authz.requestMatchers(HttpMethod.POST, "/api/v1/users/login").permitAll()
                authz.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                authz.requestMatchers("/actuator/**").permitAll()
                authz.anyRequest().authenticated()
            }
        return http.build()
    }
}

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.presentation.dto.response

import org.springframework.hateoas.RepresentationModel
import java.util.UUID

/**
 * Standard response for command results, including status, message, and correlation ID.
 */
data class CommandResultResponse(
    val status: String = "SUCCESS",
    val message: String,
    val correlationId: String = UUID.randomUUID().toString(),
) : RepresentationModel<CommandResultResponse>()

====================================================================n


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/filter/CorrelationIdFilter.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/filter/CorrelationIdFilter.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.common.presentation.filter

import jakarta.servlet.Filter
import jakarta.servlet.FilterChain
import jakarta.servlet.ServletRequest
import jakarta.servlet.ServletResponse
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.slf4j.MDC
import org.springframework.core.Ordered
import org.springframework.core.annotation.Order
import org.springframework.stereotype.Component
import java.util.UUID

/**
 * A servlet filter that extracts or generates correlation IDs for requests.
 * The correlation ID is used for request tracing across services.
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
class CorrelationIdFilter : Filter {
    companion object {
        const val CORRELATION_ID_HEADER = "X-Correlation-Id"
        const val CORRELATION_ID_MDC_KEY = "correlationId"
    }

    override fun doFilter(
        request: ServletRequest,
        response: ServletResponse,
        chain: FilterChain,
    ) {
        val httpRequest = request as HttpServletRequest
        val httpResponse = response as HttpServletResponse

        try {
            val correlationId = httpRequest.getHeader(CORRELATION_ID_HEADER) ?: UUID.randomUUID().toString()

            MDC.put(CORRELATION_ID_MDC_KEY, correlationId)

            httpResponse.setHeader(CORRELATION_ID_HEADER, correlationId)

            chain.doFilter(request, response)
        } finally {
            MDC.remove(CORRELATION_ID_MDC_KEY)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/build.gradle.kts
 Path: domains/user/application/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
}


dependencies {
    implementation(project(":domains:common:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":independent:outbox"))

    implementation(libs.bundles.kotlin.base)
    implementation(libs.resilience4j)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.kotlin.test.junit5)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

import jakarta.validation.constraints.NotBlank

data class DeleteUserCommand(
    val userId: String,
    val reason: String? = null,
    @field:NotBlank(message = "비밀번호 확인은 필수입니다.")
    val password: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

data class LoginCommand(
    val email: String,
    val password: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size
import jakarta.validation.constraints.Email as JakartaEmail

/**
 * Command DTO for registering a new user.
 * Rule App-Struct (dto/command)
 */
data class RegisterUserCommand(
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:JakartaEmail(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
    val phoneNumber: String?,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.query

data class GetUserProfileByIdQuery(
    val userId: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.query

/**
 * 로그인 결과 DTO (Application Layer)
 */
data class LoginResult(
    val userId: String,
    val username: String,
    val accessToken: String,
    val refreshToken: String,
)

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.dto.query

import java.time.Instant

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val username: String,
    val phoneNumber: String?,
    val userType: String,
    val addresses: List<AddressDto>,
    val createdAt: Instant,
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) {
    data class AddressDto(
        val id: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    BAD_REQUEST("USER-APPLICATION-001", "Bad request received by application."),
    INVALID_INPUT("USER-APPLICATION-002", "Invalid input provided to application."),
    AUTHENTICATION_FAILED("USER-APPLICATION-003", "Authentication failed."),
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-004", "External service communication error."),
    UNEXPECTED_ERROR("USER-APPLICATION-500", "An unexpected error occurred in the application."),
    USER_NOT_FOUND_BY_EMAIL("USER-APPLICATION-005", "User not found by email"),
    INVALID_CREDENTIALS("USER-APPLICATION-006", "Invalid username or password"),
    USER_INACTIVE("USER-APPLICATION-007", "User account is inactive"),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.exception

import com.restaurant.common.domain.error.ErrorCode
import com.restaurant.common.domain.exception.ApplicationException
import com.restaurant.user.application.error.UserApplicationErrorCode

/**
 * User Application 레이어 관련 예외 정의 (Rule 68)
 */
sealed class UserApplicationException(
    final override val errorCode: ErrorCode,
    message: String? = null,
    cause: Throwable? = null,
) : ApplicationException(errorCode, message ?: errorCode.message, cause) {
    /**
     * 인증 실패 관련 예외
     */
    class AuthenticationFailed(
        message: String? = UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.AUTHENTICATION_FAILED, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - e.g., Invalid UUID format
     */
    class BadRequest(
        message: String? = UserApplicationErrorCode.BAD_REQUEST.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.BAD_REQUEST, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - more specific than BadRequest
     */
    class InvalidInput(
        message: String? = UserApplicationErrorCode.INVALID_INPUT.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.INVALID_INPUT, message, cause)

    /**
     * 외부 서비스 연동 오류
     */
    class ExternalServiceError(
        message: String? = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR, message, cause)

    /**
     * 예상치 못한 시스템 오류 (Application 레벨)
     */
    class UnexpectedError(
        message: String? = UserApplicationErrorCode.UNEXPECTED_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.UNEXPECTED_ERROR, message, cause)

    /**
     * Login specific exceptions
     */
    class UserNotFound(
        errorCode: ErrorCode,
        identifier: String,
    ) : UserApplicationException(errorCode, "User not found with identifier: $identifier")

    class InvalidCredentials(
        errorCode: ErrorCode,
    ) : UserApplicationException(errorCode)

    class UserInactive(
        errorCode: ErrorCode,
        userId: String,
    ) : UserApplicationException(errorCode, "User is inactive: $userId")
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/ChangePasswordUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/ChangePasswordUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.ChangePasswordCommand

interface ChangePasswordUseCase {
    fun changePassword(command: ChangePasswordCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/DeleteAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/DeleteAddressUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.DeleteAddressCommand

/**
 * 주소 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteAddressUseCase {
    fun deleteAddress(command: DeleteAddressCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/DeleteUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/DeleteUserUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.DeleteUserCommand

/**
 * 사용자 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteUserUseCase {
    fun deleteUser(command: DeleteUserCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/GetUserProfileQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/GetUserProfileQuery.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto

/**
 * 사용자 프로필 조회 Query UseCase 인터페이스 (Rule App-Struct)
 */
interface GetUserProfileQuery {
    fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/LoginUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/LoginUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult

/**
 * 로그인 유스케이스 인터페이스 (Rule App-Struct)
 * 로그인 결과를 반환하도록 수정 (LoginResult 사용)
 */
interface LoginUseCase {
    fun login(command: LoginCommand): LoginResult
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/RegisterAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/RegisterAddressUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.domain.vo.AddressId

/**
 * 주소 등록 유스케이스 인터페이스 (Rule App-Struct)
 */
interface RegisterAddressUseCase {
    fun registerAddress(command: RegisterAddressCommand): AddressId
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/RegisterUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/RegisterUserUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.domain.vo.UserId

/**
 * 사용자 등록 유스케이스 인터페이스 (Rule App-Struct)
 * 사용자 ID(UserId)를 반환하도록 수정
 */
interface RegisterUserUseCase {
    fun register(command: RegisterUserCommand): UserId
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/UpdateAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/UpdateAddressUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.UpdateAddressCommand

/**
 * 주소 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateAddressUseCase {
    fun updateAddress(command: UpdateAddressCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/UpdateProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/input/UpdateProfileUseCase.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.port.input

import com.restaurant.user.application.dto.command.UpdateProfileCommand

/**
 * 프로필 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateProfileUseCase {
    fun updateProfile(command: UpdateProfileCommand)
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.port.input.ChangePasswordUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : ChangePasswordUseCase {
    @Transactional
    override fun changePassword(command: ChangePasswordCommand) {
        val userId = UserId.ofString(command.userId)
        log.info { "Attempting to change password for user: $userId" }

        val user =
            userRepository.findById(userId)
                ?: throw UserDomainException.User.NotFound(command.userId.toString())

        if (!passwordEncoder.matches(command.currentPassword, user.password.value)) {
            val e = UserDomainException.User.PasswordMismatch()
            log.warn(e) { "Password change failed for userId ${command.userId}: Incorrect current password, errorCode=${e.errorCode.code}" }
            throw e
        }

        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.of(encodedNewPassword)

        val updatedUser = user.changePassword(newPasswordVo)

        userRepository.save(updatedUser)
        log.info { "Password changed successfully for user: $userId" }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.input.DeleteAddressUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) : DeleteAddressUseCase {
    @Transactional
    override fun deleteAddress(command: DeleteAddressCommand) {
        log.info { "Deleting address for userId=${command.userId}, addressId=${command.addressId}" }

        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.deleteAddress(addressIdVo)
            userRepository.save(updatedUser)

            log.info { "Address deleted successfully. userId=${userIdVo.value}, addressId=${addressIdVo.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address deletion for user ${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid ID format during address deletion: userId=${command.userId}, addressId=${command.addressId}" }
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error deleting address for user ${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError("Failed to delete address due to an unexpected error.", e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.port.input.DeleteUserUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : DeleteUserUseCase {
    @Transactional
    override fun deleteUser(command: DeleteUserCommand) {
        val userId = UserId.ofString(command.userId)
        log.info { "Attempting to delete user: $userId" }

        val user =
            userRepository.findById(userId)
                ?: throw UserDomainException.User.NotFound(command.userId)

        if (!passwordEncoder.matches(command.password, user.password.value)) {
            val e = UserDomainException.User.PasswordMismatch()
            log.warn(e) { "User deletion failed for userId ${command.userId}: Incorrect password, errorCode=${e.errorCode.code}" }
            throw e
        }

        val withdrawnUser = user.withdraw()
        userRepository.save(withdrawnUser)
        log.info { "User deleted (withdrawn) successfully: $userId" }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.input.GetUserProfileQuery
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) : GetUserProfileQuery {
    @Transactional(readOnly = true)
    override fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto {
        log.debug { "Fetching user profile for userId=${query.userId}" }

        try {
            val userIdVo = UserId.ofString(query.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val dto =
                UserProfileDto(
                    id = user.id.value.toString(),
                    email = user.email.value,
                    name = user.name.value,
                    username = user.username.value,
                    phoneNumber = user.phoneNumber?.value,
                    userType = user.userType.name,
                    addresses =
                        user.addresses.map {
                            UserProfileDto.AddressDto(
                                id = it.addressId.value.toString(),
                                street = it.street,
                                detail = it.detail,
                                zipCode = it.zipCode,
                                isDefault = it.isDefault,
                            )
                        },
                    createdAt = user.createdAt,
                    updatedAt = user.updatedAt,
                    status = user.status.name,
                    version = user.version,
                )

            log.info { "User profile fetched successfully, userId=${userIdVo.value}" }
            return dto
        } catch (de: UserDomainException.User.NotFound) {
            log.warn { "User profile query failed, user not found: userId=${query.userId}" }
            throw de
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain validation error during profile query for user ${query.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid user ID format for query: ${query.userId}" }
            throw UserApplicationException.BadRequest("Invalid user ID format", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during profile query for user ${query.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError(cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult
import com.restaurant.user.application.error.UserApplicationErrorCode
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.input.LoginUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import mu.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : LoginUseCase {
    @Transactional(readOnly = true)
    override fun login(command: LoginCommand): LoginResult {
        log.info { "Processing login command for email: ${command.email}" }

        val email = Email.of(command.email)

        val user =
            userRepository.findByEmail(email)
                ?: throw UserApplicationException.UserNotFound(UserApplicationErrorCode.USER_NOT_FOUND_BY_EMAIL, command.email)

        if (!passwordEncoder.matches(command.password, user.password.value)) {
            log.warn { "Invalid password attempt for email: ${command.email}" }
            throw UserApplicationException.InvalidCredentials(UserApplicationErrorCode.INVALID_CREDENTIALS)
        }

        if (!user.isActive()) {
            log.warn { "Attempt to login with inactive user: ${command.email}" }
            throw UserApplicationException.UserInactive(UserApplicationErrorCode.USER_INACTIVE, user.id.value.toString())
        }

        val fakeToken = "fake-jwt-token-for-${user.id.value}"

        log.info { "User logged in successfully: ${user.email.value}" }
        return LoginResult(
            userId = user.id.value.toString(),
            username = user.username.value,
            accessToken = fakeToken,
            refreshToken = "fake-refresh-token",
        )
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.input.RegisterAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) : RegisterAddressUseCase {
    @Transactional
    override fun registerAddress(command: RegisterAddressCommand): AddressId {
        log.info { "Registering address for userId=${command.userId}, street=${command.street}, zipCode=${command.zipCode}" }

        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val addressId = AddressId.generate()
            val address =
                Address.create(
                    addressId = addressId,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )
            val updatedUser = user.addAddress(address)
            userRepository.save(updatedUser)

            val addedAddressId = updatedUser.addresses.first { it.addressId == address.addressId }.addressId
            log.info { "Address registered successfully. userId=${userIdVo.value}, addressId=${addedAddressId.value}" }
            return addedAddressId
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address registration for userId=${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid user ID format for address registration: ${command.userId}" }
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during address registration: userId=${command.userId}" }
            throw UserApplicationException.UnexpectedError("Failed to register address due to an unexpected error.", e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.application.port.input.RegisterUserUseCase
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import mu.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : RegisterUserUseCase {
    @Transactional
    override fun register(command: RegisterUserCommand): UserId {
        val username = Username.of(command.username)
        val email = Email.of(command.email)
        val name = Name.of(command.name)
        val password = Password.of(passwordEncoder.encode(command.password))
        val user =
            User.create(
                id = UserId.generate(),
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = null,
            )
        userRepository.save(user)
        log.info { "User registered: ${user.id}" }
        return user.id
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.input.UpdateAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) : UpdateAddressUseCase {
    @Transactional
    override fun updateAddress(command: UpdateAddressCommand) {
        log.info { "Updating address for userId=${command.userId}, addressId=${command.addressId}" }

        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val addressToUpdate =
                Address.create(
                    addressId = addressIdVo,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            val updatedUser = user.updateAddress(addressIdVo, addressToUpdate)

            userRepository.save(updatedUser)
            log.info { "Address updated successfully. userId=${userIdVo.value}, addressId=${addressIdVo.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address update for user ${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid ID format during address update: userId=${command.userId}, addressId=${command.addressId}" }
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error updating address for user ${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError("Failed to update address due to an unexpected error.", e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.port.input.UpdateProfileUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) : UpdateProfileUseCase {
    @Transactional
    override fun updateProfile(command: UpdateProfileCommand) {
        log.info { "Attempting to update profile for userId=${command.userId}" }

        try {
            val userId = UserId.ofString(command.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(userId.toString())

            val updatedName = Name.of(command.name)
            val updatedPhoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }

            val updatedUser =
                user.updateProfile(
                    newName = updatedName,
                    newPhoneNumber = updatedPhoneNumber,
                )

            userRepository.save(updatedUser)
            log.info { "Profile updated successfully for userId=${userId.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during profile update for userId=${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid data during profile update for userId=${command.userId}: ${iae.message}" }
            throw UserApplicationException.BadRequest("Invalid profile data format: ${iae.message}", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during profile update for userId=${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError(cause = e)
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/build.gradle.kts
 Path: domains/user/domain/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
}

dependencies {
    implementation(project(":domains:common:domain"))

    implementation(libs.bundles.kotlin.base)
    implementation("io.github.microutils:kotlin-logging:3.0.5")
    implementation(libs.jakarta.validation.api)
    implementation(libs.jakarta.persistence.api)

    testImplementation(libs.spring.boot.starter.test) {
        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
    }
    testImplementation(libs.kotest.runner)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
}



====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import java.time.Instant

data class User private constructor(
    val id: UserId,
    val username: Username,
    val password: Password,
    val email: Email,
    val name: Name,
    val phoneNumber: PhoneNumber?,
    val userType: UserType,
    val status: UserStatus,
    val addresses: List<Address> = listOf(),
    val defaultAddressId: AddressId? = null,
    val version: Long,
    val createdAt: Instant,
    val updatedAt: Instant,
) : AggregateRoot() {
    fun changePassword(newPassword: Password): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser =
            copy(
                password = newPassword,
                version = this.version + 1,
                updatedAt = Instant.now(),
            )
        updatedUser.addDomainEvent(
            UserEvent.PasswordChanged(
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun updateProfile(
        newName: Name,
        newPhoneNumber: PhoneNumber?,
    ): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser =
            copy(
                name = newName,
                phoneNumber = newPhoneNumber,
                version = this.version + 1,
                updatedAt = Instant.now(),
            )
        updatedUser.addDomainEvent(
            UserEvent.ProfileUpdated(
                name = newName.value,
                phoneNumber = newPhoneNumber?.value,
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun addAddress(addressData: Address): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (addresses.size >= MAX_ADDRESSES) throw UserDomainException.Address.LimitExceeded(MAX_ADDRESSES)
        if (addresses.any { it.addressId == addressData.addressId }) {
            throw UserDomainException.Address.DuplicateAddressId(addressData.addressId.value.toString())
        }
        val newAddresses = addresses.toMutableList()
        if (addressData.isDefault) {
            newAddresses.forEachIndexed { idx, addr -> newAddresses[idx] = addr.copy(isDefault = false) }
        }
        newAddresses.add(addressData)
        val currentDefault = newAddresses.find { it.isDefault }
        val finalDefaultAddressId = currentDefault?.addressId ?: newAddresses.firstOrNull()?.addressId
        val finalAddresses = newAddresses.map { addr -> addr.copy(isDefault = addr.addressId == finalDefaultAddressId) }
        val updatedUser = copy(
            addresses = finalAddresses,
            defaultAddressId = finalDefaultAddressId,
            version = this.version + 1,
            updatedAt = Instant.now(),
        )

        updatedUser.addDomainEvent(
            UserEvent.AddressRegistered(
                address = addressData.toData(),
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun updateAddress(updatedAddressData: Address): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        val addressIndex = addresses.indexOfFirst { it.addressId == updatedAddressData.addressId }
        if (addressIndex == -1) throw UserDomainException.Address.NotFound(updatedAddressData.addressId.value.toString())
        val newAddresses = addresses.toMutableList()
        if (updatedAddressData.isDefault) {
            newAddresses.forEachIndexed { idx, addr -> if (addr.addressId != updatedAddressData.addressId) newAddresses[idx] = addr.copy(isDefault = false) }
        }
        newAddresses[addressIndex] = updatedAddressData
        val currentDefault = newAddresses.find { it.isDefault }
        val finalDefaultAddressId = currentDefault?.addressId ?: if (newAddresses.isNotEmpty()) newAddresses.first().addressId else null
        val finalAddresses = newAddresses.map { addr -> addr.copy(isDefault = addr.addressId == finalDefaultAddressId) }
        val updatedUser = copy(
            addresses = finalAddresses,
            defaultAddressId = finalDefaultAddressId,
            version = this.version + 1,
            updatedAt = Instant.now(),
        )

        updatedUser.addDomainEvent(
            UserEvent.AddressUpdated(
                address = updatedAddressData.toData(),
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun deleteAddress(addressId: AddressId): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        val addressToRemove =
            addresses.find { it.addressId == addressId }
                ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        if (addresses.size == 1) throw UserDomainException.Address.CannotDeleteLast()
        if (addressToRemove.isDefault) throw UserDomainException.Address.CannotDeleteDefault()

        val remainingAddresses = addresses.filterNot { it.addressId == addressId }

        val updatedUser =
            copy(
                addresses = remainingAddresses,
                version = this.version + 1,
                updatedAt = Instant.now(),
            )
        updatedUser.addDomainEvent(
            UserEvent.AddressDeleted(
                addressId = addressId.value.toString(),
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun withdraw(): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (userType == UserType.ADMIN) throw UserDomainException.User.AdminCannotBeWithdrawn()

        val updatedUser =
            copy(
                status = UserStatus.WITHDRAWN,
                version = this.version + 1,
                updatedAt = Instant.now(),
            )
        updatedUser.addDomainEvent(
            UserEvent.Withdrawn(
                userId = this.id,
                occurredAt = updatedUser.updatedAt,
            ),
        )
        return updatedUser
    }

    fun isActive(): Boolean = this.status == UserStatus.ACTIVE


    companion object {
        const val MAX_ADDRESSES = 5

        fun create(
            id: UserId,
            username: Username,
            password: Password,
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType = UserType.CUSTOMER,
            initialAddresses: List<Address> = emptyList(),
        ): User {
            val now = Instant.now()
            if (initialAddresses.count { it.isDefault } > 1) {
                throw UserDomainException.Address.MultipleDefaultsOnInit()
            }
            val defaultAddressId =
                initialAddresses.find { it.isDefault }?.addressId
                    ?: initialAddresses.firstOrNull()?.addressId

            val finalAddresses =
                initialAddresses.map { addr ->
                    if (addr.addressId == defaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
                }

            val user =
                User(
                    id = id,
                    username = username,
                    password = password,
                    email = email,
                    name = name,
                    phoneNumber = phoneNumber,
                    userType = userType,
                    status = UserStatus.ACTIVE,
                    addresses = finalAddresses,
                    defaultAddressId = defaultAddressId,
                    createdAt = now,
                    updatedAt = now,
                    version = 0L,
                )
            user.addDomainEvent(
                UserEvent.Created(
                    username = username.value,
                    email = email.value,
                    name = name.value,
                    phoneNumber = phoneNumber?.value,
                    userType = userType.toString(),
                    userId = id,
                    occurredAt = now,
                ),
            )
            return user
        }

        fun reconstitute(
            id: UserId,
            username: Username,
            password: Password,
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
            addresses: List<Address>,
            status: UserStatus,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): User {
            val defaultAddrId = addresses.find { it.isDefault }?.addressId
            return User(
                id = id,
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = status,
                addresses = addresses,
                defaultAddressId = defaultAddrId,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
        }
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserStatus.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserStatus.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.aggregate

/**
 * Represents the status of a user account.
 */
enum class UserStatus {
    ACTIVE,
    INACTIVE,
    WITHDRAWN,
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserType.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserType.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.aggregate

/**
 * Represents the type of user.
 */
enum class UserType {
    CUSTOMER,
    ADMIN,
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.entity

import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import java.time.Instant

/**
 * Address Domain Entity (Rule 11)
 * User Aggregate에 속하지만 자체 식별자를 가짐.
 */
data class Address private constructor(
    val addressId: AddressId,
    val name: String,
    val streetAddress: String,
    val detailAddress: String?,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
    val version: Long = 0L,
) {
    init {
        if (streetAddress.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Street address cannot be blank.")
        }
        validateZipCode(zipCode)
        if (name.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Name cannot be blank.")
        }
        if (city.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("City cannot be blank.")
        }
        if (state.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("State cannot be blank.")
        }
        if (country.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Country cannot be blank.")
        }
    }

    fun updateDetails(
        name: String,
        streetAddress: String,
        detailAddress: String?,
        city: String,
        state: String,
        country: String,
        zipCode: String,
        isDefault: Boolean,
    ): Address {
        validateZipCode(zipCode)
        if (this.name == name &&
            this.streetAddress == streetAddress &&
            this.detailAddress == detailAddress &&
            this.city == city &&
            this.state == state &&
            this.country == country &&
            this.zipCode == zipCode &&
            this.isDefault == isDefault
        ) {
            return this
        }
        return this.copy(
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun toData(): UserEvent.AddressData =
        UserEvent.AddressData(
            id = addressId.value.toString(),
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
        )

    companion object {
        private fun validateZipCode(zipCode: String) {
            if (zipCode.isBlank() || zipCode.length != 5 || !zipCode.all { it.isDigit() }) {
                throw UserDomainException.Validation.InvalidAddressFormat("Zip code must be 5 digits.")
            }
        }

        fun create(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
        ): Address {
            validateZipCode(zipCode)
            val now = Instant.now()
            return Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = now,
                updatedAt = now,
                version = 0L,
            )
        }

        fun reconstitute(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): Address =
            Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
    }

    fun markAsDefault(): Address {
        if (this.isDefault) return this
        return this.copy(
            isDefault = true,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun markAsNonDefault(): Address {
        if (!this.isDefault) return this
        return this.copy(
            isDefault = false,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum (Rule 67)
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    DUPLICATE_USERNAME("USER-DOMAIN-003", "이미 사용중인 사용자 이름입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-004", "비밀번호가 일치하지 않습니다."),
    USER_ALREADY_WITHDRAWN("USER-DOMAIN-005", "이미 탈퇴한 사용자입니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-006", "주소를 찾을 수 없습니다."),
    DUPLICATE_ADDRESS_ID("USER-DOMAIN-007", "이미 존재하는 주소 ID 입니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-008", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-009", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-010", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_EMAIL_FORMAT("USER-DOMAIN-101", "잘못된 이메일 형식입니다."),
    INVALID_USERNAME_FORMAT("USER-DOMAIN-102", "사용자 이름 형식이 올바르지 않습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-103", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_NAME_FORMAT("USER-DOMAIN-104", "잘못된 이름 형식입니다."),
    INVALID_ADDRESS_FORMAT("USER-DOMAIN-105", "잘못된 주소 형식입니다."),
    INVALID_PHONE_NUMBER_FORMAT("USER-DOMAIN-106", "잘못된 전화번호 형식입니다."),
    INVALID_USER_ID_FORMAT("USER-DOMAIN-107", "잘못된 사용자 ID 형식입니다."),
    INVALID_ADDRESS_ID_FORMAT("USER-DOMAIN-108", "잘못된 주소 ID 형식입니다."),
    ADDRESS_ID_MISMATCH("USER-DOMAIN-201", "주소 ID가 일치하지 않습니다."),
    INVALID_CREDENTIALS("USER-DOMAIN-056", "Invalid credentials"),
    ADMIN_CANNOT_BE_WITHDRAWN("USER-DOMAIN-057", "Admin user cannot be withdrawn"),
    MULTIPLE_DEFAULT_ADDRESSES("USER-DOMAIN-109", "Cannot have multiple default addresses"),
    DEFAULT_ADDRESS_NOT_FOUND("USER-DOMAIN-108", "Default address not found"),
    PERSISTENCE_ERROR("USER-DOMAIN-901", "Persistence error occurred"),
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.vo.UserId
import java.time.Instant
import java.util.UUID

/**
 * Sealed class grouping all domain events related to the User aggregate. (Rule 34)
 */
sealed class UserEvent(
    override val eventId: UUID = UUID.randomUUID(),
    override val occurredAt: Instant,
    open val userId: UserId,
) : DomainEvent {
    override val aggregateId: String
        get() = userId.value.toString()
    override val aggregateType: String
        get() = "User"

    /**
     * User Created Event
     */
    data class Created(
        val username: String,
        val email: String,
        val name: String,
        val phoneNumber: String?,
        val userType: String,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Password Changed Event
     */
    data class PasswordChanged(
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Profile Updated Event
     */
    data class ProfileUpdated(
        val name: String,
        val phoneNumber: String?,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * Represents address data within user events.
     */
    data class AddressData(
        val id: String,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
    )

    /**
     * User Address Added Event
     */
    data class AddressRegistered(
        val address: AddressData,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Address Updated Event
     */
    data class AddressUpdated(
        val address: AddressData,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Address Deleted Event (Renamed from Removed)
     */
    data class AddressDeleted(
        val addressId: String,
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)

    /**
     * User Withdrawn Event (Renamed from UserWithdrawn)
     */
    data class Withdrawn(
        override val userId: UserId,
        override val eventId: UUID = UUID.randomUUID(),
        override val occurredAt: Instant,
    ) : UserEvent(eventId, occurredAt, userId)
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.exception

import com.restaurant.common.domain.exception.DomainException
import com.restaurant.user.domain.error.UserDomainErrorCodes

/**
 * Sealed class representing all possible domain exceptions for the User aggregate. (Rule 68)
 */
sealed class UserDomainException(
    override val errorCode: UserDomainErrorCodes,
    message: String? = errorCode.message,
    cause: Throwable? = null,
) : DomainException(errorCode, message, cause) {
    /**
     * Validation-related exceptions
     */
    sealed class Validation(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class InvalidEmailFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_EMAIL_FORMAT,
                "Invalid email format: $value",
            )

        class InvalidUsernameFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USERNAME_FORMAT,
                "Invalid username format: $value",
            )

        class InvalidUserIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USER_ID_FORMAT,
                "Invalid user ID format: $value",
            )

        class InvalidPasswordFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
                message,
            )

        class InvalidNameFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_NAME_FORMAT,
                "Invalid name format: $value",
            )

        class InvalidPhoneNumberFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PHONE_NUMBER_FORMAT,
                "Invalid phone number format: $value",
            )

        class InvalidAddressFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                message,
            )

        class InvalidAddressIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_ID_FORMAT,
                "Invalid address ID format: $value",
            )
    }

    /**
     * User-related exceptions
     */
    sealed class User(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            userId: String,
        ) : User(
                UserDomainErrorCodes.USER_NOT_FOUND,
                "User not found with ID: $userId",
            )

        class DuplicateUsername(
            username: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_USERNAME,
                "Username already exists: $username",
            )

        class DuplicateEmail(
            email: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_EMAIL,
                "Email already exists: $email",
            )

        class PasswordMismatch : User(UserDomainErrorCodes.PASSWORD_MISMATCH)

        class AlreadyWithdrawn : User(UserDomainErrorCodes.USER_ALREADY_WITHDRAWN)

        class InvalidCredentials(
            username: String,
        ) : User(
                UserDomainErrorCodes.INVALID_CREDENTIALS,
                "Invalid credentials for username: $username",
            )

        class AdminCannotBeWithdrawn :
            User(
                UserDomainErrorCodes.ADMIN_CANNOT_BE_WITHDRAWN,
                "Admin user cannot be withdrawn.",
            )
    }

    /**
     * Address-related exceptions
     */
    sealed class Address(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_NOT_FOUND,
                "Address not found with ID: $addressId",
            )

        class DefaultAddressNotFound(
            message: String = "Default address ID does not exist in the address list.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_NOT_FOUND,
                message,
            )

        class DuplicateAddressId(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.DUPLICATE_ADDRESS_ID,
                "Address ID already exists: $addressId",
            )

        class IdMismatch(
            existingId: String,
            newId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_ID_MISMATCH,
                "Address ID mismatch: expected $existingId, got $newId",
            )

        class LimitExceeded(
            limit: Int,
        ) : Address(
                UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
                "Cannot add more addresses, limit is $limit",
            )

        class CannotDeleteDefault(
            message: String = "Cannot remove the default address.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
                message,
            )

        class CannotDeleteLast(
            message: String = "Cannot remove the last address.",
        ) : Address(
                UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
                message,
            )

        class MultipleDefaultsOnInit(
            val reason: String = "Cannot initialize user with multiple default addresses.",
        ) : Address(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                reason,
            )
    }

    class PersistenceError(
        message: String,
        cause: Throwable? = null,
    ) : UserDomainException(
            UserDomainErrorCodes.PERSISTENCE_ERROR,
            message,
            cause,
        )
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username

/**
 * 사용자 도메인 리포지토리 Port (Domain Layer).
 * 애플리케이션 코어 로직은 이 인터페이스에 의존한다.
 * 실제 구현은 Infrastructure 레이어에서 제공한다.
 */
interface UserRepository {
    /**
     * 사용자를 저장하거나 업데이트한다.
     * @param user 저장 또는 업데이트할 User Aggregate
     * @return 저장된 User Aggregate (Immutable Aggregate 패턴 고려 시 새 인스턴스)
     */
    fun save(user: User): User

    /**
     * 사용자 ID로 사용자를 찾는다.
     * @param id 사용자 ID (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findById(id: UserId): User?

    /**
     * 사용자 이름으로 사용자를 찾는다.
     * @param username 사용자 이름 (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findByUsername(username: Username): User?

    /**
     * 이메일로 사용자를 찾는다.
     * @param email 이메일 (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun existsByUsername(username: Username): Boolean

    fun delete(user: User)
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

@JvmInline
value class AddressId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun ofString(value: String): AddressId =
            try {
                AddressId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidAddressIdFormat(value)
            }

        fun of(value: UUID): AddressId = AddressId(value)

        fun fromUUID(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * Value object representing an email address.
 * This class ensures that the email address is valid according to a basic pattern.
 */
@JvmInline
value class Email private constructor(
    val value: String,
) {
    companion object {
        private val EMAIL_PATTERN =
            Regex(
                "[a-zA-Z0-9+._%\\-]{1,256}" +
                    "@" +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
                    "(" +
                    "\\." +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
                    ")+",
            )

        /**
         * Creates a new Email from a string value.
         * @throws UserDomainException.Validation if the email format is invalid
         */
        fun of(value: String): Email {
            if (!EMAIL_PATTERN.matches(value)) {
                throw UserDomainException.Validation.InvalidEmailFormat(value)
            }
            return Email(value.lowercase())
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Name private constructor(
    val value: String,
) : Serializable {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        private const val MIN_LENGTH = 2
        private const val MAX_LENGTH = 50

        fun of(value: String): Name {
            if (value.isBlank() || value.length < MIN_LENGTH || value.length > MAX_LENGTH) {
                throw UserDomainException.Validation.InvalidNameFormat(
                    "이름은 $MIN_LENGTH 자 이상 $MAX_LENGTH 자 이하이어야 하며, 공백일 수 없습니다: '$value'",
                )
            }
            return Name(value)
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * 비밀번호 Value Object
 */
@JvmInline
value class Password private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password cannot be blank.")
        }
    }

    override fun toString(): String = "********"

    companion object {
        /**
         * Creates a Password VO from a pre-encoded password string.
         * Basic validation is done in the init block.
         */
        fun of(encodedPassword: String): Password = Password(encodedPassword)
    }
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class PhoneNumber private constructor(
    val value: String,
) : Serializable {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^010-?\\d{4}-?\\d{4}$")

        fun of(value: String): PhoneNumber {
            val normalizedValue = value.replace("-", "")
            if (!PHONE_NUMBER_REGEX.matches(value)) {
                throw UserDomainException.Validation.InvalidPhoneNumberFormat("휴대폰 번호 형식이 올바르지 않습니다: $value")
            }

            return PhoneNumber(normalizedValue)
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

/**
 * Value object representing a unique user identifier.
 * This class wraps a UUID and provides type safety and validation.
 */
@JvmInline
value class UserId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        /**
         * Creates a new UserId from a UUID.
         */
        fun of(uuid: UUID): UserId = UserId(uuid)

        /**
         * Creates a new UserId from a string representation of a UUID.
         * @throws UserDomainException.Validation if the string is not a valid UUID
         */
        fun ofString(value: String): UserId =
            try {
                UserId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUserIdFormat(value)
            }

        /**
         * Generates a new random UserId.
         */
        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromUUID(value: UUID): UserId = UserId(value)
    }

    override fun toString(): String = value.toString()
}

====================================================================n


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Username private constructor(
    val value: String,
) : Serializable {
    init {

        if (value.isBlank() || value.length < 3 || value.length > 20) {
            throw UserDomainException.Validation.InvalidUsernameFormat("Username must be between 3 and 20 characters: '$value'")
        }
    }

    companion object {
        fun of(value: String): Username {
            try {
                return Username(value)
            } catch (e: UserDomainException.Validation.InvalidUsernameFormat) {
                throw e
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUsernameFormat("Invalid username format: ${e.message}")
            }
        }
    }

    override fun toString(): String = value
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/build.gradle.kts
 Path: domains/user/infrastructure/messaging/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
    alias(libs.plugins.avro)
}


sourceSets {
    main {
        kotlin.srcDirs("src/main/kotlin", "build/generated-src/avro/main/java")
    }
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:user:domain"))
    implementation(project(":independent:outbox"))

    implementation(libs.bundles.kotlin.base)
    implementation(libs.kotlin.logging)
    implementation(libs.spring.kafka)
    implementation(libs.kafka.clients)
    implementation(libs.avro)
    implementation(libs.kafka.avro.serializer)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
    testImplementation(libs.bundles.testcontainers)
}

kotlin {
    jvmToolchain(21)
    compilerOptions {
        freeCompilerArgs.add("-Xjsr305=strict")
    }
}

tasks.test {
    useJUnitPlatform()
}

avro {
    stringType.set("String")
    fieldVisibility.set("PRIVATE")
}

// Ensure generateAvro task runs before compile tasks

====================================================================n


====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.messaging.serialization

import com.restaurant.common.infrastructure.avro.Envelope
import com.restaurant.outbox.port.model.OutboxMessage
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.infrastructure.messaging.avro.event.UserAddressAdded
import com.restaurant.user.infrastructure.messaging.avro.event.UserAddressDeleted
import com.restaurant.user.infrastructure.messaging.avro.event.UserAddressUpdated
import com.restaurant.user.infrastructure.messaging.avro.event.UserCreated
import com.restaurant.user.infrastructure.messaging.avro.event.UserPasswordChanged
import com.restaurant.user.infrastructure.messaging.avro.event.UserProfileUpdated
import com.restaurant.user.infrastructure.messaging.avro.event.UserWithdrawn
import io.github.oshai.kotlinlogging.KotlinLogging
import org.apache.avro.io.BinaryEncoder
import org.apache.avro.io.DatumWriter
import org.apache.avro.io.EncoderFactory
import org.apache.avro.specific.SpecificDatumWriter
import org.apache.avro.specific.SpecificRecordBase
import org.slf4j.MDC
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer

private val log = KotlinLogging.logger {}

@Component
class OutboxMessageFactory(
    @Value("\${kafka.topics.user-event:dev.user.domain-event.user.v1}") private val userEventTopic: String,
) {
    /**
     * Creates a list of OutboxMessage objects from a single DomainEvent.
     * Typically, one event results in one message, but allows for future flexibility.
     */
    fun createMessagesFromEvent(userEvent: UserEvent): List<OutboxMessage> {
        val domainEventPayloadDto: SpecificRecordBase =
            mapToAvroPayloadDto(userEvent) ?: run {
                log.error { "Failed to map UserEvent to Avro DTO: ${userEvent::class.simpleName}" }
                return emptyList()
            }

        val domainPayloadBytes: ByteArray =
            serializeRecord(domainEventPayloadDto) ?: run {
                log.error { "Failed to serialize Avro DTO: ${domainEventPayloadDto::class.simpleName}" }
                return emptyList()
            }

        val envelopeDto =
            com.restaurant.common.infrastructure.avro.Envelope(
                userEvent.eventId.toString(),
                "1.0",
                userEvent.occurredAt.toEpochMilli(),
                "user",
                userEvent.aggregateType,
                userEvent.aggregateId,
                java.nio.ByteBuffer.wrap(domainPayloadBytes),
            )

        val finalPayloadBytes: ByteArray =
            serializeRecord(envelopeDto) ?: run {
                log.error { "Failed to serialize Envelope: ${userEvent.eventId}" }
                return emptyList()
            }

        val targetTopic = determineTopic(userEvent)

        val headers =
            mutableMapOf(
                "correlationId" to (MDC.get("correlationId") ?: "unknown"),
                "eventType" to (userEvent::class.simpleName ?: "UnknownEvent"),
                "aggregateId" to userEvent.aggregateId,
                "aggregateType" to userEvent.aggregateType,
            )

        val outboxMessage =
            OutboxMessage(
                payload = finalPayloadBytes,
                topic = targetTopic,
                headers = headers,
                aggregateId = userEvent.aggregateId,
                aggregateType = userEvent.aggregateType,
            )

        return listOf(outboxMessage)
    }

    private fun mapToAvroPayloadDto(event: UserEvent): SpecificRecordBase? =
        try {
            when (event) {
                is UserEvent.Created ->
                    UserCreated(
                        event.userId.value.toString(),
                        event.username,
                        event.email,
                        event.name,
                        event.phoneNumber,
                        event.occurredAt.toEpochMilli(),
                    )
                is UserEvent.PasswordChanged ->
                    UserPasswordChanged(
                        event.userId.value.toString(),
                        event.occurredAt.toEpochMilli(),
                    )
                is UserEvent.ProfileUpdated ->
                    UserProfileUpdated(
                        event.userId.value.toString(),
                        event.name,
                        event.phoneNumber,
                        event.occurredAt.toEpochMilli(),
                    )
                is UserEvent.AddressRegistered ->
                    UserAddressAdded(
                        event.userId.value.toString(),
                        event.address.id,
                        event.address.name,
                        event.address.streetAddress,
                        event.address.detailAddress,
                        event.address.city,
                        event.address.state,
                        event.address.country,
                        event.address.zipCode,
                        event.address.isDefault,
                        event.occurredAt.toEpochMilli(),
                    )
                is UserEvent.AddressUpdated ->
                    UserAddressUpdated(
                        event.userId.value.toString(),
                        event.address.id,
                        event.address.name,
                        event.address.streetAddress,
                        event.address.detailAddress,
                        event.address.city,
                        event.address.state,
                        event.address.country,
                        event.address.zipCode,
                        event.address.isDefault,
                        event.occurredAt.toEpochMilli(),
                    )
                is UserEvent.AddressDeleted ->
                    UserAddressDeleted(
                        event.userId.value.toString(),
                        event.addressId,
                        event.occurredAt.toEpochMilli(),
                    )
                is UserEvent.Withdrawn ->
                    UserWithdrawn(
                        event.userId.value.toString(),
                        event.occurredAt.toEpochMilli(),
                    )
                else -> {
                    log.warn { "Unsupported UserEvent type for Avro mapping: ${event::class.simpleName}" }
                    null
                }
            }
        } catch (e: Exception) {
            log.error(e) { "Error mapping UserEvent to Avro DTO: ${event::class.simpleName}" }
            null
        }

    private fun serializeRecord(record: SpecificRecordBase): ByteArray? =
        try {
            val writer: DatumWriter<SpecificRecordBase> = SpecificDatumWriter(record.schema)
            val out = ByteArrayOutputStream()
            val encoder: BinaryEncoder = EncoderFactory.get().binaryEncoder(out, null)
            writer.write(record, encoder)
            encoder.flush()
            out.toByteArray()
        } catch (e: Exception) {
            log.error(e) { "Failed to serialize Avro record: ${record::class.simpleName}" }
            null
        }

    private fun determineTopic(event: UserEvent): String = userEventTopic
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/build.gradle.kts
 Path: domains/user/infrastructure/persistence/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
}


java {
    sourceCompatibility = JavaVersion.VERSION_21
}



dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":independent:outbox"))

    implementation(libs.bundles.kotlin.base)
    implementation("io.github.microutils:kotlin-logging:3.0.5")
    implementation(libs.spring.boot.starter.data.jpa)
    implementation(libs.postgresql)
    implementation(libs.hikari.cp)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
    testImplementation(libs.bundles.testcontainers)
}



//     enabled = false
// }


====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table
import java.time.Instant
import java.util.UUID

@Entity
@Table(name = "addresses")
class AddressEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val domainId: UUID,
    @Column(nullable = false)
    val name: String,
    @Column(nullable = false)
    val streetAddress: String,
    @Column(nullable = true)
    val detailAddress: String?,
    @Column(nullable = false)
    val city: String,
    @Column(nullable = false)
    val state: String,
    @Column(nullable = false)
    val country: String,
    @Column(nullable = false)
    val zipCode: String,
    @Column(nullable = false)
    val isDefault: Boolean,
    @Column(nullable = false)
    val createdAt: Instant,
    @Column(nullable = false)
    val updatedAt: Instant,
    @Column(nullable = false)
    val version: Long,
)

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.CascadeType
import java.time.Instant
import java.util.Objects
import java.util.UUID

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false, length = 50)
    val username: String,
    @Column(nullable = false)
    val passwordHash: String,
    @Column(unique = true, nullable = false)
    val email: String,
    @Column(nullable = false, length = 50)
    val name: String,
    @Column(length = 20)
    val phoneNumber: String?,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val userType: UserType,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val status: UserStatus = UserStatus.ACTIVE,
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY, mappedBy = "user")
    val addresses: List<AddressEntity> = listOf(),
    @Version
    @Column(nullable = false)
    val version: Long = 0L,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: Instant = Instant.now(),
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as UserEntity
        return Objects.equals(id, that.id) &&
            domainId == that.domainId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: domainId)
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, username='$username', email='$email', userType=$userType, createdAt=$createdAt, updatedAt=$updatedAt, addressId = AddressId.of(address.addressId), addresses=${addresses.size}, version=$version)"
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.infrastructure.persistence.entity.AddressEntity
import java.time.Instant

/**
 * Extension functions for mapping between Address domain entity and AddressEntity.
 * Rule 24, 25, 60
 */

fun AddressEntity.toDomain(): Address =
    Address.reconstitute(
        addressId = AddressId(this.domainId),
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )

fun Address.toEntity(): AddressEntity =
    AddressEntity(
        domainId = this.addressId.value,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = Instant.now(),
        updatedAt = Instant.now(),
        version = this.version,
    )

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import java.time.Instant

/**
 * Extension functions for mapping between User domain aggregate and UserEntity.
 * Rule 24, 25, 60
 */

fun UserEntity.toDomain(): User =
    User(
        id = UserId.fromUUID(this.domainId),
        username = Username.of(this.username),
        password = Password.of(this.passwordHash),
        email = Email.of(this.email),
        name = Name.of(this.name),
        phoneNumber = this.phoneNumber?.let { PhoneNumber.of(it) },
        userType = UserType.valueOf(this.userType.name),
        status = UserStatus.valueOf(this.status.name),
        addresses = this.addresses.map { it.toDomain() },
        defaultAddressId = this.addresses.find { it.isDefault }?.let { AddressId.of(it.addressId) },
        version = this.version,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

fun User.toEntity(): UserEntity {
    val addressEntities =
        this.addresses.map { address ->
            address.toEntity()
        }
    return UserEntity(
        domainId = this.id.value,
        username = this.username.value,
        passwordHash = this.password.value,
        email = this.email.value,
        name = this.name.value,
        phoneNumber = this.phoneNumber?.value,
        userType = this.userType,
        status = this.status,
        addresses = addressEntities,
        version = this.version,
        createdAt = Instant.now(),
        updatedAt = Instant.now(),
    )
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Modifying
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository
import java.util.Optional
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByUserId(userId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByUsername(username: String): UserEntity?

    fun existsByEmail(email: String): Boolean

    fun existsByUsername(username: String): Boolean

    @Modifying
    @Query("DELETE FROM UserEntity u WHERE u.domainId = :domainId")
    fun deleteByDomainId(
        @Param("domainId") domainId: UUID,
    )

    fun findByUserIdOrThrow(userId: UUID): UserEntity = findByUserId(userId) ?: throw UserDomainException.User.NotFound(userId.toString())
}

====================================================================n


====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.common.presentation.filter.CorrelationIdFilter
import com.restaurant.outbox.port.OutboxMessageRepository
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.messaging.serialization.OutboxMessageFactory
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import com.restaurant.user.infrastructure.persistence.extensions.toDomain
import com.restaurant.user.infrastructure.persistence.extensions.toEntity
import mu.KotlinLogging
import org.slf4j.MDC
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

private val log = KotlinLogging.logger {}

@Repository
class UserRepositoryImpl(
    private val springDataJpaUserRepository: SpringDataJpaUserRepository,
    private val outboxRepository: OutboxMessageRepository,
    private val outboxMessageFactory: OutboxMessageFactory,
) : UserRepository {
    @Transactional
    override fun save(user: User): User {
        val isNew = user.version == 0L
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "SYSTEM-${UUID.randomUUID()}"
        log.debug { "Attempting to save user: ${user.id.value}, isNew=$isNew, correlationId=$correlationId" }

        val entity: UserEntity = user.toEntity()
        val savedEntity: UserEntity =
            try {
                springDataJpaUserRepository.saveAndFlush(entity)
            } catch (e: DataIntegrityViolationException) {
                log.warn(e) { "Data integrity violation while saving user ${user.id.value}" }
                val message = e.mostSpecificCause.message ?: ""
                when {
                    message.contains("uc_users_email", ignoreCase = true) ||
                        message.contains("users_email_key") ||
                        message.contains("uk_user_email") ->
                        throw UserDomainException.User.DuplicateEmail(user.email.value)
                    message.contains("uc_users_username", ignoreCase = true) ||
                        message.contains("users_username_key") ||
                        message.contains("uk_user_username") ->
                        throw UserDomainException.User.DuplicateUsername(user.username.value)
                    else -> throw UserDomainException.PersistenceError("Data integrity violation", e)
                }
            } catch (e: Exception) {
                log.error(e) { "Failed to save user ${user.id.value}" }
                throw UserDomainException.PersistenceError("Failed to save user", e)
            }

        val events = user.getDomainEvents()
        if (events.isNotEmpty()) {
            log.info { "Processing ${events.size} domain event(s) for aggregate ${user.id.value} with correlationId $correlationId" }
            try {
                val outboxMessages =
                    events.flatMap { event ->
                        outboxMessageFactory.createMessagesFromEvent(event, correlationId)
                    }

                if (outboxMessages.isNotEmpty()) {
                    outboxRepository.saveAll(outboxMessages)
                    log.info { "Saved ${outboxMessages.size} message(s) to outbox for aggregate ${user.id.value}" }
                }
            } catch (ex: Exception) {
                log.error(ex) {
                    "Failed to process/save ${events.size} event(s) to outbox for aggregate ${user.id.value}. Rethrowing for transaction rollback."
                }
                throw UserDomainException.PersistenceError("Failed to save domain events to outbox", ex)
            } finally {
                user.clearDomainEvents()
            }
        }

        return savedEntity.toDomain()
    }

    @Transactional
    override fun delete(user: User) {
        log.debug { "Deleting user: ${user.id.value}" }
        try {
            springDataJpaUserRepository.deleteByDomainId(user.id.value)

            val events = user.getDomainEvents()
            if (events.isNotEmpty()) {
                val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "SYSTEM-${UUID.randomUUID()}"
                log.info { "Processing ${events.size} domain event(s) for deleted aggregate ${user.id.value}" }

                val outboxMessages =
                    events.flatMap { event ->
                        outboxMessageFactory.createMessagesFromEvent(event, correlationId)
                    }

                if (outboxMessages.isNotEmpty()) {
                    outboxRepository.saveAll(outboxMessages)
                    log.info { "Saved ${outboxMessages.size} message(s) to outbox for deleted aggregate ${user.id.value}" }
                }

                user.clearDomainEvents()
            }
        } catch (e: Exception) {
            log.error(e) { "Failed to delete user ${user.id.value}" }
            throw UserDomainException.PersistenceError("Failed to delete user", e)
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: UserId): User? {
        log.debug { "Finding user by ID: ${id.value}" }
        return springDataJpaUserRepository
            .findByUserId(id.value)
            ?.toDomain()
            .also { user -> if (user == null) log.warn { "User not found for ID: ${id.value}" } }
    }

    @Transactional(readOnly = true)
    override fun findByUsername(username: Username): User? {
        log.debug { "Finding user by username: ${username.value}" }
        return springDataJpaUserRepository
            .findByUsername(username.value)
            ?.toDomain()
            .also { user -> if (user == null) log.warn { "User not found for Username: ${username.value}" } }
    }

    @Transactional(readOnly = true)
    override fun findByEmail(email: Email): User? {
        log.debug { "Finding user by email: ${email.value}" }
        return springDataJpaUserRepository
            .findByEmail(email.value)
            ?.toDomain()
            .also { user -> if (user == null) log.warn { "User not found for Email: ${email.value}" } }
    }

    @Transactional(readOnly = true)
    override fun existsByUsername(username: Username): Boolean {
        log.debug { "Checking existence by username: ${username.value}" }
        return springDataJpaUserRepository.existsByUsername(username.value)
    }

    @Transactional(readOnly = true)
    override fun existsByEmail(email: Email): Boolean {
        log.debug { "Checking existence by email: ${email.value}" }
        return springDataJpaUserRepository.existsByEmail(email.value)
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/build.gradle.kts
 Path: domains/user/presentation/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.spring.boot) apply false
    alias(libs.plugins.spring.dependency.management)
}


dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:presentation"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application"))

    implementation(libs.bundles.kotlin.base)
    implementation(libs.kotlin.logging)
    implementation(libs.spring.boot.starter.web)
    implementation(libs.spring.boot.starter.validation)
    implementation(libs.spring.boot.starter.hateoas)
    implementation(libs.springdoc.openapi)
    implementation(libs.jackson.kotlin)
    implementation(libs.jackson.jsr310)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
}



====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserAddressController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserAddressController.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.api

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.common.presentation.filter.CorrelationIdFilter
import com.restaurant.user.application.usecase.RegisterAddressUseCase
import com.restaurant.user.application.usecase.UpdateAddressUseCase
import com.restaurant.user.application.usecase.DeleteAddressUseCase
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.extensions.command.dto.request.toCommand
import org.slf4j.MDC
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
class UserAddressController(
    private val registerAddressUseCase: RegisterAddressUseCase,
    private val updateAddressUseCase: UpdateAddressUseCase,
    private val deleteAddressUseCase: DeleteAddressUseCase
) {

    @PostMapping
    fun registerAddress(
        @PathVariable userId: String,
        @RequestBody request: RegisterAddressRequestV1
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        val registeredAddressId = registerAddressUseCase.registerAddress(command)

        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "unknown"
        val responseDto = CommandResultResponse(
            message = "주소 등록 성공 (ID: ${registeredAddressId.value})",
            correlationId = correlationId
        )
        responseDto.add(linkTo(methodOn(UserAddressController::class.java).registerAddress(userId, request)).withSelfRel())

        return ResponseEntity.ok(responseDto)
    }

    @PutMapping("/{addressId}")
    fun updateAddress(
        @PathVariable userId: String,
        @PathVariable addressId: String,
        @RequestBody request: UpdateAddressRequestV1
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId), AddressId.of(addressId))
        updateAddressUseCase.updateAddress(command)

        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "unknown"
        val responseDto = CommandResultResponse(
            message = "주소 수정 성공 (ID: $addressId)",
            correlationId = correlationId
        )
        responseDto.add(linkTo(methodOn(UserAddressController::class.java).updateAddress(userId, addressId, request)).withSelfRel())

        return ResponseEntity.ok(responseDto)
    }

    @DeleteMapping("/{addressId}")
    fun deleteAddress(
        @PathVariable userId: String,
        @PathVariable addressId: String
    ): ResponseEntity<CommandResultResponse> {
        deleteAddressUseCase.deleteAddress(UserId.of(userId), AddressId.of(addressId))

        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "unknown"
        val responseDto = CommandResultResponse(
            message = "주소 삭제 성공 (ID: $addressId)",
            correlationId = correlationId
        )
        responseDto.add(linkTo(methodOn(UserAddressController::class.java).deleteAddress(userId, addressId)).withSelfRel())

        return ResponseEntity.ok(responseDto)
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserController.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.api

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.port.input.ChangePasswordUseCase
import com.restaurant.user.application.port.input.DeleteUserUseCase
import com.restaurant.user.application.port.input.LoginUseCase
import com.restaurant.user.application.port.input.RegisterUserUseCase
import com.restaurant.user.application.port.input.UpdateProfileUseCase
import com.restaurant.user.presentation.v1.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.extensions.command.dto.request.toCommand
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import mu.KotlinLogging
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(
    name = "User Commands",
    description = "API for user account management (registration, login, profile updates, password change, deletion)",
)
@RestController
@RequestMapping("/api/v1/users")
class UserController(
    private val registerUserUseCase: RegisterUserUseCase,
    private val loginUseCase: LoginUseCase,
    private val updateProfileUseCase: UpdateProfileUseCase,
    private val changePasswordUseCase: ChangePasswordUseCase,
    private val deleteUserUseCase: DeleteUserUseCase,
) {
    @PostMapping
    @Operation(summary = "Register a new user")
    @ApiResponse(responseCode = "201", description = "User registered successfully")
    fun registerUser(
        @Valid @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info("Register user request received: {}", request.username)
        val command = request.toCommand()
        val userId = registerUserUseCase.register(command)
        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "User registered successfully",
            ).apply {
                add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withSelfRel())
                add(linkTo(UserController::class.java).slash("login").withRel("login"))
            }
        return ResponseEntity.created(response.getRequiredLink("self").toUri()).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "Login a user")
    @ApiResponse(responseCode = "200", description = "User logged in successfully")
    fun loginUser(
        @Valid @RequestBody request: LoginRequestV1,
    ): ResponseEntity<Any> {
        log.info("Login request received for email: {}", request.email)
        val command = request.toCommand()
        val loginResult = loginUseCase.login(command)

        val response =
            mapOf(
                "status" to "SUCCESS",
                "message" to "Login successful",
                "data" to loginResult,
            )
        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "Update user profile")
    @ApiResponse(responseCode = "200", description = "Profile updated successfully")
    fun updateProfile(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info("Update profile request received for user: {}", userId)
        val command = request.toCommand(userId)
        updateProfileUseCase.updateProfile(command)
        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "Profile updated successfully",
            ).apply {
                add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withSelfRel())
            }
        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "Change user password")
    @ApiResponse(responseCode = "200", description = "Password changed successfully")
    fun changePassword(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info("Change password request received for user: {}", userId)
        val command = request.toCommand(userId)
        changePasswordUseCase.changePassword(command)
        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "Password changed successfully",
            ).apply {
                add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withRel("view-profile"))
            }
        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "Delete user account")
    @ApiResponse(responseCode = "200", description = "User deleted successfully")
    fun deleteUser(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info("Delete user request received for user: {}", userId)
        val command = request.toCommand(userId)
        deleteUserUseCase.deleteUser(command)
        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "User deleted successfully",
            )

        return ResponseEntity.ok(response)
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserQueryController.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.api

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.port.input.GetUserProfileQuery
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
import com.restaurant.user.presentation.v1.extensions.query.dto.response.toResponseV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import mu.KotlinLogging
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Queries", description = "API for querying user information")
class UserQueryController(
    private val getUserProfileQueryUseCase: GetUserProfileQuery,
) {
    @GetMapping("/{userId}/profile")
    @Operation(summary = "Get user profile", description = "Retrieves user profile information by User ID.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Profile retrieved successfully",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = UserProfileResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "Invalid UUID format",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "User not found",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "User ID (UUID)", required = true) @PathVariable userId: String,
    ): ResponseEntity<UserProfileResponseV1> {
        log.info { "Received request to get user profile for ID: $userId" }

        val query = GetUserProfileByIdQuery(userId = userId)
        val userProfileDto = getUserProfileQueryUseCase.getUserProfile(query)

        val responseDto = userProfileDto.toResponseV1()

        responseDto.add(
            linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId)).withSelfRel(),
            linkTo(UserController::class.java).slash(userId).slash("profile").withRel("update-profile"),
            linkTo(UserController::class.java).slash(userId).slash("password").withRel("change-password"),
        )
        log.info { "Returning user profile for ID: $userId" }
        return ResponseEntity.ok(responseDto)
    }
}

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/ChangePasswordRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/ChangePasswordRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/DeleteUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/DeleteUserRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/LoginRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/LoginRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterAddressRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterUserRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
/**
 * 사용자 등록 요청 DTO
 *
 * Contains validation and schema annotations for user registration API.
 *
 * @author junoko
 */
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

@Schema(description = "사용자 등록 요청")
data class RegisterUserRequestV1(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser")
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    @Schema(description = "전화번호 (선택)", example = "010-1234-5678")
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateAddressRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateProfileRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateProfileRequestV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/AddressResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/AddressResponseV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/LoginResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/LoginResponseV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답 V1")
data class LoginResponseV1(
    @Schema(description = "사용자 ID (UUID)")
    val userId: String,
    @Schema(description = "사용자 이름")
    val username: String,
    @Schema(description = "액세스 토큰")
    val accessToken: String,
    @Schema(description = "리프레시 토큰")
    val refreshToken: String,
) : RepresentationModel<LoginResponseV1>()

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/UserProfileResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/UserProfileResponseV1.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import org.springframework.hateoas.server.core.Relation
import java.time.Instant

/**
 * 사용자 프로필 정보 응답 DTO (Rule 1.4, 39)
 */
@Relation(collectionRelation = "users", itemRelation = "user")
@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "사용자 아이디", example = "testuser") val username: String,
    @Schema(description = "전화번호", example = "010-1234-5678", nullable = true) val phoneNumber: String?,
    @Schema(description = "사용자 타입", example = "CUSTOMER") val userType: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) : RepresentationModel<UserProfileResponseV1>()

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/command/dto/request/UserCommandRequestExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/command/dto/request/UserCommandRequestExtensions.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.extensions.command.dto.request

import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.presentation.v1.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateProfileRequestV1
import java.util.UUID

fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
        username = this.username,
    )

fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

fun UpdateProfileRequestV1.toCommand(userId: UUID): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId.toString(),
        name = this.name,
        phoneNumber = null,
    )

fun ChangePasswordRequestV1.toCommand(userId: UUID): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId.toString(),
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

fun DeleteUserRequestV1.toCommand(userId: UUID): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId.toString(),
        password = this.currentPassword,
    )

fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

====================================================================n


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/query/dto/response/UserQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/query/dto/response/UserQueryResponseExtensions.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.user.presentation.v1.extensions.query.dto.response

import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.presentation.v1.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
import org.springframework.hateoas.Link

fun UserProfileDto.toResponseV1(): UserProfileResponseV1 {
    val userId = this.id

    return UserProfileResponseV1(
        id = this.id,
        username = this.username,
        email = this.email,
        name = this.name,
        phoneNumber = this.phoneNumber,
        userType = this.userType,
        status = this.status,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
        addresses = this.addresses.map { it.toResponseV1() },
    ).apply {
        add(Link.of("/api/v1/users/$userId/profile", "self"))
        add(Link.of("/api/v1/users/$userId/profile", "update-profile"))
        add(Link.of("/api/v1/users/$userId/password", "change-password"))
        add(Link.of("/api/v1/users/$userId", "delete-user"))
    }
}

fun UserProfileDto.AddressDto.toResponseV1(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

fun List<UserProfileDto.AddressDto>.toResponseV1(): List<AddressResponseV1> = map { it.toResponseV1() }

====================================================================n


====================================================================
 File: gradle/libs.versions.toml
 Path: gradle/libs.versions.toml
 Timestamp: 2025-05-11 11:28:28
====================================================================
[versions]
# Kotlin
kotlin = "2.1.20"
# Spring
springBoot = "3.4.5"
springDependencyManagement = "1.1.7"
# Jakarta
jakartaPersistence = "3.1.0"
# Libraries
kotlinLogging = "3.0.5"
kotlinxSerialization = "1.8.1"
mapstruct = "1.6.3"
avro = "1.12.0"
springKafka = "4.0.0-M2"
kafkaClients = "4.0.0"
kafkaAvroSerializer = "7.6.3"
jacksonKotlin = "2.19.0"
springdocOpenapi = "2.8.6"
resilience4j = "2.3.0"
slf4j = "2.1.0-alpha1"
kotest = "5.8.0"
mockk = "1.14.2"
mockitoKotlin = "5.4.0"
assertj = "4.0.0-M1"
testcontainers = "1.21.0"
ktlint = "12.1.1"
avroPlugin = "1.9.1"

[libraries]
# Kotlin
kotlin-stdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "kotlin" }
kotlin-reflect = { module = "org.jetbrains.kotlin:kotlin-reflect", version.ref = "kotlin" }
kotlin-stdlib-common = { module = "org.jetbrains.kotlin:kotlin-stdlib-common", version.ref = "kotlin" }

# Logging
kotlin-logging = { module = "io.github.microutils:kotlin-logging-jvm", version.ref = "kotlinLogging" }

# Serialization
kotlinx-serialization = { module = "org.jetbrains.kotlinx:kotlinx-serialization-core", version.ref = "kotlinxSerialization" }

# Spring Boot Starters
spring-boot-starter = { module = "org.springframework.boot:spring-boot-starter", version.ref = "springBoot" }
spring-boot-starter-web = { module = "org.springframework.boot:spring-boot-starter-web" }
spring-boot-starter-data-jpa = { module = "org.springframework.boot:spring-boot-starter-data-jpa" }
spring-boot-starter-validation = { module = "org.springframework.boot:spring-boot-starter-validation", version.ref = "springBoot" }
spring-boot-starter-actuator = { module = "org.springframework.boot:spring-boot-starter-actuator" }
spring-boot-starter-security = { module = "org.springframework.boot:spring-boot-starter-security", version.ref = "springBoot" }
spring-boot-starter-aop = { module = "org.springframework.boot:spring-boot-starter-aop" }
spring-boot-starter-hateoas = { module = "org.springframework.boot:spring-boot-starter-hateoas", version.ref = "springBoot" }

# Spring Framework
spring-context = { module = "org.springframework:spring-context" }
spring-tx = { module = "org.springframework:spring-tx" }

# Jakarta
jakarta-persistence-api = { module = "jakarta.persistence:jakarta.persistence-api", version.ref = "jakartaPersistence" }
jakarta-validation-api = { module = "jakarta.validation:jakarta.validation-api" }

# Database
h2 = { module = "com.h2database:h2" }
postgresql = { module = "org.postgresql:postgresql" }
hikari-cp = { module = "com.zaxxer:HikariCP" }

# MapStruct
mapstruct = { module = "org.mapstruct:mapstruct", version.ref = "mapstruct" }
mapstruct-processor = { module = "org.mapstruct:mapstruct-processor", version.ref = "mapstruct" }

# Kafka & Avro
avro = { module = "org.apache.avro:avro", version.ref = "avro" }
spring-kafka = { module = "org.springframework.kafka:spring-kafka", version.ref = "springKafka" }
kafka-clients = { module = "org.apache.kafka:kafka-clients", version.ref = "kafkaClients" }
kafka-avro-serializer = { module = "io.confluent:kafka-avro-serializer", version.ref = "kafkaAvroSerializer" }

# Jackson
jackson-kotlin = { module = "com.fasterxml.jackson.module:jackson-module-kotlin", version.ref = "jacksonKotlin" }
jackson-jsr310 = { module = "com.fasterxml.jackson.datatype:jackson-datatype-jsr310", version.ref = "jacksonKotlin" }
jackson-databind = { module = "com.fasterxml.jackson.core:jackson-databind", version.ref = "jacksonKotlin" }

# OpenAPI
springdoc-openapi = { module = "org.springdoc:springdoc-openapi-starter-webmvc-ui", version.ref = "springdocOpenapi" }

# Resilience4j
resilience4j = { module = "io.github.resilience4j:resilience4j-spring-boot3", version.ref = "resilience4j" }

# Testing
spring-boot-starter-test = { module = "org.springframework.boot:spring-boot-starter-test" }
kotest-runner = { module = "io.kotest:kotest-runner-junit5", version.ref = "kotest" }
kotest-assertions = { module = "io.kotest:kotest-assertions-core", version.ref = "kotest" }
mockk = { module = "io.mockk:mockk", version.ref = "mockk" }
mockito-kotlin = { module = "org.mockito.kotlin:mockito-kotlin", version.ref = "mockitoKotlin" }
assertj = { module = "org.assertj:assertj-core", version.ref = "assertj" }
kotlin-test-junit5 = { module = "org.jetbrains.kotlin:kotlin-test-junit5", version.ref = "kotlin" }
testcontainers-postgresql = { module = "org.testcontainers:postgresql", version.ref = "testcontainers" }
testcontainers-kafka = { module = "org.testcontainers:kafka", version.ref = "testcontainers" }
testcontainers-junit = { module = "org.testcontainers:junit-jupiter", version.ref = "testcontainers" }

# Spring Boot BOM
spring-boot-dependencies = { group = "org.springframework.boot", name = "spring-boot-dependencies", version.ref = "springBoot" }

[plugins]
kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "kotlin" }
kotlin-spring = { id = "org.jetbrains.kotlin.plugin.spring", version.ref = "kotlin" }
kotlin-jpa = { id = "org.jetbrains.kotlin.plugin.jpa", version.ref = "kotlin" }
kotlin-allopen = { id = "org.jetbrains.kotlin.plugin.allopen", version.ref = "kotlin" }
spring-boot = { id = "org.springframework.boot", version.ref = "springBoot" }
spring-dependency-management = { id = "io.spring.dependency-management", version.ref = "springDependencyManagement" }
ktlint = { id = "org.jlleitschuh.gradle.ktlint", version.ref = "ktlint" }
avro = { id = "com.github.davidmc24.gradle.plugin.avro", version.ref = "avroPlugin" }

[bundles]
kotlin-base = ["kotlin-stdlib", "kotlin-reflect", "kotlin-stdlib-common"]
jackson = ["jackson-kotlin", "jackson-jsr310", "jackson-databind"]
kotest = ["kotest-runner", "kotest-assertions"]
testcontainers = ["testcontainers-postgresql", "testcontainers-kafka", "testcontainers-junit"]
====================================================================n


====================================================================
 File: independent/outbox/build.gradle.kts
 Path: independent/outbox/build.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
plugins {
    alias(libs.plugins.kotlin.jvm)
    alias(libs.plugins.kotlin.spring)
    alias(libs.plugins.kotlin.jpa)
    alias(libs.plugins.kotlin.allopen)
    alias(libs.plugins.spring.boot)
    alias(libs.plugins.spring.dependency.management)
}


allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    implementation(platform(libs.spring.boot.dependencies))

    implementation(libs.bundles.kotlin.base)
    implementation("io.github.microutils:kotlin-logging:3.0.5")
    implementation(libs.spring.boot.starter.data.jpa)
    implementation(libs.spring.kafka)
    implementation(libs.kafka.clients)
    implementation(libs.kafka.avro.serializer)
    implementation(libs.postgresql)
    implementation(libs.hikari.cp)
    implementation(libs.bundles.jackson)

    testImplementation(libs.spring.boot.starter.test)
    testImplementation(libs.bundles.kotest)
    testImplementation(libs.mockk)
    testImplementation(libs.mockito.kotlin)
    testImplementation(libs.assertj)
    testImplementation(libs.kotlin.test.junit5)
    testImplementation(libs.bundles.testcontainers)
}


====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/OutboxApplication.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/OutboxApplication.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class OutboxApplication

fun main(args: Array<String>) {
    runApplication<OutboxApplication>(*args)
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/OutboxPoller.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/OutboxPoller.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.application

import com.restaurant.outbox.application.port.OutboxMessageRepository
import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.kafka.OutboxMessageSender
import mu.KotlinLogging
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional

private val logger = KotlinLogging.logger {}

/**
 * OutboxPoller: 주기적으로 Outbox 테이블에서 PENDING 메시지를 조회하여 Kafka로 전송하고 상태를 갱신한다.
 */
@Component
class OutboxPoller(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSender,
) {
    /**
     * 주기적으로 실행되어 PENDING 상태의 메시지를 전송한다.
     * cron/interval 설정은 application-outbox.yml 등에서 조정 가능.
     */
    @Scheduled(fixedDelay = 1000)
    @Transactional
    fun pollMessages() {
        try {
            val messages =
                outboxMessageRepository.findAndMarkForProcessing(
                    status = OutboxMessageStatus.PENDING,
                    limit = 10,
                )

            if (messages.isEmpty()) {
                return
            }

            logger.debug { "Found ${messages.size} messages to process" }

            messages.forEach { message ->
                try {
                    outboxMessageSender.send(message)
                    outboxMessageRepository.updateStatus(
                        id = message.dbId!!,
                        newStatus = OutboxMessageStatus.SENT,
                    )
                } catch (e: Exception) {
                    logger.error(e) { "Failed to process message: $message" }
                    outboxMessageRepository.updateStatus(
                        id = message.dbId!!,
                        newStatus = OutboxMessageStatus.FAILED,
                        incrementRetry = true,
                    )
                }
            }
        } catch (e: Exception) {
            logger.error(e) { "Failed to poll messages" }
        }
    }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/OutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/OutboxMessageRepository.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.application.port

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.application.port.model.OutboxMessageStatus

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 * 이 인터페이스는 Outbox 메시지의 저장, 조회, 상태 업데이트 등의 작업을 정의합니다.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다.
     *
     * @param message 저장할 메시지
     * @return 저장된 메시지
     */
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     * @return 저장된 메시지 목록
     */
    fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage>

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: Long): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어해야 합니다.
     *
     * @param status 조회할 메시지 상태
     * @return 조회된 메시지 목록
     */
    fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다.
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID (Long)
     * @param newStatus 새로운 상태
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 시간 이전에 생성된 실패 상태의 메시지들을 조회합니다.
     *
     * @param maxRetries 최대 재시도 횟수
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>

    fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    fun countByStatus(status: OutboxMessageStatus): Long

    fun incrementRetryCount(id: Long): OutboxMessage?

    fun save(messages: List<OutboxMessage>)
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessage.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessage.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.application.port.model

import java.time.Instant
import java.util.UUID

/**
 * Represents a message to be stored in the outbox.
 * This is a technology-agnostic model that contains all necessary information for message delivery.
 *
 * @property id Unique identifier for the message
 * @property dbId Database ID of the message
 * @property payload The serialized message content as a byte array
 * @property topic The target Kafka topic for message delivery
 * @property headers Additional message headers including correlationId, aggregateType, aggregateId, etc.
 * @property aggregateId Domain ID of the aggregate that generated the event (in string format)
 * @property aggregateType Type of the aggregate that generated the event
 * @property status Current status of the message
 * @property retryCount Number of retry attempts made
 * @property createdAt When the message was created
 * @property updatedAt When the message was last updated
 * @property lastAttemptTime When the last delivery attempt was made
 */
data class OutboxMessage(
    val id: UUID = UUID.randomUUID(),
    val dbId: Long? = null,
    val payload: ByteArray,
    val topic: String,
    val headers: Map<String, String>,
    val aggregateType: String,
    val aggregateId: String,
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val createdAt: Instant = Instant.now(),
    val updatedAt: Instant = Instant.now(),
    val lastAttemptTime: Instant? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (dbId != other.dbId) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + (dbId?.hashCode() ?: 0)
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String =
        "OutboxMessage(" +
            "id=$id, " +
            "dbId=$dbId, " +
            "topic='$topic', " +
            "headers=$headers, " +
            "aggregateId='$aggregateId', " +
            "aggregateType='$aggregateType', " +
            "status=$status, " +
            "retryCount=$retryCount, " +
            "createdAt=$createdAt, " +
            "updatedAt=$updatedAt, " +
            "lastAttemptTime=$lastAttemptTime" +
            ")"
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessageStatus.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessageStatus.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.application.port.model

/**
 * Outbox 메시지의 상태를 나타내는 enum
 */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,

    /**
     * 더 이상 처리하지 않을 메시지
     */
    DISCARDED,
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.entity

import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.persistence.converter.StringMapConverter
import jakarta.persistence.Column
import jakarta.persistence.Convert
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Lob
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant

/**
 * JPA Entity for Outbox messages.
 * Rule 83
 */
@Entity
@Table(name = "outbox_events")
class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "aggregate_type", nullable = false)
    val aggregateType: String,
    @Column(name = "aggregate_id", nullable = false)
    val aggregateId: String,
    @Column(nullable = false)
    val topic: String,
    @Lob
    @Column(nullable = false)
    val payload: ByteArray,
    @Convert(converter = StringMapConverter::class)
    @Column(nullable = false, columnDefinition = "text")
    val headers: Map<String, String>,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    @Column(nullable = false)
    val createdAt: Instant = Instant.now(),
    @Column(nullable = true)
    var lastAttemptTime: Instant? = null,
    @Column(nullable = false)
    var retryCount: Int = 0,
    @Version
    val version: Long = 0,
) {
    /**
     * ByteArray 필드가 포함된 엔티티의 equals/hashCode 구현
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventEntity

        if (id != other.id) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (topic != other.topic) return false
        if (!payload.contentEquals(other.payload)) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (createdAt != other.createdAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false
        if (retryCount != other.retryCount) return false
        if (version != other.version) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        result = 31 * result + retryCount
        result = 31 * result + version.hashCode()
        return result
    }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.error

enum class OutboxErrorCodes(
    val code: String,
    val message: String,
) {
    MESSAGE_PROCESSING_FAILED("OUTBOX-001", "Failed to process outbox message"),
    MESSAGE_SERIALIZATION_FAILED("OUTBOX-002", "Failed to serialize outbox message"),
    MESSAGE_DESERIALIZATION_FAILED("OUTBOX-003", "Failed to deserialize outbox message"),
    KAFKA_SEND_FAILED("OUTBOX-004", "Failed to send message to Kafka"),
    MAX_RETRIES_EXCEEDED("OUTBOX-005", "Maximum retry attempts exceeded for message"),
    DATABASE_OPERATION_FAILED("OUTBOX-006", "Database operation failed"),
    UNEXPECTED_INFRA_ERROR("OUTBOX-007", "Unexpected infrastructure error occurred"),
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.exception

import com.restaurant.outbox.infrastructure.error.OutboxErrorCodes

/**
 * Outbox 모듈에서 발생하는 예외의 베이스 클래스
 */
sealed class OutboxException(
    val errorCode: OutboxErrorCodes,
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message ?: errorCode.message, cause) {
    class MessageProcessingException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.MESSAGE_PROCESSING_FAILED, message, cause)

    class SerializationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.MESSAGE_SERIALIZATION_FAILED, message, cause)

    class DeserializationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.MESSAGE_DESERIALIZATION_FAILED, message, cause)

    class KafkaSendException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.KAFKA_SEND_FAILED, message, cause)

    class MaxRetriesExceededException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.MAX_RETRIES_EXCEEDED, message, cause)

    /**
     * 데이터베이스 작업 관련 예외
     */
    class DatabaseOperationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.DATABASE_OPERATION_FAILED, message, cause)

    /**
     * 예상치 못한 인프라 예외
     */
    class UnexpectedInfrastructureException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.UNEXPECTED_INFRA_ERROR, message, cause)

    // Removed duplicated simple data class exceptions (SerializationFailed, etc.)
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/OutboxMessageSender.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/OutboxMessageSender.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.kafka

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.infrastructure.exception.OutboxException
import mu.KotlinLogging
import org.apache.kafka.clients.producer.ProducerRecord
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Component

private val logger = KotlinLogging.logger {}

/**
 * OutboxMessageSender: Outbox 메시지를 Kafka로 전송하는 역할
 */
@Component
class OutboxMessageSender(
    private val kafkaTemplate: KafkaTemplate<String, ByteArray>,
) {
    fun send(message: OutboxMessage) {
        try {
            val record =
                ProducerRecord(
                    message.topic,
                    message.aggregateId,
                    message.payload,
                )

            message.headers.forEach { (key, value) ->
                record.headers().add(key, value.toByteArray())
            }

            kafkaTemplate.send(record).get()
            logger.debug { "Successfully sent message to topic ${message.topic}" }
        } catch (e: Exception) {
            logger.error(e) { "Failed to send message to topic ${message.topic}" }
            throw OutboxException.KafkaSendException(
                message = "Failed to send message to topic ${message.topic}",
                cause = e,
            )
        }
    }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/config/KafkaOutboxProducerConfig.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/config/KafkaOutboxProducerConfig.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.kafka.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Kafka Producer Configuration specifically for the Outbox module.
 * Configures KafkaTemplate to send raw byte arrays (Rule 129).
 */
@Configuration
class KafkaOutboxProducerConfig(
    @Value("\${spring.kafka.bootstrap-servers}")
    private val bootstrapServers: String,
) {
    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> {
        val configProps =
            mapOf(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG to true,
                ProducerConfig.ACKS_CONFIG to "all",
                ProducerConfig.RETRIES_CONFIG to 3,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1,
            )
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun kafkaTemplate(producerFactory: ProducerFactory<String, ByteArray>): KafkaTemplate<String, ByteArray> =
        KafkaTemplate(producerFactory)
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/OutboxMessageRepositoryImpl.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/OutboxMessageRepositoryImpl.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.persistence

import com.restaurant.outbox.application.port.OutboxMessageRepository
import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.persistence.extensions.toOutboxEventEntity
import com.restaurant.outbox.infrastructure.persistence.extensions.toOutboxMessage
import com.restaurant.outbox.infrastructure.persistence.repository.JpaOutboxMessageRepository
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant

@Repository
class OutboxMessageRepositoryImpl(
    private val jpaOutboxMessageRepository: JpaOutboxMessageRepository,
) : OutboxMessageRepository {
    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        val entity = message.toOutboxEventEntity()
        val savedEntity = jpaOutboxMessageRepository.save(entity)
        return savedEntity.toOutboxMessage()
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage> {
        val entities = messages.map { it.toOutboxEventEntity() }
        val savedEntities = jpaOutboxMessageRepository.saveAll(entities)
        return savedEntities.map { it.toOutboxMessage() }
    }

    @Transactional
    override fun save(messages: List<OutboxMessage>) {
        val entities = messages.map { it.toOutboxEventEntity() }
        jpaOutboxMessageRepository.saveAll(entities)
    }

    @Transactional(readOnly = true)
    override fun findById(id: Long): OutboxMessage? =
        jpaOutboxMessageRepository
            .findById(id)
            .map { it.toOutboxMessage() }
            .orElse(null)

    @Transactional(readOnly = true)
    override fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatus(status)
            .map { it.toOutboxMessage() }

    @Transactional
    override fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        val entity = jpaOutboxMessageRepository.findById(id).orElse(null) ?: return null
        entity.status = newStatus
        if (incrementRetry) {
            entity.retryCount++
        }
        entity.lastAttemptTime = Instant.now()
        val savedEntity = jpaOutboxMessageRepository.save(entity)
        return savedEntity.toOutboxMessage()
    }

    @Transactional(readOnly = true)
    override fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findFailedMessagesExceedingRetryCount(
                status = OutboxMessageStatus.FAILED,
                maxRetries = maxRetries,
                limit = limit,
            ).map { it.toOutboxMessage() }

    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> {
        val cutoffTime = Instant.now().minusSeconds(30)
        return jpaOutboxMessageRepository
            .findMessagesToProcess(status, cutoffTime)
            .map { entity ->
                entity.status = OutboxMessageStatus.PROCESSING
                entity.lastAttemptTime = Instant.now()
                val savedEntity = jpaOutboxMessageRepository.save(entity)
                savedEntity.toOutboxMessage()
            }
    }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long = jpaOutboxMessageRepository.countByStatus(status)

    @Transactional
    override fun incrementRetryCount(id: Long): OutboxMessage? {
        val entity = jpaOutboxMessageRepository.findById(id).orElse(null) ?: return null
        entity.retryCount++
        entity.lastAttemptTime = Instant.now()
        val savedEntity = jpaOutboxMessageRepository.save(entity)
        return savedEntity.toOutboxMessage()
    }
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/converter/StringMapConverter.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/converter/StringMapConverter.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.persistence.converter

import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import jakarta.persistence.AttributeConverter
import jakarta.persistence.Converter

@Converter
class StringMapConverter : AttributeConverter<Map<String, String>, String> {
    private val objectMapper = jacksonObjectMapper()

    override fun convertToDatabaseColumn(attribute: Map<String, String>?): String =
        attribute?.let {
            objectMapper.writeValueAsString(it)
        } ?: "{}"

    override fun convertToEntityAttribute(dbData: String?): Map<String, String> =
        dbData?.let {
            objectMapper.readValue(it, object : TypeReference<Map<String, String>>() {})
        } ?: emptyMap()
}

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/extensions/OutboxEventEntityExtensions.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/extensions/OutboxEventEntityExtensions.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.persistence.extensions

import com.restaurant.outbox.application.port.model.OutboxMessage
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity

// Entity -> Domain
fun OutboxEventEntity.toOutboxMessage(): OutboxMessage =
    OutboxMessage(
        dbId = id,
        payload = payload,
        topic = topic,
        headers = headers,
        aggregateId = aggregateId,
        aggregateType = aggregateType,
        status = status,
        retryCount = retryCount,
        createdAt = createdAt,
        lastAttemptTime = lastAttemptTime,
    )

// Domain -> Entity
fun OutboxMessage.toOutboxEventEntity(): OutboxEventEntity =
    OutboxEventEntity(
        aggregateType = aggregateType,
        aggregateId = aggregateId,
        topic = topic,
        payload = payload,
        headers = headers,
        status = status,
        retryCount = retryCount,
        createdAt = createdAt,
        lastAttemptTime = lastAttemptTime,
    )

====================================================================n


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/JpaOutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/repository/JpaOutboxMessageRepository.kt
 Timestamp: 2025-05-11 11:28:28
====================================================================
package com.restaurant.outbox.infrastructure.persistence.repository

import com.restaurant.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.time.Instant

interface JpaOutboxMessageRepository : JpaRepository<OutboxEventEntity, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND (e.lastAttemptTime IS NULL OR e.lastAttemptTime < :cutoffTime)
        AND e.retryCount < :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findMessagesToProcess(
        @Param("status") status: OutboxMessageStatus,
        @Param("cutoffTime") cutoffTime: Instant,
        @Param("maxRetries") maxRetries: Int = 3,
    ): List<OutboxEventEntity>

    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    @Query("SELECT COUNT(e) FROM OutboxEventEntity e WHERE e.status = :status")
    fun countByStatus(
        @Param("status") status: OutboxMessageStatus,
    ): Long

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND e.retryCount >= :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findFailedMessagesExceedingRetryCount(
        @Param("status") status: OutboxMessageStatus,
        @Param("maxRetries") maxRetries: Int,
        @Param("limit") limit: Int,
    ): List<OutboxEventEntity>
}

====================================================================n


====================================================================
 File: settings.gradle.kts
 Path: settings.gradle.kts
 Timestamp: 2025-05-11 11:28:28
====================================================================
/**
 * settings.gradle.kts for the project.
 *
 * Configures plugin repositories and project structure for Gradle.
 *
 * @author junoko
 */

rootProject.name = "restaurant"

dependencyResolutionManagement {
    repositories {
        mavenCentral()
        maven {
            url = uri("https://packages.confluent.io/maven/")
        }
    }
    // 명시적 버전 카탈로그 선언
    versionCatalogs {
        create("libs") {
            from(files("gradle/libs.versions.toml"))
        }
    }
}

// Include all subprojects
include(":independent:outbox")

include(":domains:common:domain")
include(":domains:common:application")
include(":domains:common:infrastructure")
include(":domains:common:presentation")

include(":domains:user:domain")
include(":domains:user:application")
include(":domains:user:infrastructure:persistence")
include(":domains:user:infrastructure:messaging")
include(":domains:user:presentation")

include(":apps:user-app")

====================================================================n

==============================================================
 File Collection Completed: 2025-05-11 20:28:28 
==============================================================
