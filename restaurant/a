이 문서는
```
#!/bin/bash

# File to store the output
OUTPUT_FILE="a"

# Run Gradle clean
./gradlew clean 2>&1 | tee $OUTPUT_FILE

echo -e "\n--------------------------------------------------------------------\n\n" >> $OUTPUT_FILE

# Run Gradle build for specified modules, excluding tests
./gradlew :domains:user:application:build \
  :apps:user-app:build \
  :domains:user:domain:build \
  :domains:user:infrastructure:build \
  :domains:user:presentation:build \
  :independent:outbox:build \
  -x test 2>&1 | tee -a $OUTPUT_FILE

# Add a section separator
echo -e "\n\n==============================================================" >>$OUTPUT_FILE
echo -e " Gradle Build Completed: $(date '+%Y-%m-%d %H:%M:%S') " >>$OUTPUT_FILE
echo -e "==============================================================\n" >>$OUTPUT_FILE

# Run ktlintFormat
./gradlew ktlintFormat 2>&1 | tee -a $OUTPUT_FILE

# Add another section separator
echo -e "\n\n==============================================================" >>$OUTPUT_FILE
echo -e " ktlintFormat Completed: $(date '+%Y-%m-%d %H:%M:%S') " >>$OUTPUT_FILE
echo -e "==============================================================\n" >>$OUTPUT_FILE

echo -e "\n==============================================================" >>$OUTPUT_FILE
echo -e "\n# Project Structure\n" >>$OUTPUT_FILE
tree domains independent \
  -I 'build|bin|test' \
  -P '*.kt|*.kts|*.gradle' \
  >>$OUTPUT_FILE
echo -e "==============================================================\n\n" >>$OUTPUT_FILE

# Collect and append Kotlin/Gradle files with enhanced separators
find domains/user domains/common independent \
  -type d \( -name build -o -name bin -o -name test \) -prune -o \
  -type f \( -name "*.kt" -o -name "*.kts" -o -name "*.gradle" \) -print |
  sort -u |
  while read -r file; do
    {
      echo -e "\n\n===================================================================="
      echo -e " File: $file"
      echo -e " Path: $(realpath --relative-to=. "$file")"
      echo -e " Timestamp: $(date '+%Y-%m-%d %H:%M:%S')"
      echo -e "===================================================================="
      cat "$file"
      echo -e "\n--------------------------------------------------------------------\n"
    } >> "$OUTPUT_FILE"
  done

# Final footer
echo -e "\n==============================================================" >>$OUTPUT_FILE
echo -e " File Collection Completed: $(date '+%Y-%m-%d %H:%M:%S') " >>$OUTPUT_FILE
echo -e "==============================================================" >>$OUTPUT_FILE
```
명령어의 결과이다.

즉 모듈들의 전체 코드가 첨부되어있다.
코드를 보면 불완전 한 부분도 있고 규칙을 지키지 않는 부분도 있다.
따라서 코드에 기준으로 작업을 완료하려고 하면 완성이 안될꺼다. 왜냐하면 코드가 정말 엉망이기 떄문이다. 어떤 요구사항인지 잘생각해서 수정계획을 해야한다.
그래서 이를 수정하기 위한 작업 지시서가 필요하다. 작업 지시서를 만들어라.
- tree 구조를 보고 규칙에 맞지않는 부분을 찾아서 삭제할 파일, 이동할 파일에 대한 작업지시서는 최우선이다. 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 규칙을 지키지 않는 부분에 대한 작업지시서를 작성하라
- 프로그램이 정상적으로 동작하기위해 추가적으로 작업해야하는 작업지시서를 작성하라
- 작업지시서는 단계가 명확하게 표현되어야 한다. 하지만 작업의 순서를 잘생각해서 먼저되어야 하는건 꼭 먼저하도록 단계를 잘 생각하라.
- build.gradle.kts는 최상위 파일에 공통부분을 최대한 모아놓고 각 모듈별로 필요한 부분은 모듈 내부에 작성한다.
- 작업지시서에서는 Gradle 의존성에 대한 버전에 대해서 지적하지 않는다. 모두 최신버전으로 팀내에서 직접 관리하는 영역이다.
- 필요없는 파일은 삭제하도록 지시하라.
- 필요없는 코드는 주석보단 삭제를 하도록 지시하라.
- 현재 코드를 유지하는 경우는 작업지시서에 굳이 명시하지 않아도 된다.
- 작업지시서는 ~을 확인해라. 같은 모호한 문장은 절대로 안된다. ~을 어떻게 고쳐라 같이 매우 명시적이여야 한다.
- 작업지시서는 어떤 파일이 어떤 부분이 잘못작성되었고 어떻게 고쳐야한다. 그리고 근거는 무엇이다 라는 명시적 문장이 있어야 한다.
- 작업지시서 제일 하단에는 모든 작업이 끝나고 확인해야할 체크리스트를 작성한다.
- 이프로젝트는 Kotlin 으로 작성되어있다. Java는 사용하지 않는다.

작업 지시서에 항상 상단에 첨부할 문구
```
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.

작업시 항상 기억해야할 규칙
- 파일을 수정할때는 import 구문이 완벽한지 한번씩 더 체크하도록 한다. 만약 확인이 필요하다면 다른 파일을 조회할 수 있다.
- 작업을 진행하는 도중에 작업지시서에 없는 수정사항은 일단 보류하고 작업지시서를 최우선으로 수정한다.
- 이런식의 참조는 금지한다. ( ex -> event: com.restaurant.domains.common.domain.event.DomainEvent ) 항상 import 구문을 추가해서 참조하도록 한다.
- com.restaurant.domains.common.* 과 같은 import는 절대로 금지한다.
- 공통으로 수정해야할 패턴이 확실하다면 커맨드 명령어로 한번에 처리한다. 단, 프로젝트 내부에 build,bin 같은 제외할 경로는 명확히 명시한다.
- 필요없는 코드는 주석처리 하지 말고 삭제하도록 하라.
- 파일을 생성 할때는 위치가 올바른지 확인하기 위해서 파일 구조도를 참고하도록 한다.
- 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 의존성 버전은 항상 tools 이용해서 최신 스테이블 버전을 활용하도록 한다.
- 확인하고 싶은 디렉토리 구조가 있다면 tree 명령어로 최대한 효율적이게 진행하라. 단 bin,build 는 제외한다.
```

--------------------------------------------------------------------


> Task :domains:common:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:processResources
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:application:check
> Task :apps:user-app:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:processResources NO-SOURCE
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:processResources NO-SOURCE
> Task :domains:user:infrastructure:messaging:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:messaging:processResources NO-SOURCE
> Task :domains:user:infrastructure:persistence:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:persistence:processResources NO-SOURCE
> Task :apps:user-app:processResources
> Task :apps:user-app:check
> Task :domains:user:domain:check
> Task :domains:user:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:compileKotlin NO-SOURCE
> Task :domains:user:infrastructure:compileJava NO-SOURCE
> Task :domains:user:infrastructure:processResources NO-SOURCE
> Task :domains:user:infrastructure:classes UP-TO-DATE
> Task :domains:user:infrastructure:jar
> Task :domains:user:infrastructure:assemble
> Task :domains:user:infrastructure:check
> Task :domains:user:infrastructure:build
> Task :domains:user:presentation:check
> Task :independent:outbox:check
> Task :domains:common:compileKotlin
> Task :domains:common:compileJava NO-SOURCE
> Task :domains:common:classes
> Task :domains:common:jar
> Task :independent:outbox:compileKotlin
> Task :independent:outbox:compileJava NO-SOURCE
> Task :independent:outbox:classes UP-TO-DATE
> Task :independent:outbox:jar
> Task :independent:outbox:assemble
> Task :independent:outbox:build

> Task :domains:user:domain:compileKotlin
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:98:61 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:98:94 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:149:61 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:149:94 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:263:63 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt:263:96 This 'copy()' exposes the non-public primary constructor of a 'data class'. See the appropriate 'data class' documentation or contact the 'data class' author for migration guidance. This will become an error in Kotlin 2.2.
w: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt:13:20 Non-public primary constructor is exposed via the generated 'copy()' method of the 'data' class.

The generated 'copy()' will change its visibility in future releases.

To suppress the warning do one of the following:
- Annotate the data class with the '@ConsistentCopyVisibility' annotation.
- Use the '-Xconsistent-data-class-copy-visibility' compiler flag.
- Annotate the data class with the '@ExposedCopyVisibility' annotation 
  (Discouraged, but can be used to keep binary compatibility).

To learn more, see the documentation of the '@ConsistentCopyVisibility' and '@ExposedCopyVisibility' annotations.

This will become an error in Kotlin 2.2.

> Task :domains:user:domain:compileJava NO-SOURCE
> Task :domains:user:domain:classes UP-TO-DATE
> Task :domains:user:domain:jar
> Task :domains:user:domain:assemble
> Task :domains:user:domain:build

> Task :domains:user:infrastructure:messaging:compileKotlin FAILED
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:3:37 Unresolved reference 'filter'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:5:30 Unresolved reference 'infrastructure'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:6:23 Unresolved reference 'outbox'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:8:52 Unresolved reference 'UserCreatedAvro'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:9:52 Unresolved reference 'UserUpdatedAvro'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:10:52 Unresolved reference 'UserDeletedAvro'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:11:11 Unresolved reference 'github'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:26:24 Unresolved reference 'Avro'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:32:82 Unresolved reference 'OutboxMessage'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:36:20 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:36:20 Not enough information to infer type argument for 'T'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:42:21 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:42:21 Not enough information to infer type argument for 'T'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:48:21 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:48:21 Not enough information to infer type argument for 'T'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:54:24 Unresolved reference 'Envelope'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:82:29 Unresolved reference 'OutboxMessage'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:91:16 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:97:37 Unresolved reference 'UserCreatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:98:45 Unresolved reference 'UserPasswordChangedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:99:44 Unresolved reference 'UserProfileUpdatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:100:42 Unresolved reference 'UserAddressAddedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:101:44 Unresolved reference 'UserAddressUpdatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:102:44 Unresolved reference 'UserAddressDeletedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:103:39 Unresolved reference 'UserWithdrawnEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:115:16 Unresolved reference 'UserCreatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:115:64 Unresolved reference 'UserCreatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:116:16 Unresolved reference 'UserPasswordChangedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:116:72 Unresolved reference 'UserPasswordChangedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:117:16 Unresolved reference 'UserProfileUpdatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:117:71 Unresolved reference 'UserProfileUpdatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:118:16 Unresolved reference 'UserAddressAddedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:118:69 Unresolved reference 'UserAddressAddedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:119:16 Unresolved reference 'UserAddressUpdatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:119:71 Unresolved reference 'UserAddressUpdatedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:120:16 Unresolved reference 'UserAddressDeletedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:120:71 Unresolved reference 'UserAddressDeletedEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:121:16 Unresolved reference 'UserWithdrawnEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:121:66 Unresolved reference 'UserWithdrawnEventDtoV1'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:137:82 Unresolved reference 'Envelope'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:138:16 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:139:13 Unresolved reference 'CorrelationIdFilter'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:139:13 Argument type mismatch: actual type is 'Pair<A (of fun <A, B> A.to), B (of fun <A, B> A.to)>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:139:56 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:140:13 Argument type mismatch: actual type is 'Pair<String, String>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:141:13 Argument type mismatch: actual type is 'Pair<String, String>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:142:13 Argument type mismatch: actual type is 'Pair<String, String>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:144:13 Argument type mismatch: actual type is 'Pair<String, B (of fun <A, B> A.to)>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:144:38 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:144:50 Unresolved reference 'schemaVersion'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:145:13 Argument type mismatch: actual type is 'Pair<String, B (of fun <A, B> A.to)>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:145:32 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:145:44 Unresolved reference 'eventId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:146:13 Argument type mismatch: actual type is 'Pair<String, String>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:146:46 Unresolved reference 'timestamp'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:147:13 Argument type mismatch: actual type is 'Pair<String, B (of fun <A, B> A.to)>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:147:31 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:147:43 Unresolved reference 'source'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:148:13 Argument type mismatch: actual type is 'Pair<String, B (of fun <A, B> A.to)>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:148:38 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:148:50 Unresolved reference 'aggregateType'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:149:13 Argument type mismatch: actual type is 'Pair<String, B (of fun <A, B> A.to)>', but 'Pair<K (of fun <K, V> mapOf), V (of fun <K, V> mapOf)>' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:149:36 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt:149:48 Unresolved reference 'aggregateId'.

> Task :domains:user:application:compileKotlin FAILED
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt:23:29 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:23:35 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:24:41 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:25:39 Unresolved reference 'findByIdOrThrow'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:31:22 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:34:93 Unresolved reference 'errorCode'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:34:123 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:35:19 Type mismatch: inferred type is 'ERROR CLASS: Symbol not found for UserDomainException', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:38:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:38:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: BadRequest', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:41:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt:41:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: UnexpectedError', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:7:18 Unresolved reference 'oshai'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:12:19 Unresolved reference 'KotlinLogging'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:15:1 Class 'DeleteUserCommandHandler' is not abstract and does not implement abstract member:
fun deleteUser(command: DeleteUserCommand): Unit
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:20:5 'handle' overrides nothing.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:21:38 Argument type mismatch: actual type is 'String', but 'UUID' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:26:26 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:26:26 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: NotFound', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:29:21 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt:31:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: PasswordMismatch', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:7:28 Unresolved reference 'infrastructure'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:8:18 Unresolved reference 'oshai'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:12:19 Unresolved reference 'KotlinLogging'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:16:36 Unresolved reference 'SpringDataJpaUserRepository'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:23:44 Argument type mismatch: actual type is 'String', but 'UUID' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:24:48 Unresolved reference 'findByUserIdOrThrow'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:34:21 No parameter with name 'userStatus' found.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:36:52 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:38:43 Unresolved reference 'addressId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:39:47 Unresolved reference 'street'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:40:47 Unresolved reference 'detail'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:41:48 Unresolved reference 'zipCode'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:42:50 Unresolved reference 'isDefault'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:47:21 No value passed for parameter 'status'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:52:22 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:54:19 Type mismatch: inferred type is 'ERROR CLASS: Symbol not found for UserDomainException.User.NotFound', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:55:22 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:58:99 Unresolved reference 'errorCode'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:58:129 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:59:19 Type mismatch: inferred type is 'ERROR CLASS: Symbol not found for UserDomainException', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:62:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:62:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: BadRequest', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:65:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt:65:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: UnexpectedError', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:9:18 Unresolved reference 'oshai'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:14:19 Unresolved reference 'KotlinLogging'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:30:26 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:30:26 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: UserNotFound', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:35:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:35:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: InvalidCredentials', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:40:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt:40:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: UserInactive', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:24:35 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:25:39 Unresolved reference 'findByIdOrThrow'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:32:21 No value passed for parameter 'addressId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:37:64 Unresolved reference 'it'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:37:100 Unresolved reference 'addressId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:40:22 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:43:99 Unresolved reference 'errorCode'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:43:129 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:44:19 Type mismatch: inferred type is 'ERROR CLASS: Symbol not found for UserDomainException', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:47:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:47:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: BadRequest', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:50:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt:50:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: UnexpectedError', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:12:18 Unresolved reference 'oshai'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:17:19 Unresolved reference 'KotlinLogging'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:25:58 Return type of 'register' is not a subtype of the return type of the overridden member 'fun register(command: RegisterUserCommand): UserId' defined in 'com/restaurant/user/application/port/in/RegisterUserUseCase'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:30:35 Unresolved reference 'phoneNumber'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:30:48 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:30:52 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:31:32 Argument type mismatch: actual type is 'Username', but 'UserId' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:31:42 Argument type mismatch: actual type is 'Password', but 'Username' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:31:52 Argument type mismatch: actual type is 'Email', but 'Password' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:31:59 Argument type mismatch: actual type is 'Name', but 'Email' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt:31:65 No value passed for parameter 'phoneNumber'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:24:35 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:25:41 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:26:39 Unresolved reference 'findByIdOrThrow'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:30:21 No parameter with name 'id' found.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:34:21 No value passed for parameter 'addressId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:41:22 Unresolved reference 'UserDomainException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:44:91 Unresolved reference 'errorCode'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:44:121 Unresolved reference 'message'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:45:19 Type mismatch: inferred type is 'ERROR CLASS: Symbol not found for UserDomainException', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:48:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:48:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: BadRequest', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:51:19 Unresolved reference 'UserApplicationException'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt:51:19 Type mismatch: inferred type is 'ERROR CLASS: Unresolved name: UnexpectedError', but 'Throwable' was expected.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt:26:33 Unresolved reference 'fromString'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt:27:39 Unresolved reference 'findByIdOrThrow'.

FAILURE: Build completed with 2 failures.

1: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':domains:user:infrastructure:messaging:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.
==============================================================================

2: Task failed with an exception.
-----------
* What went wrong:
Execution failed for task ':domains:user:application:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.
==============================================================================

BUILD FAILED in 1s
11 actionable tasks: 11 executed


==============================================================
 Gradle Build Completed: 2025-04-28 23:26:43 
==============================================================

[Incubating] Problems report is available at: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/build/reports/problems/problems-report.html

FAILURE: Build failed with an exception.

* What went wrong:
Task 'ktlintFormat' not found in root project 'restaurant' and its subprojects.

* Try:
> Run gradlew tasks to get a list of available tasks.
> For more on name expansion, please refer to https://docs.gradle.org/8.11.1/userguide/command_line_interface.html#sec:name_abbreviation in the Gradle documentation.
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 374ms


==============================================================
 ktlintFormat Completed: 2025-04-28 23:26:44 
==============================================================


==============================================================

# Project Structure

domains
├── common
│   ├── build.gradle.kts
│   ├── infrastructure
│   └── src
│       └── main
│           ├── kotlin
│           │   └── com
│           │       └── restaurant
│           │           └── common
│           │               ├── config
│           │               │   └── SecurityConfig.kt
│           │               ├── domain
│           │               │   ├── aggregate
│           │               │   │   └── AggregateRoot.kt
│           │               │   └── event
│           │               │       └── DomainEvent.kt
│           │               ├── error
│           │               │   ├── CommonSystemErrorCode.kt
│           │               │   └── ErrorCode.kt
│           │               └── exception
│           │                   ├── ApplicationException.kt
│           │                   └── DomainException.kt
│           └── resources
└── user
    ├── application
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── application
    │                               ├── dto
    │                               │   ├── command
    │                               │   │   ├── ChangePasswordCommand.kt
    │                               │   │   ├── DeleteAddressCommand.kt
    │                               │   │   ├── DeleteUserCommand.kt
    │                               │   │   ├── LoginCommand.kt
    │                               │   │   ├── RegisterAddressCommand.kt
    │                               │   │   ├── RegisterUserCommand.kt
    │                               │   │   ├── UpdateAddressCommand.kt
    │                               │   │   └── UpdateProfileCommand.kt
    │                               │   └── query
    │                               │       ├── GetUserProfileByIdQuery.kt
    │                               │       ├── LoginResult.kt
    │                               │       └── UserProfileDto.kt
    │                               ├── error
    │                               │   └── UserApplicationErrorCode.kt
    │                               ├── exception
    │                               │   └── UserApplicationException.kt
    │                               ├── port
    │                               │   ├── ChangePasswordUseCase.kt
    │                               │   ├── DeleteAddressUseCase.kt
    │                               │   ├── DeleteUserUseCase.kt
    │                               │   ├── GetUserProfileQuery.kt
    │                               │   ├── LoginUseCase.kt
    │                               │   ├── RegisterAddressUseCase.kt
    │                               │   ├── RegisterUserUseCase.kt
    │                               │   ├── UpdateAddressUseCase.kt
    │                               │   └── UpdateProfileUseCase.kt
    │                               └── usecase
    │                                   ├── ChangePasswordCommandHandler.kt
    │                                   ├── DeleteAddressCommandHandler.kt
    │                                   ├── DeleteUserCommandHandler.kt
    │                                   ├── GetUserProfileQueryHandler.kt
    │                                   ├── LoginCommandHandler.kt
    │                                   ├── RegisterAddressCommandHandler.kt
    │                                   ├── RegisterUserCommandHandler.kt
    │                                   ├── UpdateAddressCommandHandler.kt
    │                                   └── UpdateProfileCommandHandler.kt
    ├── domain
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── domain
    │                               ├── aggregate
    │                               │   ├── User.kt
    │                               │   ├── UserStatus.kt
    │                               │   └── UserType.kt
    │                               ├── entity
    │                               │   └── Address.kt
    │                               ├── error
    │                               │   └── UserDomainErrorCodes.kt
    │                               ├── event
    │                               │   └── UserEvents.kt
    │                               ├── exception
    │                               │   └── UserDomainException.kt
    │                               ├── repository
    │                               │   └── UserRepository.kt
    │                               └── vo
    │                                   ├── AddressId.kt
    │                                   ├── Email.kt
    │                                   ├── Name.kt
    │                                   ├── Password.kt
    │                                   ├── PhoneNumber.kt
    │                                   ├── UserId.kt
    │                                   └── Username.kt
    ├── infrastructure
    │   ├── messaging
    │   │   ├── build.gradle.kts
    │   │   └── src
    │   │       └── main
    │   │           ├── kotlin
    │   │           │   └── com
    │   │           │       └── restaurant
    │   │           │           └── user
    │   │           │               └── infrastructure
    │   │           │                   └── messaging
    │   │           │                       ├── avro
    │   │           │                       │   └── UserEventDtos.kt
    │   │           │                       └── serialization
    │   │           │                           └── OutboxMessageFactory.kt
    │   │           └── resources
    │   └── persistence
    │       ├── build.gradle.kts
    │       └── src
    │           └── main
    │               ├── kotlin
    │               │   └── com
    │               │       └── restaurant
    │               │           └── user
    │               │               └── infrastructure
    │               │                   ├── extensions
    │               │                   └── persistence
    │               │                       ├── entity
    │               │                       │   ├── AddressEntity.kt
    │               │                       │   └── UserEntity.kt
    │               │                       ├── extensions
    │               │                       │   ├── AddressEntityExtensions.kt
    │               │                       │   └── UserEntityExtensions.kt
    │               │                       └── repository
    │               │                           ├── SpringDataJpaUserRepository.kt
    │               │                           └── UserRepositoryImpl.kt
    │               └── resources
    └── presentation
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── user
                                └── presentation
                                    └── v1
                                        ├── api
                                        │   ├── UserAddressController.kt
                                        │   ├── UserController.kt
                                        │   └── UserQueryController.kt
                                        ├── dto
                                        │   ├── request
                                        │   │   ├── ChangePasswordRequestV1.kt
                                        │   │   ├── DeleteUserRequestV1.kt
                                        │   │   ├── LoginRequestV1.kt
                                        │   │   ├── RegisterAddressRequestV1.kt
                                        │   │   ├── RegisterUserRequestV1.kt
                                        │   │   ├── UpdateAddressRequestV1.kt
                                        │   │   └── UpdateProfileRequestV1.kt
                                        │   └── response
                                        │       ├── AddressResponseV1.kt
                                        │       ├── LoginResponseV1.kt
                                        │       └── UserProfileResponseV1.kt
                                        └── extensions
                                            ├── command
                                            │   └── dto
                                            │       └── request
                                            │           └── UserCommandRequestExtensions.kt
                                            └── query
                                                └── dto
                                                    └── response
                                                        └── UserQueryResponseExtensions.kt
independent
└── outbox
    ├── build.gradle.kts
    ├── infrastructure
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── outbox
    │                           └── infrastructure
    │                               └── config
    ├── port
    └── src
        └── main
            └── kotlin
                └── com
                    └── restaurant
                        └── outbox
                            ├── application
                            │   └── port
                            │       ├── OutboxMessageRepository.kt
                            │       └── model
                            │           ├── OutboxMessage.kt
                            │           └── OutboxMessageStatus.kt
                            └── infrastructure
                                ├── entity
                                │   └── OutboxEventEntity.kt
                                ├── error
                                │   └── OutboxErrorCodes.kt
                                ├── exception
                                │   └── OutboxException.kt
                                ├── kafka
                                │   ├── OutboxMessageSender.kt
                                │   └── config
                                │       └── KafkaOutboxProducerConfig.kt
                                └── persistence
                                    ├── JpaOutboxMessageRepository.kt
                                    ├── converter
                                    │   └── StringMapConverter.kt
                                    └── extensions
                                        └── OutboxMessageExtensions.kt
apps
└── user-app
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── apps
            │               └── user
            │                   ├── UserApplication.kt
            │                   └── config
            └── resources

135 directories, 96 files
==============================================================




====================================================================
 File: apps/user-app/build.gradle.kts
 Path: apps/user-app/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    id("org.springframework.boot") version "3.3.5"
    id("io.spring.dependency-management") version "1.1.6"
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    // Core Application Dependencies
    implementation(project(":domains:common"))
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:infrastructure:persistence"))
    implementation(project(":domains:user:infrastructure:messaging"))
    implementation(project(":independent:outbox"))

    // Spring Boot Starter Web
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.5")

    // Actuator for monitoring
    implementation("org.springframework.boot:spring-boot-starter-actuator:3.3.5")

    // Springdoc OpenAPI for Swagger
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")

    // Other potential dependencies
    // implementation(libs.spring.cloud.starter.config) // If using Spring Cloud Config
    // implementation(libs.micrometer.registry.prometheus) // Example Micrometer registry

    // H2 Console (개발/테스트용)
    runtimeOnly("com.h2database:h2:2.2.224")
}

// Spring Boot specific configurations
springBoot {
    mainClass.set("com.restaurant.apps.user.UserApplication")
}

// Ensure the bootJar task is configured
tasks.withType<org.springframework.boot.gradle.tasks.bundling.BootJar> {
    enabled = true
    // classifier = "boot"
}

// Optionally disable the plain JAR task
tasks.withType<Jar> {
    enabled = false
}

--------------------------------------------------------------------



====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.scheduling.annotation.EnableScheduling // For Outbox Poller @Scheduled

@SpringBootApplication
// Scan components in config, outbox.infra, user.presentation, user.application, user.infra
@ComponentScan(
    basePackages = [
        "com.restaurant.config",
        "com.restaurant.outbox.infrastructure",
        "com.restaurant.outbox.internal", // If poller is in internal
        "com.restaurant.user.presentation",
        "com.restaurant.user.application",
        "com.restaurant.user.infrastructure",
    ],
)
// Explicitly enable JPA repositories if not found by default scan
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.user.infrastructure.persistence.repository",
        "com.restaurant.outbox.infrastructure.persistence", // Include Outbox repo
    ],
)
@EnableScheduling // Enable @Scheduled tasks (for Outbox Poller)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

--------------------------------------------------------------------



====================================================================
 File: build.gradle.kts
 Path: build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
import io.spring.gradle.dependencymanagement.dsl.DependencyManagementExtension
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
import org.springframework.boot.gradle.plugin.SpringBootPlugin
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.gradle.api.artifacts.DependencySet
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.VersionCatalogsExtension

plugins {
    id("org.jetbrains.kotlin.jvm") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.jpa") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.allopen") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.spring") version "2.1.20" apply false
    id("org.jetbrains.kotlin.plugin.serialization") version "2.1.20" apply false
    id("org.springframework.boot") version "3.3.5" apply false
    id("io.spring.dependency-management") version "1.1.6" apply false
}

apply(plugin = "io.spring.dependency-management")


configure<DependencyManagementExtension> {
    imports {
        mavenBom(SpringBootPlugin.BOM_COORDINATES)
        mavenBom("org.testcontainers:testcontainers-bom:1.19.7")
        mavenBom("io.kotest:kotest-bom:5.8.1")
    }
}

tasks.register("printSubprojects") {
    doLast {
        println("Root project: ${'$'}{project.name}")
        subprojects.forEach {
            println("  Subproject: ${'$'}{it.name} (Path: ${'$'}{it.path})")
        }
    }
}


allprojects {

    plugins.apply("org.jetbrains.kotlin.jvm")

    if (project != rootProject) {
        group = "com.restaurant"
        version = "0.0.1-SNAPSHOT"
    }

    tasks.withType<KotlinCompile> {
        compilerOptions {
            jvmTarget.set(JvmTarget.JVM_21)
            freeCompilerArgs.add("-Xjsr305=strict")
        }
    }

    tasks.withType<Test> {
        useJUnitPlatform()
        testLogging {
            events("passed", "skipped", "failed")
        }
    }
}



subprojects.forEach { subproject ->
    subproject.plugins.apply("org.jetbrains.kotlin.jvm")
    subproject.plugins.apply("java")
    subproject.extensions.configure(org.gradle.api.plugins.JavaPluginExtension::class.java) {
        toolchain.languageVersion.set(JavaLanguageVersion.of(21))
    }
    subproject.tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile::class.java).configureEach {
        kotlinOptions {
            jvmTarget = "21"
            freeCompilerArgs += "-Xjsr305=strict"
        }
    }
    subproject.dependencies {
        add("api", "org.jetbrains.kotlin:kotlin-stdlib:1.9.24")
        add("api", "org.jetbrains.kotlin:kotlin-reflect:1.9.24")
        add("api", "org.slf4j:slf4j-api:2.0.13")
        add("implementation", "io.github.microutils:kotlin-logging-jvm:3.0.5")
        add("implementation", "com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
        add("implementation", "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.19.0")

        add("testImplementation", "io.kotest:kotest-runner-junit5:5.8.1")
        add("testImplementation", "io.kotest:kotest-assertions-core:5.8.1")
        add("testImplementation", "io.mockk:mockk:1.14.0")
        add("testImplementation", "org.mockito.kotlin:mockito-kotlin:5.4.0")
        add("testImplementation", "org.assertj:assertj-core:3.25.3")
        add("testImplementation", "org.jetbrains.kotlin:kotlin-test:1.9.24")
        add("testImplementation", "org.springframework.boot:spring-boot-starter-test:3.4.5")
    }

    subproject.configurations.getByName("testImplementation").withDependencies {
        val dependencySet = this as DependencySet
        dependencySet.filterIsInstance<ExternalModuleDependency>().forEach { dependency ->
            if (dependency.group == "org.springframework.boot" && dependency.name == "spring-boot-starter-test") {
                dependency.exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
            }
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/build.gradle.kts
 Path: domains/common/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    kotlin("jvm")
}

dependencies {
    api("jakarta.validation:jakarta.validation-api:3.1.1")
    api("org.springframework.boot:spring-boot-starter-web:3.4.5")
    api("org.springframework.boot:spring-boot-starter-hateoas:3.4.5")
    api("org.springframework.boot:spring-boot-starter-security:3.4.5")
    api("org.springframework.security:spring-security-crypto:6.4.5")
    api("org.apache.avro:avro:1.12.0")
    implementation("io.confluent:kafka-avro-serializer:7.9.0")
    implementation("com.sksamuel.avro4k:avro4k-core:0.40.0")

    // Test dependencies are handled by subprojects block
    // testImplementation("io.kotest:kotest-runner-junit5")
    // testImplementation("io.kotest:kotest-assertions-core")
    // testImplementation("io.mockk:mockk")
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/config/SecurityConfig.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/config/SecurityConfig.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpMethod
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() } // API 서버이므로 CSRF 비활성화
            .sessionManagement { it.sessionCreationPolicy(SessionCreationPolicy.STATELESS) } // JWT 사용하므로 세션 사용 안함
            .authorizeHttpRequests { authz ->
                // 공개 엔드포인트
                authz.requestMatchers(HttpMethod.POST, "/api/v1/users/register").permitAll()
                authz.requestMatchers(HttpMethod.POST, "/api/v1/users/login").permitAll()

                // Swagger UI 및 API 문서 접근 허용
                authz.requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()

                // 헬스 체크 등 모니터링 엔드포인트
                authz.requestMatchers("/actuator/**").permitAll()

                // 나머지 엔드포인트는 인증 필요
                authz.anyRequest().authenticated()
            }

        // 참고: JWT 필터는 별도 구현 필요 (이 PR에서는 구현하지 않음)
        // 실제 구현 시에는 http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class) 추가 필요

        return http.build()
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

/**
 * Base class for all Aggregate Roots.
 * Provides methods to manage domain events.
 * Rule 17, 18
 */
abstract class AggregateRoot {
    /**
     * Returns the list of recorded domain events.
     */
    abstract fun getDomainEvents(): List<DomainEvent>

    /**
     * Clears the list of recorded domain events.
     */
    abstract fun clearDomainEvents()

    // REMOVED: Internal addDomainEvent abstract or concrete method
    // Subclasses (like User) can implement their own internal helper (e.g., addDomainEventInternal)
    // or directly manage the event list (if mutable) ensuring proper cloning in copy().
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.domain.event

import java.time.Instant
import java.util.UUID

/**
 * Base interface for domain events. (Rule 32)
 */
interface DomainEvent {
    val eventId: UUID
        get() = UUID.randomUUID()

    val occurredAt: Instant
        get() = Instant.now()

    val aggregateId: String
    val aggregateType: String
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/error/CommonSystemErrorCode.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/error/CommonSystemErrorCode.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.error

/**
 * Common system-level error codes.
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    INTERNAL_ERROR("COMMON-SYS-001", "An internal system error occurred"),
    INVALID_REQUEST("COMMON-SYS-002", "The request is invalid"),
    RESOURCE_NOT_FOUND("COMMON-SYS-003", "The requested resource was not found"),
    UNAUTHORIZED("COMMON-SYS-004", "Unauthorized access"),
    FORBIDDEN("COMMON-SYS-005", "Access forbidden"),
    VALIDATION_ERROR("COMMON-SYS-006", "Validation error"),
    OPTIMISTIC_LOCK_ERROR("COMMON-SYS-007", "The resource was modified by another request"),
    OUTBOX_ERROR("COMMON-SYS-008", "Error processing outbox message"),
    EXTERNAL_SERVICE_ERROR("COMMON-SYS-009", "External service error"),
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/error/ErrorCode.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/error/ErrorCode.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.error

/**
 * Base interface for all error codes in the system.
 * Error codes should follow the format: {DOMAIN}-{LAYER}-{CODE}
 */
interface ErrorCode {
    /**
     * The unique code for this error.
     * Format: {DOMAIN}-{LAYER}-{CODE}
     * Example: USER-DOMAIN-001, USER-APP-002
     */
    val code: String

    /**
     * A human-readable message describing this error.
     */
    val message: String
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/exception/ApplicationException.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/exception/ApplicationException.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.exception

import com.restaurant.common.error.ErrorCode

/**
 * Base class for all custom application exceptions.
 * Represents errors occurring in the application layer (e.g., use case execution failures).
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class ApplicationException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this application exception.
     */
    abstract val errorCode: ErrorCode

    /**
     * Secondary constructor to initialize with an ErrorCode.
     * The message defaults to the errorCode's message.
     */
    constructor(
        errorCode: ErrorCode,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : this(message, cause) {
        // Note: abstract val 'errorCode' must be overridden in subclasses.
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/common/src/main/kotlin/com/restaurant/common/exception/DomainException.kt
 Path: domains/common/src/main/kotlin/com/restaurant/common/exception/DomainException.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.common.exception

import com.restaurant.common.error.ErrorCode

/**
 * Base class for all custom domain exceptions.
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class DomainException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this domain exception.
     */
    abstract val errorCode: ErrorCode

    /**
     * Secondary constructor to initialize with an ErrorCode.
     * The message defaults to the errorCode's message.
     */
    constructor(
        errorCode: ErrorCode,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : this(message, cause) {
        // Note: abstract val 'errorCode' must be overridden in subclasses.
        // It cannot be assigned here in the abstract class constructor.
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/build.gradle.kts
 Path: domains/user/application/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    kotlin("jvm")
    
    // Common plugins (jvm, spring, dependency-management, java-library) applied via subprojects
}

dependencies {
    api(project(":domains:user:domain"))
    api(project(":domains:common"))
    implementation("org.springframework.boot:spring-boot-starter:3.3.5")
    implementation("org.springframework:spring-tx:6.1.6")
    implementation("org.springframework:spring-context:6.1.6")
    implementation("org.springframework.boot:spring-boot-starter-security:3.3.5")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.2.0")
    implementation("org.springframework.boot:spring-boot-starter-aop:3.3.5")
    implementation("org.springframework.security:spring-security-crypto:6.3.1")
    testImplementation(project(":domains:user:domain")) { isTransitive = false }
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.3.1")
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.3.5")
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5:1.9.24")
}

// Disable Java compile task as no Java code is expected
tasks.withType<JavaCompile> {
    enabled = false
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/ChangePasswordCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteAddressCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/DeleteUserCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

import jakarta.validation.constraints.NotBlank

// Application 레이어의 Command DTO (Rule App-Struct)
data class DeleteUserCommand(
    val userId: String, // UUID String
    @field:NotBlank(message = "비밀번호 확인은 필수입니다.")
    val password: String, // 수정: passwordConfirmation -> password
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/LoginCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

data class LoginCommand(
    val email: String,
    val password: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterAddressCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/RegisterUserCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size
import jakarta.validation.constraints.Email as JakartaEmail // Alias to avoid conflict

/**
 * Command DTO for registering a new user.
 * Rule App-Struct (dto/command)
 */
data class RegisterUserCommand(
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:JakartaEmail(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.") // Add password complexity rules if needed
    val password: String,
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String, // Rule 6.3: Added username field
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateAddressCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/command/UpdateProfileCommand.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
    val phoneNumber: String?,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/GetUserProfileByIdQuery.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.query

data class GetUserProfileByIdQuery(
    val userId: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/LoginResult.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.query

/**
 * 로그인 결과 DTO (Application Layer)
 */
data class LoginResult(
    val userId: String,
    val username: String,
    val accessToken: String,
    val refreshToken: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/dto/query/UserProfileDto.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.dto.query

import java.time.Instant // Instant 사용 권장

// Application 레이어의 Query Result DTO (Rule App-Struct)
data class UserProfileDto(
    val id: String, // UUID String
    val email: String,
    val name: String,
    val username: String, // 추가됨
    val phoneNumber: String?,
    val userType: String, // Enum 이름 등
    val addresses: List<AddressDto>,
    val createdAt: Instant,
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) {
    data class AddressDto(
        val id: String, // UUID String
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.error

import com.restaurant.common.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    BAD_REQUEST("USER-APPLICATION-001", "Bad request received by application."),
    INVALID_INPUT("USER-APPLICATION-002", "Invalid input provided to application."),
    AUTHENTICATION_FAILED("USER-APPLICATION-003", "Authentication failed."),
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-004", "External service communication error."),
    UNEXPECTED_ERROR("USER-APPLICATION-500", "An unexpected error occurred in the application."),
    USER_NOT_FOUND_BY_EMAIL("USER-APPLICATION-005", "User not found by email"),
    INVALID_CREDENTIALS("USER-APPLICATION-006", "Invalid username or password"),
    USER_INACTIVE("USER-APPLICATION-007", "User account is inactive"),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.exception

import com.restaurant.common.error.ErrorCode
import com.restaurant.common.exception.ApplicationException
import com.restaurant.user.application.error.UserApplicationErrorCode

/**
 * User Application 레이어 관련 예외 정의 (Rule 68)
 */
sealed class UserApplicationException(
    final override val errorCode: ErrorCode,
    message: String? = null,
    cause: Throwable? = null,
) : ApplicationException(errorCode, message ?: errorCode.message, cause) {
    /**
     * 인증 실패 관련 예외
     */
    class AuthenticationFailed(
        message: String? = UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.AUTHENTICATION_FAILED, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - e.g., Invalid UUID format
     */
    class BadRequest(
        message: String? = UserApplicationErrorCode.BAD_REQUEST.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.BAD_REQUEST, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - more specific than BadRequest
     */
    class InvalidInput(
        message: String? = UserApplicationErrorCode.INVALID_INPUT.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.INVALID_INPUT, message, cause)

    /**
     * 외부 서비스 연동 오류
     */
    class ExternalServiceError(
        message: String? = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR, message, cause)

    /**
     * 예상치 못한 시스템 오류 (Application 레벨)
     */
    class UnexpectedError(
        message: String? = UserApplicationErrorCode.UNEXPECTED_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.UNEXPECTED_ERROR, message, cause)

    /**
     * Login specific exceptions
     */
    class UserNotFound(
        errorCode: ErrorCode,
        identifier: String,
    ) : UserApplicationException(errorCode, "User not found with identifier: $identifier")

    class InvalidCredentials(
        errorCode: ErrorCode,
    ) : UserApplicationException(errorCode)

    class UserInactive(
        errorCode: ErrorCode,
        userId: String,
    ) : UserApplicationException(errorCode, "User is inactive: $userId")
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/ChangePasswordUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/ChangePasswordUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.ChangePasswordCommand

interface ChangePasswordUseCase {
    fun changePassword(command: ChangePasswordCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteAddressUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.DeleteAddressCommand // Command DTO 임포트 추가

/**
 * 주소 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteAddressUseCase {
    fun deleteAddress(command: DeleteAddressCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/DeleteUserUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.DeleteUserCommand

/**
 * 사용자 삭제 유스케이스 인터페이스 (Rule App-Struct)
 */
interface DeleteUserUseCase {
    fun deleteUser(command: DeleteUserCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/GetUserProfileQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/GetUserProfileQuery.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto

/**
 * 사용자 프로필 조회 Query UseCase 인터페이스 (Rule App-Struct)
 */
interface GetUserProfileQuery {
    fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/LoginUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/LoginUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult // Corrected import path for Query Result DTO

/**
 * 로그인 유스케이스 인터페이스 (Rule App-Struct)
 * 로그인 결과를 반환하도록 수정 (LoginResult 사용)
 */
interface LoginUseCase {
    fun login(command: LoginCommand): LoginResult // 반환 타입 LoginResult로 명시
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterAddressUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.domain.vo.AddressId

/**
 * 주소 등록 유스케이스 인터페이스 (Rule App-Struct)
 */
interface RegisterAddressUseCase {
    fun registerAddress(command: RegisterAddressCommand): AddressId
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/RegisterUserUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.RegisterUserCommand // Command DTO 임포트 추가 (Package 변경됨)
import com.restaurant.user.domain.vo.UserId // UserId import

/**
 * 사용자 등록 유스케이스 인터페이스 (Rule App-Struct)
 * 사용자 ID(UserId)를 반환하도록 수정
 */
interface RegisterUserUseCase {
    fun register(command: RegisterUserCommand): UserId // 반환 타입 UserId로 명시
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateAddressUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.UpdateAddressCommand // Command DTO 임포트 추가

/**
 * 주소 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateAddressUseCase {
    fun updateAddress(command: UpdateAddressCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/port/UpdateProfileUseCase.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.port.`in`

import com.restaurant.user.application.dto.command.UpdateProfileCommand

/**
 * 프로필 업데이트 유스케이스 인터페이스 (Rule App-Struct)
 */
interface UpdateProfileUseCase {
    fun updateProfile(command: UpdateProfileCommand)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/ChangePasswordCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.port.`in`.ChangePasswordUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : ChangePasswordUseCase {
    @Transactional
    override fun changePassword(command: ChangePasswordCommand) {
        val userId = UserId.fromString(command.userId)
        log.info { "Attempting to change password for user: $userId" }

        val user =
            userRepository.findById(userId)
                ?: throw UserDomainException.User.NotFound(command.userId.toString())

        if (!passwordEncoder.matches(command.currentPassword, user.password.value)) {
            val e = UserDomainException.User.PasswordMismatch()
            log.warn(e) { "Password change failed for userId ${command.userId}: Incorrect current password, errorCode=${e.errorCode.code}" }
            throw e
        }

        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.of(encodedNewPassword)

        val updatedUser = user.changePassword(newPasswordVo)

        userRepository.save(updatedUser)
        log.info { "Password changed successfully for user: $userId" }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteAddressCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.port.`in`.DeleteAddressUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) : DeleteAddressUseCase {
    @Transactional
    override fun deleteAddress(command: DeleteAddressCommand) {
        log.info { "Deleting address for userId=${command.userId}, addressId=${command.addressId}" }

        try {
            val userIdVo = UserId.fromString(command.userId)
            val addressIdVo = AddressId.fromString(command.addressId)
            val user = userRepository.findByIdOrThrow(userIdVo)

            val updatedUser = user.deleteAddress(addressIdVo)
            userRepository.save(updatedUser)

            log.info { "Address deleted successfully. userId=${userIdVo.value}, addressId=${addressIdVo.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address deletion for user ${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid ID format during address deletion: userId=${command.userId}, addressId=${command.addressId}" }
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error deleting address for user ${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError("Failed to delete address due to an unexpected error.", e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/DeleteUserCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.port.`in`.DeleteUserUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : DeleteUserUseCase {
    @Transactional
    override fun handle(command: DeleteUserCommand) {
        val userId = UserId.fromUUID(command.userId)
        log.info { "Attempting to delete user: $userId" }

        val user =
            userRepository.findById(userId)
                ?: throw UserDomainException.User.NotFound(command.userId.toString())

        if (!passwordEncoder.matches(command.password, user.password.value)) {
            val e = UserDomainException.User.PasswordMismatch()
            log.warn(e) { "User deletion failed for userId ${command.userId}: Incorrect password, errorCode=${e.errorCode.code}" }
            throw e
        }

        val withdrawnUser = user.withdraw()
        userRepository.save(withdrawnUser)
        log.info { "User deleted (withdrawn) successfully: $userId" }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/GetUserProfileQueryHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.application.port.`in`.GetUserProfileQuery
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.infrastructure.persistence.repository.SpringDataJpaUserRepository
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class GetUserProfileQueryHandler(
    private val userJpaRepository: SpringDataJpaUserRepository,
) : GetUserProfileQuery {
    @Transactional(readOnly = true)
    override fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto {
        log.debug { "Fetching user profile for userId=${query.userId}" }

        try {
            val userIdVo = UserId.fromUUID(query.userId)
            val userEntity = userJpaRepository.findByUserIdOrThrow(userIdVo.value)

            val dto =
                UserProfileDto(
                    id = userEntity.userId.toString(),
                    email = userEntity.email,
                    name = userEntity.name,
                    username = userEntity.username,
                    phoneNumber = userEntity.phoneNumber,
                    userType = userEntity.userType.name,
                    userStatus = userEntity.status.name,
                    addresses =
                        userEntity.addresses.map { addr ->
                            UserProfileDto.AddressDto(
                                id = addr.addressId.toString(),
                                street = addr.street,
                                detail = addr.detail,
                                zipCode = addr.zipCode,
                                isDefault = addr.isDefault,
                            )
                        },
                    createdAt = userEntity.createdAt,
                    updatedAt = userEntity.updatedAt,
                    version = userEntity.version,
                )

            log.info { "User profile fetched successfully, userId=${userIdVo.value}" }
            return dto
        } catch (de: UserDomainException.User.NotFound) {
            log.warn { "User profile query failed, user not found: userId=${query.userId}" }
            throw de
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain validation error during profile query for user ${query.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid user ID format for query: ${query.userId}" }
            throw UserApplicationException.BadRequest("Invalid user ID format", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during profile query for user ${query.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError(cause = e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/LoginCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.query.LoginResult
import com.restaurant.user.application.error.UserApplicationErrorCode
import com.restaurant.user.application.port.`in`.LoginUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    // private val jwtTokenProvider: JwtTokenProvider // Assuming JWT provider exists
) : LoginUseCase {
    @Transactional(readOnly = true)
    override fun login(command: LoginCommand): LoginResult {
        log.info { "Processing login command for email: ${command.email}" }

        val email = Email.of(command.email) // DomainException.Validation can occur here and should propagate

        val user =
            userRepository.findByEmail(email)
                ?: throw UserApplicationException.UserNotFound(UserApplicationErrorCode.USER_NOT_FOUND_BY_EMAIL, command.email)

        // Validate password using PasswordEncoder (Application layer responsibility)
        if (!passwordEncoder.matches(command.password, user.password.value)) {
            log.warn { "Invalid password attempt for email: ${command.email}" }
            throw UserApplicationException.InvalidCredentials(UserApplicationErrorCode.INVALID_CREDENTIALS)
        }

        if (!user.isActive()) {
            log.warn { "Attempt to login with inactive user: ${command.email}" }
            throw UserApplicationException.UserInactive(UserApplicationErrorCode.USER_INACTIVE, user.id.value.toString())
        }

        // Generate Token (Example - Assuming JwtTokenProvider)
        // val token = jwtTokenProvider.generateToken(user.id.value.toString(), user.userType)
        val fakeToken = "fake-jwt-token-for-${user.id.value}" // Placeholder

        log.info { "User logged in successfully: ${user.email.value}" }
        return LoginResult(
            userId = user.id.value.toString(),
            username = user.username.value,
            accessToken = fakeToken,
            refreshToken = "fake-refresh-token"
        )
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterAddressCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.port.`in`.RegisterAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) : RegisterAddressUseCase {
    @Transactional
    override fun registerAddress(command: RegisterAddressCommand): AddressId {
        log.info { "Registering address for userId=${command.userId}, street=${command.street}, zipCode=${command.zipCode}" }

        try {
            val userIdVo = UserId.fromString(command.userId)
            val user = userRepository.findByIdOrThrow(userIdVo)

            val address =
                Address.create(
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )
            val updatedUser = user.addAddress(address)
            userRepository.save(updatedUser)

            val addedAddressId = updatedUser.addresses.first { it.addressId == address.addressId }.addressId
            log.info { "Address registered successfully. userId=${userIdVo.value}, addressId=${addedAddressId.value}" }
            return addedAddressId
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address registration for userId=${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid user ID format for address registration: ${command.userId}" }
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during address registration: userId=${command.userId}" }
            throw UserApplicationException.UnexpectedError("Failed to register address due to an unexpected error.", e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/RegisterUserCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
    package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.application.port.`in`.RegisterUserUseCase
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.Username
import io.github.oshai.kotlinlogging.KotlinLogging
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : RegisterUserUseCase {
    @Transactional
    override fun register(command: RegisterUserCommand): String {
        val username = Username.of(command.username)
        val email = Email.of(command.email)
        val name = Name.of(command.name)
        val password = Password.of(passwordEncoder.encode(command.password))
        val phoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }
        val user = User.create(username, password, email, name, phoneNumber)
        userRepository.save(user)
        log.info { "User registered: ${'$'}{user.id}" }
        return user.id.value.toString()
    }
}


--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateAddressCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.port.`in`.UpdateAddressUseCase
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) : UpdateAddressUseCase {
    @Transactional
    override fun updateAddress(command: UpdateAddressCommand) {
        log.info { "Updating address for userId=${command.userId}, addressId=${command.addressId}" }

        try {
            val userIdVo = UserId.fromString(command.userId)
            val addressIdVo = AddressId.fromString(command.addressId)
            val user = userRepository.findByIdOrThrow(userIdVo)

            val addressToUpdate =
                Address.create(
                    id = addressIdVo,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            val updatedUser = user.updateAddress(addressIdVo, addressToUpdate)

            userRepository.save(updatedUser)
            log.info { "Address updated successfully. userId=${userIdVo.value}, addressId=${addressIdVo.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during address update for user ${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid ID format during address update: userId=${command.userId}, addressId=${command.addressId}" }
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error updating address for user ${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError("Failed to update address due to an unexpected error.", e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/usecase/UpdateProfileCommandHandler.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.application.usecase

import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.application.port.`in`.UpdateProfileUseCase
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.application.exception.UserApplicationException
import mu.KotlinLogging
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

private val log = KotlinLogging.logger {}

@Service
class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) : UpdateProfileUseCase {
    @Transactional
    override fun updateProfile(command: UpdateProfileCommand) {
        log.info { "Attempting to update profile for userId=${command.userId}" }

        try {
            val userId = UserId.fromString(command.userId)
            val user = userRepository.findByIdOrThrow(userId)

            val updatedName = Name.of(command.name)
            val updatedPhoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }

            val updatedUser =
                user.updateProfile(
                    newName = updatedName,
                    newPhoneNumber = updatedPhoneNumber,
                )

            userRepository.save(updatedUser)
            log.info { "Profile updated successfully for userId=${userId.value}" }
        } catch (de: UserDomainException) {
            log.warn(
                de,
            ) { "Domain error during profile update for userId=${command.userId}: code=${de.errorCode.code}, message=${de.message}" }
            throw de
        } catch (iae: IllegalArgumentException) {
            log.warn(iae) { "Invalid data during profile update for userId=${command.userId}: ${iae.message}" }
            throw UserApplicationException.BadRequest("Invalid profile data format: ${iae.message}", iae)
        } catch (e: Exception) {
            log.error(e) { "Unexpected error during profile update for userId=${command.userId}: ${e.message}" }
            throw UserApplicationException.UnexpectedError(cause = e)
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/build.gradle.kts
 Path: domains/user/domain/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    
    // Common plugins (jvm, java-library) applied via subprojects
}

dependencies {
    api(project(":domains:common"))
}

// REMOVED: Comment about Jar task configuration

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.exception.UserDomainException
import java.time.Instant

/**
 * User Aggregate Root
 */
data class User(
    val id: UserId,
    val username: Username,
    val password: Password, // Assume this is the encoded password
    val email: Email,
    val name: Name,
    val phoneNumber: PhoneNumber?,
    val userType: UserType, // Use imported type
    val status: UserStatus, // Use imported type
    val addresses: List<Address> = listOf(),
    val defaultAddressId: AddressId? = null,
    val version: Long,
    val createdAt: Instant,
    val updatedAt: Instant
) : AggregateRoot() {
    @Transient
    private val _domainEvents: MutableList<DomainEvent> = mutableListOf()

    override fun getDomainEvents(): List<DomainEvent> = _domainEvents.toList()
    override fun clearDomainEvents() = _domainEvents.clear()
    internal fun addDomainEvent(event: DomainEvent) {
        this._domainEvents.add(event)
    }

    fun changePassword(newPassword: Password): User {
        // Check status etc.
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser = this.copy(
            id = this.id,
            username = this.username,
            password = newPassword, 
            email = this.email,
            name = this.name,
            phoneNumber = this.phoneNumber,
            userType = this.userType,
            status = this.status,
            addresses = this.addresses,
            defaultAddressId = this.defaultAddressId,
            version = this.version + 1,
            createdAt = this.createdAt,
            updatedAt = Instant.now()
        )
        updatedUser.addDomainEvent(UserEvent.PasswordChanged(userId = this.id, changedAt = updatedUser.updatedAt))
        return updatedUser
    }

    fun updateProfile(newName: Name, newPhoneNumber: PhoneNumber?): User {
         if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()

        val updatedUser = this.copy(
            id = this.id,
            username = this.username,
            password = this.password, 
            email = this.email,
            name = newName,
            phoneNumber = newPhoneNumber,
            userType = this.userType,
            status = this.status,
            addresses = this.addresses,
            defaultAddressId = this.defaultAddressId,
            version = this.version + 1,
            createdAt = this.createdAt,
            updatedAt = Instant.now()
        )
        updatedUser.addDomainEvent(UserEvent.ProfileUpdated(userId = this.id, name = newName.value, phoneNumber = newPhoneNumber?.value, updatedAt = updatedUser.updatedAt))
        return updatedUser
    }

    fun addAddress(addressData: Address): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (addresses.size >= User.MAX_ADDRESSES) throw UserDomainException.Address.LimitExceeded(User.MAX_ADDRESSES)
        if (addresses.any { it.addressId == addressData.addressId }) throw UserDomainException.Address.DuplicateAddressId(addressData.addressId.value.toString())

        val newAddresses = addresses + addressData
        val newDefaultAddressId = if (addressData.isDefault) addressData.addressId else if (this.defaultAddressId == null) addressData.addressId else this.defaultAddressId

        val finalAddresses = newAddresses.map { addr ->
            if (addr.addressId == newDefaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
        }

        val updatedUser = this.copy(
            id = this.id,
            username = this.username,
            password = this.password, 
            email = this.email,
            name = this.name,
            phoneNumber = this.phoneNumber,
            userType = this.userType,
            status = this.status,
            addresses = finalAddresses,
            defaultAddressId = newDefaultAddressId,
            version = this.version + 1,
            createdAt = this.createdAt,
            updatedAt = Instant.now()
        )

        updatedUser.addDomainEvent(
            UserEvent.AddressAdded(
                userId = this.id,
                address = addressData.toData(), 
                addedAt = updatedUser.updatedAt
            )
        )
        return updatedUser
    }

    fun updateAddress(addressId: AddressId, updatedAddressData: Address): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (addressId != updatedAddressData.addressId) throw UserDomainException.Address.IdMismatch(addressId.value.toString(), updatedAddressData.addressId.value.toString())

        val addressIndex = addresses.indexOfFirst { it.addressId == addressId }
        if (addressIndex == -1) throw UserDomainException.Address.NotFound(addressId.value.toString())

        val newAddresses = addresses.toMutableList()
        newAddresses[addressIndex] = updatedAddressData

        // Determine the new default ID
        val newDefaultAddressId = if (updatedAddressData.isDefault) {
            updatedAddressData.addressId // New one is default
        } else if (defaultAddressId == addressId) {
            // Default is being updated and is no longer default, pick another if possible
            newAddresses.filterNot { it.addressId == addressId }.firstOrNull()?.addressId
        } else {
            defaultAddressId // Keep the old default
        }

        // Ensure only one default address
        val finalAddresses = newAddresses.map { addr ->
            if (addr.addressId == newDefaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
        }

        val updatedUser = this.copy(
            id = this.id,
            username = this.username,
            password = this.password, 
            email = this.email,
            name = this.name,
            phoneNumber = this.phoneNumber,
            userType = this.userType,
            status = this.status,
            addresses = finalAddresses,
            defaultAddressId = newDefaultAddressId,
            version = this.version + 1,
            createdAt = this.createdAt,
            updatedAt = Instant.now()
        )

        updatedUser.addDomainEvent(
            UserEvent.AddressUpdated(
                userId = this.id,
                address = updatedAddressData.toData(), 
                updatedAt = updatedUser.updatedAt
            )
        )
        return updatedUser
    }

    fun deleteAddress(addressId: AddressId): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        val addressToRemove = addresses.find { it.addressId == addressId }
            ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        if (addresses.size == 1) throw UserDomainException.Address.CannotDeleteLast()
        if (addressToRemove.isDefault) throw UserDomainException.Address.CannotDeleteDefault()

        val remainingAddresses = addresses.filterNot { it.addressId == addressId }

        val updatedUser = this.copy(
            id = this.id,
            username = this.username,
            password = this.password, 
            email = this.email,
            name = this.name,
            phoneNumber = this.phoneNumber,
            userType = this.userType,
            status = this.status,
            addresses = remainingAddresses,
            defaultAddressId = this.defaultAddressId,
            version = this.version + 1,
            createdAt = this.createdAt,
            updatedAt = Instant.now()
        )
        updatedUser.addDomainEvent(
            UserEvent.AddressDeleted(
                userId = this.id,
                addressId = addressId.value.toString(),
                deletedAt = updatedUser.updatedAt
            )
        )
        return updatedUser
    }

    fun withdraw(): User {
        if (status == UserStatus.WITHDRAWN) throw UserDomainException.User.AlreadyWithdrawn()
        if (userType == UserType.ADMIN) throw UserDomainException.User.AdminCannotBeWithdrawn()

        val updatedUser = this.copy(
            id = this.id,
            username = this.username,
            password = this.password, 
            email = this.email,
            name = this.name,
            phoneNumber = this.phoneNumber,
            userType = this.userType,
            status = UserStatus.WITHDRAWN,
            addresses = this.addresses,
            defaultAddressId = this.defaultAddressId,
            version = this.version + 1,
            createdAt = this.createdAt,
            updatedAt = Instant.now()
        )
        updatedUser.addDomainEvent(UserEvent.Withdrawn(userId = this.id, withdrawnAt = updatedUser.updatedAt))
        return updatedUser
    }

    fun isActive(): Boolean {
        return this.status == UserStatus.ACTIVE
    }

    companion object {
        const val MAX_ADDRESSES = 5

        // Rule 16: Create factory method
        fun create(
            id: UserId,
            username: Username,
            password: Password, // Assume this is the encoded password
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType = UserType.CUSTOMER,
            initialAddresses: List<Address> = emptyList()
        ): User {
             val now = Instant.now()
             // Validate initial addresses
             if (initialAddresses.count { it.isDefault } > 1) {
                 throw UserDomainException.Address.MultipleDefaultsOnInit()
             }
             val defaultAddressId = initialAddresses.find { it.isDefault }?.addressId
                 ?: initialAddresses.firstOrNull()?.addressId // If no default, make the first one default

             val finalAddresses = initialAddresses.map { addr ->
                 if (addr.addressId == defaultAddressId) addr.copy(isDefault = true) else addr.copy(isDefault = false)
             }

            val user = User(
                id = id,
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = UserStatus.ACTIVE, // Initial status
                addresses = finalAddresses,
                defaultAddressId = defaultAddressId,
                createdAt = now,
                updatedAt = now,
                version = 0L // Initial version
            )
            // Rule 16, 18: Add creation event
            user.addDomainEvent(UserEvent.Created(
                userId = id,
                username = username.value,
                email = email.value,
                name = name.value,
                phoneNumber = phoneNumber?.value,
                userType = userType.name, // Send enum name
                registeredAt = user.createdAt
            ))
            return user
        }

        // Rule 16: Reconstitute factory method
        fun reconstitute(
            id: UserId,
            username: Username,
            password: Password,
            email: Email,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
            status: UserStatus,
            addresses: List<Address>,
            defaultAddressId: AddressId?,
            version: Long,
            createdAt: Instant,
            updatedAt: Instant
        ): User {
            return User(
                id = id,
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = status,
                addresses = addresses,
                defaultAddressId = defaultAddressId,
                version = version,
                createdAt = createdAt,
                updatedAt = updatedAt
            )
        }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserStatus.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserStatus.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.aggregate

/**
 * Represents the status of a user account.
 */
enum class UserStatus {
    ACTIVE, // Normal, active state
    INACTIVE, // Temporarily inactive, e.g., not logged in for a long time
    WITHDRAWN, // User has withdrawn from the service
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserType.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/UserType.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.aggregate

/**
 * Represents the type of user.
 */
enum class UserType {
    CUSTOMER,
    ADMIN,
    // Add other types as needed
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.entity

import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException

import com.restaurant.user.domain.vo.AddressId
import java.time.Instant

/**
 * Address Domain Entity (Rule 11)
 * User Aggregate에 속하지만 자체 식별자를 가짐.
 */
data class Address private constructor(
    val addressId: AddressId,
    val street: String,
    val detail: String,
    val zipCode: String,
    var isDefault: Boolean,
    val createdAt: Instant,
    var updatedAt: Instant,
    var version: Long = 0L
) {
    init {
        if (street.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Street cannot be blank.")
        }
        validateZipCode(zipCode)
    }

    fun updateDetails(
        street: String,
        detail: String,
        zipCode: String,
        isDefault: Boolean
    ): Address {
        validateZipCode(zipCode)
        if (this.street == street && this.detail == detail && this.zipCode == zipCode && this.isDefault == isDefault) {
            return this
        }
        return this.copy(
            street = street,
            detail = detail,
            zipCode = zipCode,
            isDefault = isDefault,
            updatedAt = Instant.now(),
            version = this.version + 1
        )
    }

    fun toData(): UserEvent.AddressData = 
        UserEvent.AddressData(
            addressId = this.addressId.value.toString(),
            street = this.street,
            detail = this.detail,
            zipCode = this.zipCode,
            isDefault = this.isDefault
        )

    companion object {
        private fun validateZipCode(zipCode: String) {
            if (zipCode.isBlank() || zipCode.length != 5 || !zipCode.all { it.isDigit() }) {
                throw UserDomainException.Validation.InvalidAddressFormat("Zip code must be 5 digits.")
            }
        }

        fun create(
            addressId: AddressId,
            street: String,
            detail: String,
            zipCode: String,
            isDefault: Boolean,
            version: Long = 0L
        ): Address {
            validateZipCode(zipCode)
            val now = Instant.now()
            return Address(
                addressId = addressId,
                street = street,
                detail = detail,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = now,
                updatedAt = now,
                version = version
            )
        }

        fun reconstitute(
            addressId: AddressId,
            street: String,
            detail: String,
            zipCode: String,
            isDefault: Boolean,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long
        ): Address {
            // No validation needed on reconstitute, assuming data is valid
            return Address(addressId, street, detail, zipCode, isDefault, createdAt, updatedAt, version)
        }
    }

    fun markAsDefault(): Address {
        if (this.isDefault) return this
        return this.copy(
            isDefault = true,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun markAsNonDefault(): Address {
        if (!this.isDefault) return this
        return this.copy(
            isDefault = false,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.error

import com.restaurant.common.error.ErrorCode // Add this

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum (Rule 67)
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    DUPLICATE_USERNAME("USER-DOMAIN-003", "이미 사용중인 사용자 이름입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-004", "비밀번호가 일치하지 않습니다."),
    USER_ALREADY_WITHDRAWN("USER-DOMAIN-005", "이미 탈퇴한 사용자입니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-006", "주소를 찾을 수 없습니다."),
    DUPLICATE_ADDRESS_ID("USER-DOMAIN-007", "이미 존재하는 주소 ID 입니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-008", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-009", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-010", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_EMAIL_FORMAT("USER-DOMAIN-101", "잘못된 이메일 형식입니다."),
    INVALID_USERNAME_FORMAT("USER-DOMAIN-102", "사용자 이름 형식이 올바르지 않습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-103", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_NAME_FORMAT("USER-DOMAIN-104", "잘못된 이름 형식입니다."),
    INVALID_ADDRESS_FORMAT("USER-DOMAIN-105", "잘못된 주소 형식입니다."),
    INVALID_PHONE_NUMBER_FORMAT("USER-DOMAIN-106", "잘못된 전화번호 형식입니다."),
    INVALID_USER_ID_FORMAT("USER-DOMAIN-107", "잘못된 사용자 ID 형식입니다."),
    INVALID_ADDRESS_ID_FORMAT("USER-DOMAIN-108", "잘못된 주소 ID 형식입니다."),
    ADDRESS_ID_MISMATCH("USER-DOMAIN-201", "주소 ID가 일치하지 않습니다."),
    INVALID_CREDENTIALS("USER-DOMAIN-056", "Invalid credentials"),
    ADMIN_CANNOT_BE_WITHDRAWN("USER-DOMAIN-057", "Admin user cannot be withdrawn"),
    MULTIPLE_DEFAULT_ADDRESSES("USER-DOMAIN-107", "Cannot have multiple default addresses"),
    DEFAULT_ADDRESS_NOT_FOUND("USER-DOMAIN-108", "Default address not found"),
    PERSISTENCE_ERROR("USER-DOMAIN-901", "Persistence error occurred"),
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvents.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvents.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import java.time.Instant
import java.util.UUID

/**
 * Sealed class grouping all domain events related to the User aggregate. (Rule 34)
 */
sealed class UserEvent(open val userId: UserId) : DomainEvent {
    override val aggregateId: String get() = userId.value.toString()
    override val aggregateType: String = "User"
    override val occurredAt: Instant = Instant.now()

    /**
     * User Created Event
     */
    data class Created(
        override val userId: UserId,
        val username: String,
        val email: String,
        val name: String,
        val phoneNumber: String?,
        val userType: String,
        val registeredAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = registeredAt // Use registration time
    }

    /**
     * User Password Changed Event
     */
    data class PasswordChanged(
        override val userId: UserId,
        val changedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = changedAt
    }

    /**
     * User Profile Updated Event
     */
    data class ProfileUpdated(
        override val userId: UserId,
        val name: String,
        val phoneNumber: String?,
        val updatedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = updatedAt
    }

    /**
     * Represents address data within user events.
     */
    data class AddressData(
        val addressId: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )

    /**
     * User Address Added Event
     */
    data class AddressAdded(
        override val userId: UserId,
        val address: AddressData,
        val addedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = addedAt
    }

    /**
     * User Address Updated Event
     */
    data class AddressUpdated(
        override val userId: UserId,
        val address: AddressData,
        val updatedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = updatedAt
    }

    /**
     * User Address Deleted Event (Renamed from Removed)
     */
    data class AddressDeleted(
        override val userId: UserId,
        val addressId: String,
        val deletedAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = deletedAt
    }

    /**
     * User Withdrawn Event (Renamed from UserWithdrawn)
     */
    data class Withdrawn(
        override val userId: UserId,
        val withdrawnAt: Instant,
    ) : UserEvent(userId) {
        override val occurredAt: Instant get() = withdrawnAt
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.exception

import com.restaurant.common.exception.DomainException
import com.restaurant.user.domain.error.UserDomainErrorCodes

/**
 * Sealed class representing all possible domain exceptions for the User aggregate. (Rule 68)
 */
sealed class UserDomainException(
    override val errorCode: UserDomainErrorCodes,
    message: String? = errorCode.message,
    cause: Throwable? = null,
) : DomainException(errorCode, message, cause) {
    /**
     * Validation-related exceptions
     */
    sealed class Validation(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class InvalidEmailFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_EMAIL_FORMAT,
                "Invalid email format: $value",
            )

        class InvalidUsernameFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USERNAME_FORMAT,
                "Invalid username format: $value",
            )

        class InvalidUserIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USER_ID_FORMAT,
                "Invalid user ID format: $value",
            )

        class InvalidPasswordFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
                message,
            )

        class InvalidNameFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_NAME_FORMAT,
                "Invalid name format: $value",
            )

        class InvalidPhoneNumberFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PHONE_NUMBER_FORMAT,
                "Invalid phone number format: $value",
            )

        class InvalidAddressFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                message,
            )

        class InvalidAddressIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_ID_FORMAT,
                "Invalid address ID format: $value",
            )
    }

    /**
     * User-related exceptions
     */
    sealed class User(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            userId: String,
        ) : User(
                UserDomainErrorCodes.USER_NOT_FOUND,
                "User not found with ID: $userId",
            )

        class DuplicateUsername(
            username: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_USERNAME,
                "Username already exists: $username",
            )

        class DuplicateEmail(
            email: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_EMAIL,
                "Email already exists: $email",
            )

        class PasswordMismatch : User(UserDomainErrorCodes.PASSWORD_MISMATCH)

        class AlreadyWithdrawn : User(UserDomainErrorCodes.USER_ALREADY_WITHDRAWN)

        class InvalidCredentials(
            username: String,
        ) : User(
                UserDomainErrorCodes.INVALID_CREDENTIALS,
                "Invalid credentials for username: $username",
            )

        class AdminCannotBeWithdrawn :
            User(
                UserDomainErrorCodes.ADMIN_CANNOT_BE_WITHDRAWN,
                "Admin user cannot be withdrawn.",
            )
    }

    /**
     * Address-related exceptions
     */
    sealed class Address(
        errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_NOT_FOUND,
                "Address not found with ID: $addressId",
            )

        class DefaultAddressNotFound(
            message: String = "Default address ID does not exist in the address list.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_NOT_FOUND,
                message,
            )

        class DuplicateAddressId(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.DUPLICATE_ADDRESS_ID,
                "Address ID already exists: $addressId",
            )

        class IdMismatch(
            existingId: String,
            newId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_ID_MISMATCH,
                "Address ID mismatch: expected $existingId, got $newId",
            )

        class LimitExceeded(
            limit: Int,
        ) : Address(
                UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
                "Cannot add more addresses, limit is $limit",
            )

        class CannotDeleteDefault(
            message: String = "Cannot remove the default address.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
                message,
            )

        class CannotDeleteLast(
            message: String = "Cannot remove the last address.",
        ) : Address(
                UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
                message,
            )

        class MultipleDefaultsOnInit(
            val reason: String = "Cannot initialize user with multiple default addresses.",
        ) : Address(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                reason,
            )
    }

    class PersistenceError(
        message: String,
        cause: Throwable? = null,
    ) : UserDomainException(
            UserDomainErrorCodes.PERSISTENCE_ERROR,
            message,
            cause,
        )
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username

/**
 * 사용자 도메인 리포지토리 Port (Domain Layer).
 * 애플리케이션 코어 로직은 이 인터페이스에 의존한다.
 * 실제 구현은 Infrastructure 레이어에서 제공한다.
 */
interface UserRepository {
    /**
     * 사용자를 저장하거나 업데이트한다.
     * @param user 저장 또는 업데이트할 User Aggregate
     * @return 저장된 User Aggregate (Immutable Aggregate 패턴 고려 시 새 인스턴스)
     */
    fun save(user: User): User

    /**
     * 사용자 ID로 사용자를 찾는다.
     * @param id 사용자 ID (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findById(id: UserId): User?

    /**
     * 사용자 이름으로 사용자를 찾는다.
     * @param username 사용자 이름 (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findByUsername(username: Username): User?

    /**
     * 이메일로 사용자를 찾는다.
     * @param email 이메일 (Value Object)
     * @return 찾은 User Aggregate 또는 null
     */
    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun existsByUsername(username: Username): Boolean

    fun delete(user: User)
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

@JvmInline
value class AddressId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun ofString(value: String): AddressId =
            try {
                AddressId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidAddressIdFormat(value)
            }

        fun of(value: UUID): AddressId = AddressId(value)

        fun fromUUID(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * Value object representing an email address.
 * This class ensures that the email address is valid according to a basic pattern.
 */
@JvmInline
value class Email private constructor(
    val value: String,
) {
    companion object {
        private val EMAIL_PATTERN =
            Regex(
                "[a-zA-Z0-9+._%\\-]{1,256}" +
                    "@" +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
                    "(" +
                    "\\." +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
                    ")+",
            )

        /**
         * Creates a new Email from a string value.
         * @throws UserDomainException.Validation if the email format is invalid
         */
        fun of(value: String): Email {
            if (!EMAIL_PATTERN.matches(value)) {
                throw UserDomainException.Validation.InvalidEmailFormat(value)
            }
            return Email(value.lowercase())
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Name private constructor(
    val value: String,
) : Serializable {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        private const val MIN_LENGTH = 2
        private const val MAX_LENGTH = 50

        fun of(value: String): Name {
            if (value.isBlank() || value.length < MIN_LENGTH || value.length > MAX_LENGTH) {
                throw UserDomainException.Validation.InvalidNameFormat(
                    "이름은 $MIN_LENGTH 자 이상 $MAX_LENGTH 자 이하이어야 하며, 공백일 수 없습니다: '$value'",
                )
            }
            return Name(value)
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * 비밀번호 Value Object
 */
@JvmInline
value class Password private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password cannot be blank.")
        }
        // Example: Add more checks for encoded format if applicable
        // if (!value.startsWith("{bcrypt}")) { // Example check
        //     throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password format is invalid.")
        // }
    }

    override fun toString(): String = "********"

    companion object {
        /**
         * Creates a Password VO from a pre-encoded password string.
         * Basic validation is done in the init block.
         */
        fun of(encodedPassword: String): Password {
            // Validation moved to init block
            return Password(encodedPassword)
        }

        // encode method removed - responsibility of Application layer
        // fun encode(rawPassword: String, passwordEncoder: PasswordEncoder): Password { ... }

        // matches method removed - responsibility of Application layer
        // fun matches(rawPassword: String, passwordEncoder: PasswordEncoder): Boolean { ... }
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class PhoneNumber private constructor(
    val value: String,
) : Serializable {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        // 대한민국 휴대폰 번호 형식 (010-xxxx-xxxx 또는 010xxxxxxxx)
        private val PHONE_NUMBER_REGEX = Regex("^010-?\\d{4}-?\\d{4}$")

        fun of(value: String): PhoneNumber {
            val normalizedValue = value.replace("-", "") // 하이픈 제거하여 검증
            if (!PHONE_NUMBER_REGEX.matches(value)) {
                throw UserDomainException.Validation.InvalidPhoneNumberFormat("휴대폰 번호 형식이 올바르지 않습니다: $value")
            }
            // 저장 시 하이픈 포함 또는 미포함 선택 가능 (여기서는 미포함 저장)
            return PhoneNumber(normalizedValue)
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable
import java.util.UUID

/**
 * Value object representing a unique user identifier.
 * This class wraps a UUID and provides type safety and validation.
 */
@JvmInline
value class UserId private constructor(
    val value: UUID,
) : Serializable {
    companion object {
        /**
         * Creates a new UserId from a UUID.
         */
        fun of(uuid: UUID): UserId = UserId(uuid)

        /**
         * Creates a new UserId from a string representation of a UUID.
         * @throws UserDomainException.Validation if the string is not a valid UUID
         */
        fun ofString(value: String): UserId =
            try {
                UserId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUserIdFormat(value)
            }

        /**
         * Generates a new random UserId.
         */
        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromUUID(value: UUID): UserId = UserId(value)
    }

    override fun toString(): String = value.toString()
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Username private constructor(
    val value: String,
) : Serializable {
    init {
        // Add validation logic here if needed (e.g., length, characters)
        if (value.isBlank() || value.length < 3 || value.length > 20) {
            throw UserDomainException.Validation.InvalidUsernameFormat("Username must be between 3 and 20 characters: '$value'")
        }
        // Example: Allow only alphanumeric characters
        // if (!value.matches(Regex("^[a-zA-Z0-9]*$"))) {
        //    throw UserDomainException.Validation.InvalidUsernameFormat("Username must be alphanumeric: '$value'")
        // }
    }

    companion object {
        fun of(value: String): Username {
            // Perform validation before creating
            try {
                // Reuse init block validation implicitly by calling private constructor
                return Username(value)
            } catch (e: UserDomainException.Validation.InvalidUsernameFormat) {
                // Re-throw specific exception if caught from init
                throw e
            } catch (e: IllegalArgumentException) {
                // Catch potential issues from require/check if used in init
                throw UserDomainException.Validation.InvalidUsernameFormat("Invalid username format: ${e.message}")
            }
        }
    }

    override fun toString(): String = value
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/build.gradle.kts
 Path: domains/user/infrastructure/messaging/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    kotlin("jvm")

    
}

dependencies {
    api(project(":domains:user:domain"))
    implementation(project(":domains:common"))
    implementation("org.apache.avro:avro:1.12.0")
    implementation("io.confluent:kafka-avro-serializer:7.9.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-core:1.8.1")
    implementation("com.sksamuel.avro4k:avro4k-core:0.40.0")
    implementation("io.github.microutils:kotlin-logging-jvm:3.0.5")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("org.springframework:spring-context:6.1.6")
}
// Avro Kotlin 클래스 생성 설정 및 sourceSets 주석 필요시 추가

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/avro/UserEventDtos.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/avro/UserEventDtos.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.avro.dto

import kotlinx.serialization.Contextual // Import Contextual
import kotlinx.serialization.Serializable
import java.time.Instant // Import Instant

// Rule 109, 111: @Serializable Kotlin DTO 직접 작성

@Serializable
data class AddressAvroDto( // AddressData 에 대응
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

@Serializable
data class UserCreatedEventDtoV1(
    val userId: String,
    val username: String,
    val email: String,
    val name: String,
    val phoneNumber: String?, // Nullable
    val userType: String, // Enum name as String
    // @Contextual // Temporarily removed
    @Contextual
    val registeredAt: Instant,
    // addresses 필드는 필요시 AddressAvroDto 리스트로 추가
    // val addresses: List<AddressAvroDto> = emptyList()
)

@Serializable
data class UserPasswordChangedEventDtoV1(
    val userId: String,
    // @Contextual // Temporarily removed
    @Contextual
    val changedAt: Instant,
)

@Serializable
data class UserProfileUpdatedEventDtoV1(
    val userId: String,
    val name: String,
    val phoneNumber: String?, // Nullable
    // @Contextual // Temporarily removed
    @Contextual
    val updatedAt: Instant,
)

@Serializable
data class UserAddressAddedEventDtoV1(
    val userId: String,
    val address: AddressAvroDto,
    // @Contextual // Temporarily removed
    @Contextual
    val addedAt: Instant,
)

@Serializable
data class UserAddressUpdatedEventDtoV1(
    val userId: String,
    val address: AddressAvroDto,
    // @Contextual // Temporarily removed
    val updatedAt: Instant,
)

@Serializable
data class UserAddressDeletedEventDtoV1( // Renamed from Removed
    val userId: String,
    val addressId: String,
    // @Contextual // Temporarily removed
    val deletedAt: Instant,
)

@Serializable
data class UserWithdrawnEventDtoV1( // Renamed from UserWithdrawn
    val userId: String,
    // @Contextual // Temporarily removed
    val withdrawnAt: Instant,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Path: domains/user/infrastructure/messaging/src/main/kotlin/com/restaurant/user/infrastructure/messaging/serialization/OutboxMessageFactory.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.messaging.serialization

import com.restaurant.common.config.filter.CorrelationIdFilter
import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.common.infrastructure.avro.dto.Envelope
import com.restaurant.outbox.port.dto.OutboxMessage
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.infrastructure.avro.dto.UserCreatedAvro
import com.restaurant.user.infrastructure.avro.dto.UserUpdatedAvro
import com.restaurant.user.infrastructure.avro.dto.UserDeletedAvro
import io.github.avro4k.Avro
import mu.KotlinLogging
import kotlinx.serialization.serializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component
import java.util.UUID

private val log = KotlinLogging.logger {}

@Component
class OutboxMessageFactory(
    // Inject Kafka topic name from application properties
    @Value("\${kafka.topics.user-event:dev.user.domain-event.user.v1}") private val userEventTopic: String
) {
    // Default Avro instance configured for avro4k
    private val avro = Avro.default

    /**
     * Creates a list of OutboxMessage objects from a single DomainEvent.
     * Typically, one event results in one message, but allows for future flexibility.
     */
    fun createMessagesFromEvent(event: DomainEvent, correlationId: String): List<OutboxMessage> {
        // Ensure the event is a UserEvent before processing
        val userEvent = event as? UserEvent ?: run {
            log.warn { "Received non-UserEvent domain event type: ${event::class.simpleName}. Skipping outbox message creation." }
            return emptyList()
        }

        // 1. Map DomainEvent to specific Avro Payload DTO
        val payloadDto: Any = mapToAvroPayloadDto(userEvent) ?: run {
             log.error { "Failed to map domain event to Avro DTO for event: ${userEvent::class.simpleName}, aggregateId: ${userEvent.aggregateId}" }
             return emptyList() // Or handle error appropriately
        }

        // 2. Serialize the specific Avro Payload DTO to ByteArray
        val payloadBytes: ByteArray = serializePayload(payloadDto) ?: run {
            log.error { "Failed to serialize Avro payload DTO for event: ${userEvent::class.simpleName}, aggregateId: ${userEvent.aggregateId}" }
             return emptyList() // Or handle error appropriately
        }

        // 3. Create the Envelope DTO (without payload initially)
        // Note: Envelope schema version might need a more robust strategy
        val schemaVersion = payloadDto::class.simpleName + "_V1" // Example versioning
        val envelope = Envelope(
            schemaVersion = schemaVersion,
            eventId = correlationId, // Use correlationId as eventId for tracing
            timestamp = userEvent.occurredAt, // From DomainEvent
            source = "user", // Hardcoded domain source for this factory
            aggregateType = userEvent.aggregateType, // From DomainEvent
            aggregateId = userEvent.aggregateId // From DomainEvent (usually String UUID)
            // payload = payloadBytes // Payload is NOT part of the Avro Envelope DTO itself per Rule 113
        )

        // 4. Serialize the Envelope DTO to ByteArray (this will be the final Kafka message payload)
        // This step seems redundant if the goal is to send the *payloadBytes* created in step 2
        // wrapped in an OUTBOX message structure.
        // Rule 85 says: "Envelope DTO와 이벤트 DTO를 조합하여 ... 최종 Kafka 메시지가 될 raw payload bytes (ByteArray)를 생성합니다"
        // Rule 83 OutboxEventEntity: "이벤트 payload (바이트 배열 ByteArray)"
        // Rule 81 OutboxMessage DTO: "raw payload bytes ByteArray"
        // This implies the Outbox stores the *payload* bytes (step 2), NOT the envelope bytes.
        // The Envelope information should likely go into the OutboxMessage/Entity headers/metadata.
        // Let's store payloadBytes from step 2 in OutboxMessage.payload.
        // val finalPayloadBytes = avro.encodeToByteArray(Envelope.serializer(), envelope) // Incorrect based on re-read rules

        // 5. Determine the target Kafka topic
        val targetTopic = determineTopic(userEvent)

        // 6. Create Kafka message headers (including Envelope metadata)
        val headers = createHeaders(userEvent, correlationId, envelope)

        // 7. Create the OutboxMessage DTO
        val outboxMessage = OutboxMessage(
            aggregateId = userEvent.aggregateId,
            aggregateType = userEvent.aggregateType,
            eventType = userEvent::class.simpleName ?: "UnknownEvent",
            payload = payloadBytes, // Use the serialized DTO bytes (Step 2)
            targetTopic = targetTopic,
            headers = headers // Include Envelope info here
        )

        return listOf(outboxMessage)
    }

    // Maps specific UserEvent subtypes to their corresponding Avro DTOs
    private fun mapToAvroPayloadDto(event: UserEvent): Any? = try {
        when (event) {
            is UserEvent.Created -> UserCreatedEventDtoV1(event.userId.value.toString(), event.username, event.email, event.name, event.phoneNumber, event.userType, event.registeredAt)
            is UserEvent.PasswordChanged -> UserPasswordChangedEventDtoV1(event.userId.value.toString(), event.changedAt)
            is UserEvent.ProfileUpdated -> UserProfileUpdatedEventDtoV1(event.userId.value.toString(), event.name, event.phoneNumber, event.updatedAt)
            is UserEvent.AddressAdded -> UserAddressAddedEventDtoV1(event.userId.value.toString(), event.address.toAvroDto(), event.addedAt)
            is UserEvent.AddressUpdated -> UserAddressUpdatedEventDtoV1(event.userId.value.toString(), event.address.toAvroDto(), event.updatedAt)
            is UserEvent.AddressDeleted -> UserAddressDeletedEventDtoV1(event.userId.value.toString(), event.addressId, event.deletedAt)
            is UserEvent.Withdrawn -> UserWithdrawnEventDtoV1(event.userId.value.toString(), event.withdrawnAt)
            // Add cases for other UserEvent subtypes if they exist
        }
    } catch (e: Exception) {
         log.error(e) { "Error mapping UserEvent to Avro DTO: ${event::class.simpleName}" }
         null
    }

    // Serializes the provided Avro DTO object into a ByteArray
    private fun serializePayload(payloadDto: Any): ByteArray? = try {
        when(payloadDto) {
            // Use kx.serialization's serializer() function
            is UserCreatedEventDtoV1 -> avro.encodeToByteArray(UserCreatedEventDtoV1.serializer(), payloadDto)
            is UserPasswordChangedEventDtoV1 -> avro.encodeToByteArray(UserPasswordChangedEventDtoV1.serializer(), payloadDto)
            is UserProfileUpdatedEventDtoV1 -> avro.encodeToByteArray(UserProfileUpdatedEventDtoV1.serializer(), payloadDto)
            is UserAddressAddedEventDtoV1 -> avro.encodeToByteArray(UserAddressAddedEventDtoV1.serializer(), payloadDto)
            is UserAddressUpdatedEventDtoV1 -> avro.encodeToByteArray(UserAddressUpdatedEventDtoV1.serializer(), payloadDto)
            is UserAddressDeletedEventDtoV1 -> avro.encodeToByteArray(UserAddressDeletedEventDtoV1.serializer(), payloadDto)
            is UserWithdrawnEventDtoV1 -> avro.encodeToByteArray(UserWithdrawnEventDtoV1.serializer(), payloadDto)
            // Add other DTO types here
            else -> throw IllegalArgumentException("Cannot serialize unknown Avro DTO type: ${payloadDto::class.simpleName}")
        }
    } catch (e: Exception) {
        log.error(e) { "Failed to serialize Avro payload DTO: ${payloadDto::class.simpleName}" }
        null
    }

    // Determines the Kafka topic based on the event type (simple example)
    private fun determineTopic(event: UserEvent): String {
        // Can be more sophisticated based on event type if needed
        return userEventTopic
    }

    // Creates the headers map for the Kafka message, including Envelope data
    private fun createHeaders(event: UserEvent, correlationId: String, envelope: Envelope): Map<String, String> {
        return mapOf(
            CorrelationIdFilter.CORRELATION_ID_MDC_KEY to correlationId, // Use constant
            "aggregateId" to event.aggregateId,
            "aggregateType" to event.aggregateType,
            "eventType" to (event::class.simpleName ?: "UnknownEvent"),
            // Include Envelope fields in headers
            "envelope_schemaVersion" to envelope.schemaVersion,
            "envelope_eventId" to envelope.eventId, // This is correlationId again
            "envelope_timestamp" to envelope.timestamp.toString(), // Convert Instant to String
            "envelope_source" to envelope.source,
            "envelope_aggregateType" to envelope.aggregateType, // Duplicates aggregateType?
            "envelope_aggregateId" to envelope.aggregateId // Duplicates aggregateId?
            // Consider if duplicating envelope fields in headers is necessary
        ).filterValues { it != null } // Ensure no null values if any fields are optional
    }

    // Extension function to convert AddressData (from UserEvent) to AddressAvroDto
    // This should be private or internal to this factory/module
    private fun UserEvent.AddressData.toAvroDto() = com.restaurant.user.infrastructure.avro.dto.AddressAvroDto(
        addressId = this.addressId,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault
    )
} 
--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/build.gradle.kts
 Path: domains/user/infrastructure/persistence/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.jpa")
    kotlin("plugin.allopen")
    
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.Embeddable")
    annotation("jakarta.persistence.MappedSuperclass")
}

dependencies {
    api(project(":domains:user:domain"))
    implementation(project(":domains:common"))
    implementation(project(":independent:outbox"))
    implementation(project(":domains:user:infrastructure:messaging"))
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.5")
    runtimeOnly("com.h2database:h2:2.2.224")
    implementation("org.springframework:spring-context:6.1.6")
    implementation("org.springframework:spring-tx:6.1.6")
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/AddressEntity.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import com.restaurant.common.infrastructure.persistence.entity.BaseEntity
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.Instant
import java.util.UUID
import java.util.Objects
import jakarta.persistence.Version

@Entity
@Table(name = "addresses")
class AddressEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,

    @Column(name = "address_id", unique = true, nullable = false, updatable = false)
    val addressId: UUID = UUID.randomUUID(),

    @Column(nullable = false)
    var street: String,

    @Column(nullable = false)
    var detail: String,

    @Column(nullable = false, length = 10)
    var zipCode: String,

    @Column(nullable = false)
    var isDefault: Boolean = false,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null,

    @Version
    @Column(nullable = false)
    val version: Long = 0L,

    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),

    @Column(name = "updated_at", nullable = false)
    var updatedAt: Instant = Instant.now(),
) : BaseEntity() {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as AddressEntity
        return Objects.equals(id, that.id) &&
            addressId == that.addressId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: addressId)
    }

    override fun toString(): String {
        return "AddressEntity(id=$id, addressId=$addressId, street='$street', detail='$detail', zipCode='$zipCode', isDefault=$isDefault, userId=${user?.id}, version=$version)"
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/entity/UserEntity.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.persistence.entity

import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant
import java.util.UUID
import java.util.Objects

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false, length = 50)
    val username: String,
    @Column(nullable = false)
    val passwordHash: String,
    @Column(unique = true, nullable = false)
    val email: String,
    @Column(nullable = false, length = 50)
    val name: String,
    @Column(length = 20)
    val phoneNumber: String?,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val userType: UserType,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val status: UserStatus = UserStatus.ACTIVE,
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY, mappedBy = "user")
    val addresses: List<AddressEntity> = listOf(),
    @Version
    @Column(nullable = false)
    val version: Long = 0L,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: Instant = Instant.now(),
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as UserEntity
        return Objects.equals(id, that.id) &&
            domainId == that.domainId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: domainId)
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, username='$username', email='$email', userType=$userType, createdAt=$createdAt, updatedAt=$updatedAt, addressId = AddressId.of(address.addressId), addresses=${addresses.size}, version=$version)"
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/AddressEntityExtensions.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.entity.Address // Import Address domain entity
import com.restaurant.user.domain.vo.AddressId // Import AddressId VO
import com.restaurant.user.infrastructure.persistence.entity.AddressEntity
import com.restaurant.user.infrastructure.persistence.entity.UserEntity // Added import for user property in toEntity

/**
 * Extension functions for mapping between Address domain entity and AddressEntity.
 * Rule 24, 25, 60
 */

// AddressEntity -> Address Domain
fun AddressEntity.toDomain(): Address {
    return Address.reconstitute(
        addressId = AddressId.of(this.addressId),
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        version = this.version // Add version mapping
    )
}

// Address Domain -> AddressEntity
fun Address.toEntity(userEntity: UserEntity? = null): AddressEntity {
    // Note: Passing userEntity here might be less common than setting it from the UserEntity side.
    // If userEntity is null, it assumes the relationship is managed elsewhere.
    return AddressEntity(
        addressId = this.addressId.value,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        version = this.version, // Add version mapping
        user = userEntity // Set user relationship if provided
        // id = null // Let JPA handle the Long id
    )
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/extensions/UserEntityExtensions.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.persistence.extensions

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.aggregate.UserStatus
import com.restaurant.user.domain.aggregate.UserType
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.infrastructure.persistence.entity.AddressEntity
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import java.util.stream.Collectors

/**
 * Extension functions for mapping between User domain aggregate and UserEntity.
 * Rule 24, 25, 60
 */

// UserEntity -> User Domain
fun UserEntity.toDomain(): User {
    return User.reconstitute(
        id = UserId.fromUUID(this.userId),
        username = Username.of(this.username),
        password = Password.of(this.passwordHash),
        email = Email.of(this.email),
        name = this.name,
        phoneNumber = this.phoneNumber?.let { PhoneNumber.of(it) },
        userType = this.userType,
        userStatus = this.status,
        addresses = this.addresses.stream().map { it.toDomain() }.collect(Collectors.toList()),
        defaultAddressId = this.addresses.find { it.isDefault }?.let { AddressId.of(it.addressId) },
        version = this.version
    )
}

// User Domain -> UserEntity
fun User.toEntity(): UserEntity {
    val userEntity = UserEntity(
        userId = this.id.value,
        username = this.username.value,
        passwordHash = this.password.value,
        email = this.email.value,
        name = this.name,
        phoneNumber = this.phoneNumber?.value,
        userType = this.userType,
        status = this.userStatus,
        addresses = mutableListOf(),
        version = this.version,
    )

    val addressEntities = this.addresses.map { address ->
        address.toEntity(userEntity)
    }
    userEntity.addresses.addAll(addressEntities)

    this.defaultAddressId?.let { defId ->
        userEntity.addresses.find { it.addressId == defId.value }?.isDefault = true
    }

    return userEntity
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/SpringDataJpaUserRepository.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Modifying
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository
import java.util.Optional
import java.util.UUID
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByUserId(userId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByUsername(username: String): UserEntity?

    fun existsByEmail(email: String): Boolean

    fun existsByUsername(username: String): Boolean

    @Modifying
    @Query("DELETE FROM UserEntity u WHERE u.domainId = :domainId")
    fun deleteByDomainId(@Param("domainId") domainId: UUID)

    fun findByUserIdOrThrow(userId: UUID): UserEntity =
        findByUserId(userId) ?: throw UserDomainException.User.NotFound(userId.toString())
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Path: domains/user/infrastructure/persistence/src/main/kotlin/com/restaurant/user/infrastructure/persistence/repository/UserRepositoryImpl.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.infrastructure.persistence.repository

import com.restaurant.common.config.filter.CorrelationIdFilter
import com.restaurant.outbox.port.OutboxMessageRepository
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.persistence.entity.UserEntity
import com.restaurant.user.infrastructure.persistence.extensions.toDomain
import com.restaurant.user.infrastructure.persistence.extensions.toEntity
import com.restaurant.user.infrastructure.persistence.repository.SpringDataJpaUserRepository
import com.restaurant.user.infrastructure.messaging.serialization.OutboxMessageFactory
import io.github.oshai.kotlinlogging.KotlinLogging
import org.slf4j.MDC
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.util.Optional
import java.util.UUID

private val log = KotlinLogging.logger {}

@Repository
class UserRepositoryImpl(
    private val springDataJpaUserRepository: SpringDataJpaUserRepository,
    private val outboxRepository: OutboxMessageRepository,
    private val outboxMessageFactory: OutboxMessageFactory
) : UserRepository {
    @Transactional
    override fun save(user: User): User {
        val isNew = user.version == 0L
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "SYSTEM-${UUID.randomUUID()}"
        log.debug { "Attempting to save user: ${user.id.value}, isNew=$isNew, correlationId=$correlationId" }

        val entity: UserEntity = user.toEntity()
        val savedEntity: UserEntity = try {
            springDataJpaUserRepository.saveAndFlush(entity)
        } catch (e: DataIntegrityViolationException) {
            log.warn(e) { "Data integrity violation while saving user ${user.id.value}" }
            val message = e.mostSpecificCause.message ?: ""
            when {
                message.contains("uc_users_email", ignoreCase = true) || message.contains("users_email_key") || message.contains("uk_user_email") ->
                    throw UserDomainException.User.DuplicateEmail(user.email.value)
                message.contains("uc_users_username", ignoreCase = true) || message.contains("users_username_key") || message.contains("uk_user_username") ->
                    throw UserDomainException.User.DuplicateUsername(user.username.value)
                else -> throw UserDomainException.PersistenceError("Data integrity violation", e)
            }
        } catch (e: Exception) {
            log.error(e) { "Failed to save user ${user.id.value}" }
            throw UserDomainException.PersistenceError("Failed to save user", e)
        }

        val events = user.getDomainEvents()
        if (events.isNotEmpty()) {
            log.info { "Processing ${events.size} domain event(s) for aggregate ${user.id.value} with correlationId $correlationId" }
            try {
                val outboxMessages = events.flatMap { event ->
                    outboxMessageFactory.createMessagesFromEvent(event, correlationId)
                }

                if (outboxMessages.isNotEmpty()) {
                    outboxRepository.save(outboxMessages)
                    log.info { "Saved ${outboxMessages.size} message(s) to outbox for aggregate ${user.id.value}" }
                }
            } catch (ex: Exception) {
                log.error(ex) {
                    "Failed to process/save ${events.size} event(s) to outbox for aggregate ${user.id.value}. Rethrowing for transaction rollback."
                }
                throw UserDomainException.PersistenceError("Failed to save domain events to outbox", ex)
            } finally {
                user.clearDomainEvents()
            }
        }

        return savedEntity.toDomain()
    }

    @Transactional(readOnly = true)
    override fun findById(id: UserId): User? {
        log.debug { "Finding user by ID: ${id.value}" }
        return springDataJpaUserRepository
            .findByDomainId(id.value)
            ?.toDomain()
            .also { if (it == null) log.warn { "User not found for ID: ${id.value}" } }
    }

    @Transactional(readOnly = true)
    override fun findByUsername(username: Username): User? {
        log.debug { "Finding user by username: ${username.value}" }
        return springDataJpaUserRepository
            .findByUsername(username.value)
            ?.toDomain()
            .also { if (it == null) log.warn { "User not found for Username: ${username.value}" } }
    }

    @Transactional(readOnly = true)
    override fun findByEmail(email: Email): User? {
        log.debug { "Finding user by email: ${email.value}" }
        return springDataJpaUserRepository
            .findByEmailValue(email.value)
            ?.toDomain()
            .also { if (it == null) log.warn { "User not found for Email: ${email.value}" } }
    }

    @Transactional(readOnly = true)
    override fun existsByUsername(username: Username): Boolean {
        log.debug { "Checking existence by username: ${username.value}" }
        return springDataJpaUserRepository.existsByUsername(username.value)
    }

    @Transactional(readOnly = true)
    override fun existsByEmail(email: Email): Boolean {
        log.debug { "Checking existence by email: ${email.value}" }
        return springDataJpaUserRepository.existsByEmailValue(email.value)
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/build.gradle.kts
 Path: domains/user/presentation/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    kotlin("jvm")
    
}

dependencies {
    // Keep module-specific dependencies
    implementation(project(":domains:user:application"))
    implementation(project(":domains:common"))

    // Keep presentation-specific dependencies
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.5")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.5")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.5")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")

    // Common dependencies (kotlin, slf4j, jackson, test deps) are handled by subprojects block
    // implementation(libs.kotlin.stdlib)
    // implementation(libs.kotlin.logging.jvm)
    // implementation(libs.jackson.module.kotlin)
    // implementation(libs.jackson.datatype.jsr310)
    // implementation(libs.jakarta.validation.api)
    // implementation(libs.jakarta.servlet.api)

    // Test dependencies handled by subprojects block
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserAddressController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserAddressController.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.api

import com.restaurant.common.config.dto.response.CommandResultResponse
import com.restaurant.common.config.filter.CorrelationIdFilter
import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.port.`in`.DeleteAddressUseCase
import com.restaurant.user.application.port.`in`.RegisterAddressUseCase
import com.restaurant.user.application.port.`in`.UpdateAddressUseCase
import com.restaurant.user.presentation.extensions.v1.request.toCommand
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import mu.KotlinLogging
import org.slf4j.MDC
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

private val log = KotlinLogging.logger {}

@Tag(name = "사용자 주소 관리 API V1", description = "사용자 주소 등록, 수정, 삭제 API")
@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
class UserAddressController(
    private val registerAddressUseCase: RegisterAddressUseCase,
    private val updateAddressUseCase: UpdateAddressUseCase,
    private val deleteAddressUseCase: DeleteAddressUseCase,
) {
    @Operation(summary = "주소 등록")
    @PostMapping
    fun registerAddress(
        @Parameter(description = "사용자 ID") @PathVariable userId: String,
        @Valid @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Registering address for userId: $userId" }
        val command = request.toCommand(userId)
        registerAddressUseCase.handle(command)

        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "unknown"
        val response = CommandResultResponse(
            message = "주소 등록 성공",
            correlationId = correlationId,
        )

        response.add(linkTo(methodOn(UserAddressController::class.java).registerAddress(userId, request)).withSelfRel())

        log.info { "Address registered for userId: $userId" }
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "주소 수정")
    @PutMapping("/{addressId}")
    fun updateAddress(
        @Parameter(description = "사용자 ID") @PathVariable userId: String,
        @Parameter(description = "주소 ID") @PathVariable addressId: String,
        @Valid @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "N/A"
        log.info { "Updating address $addressId for userId: $userId" }

        val command = request.toCommand(userId, addressId)
        updateAddressUseCase.handle(command)

        val response = CommandResultResponse(
            message = "주소 수정 성공",
            correlationId = correlationId,
        )
        response.add(linkTo(methodOn(UserAddressController::class.java).updateAddress(userId, addressId, request)).withSelfRel())

        log.info { "Address $addressId updated for userId: $userId" }
        return ResponseEntity.ok(response)
    }

    @Operation(summary = "주소 삭제")
    @DeleteMapping("/{addressId}")
    fun deleteAddress(
        @Parameter(description = "사용자 ID") @PathVariable userId: String,
        @Parameter(description = "주소 ID") @PathVariable addressId: String,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = MDC.get(CorrelationIdFilter.CORRELATION_ID_MDC_KEY) ?: "N/A"
        log.info { "Deleting address $addressId for userId: $userId" }

        val command = DeleteAddressCommand(userId = userId, addressId = addressId)
        deleteAddressUseCase.handle(command)

        val response = CommandResultResponse(
            message = "주소 삭제 성공",
            correlationId = correlationId,
        )
        response.add(linkTo(methodOn(UserAddressController::class.java).deleteAddress(userId, addressId)).withSelfRel())

        log.info { "Address $addressId deleted for userId: $userId" }
        return ResponseEntity.ok(response)
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserController.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.api

import com.restaurant.common.config.dto.response.CommandResultResponse
import com.restaurant.common.config.filter.CorrelationIdFilter
// Command Use Cases
import com.restaurant.user.application.port.`in`.ChangePasswordUseCase
import com.restaurant.user.application.port.`in`.DeleteAddressUseCase
import com.restaurant.user.application.port.`in`.DeleteUserUseCase
import com.restaurant.user.application.port.`in`.RegisterAddressUseCase
import com.restaurant.user.application.port.`in`.RegisterUserUseCase
import com.restaurant.user.application.port.`in`.UpdateAddressUseCase
import com.restaurant.user.application.port.`in`.UpdateProfileUseCase
// Query Use Cases
import com.restaurant.user.application.port.`in`.GetUserAddressesQuery
import com.restaurant.user.application.port.`in`.GetUserProfileQuery
// DTOs
import com.restaurant.user.application.dto.command.DeleteAddressCommand
import com.restaurant.user.application.dto.query.AddressDto
import com.restaurant.user.application.dto.query.GetUserAddressesQuery as AppGetUserAddressesQuery
import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.presentation.v1.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
// Extensions
import com.restaurant.user.presentation.v1.extensions.request.toCommand
import com.restaurant.user.presentation.v1.extensions.response.toResponse
import com.restaurant.user.presentation.v1.extensions.response.toResponseV1
// Other imports
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.MDC
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(name = "User Commands", description = "API for user account management (registration, login, profile updates, password change, deletion)")
@RestController
@RequestMapping("/api/v1/users")
class UserController(
    private val registerUserUseCase: RegisterUserUseCase,
    private val loginUseCase: LoginUseCase,
    private val updateProfileUseCase: UpdateProfileUseCase,
    private val changePasswordUseCase: ChangePasswordUseCase,
    private val deleteUserUseCase: DeleteUserUseCase,
    // Remove Address Use Cases - Moved to UserAddressController
    // private val registerAddressUseCase: RegisterAddressUseCase,
    // private val updateAddressUseCase: UpdateAddressUseCase,
    // private val deleteAddressUseCase: DeleteAddressUseCase
) {

    @PostMapping
    @Operation(summary = "Register a new user")
    @ApiResponse(responseCode = "201", description = "User registered successfully")
    fun registerUser(@Valid @RequestBody request: RegisterUserRequestV1): ResponseEntity<CommandResultResponse> {
        log.info("Register user request received: {}", request.username)
        val command = request.toCommand()
        val userId = registerUserUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "User registered successfully",
        ).apply {
            add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.value.toString())).withSelfRel())
            add(linkTo(methodOn(UserController::class.java).loginUser(null)).withRel("login")) // Pass null for request body placeholder
        }
        return ResponseEntity.created(response.getRequiredLink("self").toUri()).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "Login a user")
    @ApiResponse(responseCode = "200", description = "User logged in successfully")
    fun loginUser(@Valid @RequestBody request: LoginRequestV1): ResponseEntity<Any> { // Return type can be more specific
        log.info("Login request received for email: {}", request.email)
        val command = request.toCommand()
        val loginResult = loginUseCase.login(command)
        // Login response usually includes the token directly, maybe not CommandResultResponse
        // HATEOAS for login might link to profile, logout etc.
        val response = mapOf(
             "status" to "SUCCESS",
             "message" to "Login successful",
             "data" to loginResult
        ) // Example - Adapt response as needed
        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "Update user profile")
    @ApiResponse(responseCode = "200", description = "Profile updated successfully")
    fun updateProfile(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: UpdateProfileRequestV1
    ): ResponseEntity<CommandResultResponse> {
        log.info("Update profile request received for user: {}", userId)
        val command = request.toCommand(userId)
        updateProfileUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "Profile updated successfully",
        ).apply {
            add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withSelfRel())
        }
        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "Change user password")
    @ApiResponse(responseCode = "200", description = "Password changed successfully")
    fun changePassword(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: ChangePasswordRequestV1
    ): ResponseEntity<CommandResultResponse> {
        log.info("Change password request received for user: {}", userId)
        val command = request.toCommand(userId)
        changePasswordUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "Password changed successfully",
        ).apply {
            add(linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId.toString())).withRel("view-profile"))
        }
        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "Delete user account")
    @ApiResponse(responseCode = "200", description = "User deleted successfully")
    fun deleteUser(
        @Parameter(description = "User ID") @PathVariable userId: UUID,
        @Valid @RequestBody request: DeleteUserRequestV1 // Assuming password needed for deletion
    ): ResponseEntity<CommandResultResponse> {
        log.info("Delete user request received for user: {}", userId)
        val command = request.toCommand(userId)
        deleteUserUseCase.handle(command)
        val response = CommandResultResponse(
            status = "SUCCESS",
            message = "User deleted successfully",
        )
        // No HATEOAS links usually for deletion confirmation
        return ResponseEntity.ok(response)
    }

    // Remove Address related endpoints
    // @PostMapping("/{userId}/addresses") ...
    // @PutMapping("/{userId}/addresses/{addressId}") ...
    // @DeleteMapping("/{userId}/addresses/{addressId}") ...

    // Remove Query related endpoints (moved to UserQueryController)
    // @GetMapping("/{userId}/profile") ...
    // @GetMapping("/{userId}/addresses") ...
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/api/UserQueryController.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.api

import com.restaurant.user.application.dto.query.GetUserProfileByIdQuery
import com.restaurant.user.application.port.`in`.GetUserProfileQuery
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
import com.restaurant.user.presentation.v1.extensions.response.toResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Queries", description = "API for querying user information")
class UserQueryController(
    private val getUserProfileQueryUseCase: GetUserProfileQuery,
) {
    @GetMapping("/{userId}/profile")
    @Operation(summary = "Get user profile", description = "Retrieves user profile information by User ID.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "Profile retrieved successfully",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = UserProfileResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "Invalid UUID format",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "User not found",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "User ID (UUID)", required = true) @PathVariable userId: String,
    ): ResponseEntity<UserProfileResponseV1> {
        log.info { "Received request to get user profile for ID: $userId" }

        val query = GetUserProfileByIdQuery(userId = userId)
        val userProfileDto = getUserProfileQueryUseCase.getUserProfile(query)

        val responseDto = userProfileDto.toResponseV1()

        val userUuid = UUID.fromString(userId)
        responseDto.add(
            linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId)).withSelfRel(),
            linkTo(methodOn(UserController::class.java).updateProfile(userUuid, null)).withRel("update-profile"),
            linkTo(methodOn(UserController::class.java).changePassword(userUuid, null)).withRel("change-password"),
        )
        log.info { "Returning user profile for ID: $userId" }
        return ResponseEntity.ok(responseDto)
    }
}

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/ChangePasswordRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/ChangePasswordRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/DeleteUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/DeleteUserRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/LoginRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/LoginRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterAddressRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/RegisterUserRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

@Schema(description = "사용자 등록 요청")
data class RegisterUserRequestV1(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser")
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    @Schema(description = "전화번호 (선택)", example = "010-1234-5678")
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateAddressRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateProfileRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/request/UpdateProfileRequestV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/AddressResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/AddressResponseV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/LoginResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/LoginResponseV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답 V1")
data class LoginResponseV1(
    @Schema(description = "사용자 ID (UUID)")
    val userId: String,
    @Schema(description = "사용자 이름")
    val username: String,
    @Schema(description = "사용자 이메일")
    val email: String,
    @Schema(description = "액세스 토큰")
    val accessToken: String,
    @Schema(description = "리프레시 토큰")
    val refreshToken: String,
) : RepresentationModel<LoginResponseV1>()

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/UserProfileResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/dto/response/UserProfileResponseV1.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import org.springframework.hateoas.server.core.Relation
import java.time.Instant

@Schema(description = "주소 응답")
data class AddressResponseV1(
    @Schema(description = "주소 ID") val addressId: String,
    @Schema(description = "도로명 주소") val street: String,
    @Schema(description = "상세 주소") val detail: String,
    @Schema(description = "우편번호") val zipCode: String,
    @Schema(description = "기본 주소 여부") val isDefault: Boolean,
)

/**
 * 사용자 프로필 정보 응답 DTO (Rule 1.4, 39)
 */
@Relation(collectionRelation = "users", itemRelation = "user") // For HATEOAS collection relation
@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "사용자 아이디", example = "testuser") val username: String,
    @Schema(description = "전화번호", example = "010-1234-5678", nullable = true) val phoneNumber: String?,
    @Schema(description = "사용자 타입", example = "CUSTOMER") val userType: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) : RepresentationModel<UserProfileResponseV1>() // Inherit from RepresentationModel

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/command/dto/request/UserCommandRequestExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/command/dto/request/UserCommandRequestExtensions.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.extensions.command.dto.request

import com.restaurant.user.application.dto.command.ChangePasswordCommand
import com.restaurant.user.application.dto.command.DeleteUserCommand
import com.restaurant.user.application.dto.command.LoginCommand
import com.restaurant.user.application.dto.command.RegisterAddressCommand
import com.restaurant.user.application.dto.command.RegisterUserCommand
import com.restaurant.user.application.dto.command.UpdateAddressCommand
import com.restaurant.user.application.dto.command.UpdateProfileCommand
import com.restaurant.user.domain.aggregate.UserType
import com.restaurant.user.presentation.v1.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.dto.request.UpdateProfileRequestV1
import java.util.UUID

// RegisterUserRequestV1 -> RegisterUserCommand 변환
fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        username = this.username,
        password = this.password,
        email = this.email,
        name = this.name,
        phoneNumber = this.phoneNumber,
        userType = this.userType ?: UserType.CUSTOMER, // Default to CUSTOMER if null
    )

// LoginRequestV1 -> LoginCommand 변환
fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

// UpdateProfileRequestV1 -> UpdateProfileCommand 변환
fun UpdateProfileRequestV1.toCommand(userId: UUID): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId,
        name = this.name,
        phoneNumber = this.phoneNumber,
    )

// ChangePasswordRequestV1 -> ChangePasswordCommand 변환
fun ChangePasswordRequestV1.toCommand(userId: UUID): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId,
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

// DeleteUserRequestV1 -> DeleteUserCommand 변환
fun DeleteUserRequestV1.toCommand(userId: UUID): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId,
        password = this.password,
    )

// RegisterAddressRequestV1 -> RegisterAddressCommand 변환
fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// UpdateAddressRequestV1 -> UpdateAddressCommand 변환
fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

--------------------------------------------------------------------



====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/query/dto/response/UserQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/extensions/query/dto/response/UserQueryResponseExtensions.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.user.presentation.v1.extensions.query.dto.response

import com.restaurant.user.application.dto.query.UserProfileDto
import com.restaurant.user.presentation.v1.controller.UserController
import com.restaurant.user.presentation.v1.controller.UserQueryController
import com.restaurant.user.presentation.v1.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.dto.response.UserProfileResponseV1
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import java.util.UUID

// UserProfileDto -> UserProfileResponseV1 변환
fun UserProfileDto.toResponseV1(): UserProfileResponseV1 {
    val userId = this.id // Assuming UserProfileDto has 'id' which is the UUID string
    val userUuid = UUID.fromString(userId)

    // Use correct Controller classes for links
    val selfLink = linkTo(methodOn(UserQueryController::class.java).getUserProfile(userId)).withSelfRel()
    // Assuming addresses are handled by UserAddressController or UserQueryController
    // val addressesLink = linkTo(methodOn(UserAddressController::class.java).getUserAddresses(userUuid)).withRel("addresses")
    val updateProfileLink =
        linkTo(methodOn(UserController::class.java).updateProfile(userUuid, null)).withRel("update-profile")
    val changePasswordLink =
        linkTo(methodOn(UserController::class.java).changePassword(userUuid, null)).withRel("change-password")
    val deleteUserLink = linkTo(methodOn(UserController::class.java).deleteUser(userUuid, null)).withRel("delete-user")

    return UserProfileResponseV1(
        id = this.id,
        username = this.username,
        email = this.email,
        name = this.name,
        phoneNumber = this.phoneNumber,
        userType = this.userType,
        status = this.userStatus, // Map userStatus field added in Query DTO
        createdAt = this.createdAt,
        status = this.status,
        version = this.version, // Keep as Instant or format as needed
        updatedAt = this.updatedAt, // Keep as Instant or format as needed
        addresses = this.addresses.map { it.toResponseV1() }, // Use correct function name
    ).apply {
        // Add relevant links
        add(selfLink, updateProfileLink, changePasswordLink, deleteUserLink)
        // if (addressesLink != null) add(addressesLink) // Add address link if implemented
    }
}

// UserProfileDto.AddressDto -> AddressResponseV1 변환
fun UserProfileDto.AddressDto.toResponseV1(): AddressResponseV1 {
    // Add links if needed, e.g., link to update/delete this specific address
    // val updateLink = linkTo(methodOn(UserAddressController::class.java).updateAddress(userId, addressId, null)).withRel("update")
    // val deleteLink = linkTo(methodOn(UserAddressController::class.java).deleteAddress(userId, addressId)).withRel("delete")
    return AddressResponseV1(
        id = this.id, // Use correct field name 'id' from DTO
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    ) // .apply { add(updateLink, deleteLink) }
}

// List extension (can be useful)
fun List<UserProfileDto.AddressDto>.toResponseV1(): List<AddressResponseV1> = map { it.toResponseV1() }

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/build.gradle.kts
 Path: independent/outbox/build.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
plugins {
    kotlin("jvm")
    kotlin("plugin.jpa")
    kotlin("plugin.allopen")
    
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.Embeddable")
    annotation("jakarta.persistence.MappedSuperclass")
}

dependencies {
    // REMOVED: Dependencies belong in submodules
    // implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    // implementation("org.springframework.kafka:spring-kafka")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.5")
    implementation("org.springframework.kafka:spring-kafka:3.1.2")
    runtimeOnly("com.h2database:h2:2.2.224")
    runtimeOnly("org.postgresql:postgresql:42.7.3")
    // testImplementation("org.springframework.boot:spring-boot-starter-test")
    // testImplementation("org.springframework.kafka:spring-kafka-test")
    // testImplementation("org.testcontainers:junit-jupiter")
    // testImplementation("org.testcontainers:kafka")
    // testImplementation("org.testcontainers:postgresql")
}

// REMOVED: Configuration belongs in the infrastructure submodule
// allOpen {
//     annotation("jakarta.persistence.Entity")
//     annotation("jakarta.persistence.Embeddable")
//     annotation("jakarta.persistence.MappedSuperclass")
// }
//
// noArg {
//     annotation("jakarta.persistence.Entity")
// }

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/OutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/OutboxMessageRepository.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.port

import com.restaurant.outbox.port.model.OutboxMessage
import com.restaurant.outbox.port.model.OutboxMessageStatus
import java.util.UUID

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 * 이 인터페이스는 Outbox 메시지의 저장, 조회, 상태 업데이트 등의 작업을 정의합니다.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다.
     *
     * @param message 저장할 메시지
     * @return 저장된 메시지
     */
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     * @return 저장된 메시지 목록
     */
    fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage>

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: UUID): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어해야 합니다.
     *
     * @param status 조회할 메시지 상태
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다.
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID
     * @param newStatus 새로운 상태
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 시간 이전에 생성된 실패 상태의 메시지들을 조회합니다.
     *
     * @param maxRetries 최대 재시도 횟수
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>

    fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    fun countByStatus(status: OutboxMessageStatus): Long

    fun incrementRetryCount(id: UUID): OutboxMessage?
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessage.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessage.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.port.model

import com.restaurant.outbox.port.model.OutboxMessageStatus
import java.time.Instant
import java.util.UUID

/**
 * Represents a message to be stored in the outbox.
 * This is a technology-agnostic model that contains all necessary information for message delivery.
 *
 * @property id Unique identifier for the message
 * @property payload The serialized message content as a byte array
 * @property topic The target Kafka topic for message delivery
 * @property headers Additional message headers including correlationId, aggregateType, aggregateId, etc.
 * @property aggregateId Domain ID of the aggregate that generated the event (in string format)
 * @property aggregateType Type of the aggregate that generated the event
 * @property status Current status of the message
 * @property retryCount Number of retry attempts made
 * @property createdAt When the message was created
 * @property updatedAt When the message was last updated
 * @property lastAttemptTime When the last delivery attempt was made
 */
data class OutboxMessage(
    val id: UUID = UUID.randomUUID(),
    val payload: ByteArray,
    val topic: String,
    val headers: Map<String, String>,
    val aggregateId: String,
    val aggregateType: String,
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val createdAt: Instant = Instant.now(),
    val updatedAt: Instant = createdAt,
    val lastAttemptTime: Instant? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateId != other.aggregateId) return false
        if (aggregateType != other.aggregateType) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String =
        "OutboxMessage(" +
            "id=$id, " +
            "topic='$topic', " +
            "headers=$headers, " +
            "aggregateId='$aggregateId', " +
            "aggregateType='$aggregateType', " +
            "status=$status, " +
            "retryCount=$retryCount, " +
            "createdAt=$createdAt, " +
            "updatedAt=$updatedAt, " +
            "lastAttemptTime=$lastAttemptTime" +
            ")"
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessageStatus.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/port/model/OutboxMessageStatus.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.port.model

/**
 * Outbox 메시지의 상태를 나타내는 enum
 */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.persistence.entity

import com.restaurant.outbox.infrastructure.converter.StringMapConverter
import com.restaurant.outbox.port.model.OutboxMessageStatus
import jakarta.persistence.Column
import jakarta.persistence.Convert
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Lob
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant
import java.util.UUID

/**
 * JPA Entity for Outbox messages.
 * Rule 83
 */
@Entity
@Table(name = "outbox_events")
data class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "aggregate_type", nullable = false)
    val aggregateType: String,
    @Column(name = "aggregate_id", nullable = false)
    val aggregateId: String,
    @Column(name = "event_type", nullable = false)
    val eventType: String,
    @Lob
    @Column(name = "payload", nullable = false)
    val payload: ByteArray,
    @Column(name = "target_topic", nullable = false)
    val targetTopic: String,
    @Lob
    @Column(name = "headers", nullable = false, columnDefinition = "TEXT")
    @Convert(converter = StringMapConverter::class)
    val headers: Map<String, String>,
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    var status: OutboxMessageStatus,
    @Column(nullable = false)
    var retryCount: Int,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant,
    @Column(nullable = false)
    var updatedAt: Instant,
    @Column(nullable = true)
    var lastAttemptTime: Instant?,
    @Version
    @Column(nullable = false)
    val version: Long = 0L,
) {
    /**
     * ByteArray 필드가 포함된 엔티티의 equals/hashCode 구현
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventEntity

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (targetTopic != other.targetTopic) return false
        if (headers != other.headers) return false
        if (aggregateId != other.aggregateId) return false
        if (aggregateType != other.aggregateType) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false
        if (version != other.version) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + targetTopic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        result = 31 * result + version.hashCode()
        return result
    }
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.error

/**
 * Outbox 모듈 관련 에러 코드 Enum
 */
enum class OutboxErrorCode(
    val code: String,
    val message: String,
) {
    MESSAGE_SERIALIZATION_FAILED("OUTBOX-INFRA-001", "Failed to serialize outbox message payload."),
    MESSAGE_DESERIALIZATION_FAILED("OUTBOX-INFRA-002", "Failed to deserialize outbox message payload."),
    KAFKA_PRODUCER_ERROR("OUTBOX-INFRA-003", "Error occurred while sending message to Kafka."),
    DATABASE_OPERATION_FAILED("OUTBOX-INFRA-004", "Database operation failed for outbox message."),
    UNEXPECTED_INFRA_ERROR("OUTBOX-INFRA-999", "An unexpected infrastructure error occurred in the outbox module."),
    // 필요한 다른 Outbox 에러 코드 추가
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.exception

import com.restaurant.outbox.infrastructure.error.OutboxErrorCode

/**
 * Outbox 모듈에서 발생하는 예외의 베이스 클래스
 */
sealed class OutboxException(
    val errorCode: OutboxErrorCode,
    override val message: String = errorCode.message,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * 메시지 직렬화 관련 예외
     */
    class SerializationException(
        errorCode: OutboxErrorCode = OutboxErrorCode.MESSAGE_SERIALIZATION_FAILED,
        override val message: String = errorCode.message,
        cause: Throwable? = null,
    ) : OutboxException(errorCode, message, cause)

    /**
     * 메시지 역직렬화 관련 예외
     */
    class DeserializationException(
        errorCode: OutboxErrorCode = OutboxErrorCode.MESSAGE_DESERIALIZATION_FAILED,
        override val message: String = errorCode.message,
        cause: Throwable? = null,
    ) : OutboxException(errorCode, message, cause)

    /**
     * Kafka 전송 관련 예외
     */
    class KafkaProducerException(
        errorCode: OutboxErrorCode = OutboxErrorCode.KAFKA_PRODUCER_ERROR,
        override val message: String = errorCode.message,
        cause: Throwable? = null,
    ) : OutboxException(errorCode, message, cause)

    /**
     * 데이터베이스 작업 관련 예외
     */
    class DatabaseOperationException(
        errorCode: OutboxErrorCode = OutboxErrorCode.DATABASE_OPERATION_FAILED,
        override val message: String = errorCode.message,
        cause: Throwable? = null,
    ) : OutboxException(errorCode, message, cause)

    /**
     * 예상치 못한 인프라 예외
     */
    class UnexpectedInfraException(
        errorCode: OutboxErrorCode = OutboxErrorCode.UNEXPECTED_INFRA_ERROR,
        override val message: String = errorCode.message,
        cause: Throwable? = null,
    ) : OutboxException(errorCode, message, cause)

    /**
     * 메시지 폴링 관련 예외 (Removed - Use more specific exceptions like DatabaseOperationException)
     */
    // class PollingException(
    //     override val message: String,
    //     cause: Throwable? = null,
    // ) : OutboxException(OutboxErrorCode.UNEXPECTED_INFRA_ERROR, message, cause)

    /**
     * 메시지 전송 관련 예외 (Removed - Use KafkaProducerException)
     */
    // class MessageSendException(
    //     override val message: String,
    //     cause: Throwable? = null,
    // ) : OutboxException(OutboxErrorCode.KAFKA_PRODUCER_ERROR, message, cause)

    /**
     * 최대 재시도 횟수 초과 예외 (Removed - Let poller handle retry logic state)
     */
    // class MaxRetriesExceededException(
    //     override val message: String,
    //     cause: Throwable? = null,
    // ) : OutboxException(OutboxErrorCode.UNEXPECTED_INFRA_ERROR, message, cause)

    // Removed duplicated simple data class exceptions (SerializationFailed, etc.)
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/OutboxMessageSender.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/OutboxMessageSender.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.kafka

// OutboxMessageSender: Outbox 메시지를 Kafka로 전송하는 역할
class OutboxMessageSender {
    // TODO: 구현 필요
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/config/KafkaOutboxProducerConfig.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/kafka/config/KafkaOutboxProducerConfig.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.kafka.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Kafka Producer Configuration specifically for the Outbox module.
 * Configures KafkaTemplate to send raw byte arrays (Rule 129).
 */
@Configuration
class KafkaOutboxProducerConfig {
    @Value("\${spring.kafka.bootstrap-servers}")
    private lateinit var bootstrapServers: String

    // No Schema Registry URL needed here as we send raw bytes
    // @Value("\${spring.kafka.properties.schema.registry.url}")
    // private lateinit var schemaRegistryUrl: String

    @Bean("outboxKafkaProducerFactory")
    fun outboxProducerFactory(): ProducerFactory<String, ByteArray> {
        val configProps: MutableMap<String, Any> = HashMap()
        configProps[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = bootstrapServers
        configProps[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java
        // Rule 129: Use ByteArraySerializer for value as payload is pre-serialized bytes
        configProps[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = ByteArraySerializer::class.java

        // Optional: Configure idempotence, retries, acks etc. for higher reliability
        // configProps[ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG] = "true"
        // configProps[ProducerConfig.ACKS_CONFIG] = "all"
        // configProps[ProducerConfig.RETRIES_CONFIG] = Int.MAX_VALUE.toString()
        // configProps[ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION] = "5"

        // No Schema Registry config needed for ByteArraySerializer
        // configProps["schema.registry.url"] = schemaRegistryUrl

        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean("outboxKafkaTemplate")
    fun outboxKafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(outboxProducerFactory())
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/JpaOutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/JpaOutboxMessageRepository.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.persistence

import com.restaurant.outbox.infrastructure.exception.OutboxException
import com.restaurant.outbox.infrastructure.persistence.entity.OutboxEventEntity
import com.restaurant.outbox.infrastructure.persistence.extensions.toDomainModel
import com.restaurant.outbox.infrastructure.persistence.extensions.toEntity
import com.restaurant.outbox.port.OutboxMessageRepository
import com.restaurant.outbox.port.model.OutboxMessage
import com.restaurant.outbox.port.model.OutboxMessageStatus
import jakarta.persistence.LockModeType
import mu.KotlinLogging
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Modifying
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.findByIdOrNull
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.util.UUID

private val log = KotlinLogging.logger {}

/**
 * Interface combining JpaRepository and custom methods for OutboxEventEntity.
 * This interface will be implemented by Spring Data JPA. Uses UUID as ID type.
 */
interface JpaOutboxMessageRepository :
    JpaRepository<OutboxEventEntity, UUID>,
    OutboxMessageRepositoryCustom {
    fun findByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        pageable: Pageable,
    ): List<OutboxEventEntity> // Use Pageable for limit

    fun countByStatus(status: OutboxMessageStatus): Long

    fun findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        retryCount: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity> // Use Pageable for limit

    // Custom query for finding and locking with SKIP LOCKED (PostgreSQL specific example)
    // Adjust the query for your specific database if not PostgreSQL
    @Lock(LockModeType.PESSIMISTIC_WRITE) // Basic pessimistic lock, DB specific needed for SKIP LOCKED
    @Query(
        value = """
            SELECT o.* FROM outbox_events o
            WHERE o.status = :#{#status.name()}
            ORDER BY o.created_at ASC
            LIMIT :limit FOR UPDATE SKIP LOCKED
        """,
        nativeQuery = true,
    )
    fun findAndLockByStatusNativeSkipLocked(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxEventEntity>

    @Modifying
    @Transactional // Add Transactional for modifying queries
    @Query("UPDATE OutboxEventEntity o SET o.status = :newStatus, o.updatedAt = :now WHERE o.id = :id")
    fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        now: Instant,
    ): Int

    @Modifying
    @Transactional // Add Transactional for modifying queries
    @Query(
        "UPDATE OutboxEventEntity o SET o.status = :newStatus, o.retryCount = o.retryCount + 1, o.lastAttemptTime = :now, o.updatedAt = :now WHERE o.id = :id",
    )
    fun updateStatusAndIncrementRetry(
        id: UUID,
        newStatus: OutboxMessageStatus,
        now: Instant,
    ): Int
}

/**
 * Custom methods separated for clarity, implemented below.
 */
interface OutboxMessageRepositoryCustom {
    fun findAndLockByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxEventEntity>
    // Add other custom methods if needed
}

/**
 * Implementation of the Port interface and custom methods.
 * Uses the Spring Data JPA repository for database operations.
 */
@Repository("jpaOutboxMessageRepositoryImpl") // Changed bean name slightly for clarity
class JpaOutboxMessageRepositoryImpl(
    private val springDataRepo: JpaOutboxMessageRepository, // Inject the composite interface
) : OutboxMessageRepository,
    OutboxMessageRepositoryCustom { // Implement both Port and Custom
    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        log.debug { "Saving single outbox message: aggregateId=${message.aggregateId}, topic=${message.topic}" }
        try {
            val entity = message.toEntity()
            val savedEntity = springDataRepo.save(entity)
            return savedEntity.toDomainModel()
        } catch (e: Exception) {
            log.error(e) { "Error saving single outbox message with aggregateId ${message.aggregateId}" }
            throw OutboxException.DatabaseOperationException(message = "Failed to save outbox message", cause = e)
        }
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage> {
        if (messages.isEmpty()) return emptyList()
        log.debug { "Saving ${messages.size} outbox message(s). First aggregateId=${messages.firstOrNull()?.aggregateId}" }
        try {
            val entities = messages.map { it.toEntity() }
            val savedEntities = springDataRepo.saveAll(entities)
            return savedEntities.map { it.toDomainModel() }
        } catch (e: Exception) {
            log.error(e) { "Error saving batch of ${messages.size} outbox messages" }
            throw OutboxException.DatabaseOperationException(message = "Failed to save batch of outbox messages", cause = e)
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: UUID): OutboxMessage? {
        log.trace { "Finding outbox message by ID: $id" }
        return springDataRepo.findByIdOrNull(id)?.toDomainModel()
    }

    @Transactional(readOnly = true)
    override fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> =
        springDataRepo
            .findByStatusOrderByCreatedAtAsc(status, Pageable.ofSize(limit))
            .map { it.toDomainModel() }

    // Implementation of findAndLockByStatus using the native query
    @Transactional
    override fun findAndLockByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxEventEntity> {
        log.trace { "Finding and locking up to $limit messages with status $status." }
        try {
            // Use the native query with SKIP LOCKED
            val lockedEntities: List<OutboxEventEntity> = springDataRepo.findAndLockByStatusNativeSkipLocked(status, limit)
            log.debug { "Found and locked ${lockedEntities.size} messages with status $status." }
            return lockedEntities
        } catch (e: Exception) {
            log.error(e) { "Database error finding and locking messages with status $status" }
            throw OutboxException.DatabaseOperationException(message = "Failed to find/lock messages with status $status", cause = e)
        }
    }

    @Transactional
    override fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        log.debug { "Updating status for outbox message $id to $newStatus (incrementRetry=$incrementRetry)" }
        try {
            val entity = springDataRepo.findByIdOrNull(id) ?: return null
            entity.status = newStatus
            entity.updatedAt = Instant.now()
            if (incrementRetry) {
                entity.retryCount += 1
                entity.lastAttemptTime = Instant.now()
            }
            val saved = springDataRepo.save(entity)
            return saved.toDomainModel()
        } catch (e: Exception) {
            log.error(e) { "Error updating status for outbox message $id to $newStatus" }
            throw OutboxException.DatabaseOperationException(message = "Failed to update outbox message status", cause = e)
        }
    }

    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> {
        log.debug { "Finding and marking up to $limit messages with status $status for processing." }
        try {
            val lockedEntities = springDataRepo.findAndLockByStatusNativeSkipLocked(status, limit)
            lockedEntities.forEach {
                it.status = OutboxMessageStatus.PROCESSING
                it.updatedAt = Instant.now()
            }
            val saved = springDataRepo.saveAll(lockedEntities)
            return saved.map { it.toDomainModel() }
        } catch (e: Exception) {
            log.error(e) { "Database error finding/marking messages with status $status" }
            throw OutboxException.DatabaseOperationException(message = "Failed to find/mark messages with status $status", cause = e)
        }
    }

    @Transactional
    override fun incrementRetryCount(id: UUID): OutboxMessage? {
        log.debug { "Incrementing retry count for outbox message $id" }
        try {
            val entity = springDataRepo.findByIdOrNull(id) ?: return null
            entity.retryCount += 1
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()
            val saved = springDataRepo.save(entity)
            return saved.toDomainModel()
        } catch (e: Exception) {
            log.error(e) { "Error incrementing retry count for outbox message $id" }
            throw OutboxException.DatabaseOperationException(message = "Failed to increment retry count", cause = e)
        }
    }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long = springDataRepo.countByStatus(status)

    @Transactional(readOnly = true)
    override fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        springDataRepo
            .findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
                OutboxMessageStatus.FAILED,
                maxRetries,
                Pageable.ofSize(limit),
            ).map { it.toDomainModel() }
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/converter/StringMapConverter.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/converter/StringMapConverter.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.converter

import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.ObjectMapper
import jakarta.persistence.AttributeConverter
import jakarta.persistence.Converter

@Converter(autoApply = true)
class StringMapConverter : AttributeConverter<Map<String, String>, String> {
    private val objectMapper = ObjectMapper()

    override fun convertToDatabaseColumn(attribute: Map<String, String>?): String =
        if (attribute == null || attribute.isEmpty()) {
            "{}"
        } else {
            objectMapper.writeValueAsString(attribute)
        }

    override fun convertToEntityAttribute(dbData: String?): Map<String, String> =
        if (dbData.isNullOrBlank()) {
            emptyMap()
        } else {
            objectMapper.readValue(dbData, object : TypeReference<Map<String, String>>() {})
        }
}

--------------------------------------------------------------------



====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/extensions/OutboxMessageExtensions.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/persistence/extensions/OutboxMessageExtensions.kt
 Timestamp: 2025-04-28 14:26:44
====================================================================
package com.restaurant.outbox.infrastructure.persistence.extensions

import com.restaurant.outbox.infrastructure.persistence.entity.OutboxEventEntity
import com.restaurant.outbox.port.model.OutboxMessage

/**
 * OutboxMessage DTO (from port) -> OutboxEventEntity (for infrastructure persistence)
 */
fun OutboxMessage.toEntity(): OutboxEventEntity =
    OutboxEventEntity(
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.headers["eventType"] ?: "",
        payload = this.payload,
        targetTopic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        lastAttemptTime = this.lastAttemptTime,
        updatedAt = this.updatedAt,
    )

/**
 * OutboxEventEntity -> OutboxMessage DTO (Optional - if needed by poller/sender)
 */
fun OutboxEventEntity.toDto(): OutboxMessage =
    OutboxMessage(
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        payload = this.payload,
        topic = this.targetTopic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

fun OutboxEventEntity.toDomainModel(): OutboxMessage =
    OutboxMessage(
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        payload = this.payload,
        topic = this.targetTopic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

--------------------------------------------------------------------



====================================================================
 File: settings.gradle.kts
 Path: settings.gradle.kts
 Timestamp: 2025-04-28 14:26:44
====================================================================
import java.net.URI
import java.io.File

pluginManagement {
    repositories {
        gradlePluginPortal()
        mavenCentral()
        maven { url = uri("https://repo.spring.io/milestone") }
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        mavenCentral()
        maven { url = uri("https://packages.confluent.io/maven/") }
        maven { url = uri("https://jitpack.io") }
        flatDir { dirs("libs") }
    }
}

rootProject.name = "restaurant"

include(
    ":domains:common",
    ":domains:user:presentation",
    ":domains:user:application",
    ":domains:user:domain",
    ":domains:user:infrastructure:persistence",
    ":domains:user:infrastructure:messaging",
    ":independent:outbox",
    ":apps:user-app"
)

fun includeGradleBuilds(vararg paths: String) {
    paths.forEach { path ->
        val moduleName = path.substring(1).replace("/", ":")
        includeBuild(path) {
            dependencySubstitution {
                substitute(module(moduleName)).using(project(":"))
            }
        }
    }
}

fun isCiServer(): Boolean {
    return System.getenv("CI") != null
}

fun shouldIncludeBuild(modulePath: String): Boolean {
    val ci = isCiServer()
    val requestedPath = System.getProperty("includeBuild")

    return when {
        !ci && requestedPath == null -> true // Local build, no specific request: include all
        !ci && requestedPath != null -> modulePath == requestedPath // Local build, specific request: include only requested
        else -> false // CI build: never include builds
    }
}

--------------------------------------------------------------------


==============================================================
 File Collection Completed: 2025-04-28 23:26:44 
==============================================================
