> Task :domains:common:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:processResources NO-SOURCE
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:application:processResources NO-SOURCE
> Task :domains:user:infrastructure:processResources
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:apps:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:processResources
> Task :domains:user:apps:processResources
> Task :domains:user:application:loadKtlintReporters
> Task :domains:user:apps:loadKtlintReporters
> Task :domains:user:domain:loadKtlintReporters
> Task :domains:user:infrastructure:loadKtlintReporters
> Task :domains:user:apps:runKtlintCheckOverTestSourceSet NO-SOURCE
> Task :domains:user:apps:ktlintTestSourceSetCheck SKIPPED
> Task :independent:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :independent:outbox:compileKotlin NO-SOURCE
> Task :independent:outbox:compileJava NO-SOURCE
> Task :independent:outbox:processResources
> Task :independent:outbox:classes
> Task :independent:outbox:resolveMainClassName
> Task :independent:outbox:bootJar SKIPPED
> Task :independent:outbox:jar
> Task :independent:outbox:assemble
> Task :domains:user:presentation:loadKtlintReporters
> Task :domains:user:presentation:runKtlintCheckOverTestSourceSet NO-SOURCE
> Task :domains:user:presentation:ktlintTestSourceSetCheck SKIPPED
> Task :independent:outbox:loadKtlintReporters
> Task :independent:outbox:runKtlintCheckOverMainSourceSet NO-SOURCE
> Task :independent:outbox:ktlintMainSourceSetCheck SKIPPED
> Task :independent:outbox:runKtlintCheckOverTestSourceSet NO-SOURCE
> Task :independent:outbox:ktlintTestSourceSetCheck SKIPPED

> Task :independent:outbox:application:compileKotlin FAILED
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:4:54 Unresolved reference 'event'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:26:24 Unresolved reference 'OutboxDomainEvent'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:45:33 Unresolved reference 'OutboxDomainEvent'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:47:35 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:47:35 Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:
fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R>
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:47:39 Cannot infer type for this parameter. Specify it explicitly.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:61:44 Unresolved reference 'OutboxDomainEvent'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:64:33 Unresolved reference 'payload'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:65:31 Unresolved reference 'topic'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:80:37 Unresolved reference 'OutboxDomainEvent'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:82:32 Unresolved reference 'eventId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:83:38 Unresolved reference 'aggregateType'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:84:36 Unresolved reference 'aggregateId'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:85:34 Unresolved reference 'eventType'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt:86:37 Unresolved reference 'eventVersion'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxEventRepository.kt:3:54 Unresolved reference 'event'.
e: file:///home/junoko/Code/kotlin-spring-boot-msa/restaurant/independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxEventRepository.kt:7:22 Unresolved reference 'OutboxDomainEvent'.

> Task :domains:common:compileKotlin
> Task :domains:user:apps:runKtlintCheckOverKotlinScripts
> Task :domains:user:domain:runKtlintCheckOverKotlinScripts
> Task :domains:user:presentation:runKtlintCheckOverKotlinScripts
> Task :domains:user:infrastructure:runKtlintCheckOverKotlinScripts
> Task :domains:user:application:runKtlintCheckOverKotlinScripts
> Task :domains:user:apps:runKtlintCheckOverMainSourceSet
> Task :independent:outbox:runKtlintCheckOverKotlinScripts
> Task :domains:user:domain:runKtlintCheckOverTestSourceSet
> Task :domains:user:application:runKtlintCheckOverTestSourceSet
> Task :domains:user:domain:runKtlintCheckOverMainSourceSet
> Task :domains:user:application:runKtlintCheckOverMainSourceSet
> Task :domains:user:presentation:runKtlintCheckOverMainSourceSet

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':independent:outbox:application:compileKotlin'.
> A failure occurred while executing org.jetbrains.kotlin.compilerRunner.GradleCompilerRunnerWithWorkers$GradleKotlinCompilerWorkAction
   > Compilation error. See log for more details

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 4s
26 actionable tasks: 26 executed

--------------------------------


// ===== ./build.gradle.kts =====
plugins {
    kotlin("jvm") version "2.1.20" apply false
    kotlin("plugin.spring") version "2.1.20" apply false
    kotlin("plugin.jpa") version "2.1.20" apply false
    kotlin("plugin.allopen") version "2.1.20" apply false
    kotlin("plugin.noarg") version "2.1.20" apply false
    kotlin("kapt") version "2.1.20" apply false
    id("org.springframework.boot") version "3.3.2" apply false
    id("io.spring.dependency-management") version "1.1.7" apply false
    id("org.jlleitschuh.gradle.ktlint") version "12.2.0" apply false
    java
}


repositories {
    mavenCentral()
    gradlePluginPortal()
}

allprojects {
    group = "com.restaurant"
    version = "1.0.0"

    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

subprojects {
    apply(plugin = "org.jetbrains.kotlin.jvm")
    apply(plugin = "org.jetbrains.kotlin.plugin.spring")
    apply(plugin = "org.jetbrains.kotlin.plugin.jpa")
    apply(plugin = "org.springframework.boot")
    apply(plugin = "io.spring.dependency-management")
    apply(plugin = "java")
    apply(plugin = "org.jlleitschuh.gradle.ktlint")

    configure<org.jlleitschuh.gradle.ktlint.KtlintExtension> {
        version.set("1.5.0")
        debug.set(true)
        verbose.set(true)
        outputToConsole.set(true)
        outputColorName.set("RED")
        ignoreFailures.set(false)
        enableExperimentalRules.set(true)
        filter {
            exclude { it.file.path.contains("generated/") }
        }
        disabledRules.set(setOf("HEADER_KEYWORD", "no-wildcard-imports", "no-blank-line-before-rbrace", "no-empty-file"))
    }

    configure<JavaPluginExtension> {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    configure<org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension> {
        jvmToolchain(21)
    }

    tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        compilerOptions {
            freeCompilerArgs.set(listOf("-Xjsr305=strict", "-Xconsistent-data-class-copy-visibility"))
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
        }
    }

    tasks.withType<Test> {
        useJUnitPlatform()
    }

    dependencies {
        // Kotlin
        implementation("org.jetbrains.kotlin:kotlin-reflect")
        implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
        implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.20")
    }

    configurations {
        compileOnly {
            extendsFrom(configurations.annotationProcessor.get())
        }
    }

    tasks.getByName<org.springframework.boot.gradle.tasks.bundling.BootJar>("bootJar") {
        enabled = false
    }

    tasks.getByName<Jar>("jar") {
        enabled = true
    }
}

// ===== ./domains/account/application/build.gradle.kts =====
plugins {
    id("org.springframework.boot") version "3.3.2"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common"))
    implementation(project(":domains:account:domain"))
    implementation(project(":domains:account:infrastructure"))

    // Spring Boot 버전을 통일
    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    implementation("org.mapstruct:mapstruct:1.6.3")
    implementation("org.springframework:spring-web:6.1.4")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.3.2")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/CancelAccountPaymentCommand.kt =====
package com.restaurant.application.account.command

/**
 * 계좌 결제 취소 명령
 *
 * @property accountId 계좌 ID
 * @property orderId 주문 ID
 */
data class CancelAccountPaymentCommand(
    val accountId: Long,
    val orderId: String,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/DeleteAccountCommand.kt =====
package com.restaurant.application.account.command

/**
 * 계좌 삭제 커맨드
 */
data class DeleteAccountCommand(
    val accountId: Long,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/ProcessAccountPaymentCommand.kt =====
package com.restaurant.application.account.command

import java.math.BigDecimal

/**
 * 계좌 결제 처리 명령
 *
 * @property accountId 계좌 ID
 * @property amount 결제 금액
 * @property orderId 주문 ID
 */
data class ProcessAccountPaymentCommand(
    val accountId: Long,
    val amount: BigDecimal,
    val orderId: String,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/RegisterAccountCommand.kt =====
package com.restaurant.application.account.command

import java.math.BigDecimal

/**
 * 계좌 등록 명령
 *
 * @property userId 사용자 ID
 * @property initialBalance 초기 잔액
 */
data class RegisterAccountCommand(
    val userId: Long,
    val initialBalance: BigDecimal,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/handler/CancelAccountPaymentCommandHandler.kt =====
package com.restaurant.application.account.command.handler

import com.restaurant.application.account.command.CancelAccountPaymentCommand
import com.restaurant.application.account.exception.AccountApplicationException
import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.account.repository.AccountRepository
import com.restaurant.domain.account.repository.TransactionRepository
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.OrderId
import com.restaurant.domain.account.vo.TransactionId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

/**
 * 계좌 결제 취소 커맨드 핸들러
 */
@Service
class CancelAccountPaymentCommandHandler(
    private val accountRepository: AccountRepository,
    private val transactionRepository: TransactionRepository,
) {
    private val log = LoggerFactory.getLogger(CancelAccountPaymentCommandHandler::class.java)

    /**
     * 계좌 결제 취소 명령 처리
     *
     * @param command 계좌 결제 취소 명령
     * @param correlationId 요청 추적용 상관관계 ID
     * @return 처리된 요청의 상관관계 ID
     */
    @Transactional
    fun handle(
        command: CancelAccountPaymentCommand,
        correlationId: String? = null,
    ): String {
        val actualCorrelationId = correlationId ?: UUID.randomUUID().toString()
        log.info("계좌 결제 취소 명령 처리 시작, correlationId={}", actualCorrelationId)

        try {
            val accountId = AccountId.of(command.accountId)
            val orderId = OrderId.of(command.orderId)

            // 계좌 조회
            val account =
                accountRepository.findById(accountId)
                    ?: throw AccountDomainException.Account.NotFound(accountId)

            // 해당 주문과 관련된 트랜잭션 조회
            val transactions = transactionRepository.findByOrderId(orderId)
            if (transactions.isEmpty()) {
                throw AccountDomainException.Transaction.NotFound(
                    transactionId = TransactionId.of(0L),
                )
            }

            // 결제 트랜잭션 찾기 (DEBIT 타입)
            val debitTransaction =
                transactions.firstOrNull { it.type.name == "DEBIT" }
                    ?: throw AccountDomainException.Transaction.NotFound(
                        transactionId = TransactionId.of(0L),
                    )

            // 이미 취소된 트랜잭션인지 확인
            if (debitTransaction.isCancelled()) {
                throw AccountDomainException.Transaction.AlreadyCancelled(debitTransaction.id!!)
            }

            // 결제 취소 처리 (계좌에 금액 반환)
            val updatedAccount = account.credit(debitTransaction.amount)

            // 트랜잭션 취소 처리
            val cancelledTransaction = debitTransaction.cancel()

            // 업데이트된 계좌 및 트랜잭션 저장
            accountRepository.save(updatedAccount)
            transactionRepository.save(cancelledTransaction)

            log.info(
                "계좌 결제 취소 명령 처리 완료, correlationId={}, accountId={}, orderId={}",
                actualCorrelationId,
                accountId.value,
                orderId.value,
            )

            return actualCorrelationId
        } catch (e: IllegalArgumentException) {
            log.error("유효하지 않은 입력값, correlationId={}, error={}", actualCorrelationId, e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "유효하지 않은 요청 파라미터입니다: ${e.message}",
            )
        } catch (e: Exception) {
            log.error(
                "결제 취소 중 시스템 오류, correlationId={}, error={}",
                actualCorrelationId,
                e.message,
                e,
            )
            throw AccountApplicationException.SystemError(
                errorMessage = "결제 취소 처리 중 시스템 오류가 발생했습니다: ${e.message}",
            )
        }
    }
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/handler/DeleteAccountCommandHandler.kt =====
package com.restaurant.application.account.command.handler

import com.restaurant.application.account.command.DeleteAccountCommand
import com.restaurant.application.account.exception.AccountApplicationException
import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.account.repository.AccountRepository
import com.restaurant.domain.account.vo.AccountId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

/**
 * 계좌 삭제 커맨드 핸들러
 */
@Service
class DeleteAccountCommandHandler(
    private val accountRepository: AccountRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteAccountCommandHandler::class.java)

    /**
     * 계좌 삭제 명령 처리
     *
     * @param command 계좌 삭제 명령
     * @param correlationId 요청 추적용 상관관계 ID
     */
    @Transactional
    fun handle(
        command: DeleteAccountCommand,
        correlationId: String? = null,
    ) {
        val actualCorrelationId = correlationId ?: UUID.randomUUID().toString()
        log.info("계좌 삭제 명령 처리 시작, correlationId={}", actualCorrelationId)

        try {
            val accountId = AccountId.of(command.accountId)

            // 계좌 존재 여부 확인
            val account =
                accountRepository.findById(accountId)
                    ?: throw AccountDomainException.Account.NotFound(accountId)

            // 계좌 삭제
            accountRepository.delete(accountId)

            log.info(
                "계좌 삭제 명령 처리 완료, correlationId={}, accountId={}",
                actualCorrelationId,
                accountId.value,
            )
        } catch (e: IllegalArgumentException) {
            log.error("유효하지 않은 입력값, correlationId={}, error={}", actualCorrelationId, e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "유효하지 않은 계좌 ID 형식입니다: ${e.message}",
            )
        } catch (e: AccountDomainException.Account.NotFound) {
            log.error(
                "계좌를 찾을 수 없음, correlationId={}, accountId={}",
                actualCorrelationId,
                e.accountId.value,
                e,
            )
            throw AccountApplicationException.Query.NotFound(e.accountId.value.toString())
        } catch (e: Exception) {
            log.error(
                "계좌 삭제 중 시스템 오류, correlationId={}, error={}",
                actualCorrelationId,
                e.message,
                e,
            )
            throw AccountApplicationException.SystemError(
                errorMessage = "계좌 삭제 중 시스템 오류가 발생했습니다: ${e.message}",
            )
        }
    }
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/handler/ProcessAccountPaymentCommandHandler.kt =====
package com.restaurant.application.account.command.handler

import com.restaurant.application.account.command.ProcessAccountPaymentCommand
import com.restaurant.application.account.exception.AccountApplicationException
import com.restaurant.domain.account.aggregate.Transaction
import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.account.repository.AccountRepository
import com.restaurant.domain.account.repository.TransactionRepository
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.OrderId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

/**
 * 계좌 결제 처리 커맨드 핸들러
 */
@Service
class ProcessAccountPaymentCommandHandler(
    private val accountRepository: AccountRepository,
    private val transactionRepository: TransactionRepository,
) {
    private val log = LoggerFactory.getLogger(ProcessAccountPaymentCommandHandler::class.java)

    /**
     * 계좌 결제 처리 명령 처리
     *
     * @param command 계좌 결제 처리 명령
     * @param correlationId 요청 추적용 상관관계 ID
     * @return 처리된 요청의 상관관계 ID
     */
    @Transactional
    fun handle(
        command: ProcessAccountPaymentCommand,
        correlationId: String? = null,
    ): String {
        val actualCorrelationId = correlationId ?: UUID.randomUUID().toString()
        log.info("계좌 결제 처리 명령 시작, correlationId={}", actualCorrelationId)

        try {
            val accountId = AccountId.of(command.accountId)
            val amount = Money.of(command.amount)
            val orderId = OrderId.of(command.orderId)

            // 계좌 조회
            val account =
                accountRepository.findById(accountId)
                    ?: throw AccountDomainException.Account.NotFound(accountId)

            // 계좌에서 금액 차감
            val updatedAccount = account.debit(amount)

            // 거래 내역 생성
            val transaction =
                Transaction.debit(
                    amount = amount,
                    orderId = orderId,
                    accountId = accountId,
                )

            // 업데이트된 계좌 및 트랜잭션 저장
            accountRepository.save(updatedAccount)
            transactionRepository.save(transaction)

            log.info(
                "계좌 결제 처리 명령 완료, correlationId={}, accountId={}, amount={}, orderId={}",
                actualCorrelationId,
                accountId.value,
                amount.value,
                orderId.value,
            )

            return actualCorrelationId
        } catch (e: IllegalArgumentException) {
            log.error("유효하지 않은 입력값, correlationId={}, error={}", actualCorrelationId, e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "유효하지 않은 요청 파라미터입니다: ${e.message}",
            )
        } catch (e: Exception) {
            log.error(
                "결제 처리 중 시스템 오류, correlationId={}, error={}",
                actualCorrelationId,
                e.message,
                e,
            )
            throw AccountApplicationException.SystemError(
                errorMessage = "결제 처리 중 시스템 오류가 발생했습니다: ${e.message}",
            )
        }
    }
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/command/handler/RegisterAccountCommandHandler.kt =====
package com.restaurant.application.account.command.handler

import com.restaurant.application.account.command.RegisterAccountCommand
import com.restaurant.application.account.exception.AccountApplicationException
import com.restaurant.domain.account.aggregate.Account
import com.restaurant.domain.account.repository.AccountRepository
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.util.UUID

/**
 * 계좌 등록 커맨드 핸들러
 */
@Service
class RegisterAccountCommandHandler(
    private val accountRepository: AccountRepository,
) {
    private val log = LoggerFactory.getLogger(RegisterAccountCommandHandler::class.java)

    /**
     * 계좌 등록 명령 처리
     *
     * @param command 계좌 등록 명령
     * @param correlationId 요청 추적용 상관관계 ID
     */
    @Transactional
    fun handle(
        command: RegisterAccountCommand,
        correlationId: String? = null,
    ) {
        val actualCorrelationId = correlationId ?: UUID.randomUUID().toString()
        log.info("계좌 등록 명령 처리 시작, correlationId={}", actualCorrelationId)

        try {
            val userId = UserId.of(command.userId)
            val initialBalance = Money.of(command.initialBalance)

            // 이미 존재하는 계좌가 있는지 확인
            val existingAccount = accountRepository.findByUserId(userId)
            if (existingAccount != null) {
                // 이미 계좌가 있으면 기존 계좌에 입금만 처리
                val updatedAccount = existingAccount.credit(initialBalance)
                accountRepository.save(updatedAccount)
                log.info(
                    "기존 계좌에 입금 처리 완료, correlationId={}, userId={}, amount={}",
                    actualCorrelationId,
                    userId.value,
                    initialBalance.value,
                )
            } else {
                // 새 계좌 생성
                val account = Account.create(userId, initialBalance)
                accountRepository.save(account)
                log.info(
                    "새 계좌 생성 완료, correlationId={}, userId={}, initialBalance={}",
                    actualCorrelationId,
                    userId.value,
                    initialBalance.value,
                )
            }
        } catch (e: IllegalArgumentException) {
            log.error("유효하지 않은 입력값, correlationId={}, error={}", actualCorrelationId, e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "유효하지 않은 요청 파라미터입니다: ${e.message}",
            )
        } catch (e: Exception) {
            log.error(
                "계좌 등록 중 시스템 오류, correlationId={}, error={}",
                actualCorrelationId,
                e.message,
                e,
            )
            throw AccountApplicationException.SystemError(
                errorMessage = "계좌 등록 중 시스템 오류가 발생했습니다: ${e.message}",
            )
        }
    }
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/error/AccountApplicationErrorCode.kt =====
package com.restaurant.application.account.error

import com.restaurant.common.core.error.ErrorCode
import org.springframework.http.HttpStatus

enum class AccountApplicationErrorCode(
    override val code: String,
    override val message: String,
    override val status: HttpStatus,
) : ErrorCode {
    ACCOUNT_NOT_FOUND(
        "ACCOUNT-APPLICATION-001",
        "계좌를 찾을 수 없습니다.",
        HttpStatus.NOT_FOUND,
    ),
    INSUFFICIENT_BALANCE(
        "ACCOUNT-APPLICATION-002",
        "잔액이 부족합니다.",
        HttpStatus.BAD_REQUEST,
    ),
    TRANSACTION_NOT_FOUND(
        "ACCOUNT-APPLICATION-003",
        "트랜잭션을 찾을 수 없습니다.",
        HttpStatus.NOT_FOUND,
    ),
    TRANSACTION_ALREADY_CANCELLED(
        "ACCOUNT-APPLICATION-004",
        "이미 취소된 트랜잭션입니다.",
        HttpStatus.BAD_REQUEST,
    ),
    SYSTEM_ERROR(
        "ACCOUNT-APPLICATION-999",
        "시스템 오류가 발생했습니다.",
        HttpStatus.INTERNAL_SERVER_ERROR,
    ),
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/exception/AccountApplicationException.kt =====
package com.restaurant.application.account.exception

import com.restaurant.application.account.error.AccountApplicationErrorCode
import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.TransactionId

/**
 * 계좌 애플리케이션 예외의 부모 클래스
 */
sealed class AccountApplicationException(
    override val message: String,
    override val errorCode: ErrorCode,
) : ApplicationException(message) {
    /**
     * 계좌 조회 관련 예외
     */
    sealed class Query(
        message: String,
        override val errorCode: ErrorCode,
    ) : AccountApplicationException(message, errorCode) {
        /**
         * 계좌를 찾을 수 없을 때 발생하는 예외
         */
        data class NotFound(
            val accountId: String,
            override val errorCode: ErrorCode = AccountApplicationErrorCode.ACCOUNT_NOT_FOUND,
        ) : Query("계좌를 찾을 수 없습니다: $accountId", errorCode)
    }

    /**
     * 계좌 트랜잭션 관련 예외
     */
    sealed class Transaction(
        message: String,
        override val errorCode: ErrorCode,
    ) : AccountApplicationException(message, errorCode) {
        /**
         * 잔액이 부족할 때 발생하는 예외
         */
        data class InsufficientBalance(
            val accountId: AccountId,
            val currentBalance: Money,
            val requiredAmount: Money,
            override val errorCode: ErrorCode = AccountApplicationErrorCode.INSUFFICIENT_BALANCE,
        ) : Transaction(
                "계좌 ${accountId.value}의 잔액이 부족합니다. 현재 잔액: ${currentBalance.value}, 필요 금액: ${requiredAmount.value}",
                errorCode,
            )

        /**
         * 트랜잭션을 찾을 수 없을 때 발생하는 예외
         */
        data class NotFound(
            val transactionId: TransactionId,
            override val errorCode: ErrorCode = AccountApplicationErrorCode.TRANSACTION_NOT_FOUND,
        ) : Transaction("트랜잭션을 찾을 수 없습니다: ${transactionId.value}", errorCode)

        /**
         * 이미 취소된 트랜잭션을 취소하려고 할 때 발생하는 예외
         */
        data class AlreadyCancelled(
            val transactionId: TransactionId,
            override val errorCode: ErrorCode = AccountApplicationErrorCode.TRANSACTION_ALREADY_CANCELLED,
        ) : Transaction("이미 취소된 트랜잭션입니다: ${transactionId.value}", errorCode)
    }

    /**
     * 시스템 오류 관련 예외
     */
    data class SystemError(
        val errorMessage: String,
        override val errorCode: ErrorCode = AccountApplicationErrorCode.SYSTEM_ERROR,
    ) : AccountApplicationException("시스템 오류가 발생했습니다: $errorMessage", errorCode)
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/extensions/AccountCommandExtensions.kt =====
package com.restaurant.application.account.extensions

import com.restaurant.application.account.command.CancelAccountPaymentCommand
import com.restaurant.application.account.command.DeleteAccountCommand
import com.restaurant.application.account.command.ProcessAccountPaymentCommand
import com.restaurant.application.account.command.RegisterAccountCommand
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.OrderId
import com.restaurant.domain.account.vo.UserId

// RegisterAccountCommand 확장 함수
fun RegisterAccountCommand.toUserId(): UserId = UserId.of(this.userId)

fun RegisterAccountCommand.toInitialBalance(): Money = Money.of(this.initialBalance)

// DeleteAccountCommand 확장 함수
fun DeleteAccountCommand.toAccountId(): AccountId = AccountId.of(this.accountId)

// ProcessAccountPaymentCommand 확장 함수
fun ProcessAccountPaymentCommand.toAccountId(): AccountId = AccountId.of(this.accountId)

fun ProcessAccountPaymentCommand.toAmount(): Money = Money.of(this.amount)

fun ProcessAccountPaymentCommand.toOrderId(): OrderId = OrderId.of(this.orderId)

// CancelAccountPaymentCommand 확장 함수
fun CancelAccountPaymentCommand.toAccountId(): AccountId = AccountId.of(this.accountId)

fun CancelAccountPaymentCommand.toOrderId(): OrderId = OrderId.of(this.orderId)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/extensions/AccountQueryExtensions.kt =====
package com.restaurant.application.account.extensions

import com.restaurant.application.account.query.GetAccountBalanceQuery
import com.restaurant.application.account.query.GetAccountTransactionsQuery
import com.restaurant.application.account.query.dto.TransactionDto
import com.restaurant.domain.account.aggregate.Transaction
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.TransactionId

// GetAccountBalanceQuery 확장 함수
fun GetAccountBalanceQuery.toAccountId(): AccountId = AccountId.of(this.accountId)

// GetAccountTransactionsQuery 확장 함수
fun GetAccountTransactionsQuery.toAccountId(): AccountId = AccountId.of(this.accountId)

fun GetAccountTransactionsQuery.toCursor(): TransactionId? = this.cursor?.toLongOrNull()?.let { TransactionId.of(it) }

// Transaction 변환 확장 함수
fun Transaction.toDto(): TransactionDto =
    TransactionDto(
        id = this.id?.value ?: 0,
        accountId = this.accountId?.value ?: 0,
        type = this.type.toString(),
        amount = this.amount.value,
        orderId = this.orderId.value,
        timestamp = this.timestamp,
    )

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/GetAccountBalanceQuery.kt =====
package com.restaurant.application.account.query

/**
 * 계좌 잔액 조회 쿼리
 *
 * @property accountId 계좌 ID
 */
data class GetAccountBalanceQuery(
    val accountId: Long,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/GetAccountTransactionsQuery.kt =====
package com.restaurant.application.account.query

/**
 * 계좌 트랜잭션 조회 쿼리
 *
 * @property accountId 계좌 ID
 * @property cursor 커서 (다음 페이지 조회 시 사용)
 * @property limit 조회할 항목 수
 */
data class GetAccountTransactionsQuery(
    val accountId: Long,
    val cursor: String? = null,
    val limit: Int = 10,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/dto/AccountBalanceDto.kt =====
package com.restaurant.application.account.query.dto

import java.math.BigDecimal

/**
 * 계좌 잔액 정보 DTO
 *
 * @property accountId 계좌 ID
 * @property balance 현재 잔액
 */
data class AccountBalanceDto(
    val accountId: Long,
    val balance: BigDecimal,
)

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/dto/TransactionDto.kt =====
package com.restaurant.application.account.query.dto

import java.math.BigDecimal
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId

/**
 * 트랜잭션 정보 DTO
 *
 * @property id 트랜잭션 ID
 * @property accountId 계좌 ID
 * @property type 트랜잭션 타입 (DEBIT, CREDIT)
 * @property amount 금액
 * @property orderId 주문 ID
 * @property timestamp 트랜잭션 발생 시간 (밀리초)
 * @property dateTime 트랜잭션 발생 시간 (LocalDateTime)
 */
data class TransactionDto(
    val id: Long,
    val accountId: Long,
    val type: String,
    val amount: BigDecimal,
    val orderId: String,
    val timestamp: Long,
) {
    // 프론트엔드에서 표시하기 쉽도록 LocalDateTime 추가
    val dateTime: LocalDateTime =
        Instant
            .ofEpochMilli(timestamp)
            .atZone(ZoneId.systemDefault())
            .toLocalDateTime()
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/handler/GetAccountBalanceQueryHandler.kt =====
package com.restaurant.application.account.query.handler

import com.restaurant.application.account.exception.AccountApplicationException
import com.restaurant.application.account.extensions.toAccountId
import com.restaurant.application.account.query.GetAccountBalanceQuery
import com.restaurant.application.account.query.dto.AccountBalanceDto
import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.account.repository.AccountRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 계좌 잔액 조회 쿼리 핸들러
 */
@Service
class GetAccountBalanceQueryHandler(
    private val accountRepository: AccountRepository,
) {
    private val log = LoggerFactory.getLogger(GetAccountBalanceQueryHandler::class.java)

    /**
     * 계좌 잔액 조회 쿼리 처리
     *
     * @param query 계좌 잔액 조회 쿼리
     * @return 계좌 잔액 결과
     * @throws AccountApplicationException.Query.NotFound 계좌를 찾을 수 없을 경우
     */
    @Transactional(readOnly = true)
    fun handle(query: GetAccountBalanceQuery): AccountBalanceDto {
        try {
            val accountId = query.toAccountId()

            // 계좌 조회
            val account =
                accountRepository.findById(accountId)
                    ?: throw AccountDomainException.Account.NotFound(accountId)

            // 잔액 반환
            return AccountBalanceDto(
                accountId = accountId.value,
                balance = account.balance.value,
            )
        } catch (e: IllegalArgumentException) {
            // 유효하지 않은 AccountId 등의 문제
            log.error("잘못된 계좌 ID 형식입니다: {}", e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "잘못된 계좌 ID 형식입니다: ${e.message}",
            )
        } catch (e: Exception) {
            // 기타 예외 처리
            log.error("계좌 조회 중 시스템 오류가 발생했습니다: {}", e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "계좌 조회 중 시스템 오류가 발생했습니다: ${e.message}",
            )
        }
    }
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/handler/GetAccountTransactionsQueryHandler.kt =====
package com.restaurant.application.account.query.handler

import com.restaurant.application.account.exception.AccountApplicationException
import com.restaurant.application.account.extensions.toAccountId
import com.restaurant.application.account.extensions.toCursor
import com.restaurant.application.account.extensions.toDto
import com.restaurant.application.account.query.GetAccountTransactionsQuery
import com.restaurant.application.account.query.dto.TransactionDto
import com.restaurant.common.core.query.dto.CursorPageDto
import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.account.repository.AccountRepository
import com.restaurant.domain.account.repository.TransactionRepository
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 계좌 트랜잭션 조회 핸들러
 */
@Service
class GetAccountTransactionsQueryHandler(
    private val accountRepository: AccountRepository,
    private val transactionRepository: TransactionRepository,
) {
    private val log = LoggerFactory.getLogger(GetAccountTransactionsQueryHandler::class.java)

    /**
     * 계좌 트랜잭션 조회 쿼리 처리
     *
     * @param query 트랜잭션 조회 쿼리
     * @return 커서 기반 트랜잭션 목록
     * @throws AccountApplicationException.Query.NotFound 계좌를 찾을 수 없을 경우
     */
    @Transactional(readOnly = true)
    fun handle(query: GetAccountTransactionsQuery): CursorPageDto<TransactionDto> {
        try {
            val accountId = query.toAccountId()
            val cursor = query.toCursor()
            val limit = query.limit + 1 // 다음 페이지 확인을 위해 1개 더 조회

            // 계좌 존재 여부 확인
            accountRepository.findById(accountId)
                ?: throw AccountDomainException.Account.NotFound(accountId)

            // 트랜잭션 조회
            val transactions =
                transactionRepository.findByAccountIdWithCursor(
                    accountId = accountId,
                    cursor = cursor,
                    limit = limit,
                )

            // 다음 페이지 존재 여부 확인
            val hasNext = transactions.size > query.limit
            val items = transactions.take(query.limit).map { it.toDto() }

            // 다음 커서 설정
            val nextCursor =
                if (hasNext && items.isNotEmpty()) {
                    items.last().id.toString()
                } else {
                    null
                }

            return CursorPageDto(
                items = items,
                nextCursor = nextCursor,
                hasNext = hasNext,
            )
        } catch (e: IllegalArgumentException) {
            // 유효하지 않은 AccountId 등의 문제
            log.error("잘못된 계좌 ID 또는 커서 형식입니다: {}", e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "잘못된 계좌 ID 또는 커서 형식입니다: ${e.message}",
            )
        } catch (e: Exception) {
            // 기타 예외 처리
            log.error("계좌 거래내역 조회 중 시스템 오류가 발생했습니다: {}", e.message, e)
            throw AccountApplicationException.SystemError(
                errorMessage = "계좌 거래내역 조회 중 시스템 오류가 발생했습니다: ${e.message}",
            )
        }
    }
}

// ===== ./domains/account/application/src/main/kotlin/com/restaurant/application/account/query/result/AccountBalanceResult.kt =====
package com.restaurant.application.account.query.result

/**
 * 계좌 잔액 쿼리 결과
 */
data class AccountBalanceResult(
    val accountId: Long,
    val balance: Long,
)

// ===== ./domains/account/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:account:presentation"))
    implementation(project(":domains:account:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/account/apps/src/main/kotlin/com/restaurant/apps/account/AccountApplication.kt =====
package com.restaurant.apps.account

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

/**
 * 계좌 마이크로서비스 진입점
 */
@SpringBootApplication(
    scanBasePackages = [
        "com.restaurant.apps.account",
        "com.restaurant.presentation.account",
        "com.restaurant.application.account",
        "com.restaurant.infrastructure.account",
        "com.restaurant.domain.account",
        "com.restaurant.common",
    ],
)
class AccountApplication

/**
 * 애플리케이션 시작점
 */
fun main(args: Array<String>) {
    runApplication<AccountApplication>(*args)
}

// ===== ./domains/account/apps/src/main/kotlin/com/restaurant/apps/account/config/JpaConfig.kt =====
package com.restaurant.apps.account.config

import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.context.annotation.Configuration
import org.springframework.data.jpa.repository.config.EnableJpaRepositories

/**
 * JPA 설정
 */
@Configuration
@EntityScan(basePackages = ["com.restaurant.infrastructure.account.entity"])
@EnableJpaRepositories(basePackages = ["com.restaurant.infrastructure.account.repository"])
class JpaConfig

// ===== ./domains/account/apps/src/main/kotlin/com/restaurant/apps/account/config/SwaggerConfig.kt =====
package com.restaurant.apps.account.config

import io.swagger.v3.oas.models.Components
import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Contact
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.info.License
import io.swagger.v3.oas.models.servers.Server
import org.springdoc.core.models.GroupedOpenApi
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

/**
 * Swagger(OpenAPI) 설정
 */
@Configuration
class SwaggerConfig {
    @Bean
    fun accountApi(): GroupedOpenApi =
        GroupedOpenApi
            .builder()
            .group("account-api")
            .pathsToMatch("/api/v1/accounts/**")
            .build()

    @Bean
    fun openAPI(): OpenAPI =
        OpenAPI()
            .info(apiInfo())
            .servers(
                listOf(
                    Server().url("/").description("Default Server URL"),
                ),
            ).components(Components())

    private fun apiInfo(): Info =
        Info()
            .title("계좌 관리 API")
            .description("계좌 등록, 결제 처리, 잔액 조회 등 계좌 관련 API")
            .version("v1")
            .contact(
                Contact()
                    .name("Restaurant MSA Team")
                    .email("api@restaurant.com")
                    .url("https://restaurant.com"),
            ).license(
                License()
                    .name("Apache 2.0")
                    .url("https://www.apache.org/licenses/LICENSE-2.0.html"),
            )
}

// ===== ./domains/account/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/aggregate/Account.kt =====
package com.restaurant.domain.account.aggregate

import com.restaurant.domain.account.exception.AccountDomainException
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.UserId

/**
 * 계좌 애그리게이트
 * 사용자에 연결된 계좌를 관리합니다.
 */
data class Account(
    val id: AccountId,
    val userId: UserId,
    val balance: Money,
) {
    /**
     * 계좌에서 금액을 차감합니다.
     *
     * @param amount 차감할 금액
     * @throws AccountDomainException.Account.InsufficientBalance 잔액이 부족할 경우 발생
     */
    fun debit(amount: Money): Account {
        if (!balance.isGreaterThanOrEqual(amount)) {
            throw AccountDomainException.Account.InsufficientBalance(
                accountId = id,
                currentBalance = balance,
                requiredAmount = amount,
            )
        }

        return copy(
            balance = balance - amount,
        )
    }

    /**
     * 계좌에 금액을 입금합니다.
     *
     * @param amount 입금할 금액
     */
    fun credit(amount: Money): Account =
        copy(
            balance = balance + amount,
        )

    companion object {
        /**
         * 새 계좌를 생성합니다. (ID는 부여되지 않은 상태)
         *
         * @param userId 사용자 ID
         * @param initialBalance 초기 잔액 (기본값 0)
         */
        fun create(
            userId: UserId,
            initialBalance: Money = Money.ZERO,
        ): Account =
            Account(
                id = AccountId.of(0L),
                userId = userId,
                balance = initialBalance,
            )

        /**
         * 기존 계좌를 재구성합니다.
         *
         * @param id 계좌 ID
         * @param userId 사용자 ID
         * @param balance 잔액
         */
        fun reconstitute(
            id: AccountId,
            userId: UserId,
            balance: Money,
        ): Account =
            Account(
                id = id,
                userId = userId,
                balance = balance,
            )
    }
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/aggregate/Transaction.kt =====
package com.restaurant.domain.account.aggregate

import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.OrderId
import com.restaurant.domain.account.vo.TransactionId
import com.restaurant.domain.account.vo.TransactionType

/**
 * 계좌 트랜잭션 애그리게이트 루트
 * 계좌의 입출금 내역을 독립적으로 관리합니다.
 */
data class Transaction(
    val id: TransactionId,
    val type: TransactionType,
    val amount: Money,
    val orderId: OrderId,
    val accountId: AccountId,
    val cancelled: Boolean = false,
    val timestamp: Long = System.currentTimeMillis(),
) {
    /**
     * 트랜잭션이 취소되었는지 확인합니다.
     *
     * @return 취소 여부
     */
    fun isCancelled(): Boolean = cancelled

    /**
     * 트랜잭션을 취소 상태로 변경합니다.
     *
     * @return 취소된 트랜잭션
     */
    fun cancel(): Transaction = copy(cancelled = true)

    companion object {
        /**
         * 출금 트랜잭션 생성
         *
         * @param amount 출금 금액
         * @param orderId 주문 ID
         * @param accountId 계좌 ID
         */
        fun debit(
            amount: Money,
            orderId: OrderId,
            accountId: AccountId,
        ): Transaction =
            Transaction(
                id = TransactionId.of(0L),
                type = TransactionType.DEBIT,
                amount = amount,
                orderId = orderId,
                accountId = accountId,
            )

        /**
         * 입금 트랜잭션 생성
         *
         * @param amount 입금 금액
         * @param orderId 주문 ID
         * @param accountId 계좌 ID
         */
        fun credit(
            amount: Money,
            orderId: OrderId,
            accountId: AccountId,
        ): Transaction =
            Transaction(
                id = TransactionId.of(0L),
                type = TransactionType.CREDIT,
                amount = amount,
                orderId = orderId,
                accountId = accountId,
            )

        /**
         * 기존 트랜잭션을 재구성합니다.
         *
         * @param id 트랜잭션 ID
         * @param type 트랜잭션 타입
         * @param amount 금액
         * @param orderId 주문 ID
         * @param accountId 계좌 ID
         * @param cancelled 취소 여부
         * @param timestamp 타임스탬프
         */
        fun reconstitute(
            id: TransactionId,
            type: TransactionType,
            amount: Money,
            orderId: OrderId,
            accountId: AccountId,
            cancelled: Boolean,
            timestamp: Long,
        ): Transaction =
            Transaction(
                id = id,
                type = type,
                amount = amount,
                orderId = orderId,
                accountId = accountId,
                cancelled = cancelled,
                timestamp = timestamp,
            )
    }
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/error/AccountErrorCode.kt =====
package com.restaurant.domain.account.error

/**
 * 계좌 도메인 에러 코드
 * 기술적 구현(HTTP 상태 코드)와 분리된 순수한 도메인 에러 코드입니다.
 */
enum class AccountErrorCode(
    val code: String,
    val message: String,
    val statusCode: Int,
) {
    ACCOUNT_NOT_FOUND(
        "ACCOUNT_001",
        "계좌를 찾을 수 없습니다.",
        404,
    ),
    INSUFFICIENT_BALANCE(
        "ACCOUNT_002",
        "잔액이 부족합니다.",
        400,
    ),
    TRANSACTION_NOT_FOUND(
        "ACCOUNT_003",
        "트랜잭션을 찾을 수 없습니다.",
        404,
    ),
    TRANSACTION_ALREADY_CANCELLED(
        "ACCOUNT_004",
        "이미 취소된 트랜잭션입니다.",
        400,
    ),
    INVALID_ACCOUNT_STATE(
        "ACCOUNT_005",
        "유효하지 않은 계좌 상태입니다.",
        400,
    ),
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/exception/AccountDomainException.kt =====
package com.restaurant.domain.account.exception

import com.restaurant.domain.account.error.AccountErrorCode
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.TransactionId

/**
 * Account 도메인의 기본 예외 클래스
 */
sealed class AccountDomainException(
    override val message: String,
    open val errorCode: AccountErrorCode,
) : DomainException(message) {
    /**
     * 계좌 관련 예외
     */
    sealed class Account(
        message: String,
        errorCode: AccountErrorCode,
    ) : AccountDomainException(message, errorCode) {
        /**
         * 계좌를 찾을 수 없을 때 발생하는 예외
         */
        data class NotFound(
            val accountId: AccountId,
            override val errorCode: AccountErrorCode = AccountErrorCode.ACCOUNT_NOT_FOUND,
        ) : Account(
                message = "계좌를 찾을 수 없습니다: ${accountId.value}",
                errorCode = errorCode,
            )

        /**
         * 계좌의 잔액이 부족할 때 발생하는 예외
         */
        data class InsufficientBalance(
            val accountId: AccountId,
            val currentBalance: Money,
            val requiredAmount: Money,
            override val errorCode: AccountErrorCode = AccountErrorCode.INSUFFICIENT_BALANCE,
        ) : Account(
                message = "계좌 ${accountId.value}의 잔액이 부족합니다. 잔액: ${currentBalance.value}, 필요 금액: ${requiredAmount.value}",
                errorCode = errorCode,
            )
    }

    /**
     * 트랜잭션 관련 예외
     */
    sealed class Transaction(
        message: String,
        errorCode: AccountErrorCode,
    ) : AccountDomainException(message, errorCode) {
        /**
         * 트랜잭션을 찾을 수 없을 때 발생하는 예외
         */
        data class NotFound(
            val transactionId: TransactionId,
            override val errorCode: AccountErrorCode = AccountErrorCode.TRANSACTION_NOT_FOUND,
        ) : Transaction(
                message = "트랜잭션을 찾을 수 없습니다: ${transactionId.value}",
                errorCode = errorCode,
            )

        /**
         * 이미 취소된 결제를 취소하려고 할 때 발생하는 예외
         */
        data class AlreadyCancelled(
            val transactionId: TransactionId,
            override val errorCode: AccountErrorCode = AccountErrorCode.TRANSACTION_ALREADY_CANCELLED,
        ) : Transaction(
                message = "이미 취소된 결제입니다: ${transactionId.value}",
                errorCode = errorCode,
            )
    }
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/exception/DomainException.kt =====
package com.restaurant.domain.account.exception

/**
 * 도메인 예외의 기본 클래스
 */
abstract class DomainException(
    override val message: String,
) : RuntimeException(message)

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/repository/AccountRepository.kt =====
package com.restaurant.domain.account.repository

import com.restaurant.domain.account.aggregate.Account
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.UserId

/**
 * 계좌 리포지토리 인터페이스
 */
interface AccountRepository {
    /**
     * ID로 계좌를 찾습니다.
     */
    fun findById(id: AccountId): Account?

    /**
     * 사용자 ID로 계좌를 찾습니다.
     */
    fun findByUserId(userId: UserId): Account?

    /**
     * 계좌를 저장합니다.
     */
    fun save(account: Account): Account

    /**
     * 계좌를 삭제합니다.
     */
    fun delete(id: AccountId)
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/repository/TransactionRepository.kt =====
package com.restaurant.domain.account.repository

import com.restaurant.domain.account.aggregate.Transaction
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.OrderId
import com.restaurant.domain.account.vo.TransactionId
import com.restaurant.domain.account.vo.TransactionType

/**
 * 계좌 트랜잭션 리포지토리 인터페이스
 */
interface TransactionRepository {
    /**
     * ID로 트랜잭션을 찾습니다.
     */
    fun findById(id: TransactionId): Transaction?

    /**
     * 트랜잭션을 저장합니다.
     */
    fun save(transaction: Transaction): Transaction

    /**
     * 계좌 ID로 커서 기반 트랜잭션 목록을 조회합니다.
     */
    fun findByAccountIdWithCursor(
        accountId: AccountId,
        cursor: TransactionId?,
        limit: Int,
    ): List<Transaction>

    /**
     * 주문 ID로 트랜잭션을 조회합니다.
     */
    fun findByOrderId(orderId: OrderId): List<Transaction>

    /**
     * 계좌 ID와 트랜잭션 타입으로 커서 기반 트랜잭션 목록을 조회합니다.
     */
    fun findByAccountIdAndTypeWithCursor(
        accountId: AccountId,
        type: TransactionType,
        cursor: TransactionId?,
        limit: Int,
    ): List<Transaction>

    /**
     * 계좌 ID와 날짜 범위로 커서 기반 트랜잭션 목록을 조회합니다.
     */
    fun findByAccountIdAndTimestampBetweenWithCursor(
        accountId: AccountId,
        startTime: Long,
        endTime: Long,
        cursor: TransactionId?,
        limit: Int,
    ): List<Transaction>
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/vo/AccountId.kt =====
package com.restaurant.domain.account.vo

data class AccountId private constructor(
    val value: Long,
) {
    init {
        require(value >= 0L) { "AccountId must be greater than or equal to 0, but was: $value" }
    }

    companion object {
        fun of(value: Long): AccountId = AccountId(value)
    }

    override fun toString(): String = "AccountId(value=$value)"
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/vo/Money.kt =====
package com.restaurant.domain.account.vo

import java.math.BigDecimal

data class Money private constructor(
    val value: BigDecimal,
) {
    init {
        require(value >= BigDecimal.ZERO) { "금액은 음수일 수 없습니다." }
    }

    operator fun plus(other: Money): Money = Money(this.value.add(other.value))

    operator fun minus(other: Money): Money = Money(this.value.subtract(other.value))

    fun isGreaterThanOrEqual(other: Money): Boolean = this.value >= other.value

    fun isZero(): Boolean = value.compareTo(BigDecimal.ZERO) == 0

    companion object {
        fun of(value: BigDecimal): Money = Money(value)

        fun of(value: Long): Money = Money(BigDecimal.valueOf(value))

        fun of(value: Int): Money = Money(BigDecimal.valueOf(value.toLong()))

        val ZERO: Money = Money(BigDecimal.ZERO)
    }

    override fun toString(): String = "Money(value=$value)"
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/vo/OrderId.kt =====
package com.restaurant.domain.account.vo

data class OrderId private constructor(
    val value: String,
) {
    init {
        require(value.isNotBlank()) { "OrderId는 빈 값일 수 없습니다." }
    }

    companion object {
        fun of(value: String): OrderId = OrderId(value)
    }

    override fun toString(): String = value
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/vo/TransactionId.kt =====
package com.restaurant.domain.account.vo

data class TransactionId private constructor(
    val value: Long,
) {
    init {
        require(value > 0) { "TransactionId는 0보다 커야 합니다." }
    }

    companion object {
        fun of(value: Long): TransactionId = TransactionId(value)

        /**
         * 문자열 값으로부터 TransactionId를 생성합니다.
         *
         * @param value 문자열 값 (숫자로 변환 가능해야 함)
         * @return TransactionId 객체
         */
        fun of(value: String): TransactionId = of(value.toLong())
    }

    override fun toString(): String = value.toString()
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/vo/TransactionType.kt =====
package com.restaurant.domain.account.vo

/**
 * 거래 유형 Value Object
 */
enum class TransactionType {
    DEBIT, // 출금 (계좌에서 차감)
    CREDIT, // 입금 (계좌로 추가)
}

// ===== ./domains/account/domain/src/main/kotlin/com/restaurant/domain/account/vo/UserId.kt =====
package com.restaurant.domain.account.vo

data class UserId private constructor(
    val value: Long,
) {
    init {
        require(value > 0L) { "UserId must be greater than 0, but was: $value" }
    }

    companion object {
        fun of(value: Long): UserId = UserId(value)
    }

    override fun toString(): String = "UserId(value=$value)"
}

// ===== ./domains/account/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
}

dependencies {
    implementation(project(":domains:account:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/entity/AccountEntity.kt =====
package com.restaurant.infrastructure.account.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.math.BigDecimal

/**
 * 계좌 JPA 엔티티
 */
@Entity
@Table(name = "accounts")
class AccountEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "user_id", nullable = false)
    val userId: Long,
    @Column(name = "balance", nullable = false, precision = 19, scale = 4)
    val balance: BigDecimal,
    @Version
    @Column(nullable = false)
    val version: Long = 0,
)

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/entity/TransactionEntity.kt =====
package com.restaurant.infrastructure.account.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.math.BigDecimal
import java.time.Instant

/**
 * 거래 내역 JPA 엔티티
 */
@Entity
@Table(name = "account_transactions")
class TransactionEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "account_id", nullable = false)
    val accountId: Long,
    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false)
    val type: AccountTransactionTypeEntity,
    @Column(name = "amount", nullable = false, precision = 19, scale = 4)
    val amount: BigDecimal,
    @Column(name = "order_id", nullable = false)
    val orderId: String,
    @Column(name = "cancelled", nullable = false)
    val cancelled: Boolean = false,
    @Column(name = "timestamp", nullable = false, columnDefinition = "TIMESTAMP")
    val timestamp: Instant,
    @Version
    @Column(nullable = false)
    val version: Long = 0,
)

/**
 * 거래 유형 Enum
 */
enum class AccountTransactionTypeEntity {
    DEBIT, // 출금 (계좌에서 차감)
    CREDIT, // 입금 (계좌로 추가)
}

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/entity/extensions/AccountEntityExtensions.kt =====
package com.restaurant.infrastructure.account.entity.extensions

import com.restaurant.domain.account.aggregate.Account
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.UserId
import com.restaurant.infrastructure.account.entity.AccountEntity

/**
 * AccountEntity를 도메인 Account로 변환
 */
fun AccountEntity.toDomain(): Account =
    Account.reconstitute(
        id = AccountId.of(id!!),
        userId = UserId.of(userId),
        balance = Money.of(balance),
    )

/**
 * Account를 AccountEntity로 변환
 */
fun Account.toEntity(): AccountEntity =
    AccountEntity(
        id = id.value,
        userId = userId.value,
        balance = balance.value,
    )

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/entity/extensions/TransactionEntityExtensions.kt =====
package com.restaurant.infrastructure.account.entity.extensions

import com.restaurant.domain.account.aggregate.Transaction
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.Money
import com.restaurant.domain.account.vo.OrderId
import com.restaurant.domain.account.vo.TransactionId
import com.restaurant.domain.account.vo.TransactionType
import com.restaurant.infrastructure.account.entity.AccountTransactionTypeEntity
import com.restaurant.infrastructure.account.entity.TransactionEntity
import java.time.Instant

/**
 * TransactionEntity를 도메인 Transaction으로 변환
 */
fun TransactionEntity.toDomain(): Transaction =
    Transaction.reconstitute(
        id = TransactionId.of(id!!),
        type = type.toDomain(),
        amount = Money.of(amount),
        orderId = OrderId.of(orderId),
        accountId = AccountId.of(accountId),
        cancelled = cancelled,
        timestamp = timestamp.toEpochMilli(),
    )

/**
 * Transaction을 TransactionEntity로 변환
 */
fun Transaction.toEntity(): TransactionEntity =
    TransactionEntity(
        id = id.value,
        accountId = accountId.value,
        type = type.toEntity(),
        amount = amount.value,
        orderId = orderId.value,
        cancelled = cancelled,
        timestamp = Instant.ofEpochMilli(timestamp),
    )

/**
 * AccountTransactionTypeEntity를 도메인 TransactionType으로 변환
 */
private fun AccountTransactionTypeEntity.toDomain(): TransactionType =
    when (this) {
        AccountTransactionTypeEntity.DEBIT -> TransactionType.DEBIT
        AccountTransactionTypeEntity.CREDIT -> TransactionType.CREDIT
    }

/**
 * TransactionType을 AccountTransactionTypeEntity로 변환
 */
private fun TransactionType.toEntity(): AccountTransactionTypeEntity =
    when (this) {
        TransactionType.DEBIT -> AccountTransactionTypeEntity.DEBIT
        TransactionType.CREDIT -> AccountTransactionTypeEntity.CREDIT
    }

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/repository/AccountRepositoryImpl.kt =====
package com.restaurant.infrastructure.account.repository

import com.restaurant.domain.account.aggregate.Account
import com.restaurant.domain.account.repository.AccountRepository
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.UserId
import com.restaurant.infrastructure.account.entity.extensions.toDomain
import com.restaurant.infrastructure.account.entity.extensions.toEntity
import org.springframework.stereotype.Component

/**
 * 계좌 리포지토리 구현체
 */
@Component
class AccountRepositoryImpl(
    private val jpaAccountRepository: JpaAccountRepository,
) : AccountRepository {
    override fun findById(id: AccountId): Account? = jpaAccountRepository.findById(id.value).map { it.toDomain() }.orElse(null)

    override fun findByUserId(userId: UserId): Account? = jpaAccountRepository.findByUserId(userId.value)?.toDomain()

    override fun save(account: Account): Account {
        val entity = account.toEntity()
        val savedEntity = jpaAccountRepository.save(entity)
        return savedEntity.toDomain()
    }

    override fun delete(id: AccountId) {
        jpaAccountRepository.deleteById(id.value)
    }
}

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/repository/JpaAccountRepository.kt =====
package com.restaurant.infrastructure.account.repository

import com.restaurant.infrastructure.account.entity.AccountEntity
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

/**
 * 계좌 JPA 리포지토리
 */
@Repository
interface JpaAccountRepository : JpaRepository<AccountEntity, Long> {
    /**
     * 사용자 ID로 계좌를 찾습니다.
     */
    fun findByUserId(userId: Long): AccountEntity?
}

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/repository/JpaTransactionRepository.kt =====
package com.restaurant.infrastructure.account.repository

import com.restaurant.infrastructure.account.entity.AccountTransactionTypeEntity
import com.restaurant.infrastructure.account.entity.TransactionEntity
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

/**
 * 트랜잭션 JPA 리포지토리
 */
@Repository
interface JpaTransactionRepository : JpaRepository<TransactionEntity, Long> {
    /**
     * 계좌 ID로 커서 기반 조회 (ID 내림차순)
     */
    @Query("SELECT t FROM TransactionEntity t WHERE t.accountId = :accountId AND (:cursor IS NULL OR t.id < :cursor) ORDER BY t.id DESC")
    fun findByAccountIdWithCursor(
        @Param("accountId") accountId: Long,
        @Param("cursor") cursor: Long?,
        pageable: Pageable,
    ): List<TransactionEntity>

    /**
     * 주문 ID로 트랜잭션 조회
     */
    fun findByOrderId(orderId: String): List<TransactionEntity>

    /**
     * 계좌 ID와 타입으로 커서 기반 조회 (ID 내림차순)
     */
    @Query(
        "SELECT t FROM TransactionEntity t WHERE t.accountId = :accountId AND t.type = :type AND (:cursor IS NULL OR t.id < :cursor) ORDER BY t.id DESC",
    )
    fun findByAccountIdAndTypeWithCursor(
        @Param("accountId") accountId: Long,
        @Param("type") type: AccountTransactionTypeEntity,
        @Param("cursor") cursor: Long?,
        pageable: Pageable,
    ): List<TransactionEntity>

    /**
     * 계좌 ID와 날짜 범위로 커서 기반 조회 (ID 내림차순)
     */
    @Query(
        """
        SELECT t FROM TransactionEntity t
        WHERE t.accountId = :accountId
        AND t.timestamp BETWEEN :startTime AND :endTime
        AND (:cursor IS NULL OR t.id < :cursor)
        ORDER BY t.id DESC
        """,
    )
    fun findByAccountIdAndTimestampBetweenWithCursor(
        @Param("accountId") accountId: Long,
        @Param("startTime") startTime: java.time.Instant,
        @Param("endTime") endTime: java.time.Instant,
        @Param("cursor") cursor: Long?,
        pageable: Pageable,
    ): List<TransactionEntity>
}

// ===== ./domains/account/infrastructure/src/main/kotlin/com/restaurant/infrastructure/account/repository/TransactionRepositoryImpl.kt =====
package com.restaurant.infrastructure.account.repository

import com.restaurant.domain.account.aggregate.Transaction
import com.restaurant.domain.account.repository.TransactionRepository
import com.restaurant.domain.account.vo.AccountId
import com.restaurant.domain.account.vo.OrderId
import com.restaurant.domain.account.vo.TransactionId
import com.restaurant.domain.account.vo.TransactionType
import com.restaurant.infrastructure.account.entity.AccountTransactionTypeEntity
import com.restaurant.infrastructure.account.entity.extensions.toDomain
import com.restaurant.infrastructure.account.entity.extensions.toEntity
import org.springframework.data.domain.PageRequest
import org.springframework.stereotype.Component
import java.time.Instant

/**
 * 트랜잭션 리포지토리 구현체
 */
@Component
class TransactionRepositoryImpl(
    private val jpaTransactionRepository: JpaTransactionRepository,
) : TransactionRepository {
    override fun findById(id: TransactionId): Transaction? = jpaTransactionRepository.findById(id.value).map { it.toDomain() }.orElse(null)

    override fun save(transaction: Transaction): Transaction {
        val entity = transaction.toEntity()
        val savedEntity = jpaTransactionRepository.save(entity)
        return savedEntity.toDomain()
    }

    override fun findByAccountIdWithCursor(
        accountId: AccountId,
        cursor: TransactionId?,
        limit: Int,
    ): List<Transaction> {
        val pageable = PageRequest.of(0, limit)
        return jpaTransactionRepository
            .findByAccountIdWithCursor(
                accountId.value,
                cursor?.value,
                pageable,
            ).map { it.toDomain() }
    }

    override fun findByOrderId(orderId: OrderId): List<Transaction> =
        jpaTransactionRepository
            .findByOrderId(orderId.value)
            .map { it.toDomain() }

    override fun findByAccountIdAndTypeWithCursor(
        accountId: AccountId,
        type: TransactionType,
        cursor: TransactionId?,
        limit: Int,
    ): List<Transaction> {
        val entityType =
            when (type) {
                TransactionType.DEBIT -> AccountTransactionTypeEntity.DEBIT
                TransactionType.CREDIT -> AccountTransactionTypeEntity.CREDIT
            }

        val pageable = PageRequest.of(0, limit)
        return jpaTransactionRepository
            .findByAccountIdAndTypeWithCursor(
                accountId.value,
                entityType,
                cursor?.value,
                pageable,
            ).map { it.toDomain() }
    }

    override fun findByAccountIdAndTimestampBetweenWithCursor(
        accountId: AccountId,
        startTime: Long,
        endTime: Long,
        cursor: TransactionId?,
        limit: Int,
    ): List<Transaction> {
        val pageable = PageRequest.of(0, limit)
        return jpaTransactionRepository
            .findByAccountIdAndTimestampBetweenWithCursor(
                accountId.value,
                Instant.ofEpochMilli(startTime),
                Instant.ofEpochMilli(endTime),
                cursor?.value,
                pageable,
            ).map { it.toDomain() }
    }
}

// ===== ./domains/account/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:account:application"))
    implementation(project(":domains:account:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/exception/AccountGlobalExceptionHandler.kt =====
package com.restaurant.presentation.account.exception

import com.restaurant.domain.account.exception.AccountDomainException
import jakarta.validation.ConstraintViolationException
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import java.net.URI
import java.time.Instant

/**
 * 계좌 관련 전역 예외 처리기
 * RFC 9457 형식(ProblemDetail)으로 에러 응답을 변환
 */
@ControllerAdvice(basePackages = ["com.restaurant.presentation.account"])
class AccountGlobalExceptionHandler {
    /**
     * 계좌를 찾을 수 없는 예외 처리
     */
    @ExceptionHandler(AccountDomainException.Account.NotFound::class)
    fun handleAccountNotFoundException(ex: AccountDomainException.Account.NotFound): ResponseEntity<ProblemDetail> {
        val problem =
            ProblemDetail.forStatus(HttpStatus.NOT_FOUND).apply {
                type = URI.create("probs/account_not_found")
                title = "Account Not Found"
                detail = ex.message
                setProperty("errorCode", "ACCOUNT_NOT_FOUND")
                setProperty("timestamp", Instant.now().toString())
            }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem)
    }

    /**
     * 거래 내역을 찾을 수 없는 예외 처리
     */
    @ExceptionHandler(AccountDomainException.Transaction.NotFound::class)
    fun handleTransactionNotFoundException(ex: AccountDomainException.Transaction.NotFound): ResponseEntity<ProblemDetail> {
        val problem =
            ProblemDetail.forStatus(HttpStatus.NOT_FOUND).apply {
                type = URI.create("probs/transaction_not_found")
                title = "Transaction Not Found"
                detail = ex.message
                setProperty("errorCode", "TRANSACTION_NOT_FOUND")
                setProperty("timestamp", Instant.now().toString())
            }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(problem)
    }

    /**
     * 이미 결제가 취소된 경우 예외 처리
     */
    @ExceptionHandler(AccountDomainException.Transaction.AlreadyCancelled::class)
    fun handlePaymentAlreadyCancelledException(ex: AccountDomainException.Transaction.AlreadyCancelled): ResponseEntity<ProblemDetail> {
        val problem =
            ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                type = URI.create("probs/payment_already_cancelled")
                title = "Payment Already Cancelled"
                detail = ex.message
                setProperty("errorCode", "PAYMENT_ALREADY_CANCELLED")
                setProperty("timestamp", Instant.now().toString())
            }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
    }

    /**
     * 잔액 부족 예외 처리
     */
    @ExceptionHandler(AccountDomainException.Account.InsufficientBalance::class)
    fun handleInsufficientBalanceException(ex: AccountDomainException.Account.InsufficientBalance): ResponseEntity<ProblemDetail> {
        val problem =
            ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                type = URI.create("probs/insufficient_balance")
                title = "Insufficient Balance"
                detail = ex.message
                setProperty("errorCode", "INSUFFICIENT_BALANCE")
                setProperty("timestamp", Instant.now().toString())
                setProperty("currentBalance", ex.currentBalance.value)
                setProperty("requiredAmount", ex.requiredAmount.value)
            }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
    }

    /**
     * 유효성 검사 실패 예외 처리
     */
    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(ex: MethodArgumentNotValidException): ResponseEntity<ProblemDetail> {
        val fieldErrors =
            ex.bindingResult.fieldErrors.map {
                mapOf(
                    "field" to it.field,
                    "message" to (it.defaultMessage ?: "Invalid value"),
                    "rejectedValue" to it.rejectedValue,
                )
            }

        val problem =
            ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                type = URI.create("probs/validation_error")
                title = "Validation Error"
                detail = "입력값 유효성 검사에 실패했습니다."
                setProperty("errorCode", "VALIDATION_ERROR")
                setProperty("timestamp", Instant.now().toString())
                setProperty("errors", fieldErrors)
            }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
    }

    /**
     * 제약 조건 위반 예외 처리
     */
    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(ex: ConstraintViolationException): ResponseEntity<ProblemDetail> {
        val violations =
            ex.constraintViolations.map {
                mapOf(
                    "property" to it.propertyPath.toString(),
                    "message" to it.message,
                    "invalidValue" to it.invalidValue,
                )
            }

        val problem =
            ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                type = URI.create("probs/constraint_violation")
                title = "Constraint Violation"
                detail = "제약 조건 위반이 발생했습니다."
                setProperty("errorCode", "CONSTRAINT_VIOLATION")
                setProperty("timestamp", Instant.now().toString())
                setProperty("violations", violations)
            }
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
    }

    /**
     * 기타 모든 예외에 대한 처리
     */
    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception): ResponseEntity<ProblemDetail> {
        val problem =
            ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR).apply {
                type = URI.create("probs/internal_server_error")
                title = "Internal Server Error"
                detail = "서버 내부 오류가 발생했습니다."
                setProperty("errorCode", "INTERNAL_SERVER_ERROR")
                setProperty("timestamp", Instant.now().toString())
                setProperty("exception", ex.javaClass.simpleName)
            }
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(problem)
    }
}

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/command/AccountCommandControllerV1.kt =====
package com.restaurant.presentation.account.v1.command

import com.restaurant.application.account.command.handler.CancelAccountPaymentCommandHandler
import com.restaurant.application.account.command.handler.ProcessAccountPaymentCommandHandler
import com.restaurant.common.presentation.dto.response.BusinessErrorResponse
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.common.presentation.dto.response.InternalServerErrorResponse
import com.restaurant.common.presentation.dto.response.NotFoundErrorResponse
import com.restaurant.common.presentation.dto.response.ValidationErrorResponse
import com.restaurant.presentation.account.v1.dto.request.CancelPaymentRequestV1
import com.restaurant.presentation.account.v1.dto.request.ProcessPaymentRequestV1
import com.restaurant.presentation.account.v1.extensions.request.toCommand
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.hateoas.server.mvc.linkTo
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@Tag(
    name = "계좌 커맨드 API",
    description = "계좌 관련 커맨드를 처리하는 API",
)
@RestController
@RequestMapping("/api/v1/accounts")
class AccountCommandControllerV1(
    private val processAccountPaymentCommandHandler: ProcessAccountPaymentCommandHandler,
    private val cancelAccountPaymentCommandHandler: CancelAccountPaymentCommandHandler,
) {
    @Operation(
        summary = "계좌 결제 처리",
        description = "주문에 대한 결제를 처리합니다.",
    )
    @ApiResponse(
        responseCode = "200",
        description = "결제 처리 성공",
        content = [Content(schema = Schema(implementation = CommandResultResponse::class))],
    )
    @ApiResponse(
        responseCode = "400",
        description = "잘못된 요청 또는 잔액 부족",
        content = [Content(schema = Schema(implementation = BusinessErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "404",
        description = "계좌를 찾을 수 없음",
        content = [Content(schema = Schema(implementation = NotFoundErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "500",
        description = "서버 내부 오류",
        content = [Content(schema = Schema(implementation = InternalServerErrorResponse::class))],
    )
    @PostMapping("/{accountId}/payments")
    fun processPayment(
        @Parameter(description = "계좌 ID")
        @PathVariable accountId: Long,
        @Valid @RequestBody request: ProcessPaymentRequestV1,
        @Parameter(description = "상관 관계 ID")
        @RequestHeader(name = "X-Correlation-Id", required = false) correlationId: String?,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(accountId)
        val resultCorrelationId =
            processAccountPaymentCommandHandler.handle(
                command,
                correlationId,
            )

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "결제가 성공적으로 처리되었습니다.",
                correlationId = resultCorrelationId,
            )

        response.add(
            linkTo<AccountCommandControllerV1> {
                this.processPayment(accountId, request, correlationId)
            }.withSelfRel(),
        )

        return ResponseEntity.ok(response)
    }

    @Operation(
        summary = "계좌 결제 취소",
        description = "처리된 결제를 취소합니다.",
    )
    @ApiResponse(
        responseCode = "200",
        description = "결제 취소 성공",
        content = [Content(schema = Schema(implementation = CommandResultResponse::class))],
    )
    @ApiResponse(
        responseCode = "400",
        description = "잘못된 요청 또는 이미 취소된 결제",
        content = [Content(schema = Schema(implementation = ValidationErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "404",
        description = "계좌 또는 거래내역을 찾을 수 없음",
        content = [Content(schema = Schema(implementation = NotFoundErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "500",
        description = "서버 내부 오류",
        content = [Content(schema = Schema(implementation = InternalServerErrorResponse::class))],
    )
    @PostMapping("/{accountId}/payments/cancel")
    fun cancelPayment(
        @Parameter(description = "계좌 ID")
        @PathVariable accountId: Long,
        @Valid @RequestBody request: CancelPaymentRequestV1,
        @Parameter(description = "상관 관계 ID")
        @RequestHeader(name = "X-Correlation-Id", required = false) correlationId: String?,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(accountId)
        val resultCorrelationId =
            cancelAccountPaymentCommandHandler.handle(
                command,
                correlationId,
            )

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "결제가 성공적으로 취소되었습니다.",
                correlationId = resultCorrelationId,
            )

        response.add(
            linkTo<AccountCommandControllerV1> {
                this.cancelPayment(accountId, request, correlationId)
            }.withSelfRel(),
        )

        return ResponseEntity.ok(response)
    }
}

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/dto/request/AccountRegisterRequestV1.kt =====
package com.restaurant.presentation.account.v1.dto.request

import jakarta.validation.constraints.Min
import java.math.BigDecimal

/**
 * 계좌 등록 요청 DTO
 */
data class AccountRegisterRequestV1(
    @field:Min(value = 0, message = "초기 잔액은 0 이상이어야 합니다.")
    val initialBalance: BigDecimal,
)

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/dto/request/CancelPaymentRequestV1.kt =====
package com.restaurant.presentation.account.v1.dto.request

import jakarta.validation.constraints.NotNull

/**
 * 결제 취소 요청 DTO
 */
data class CancelPaymentRequestV1(
    @field:NotNull(message = "주문 번호는 필수 입력 값입니다.")
    val orderId: String,
)

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/dto/request/ProcessPaymentRequestV1.kt =====
package com.restaurant.presentation.account.v1.dto.request

import jakarta.validation.constraints.Min
import jakarta.validation.constraints.NotNull
import java.math.BigDecimal

/**
 * 결제 처리 요청 DTO
 */
data class ProcessPaymentRequestV1(
    @field:NotNull(message = "주문 번호는 필수 입력 값입니다.")
    val orderId: String,
    @field:NotNull(message = "결제 금액은 필수 입력 값입니다.")
    @field:Min(value = 1, message = "결제 금액은 1 이상이어야 합니다.")
    val amount: BigDecimal,
)

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/dto/response/AccountBalanceResponseV1.kt =====
package com.restaurant.presentation.account.v1.dto.response

import java.math.BigDecimal

/**
 * 계좌 잔액 응답 DTO
 */
data class AccountBalanceResponseV1(
    val accountId: Long,
    val balance: BigDecimal,
)

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/extensions/request/AccountRequestExtensions.kt =====
package com.restaurant.presentation.account.v1.extensions.request

import com.restaurant.application.account.command.CancelAccountPaymentCommand
import com.restaurant.application.account.command.ProcessAccountPaymentCommand
import com.restaurant.application.account.command.RegisterAccountCommand
import com.restaurant.presentation.account.v1.dto.request.AccountRegisterRequestV1
import com.restaurant.presentation.account.v1.dto.request.CancelPaymentRequestV1
import com.restaurant.presentation.account.v1.dto.request.ProcessPaymentRequestV1

/**
 * 계좌 등록 요청 -> 명령 변환
 */
fun AccountRegisterRequestV1.toCommand(userId: Long): RegisterAccountCommand =
    RegisterAccountCommand(
        userId = userId,
        initialBalance = this.initialBalance,
    )

/**
 * 결제 처리 요청 -> 명령 변환
 */
fun ProcessPaymentRequestV1.toCommand(accountId: Long): ProcessAccountPaymentCommand =
    ProcessAccountPaymentCommand(
        accountId = accountId,
        amount = this.amount,
        orderId = this.orderId,
    )

/**
 * 결제 취소 요청 -> 명령 변환
 */
fun CancelPaymentRequestV1.toCommand(accountId: Long): CancelAccountPaymentCommand =
    CancelAccountPaymentCommand(
        accountId = accountId,
        orderId = this.orderId,
    )

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/extensions/response/AccountResponseExtensions.kt =====
package com.restaurant.presentation.account.v1.extensions.response

import com.restaurant.application.account.query.dto.AccountBalanceDto
import com.restaurant.presentation.account.v1.dto.response.AccountBalanceResponseV1

/**
 * 계좌 잔액 DTO -> 응답 변환
 */
fun AccountBalanceDto.toResponse(): AccountBalanceResponseV1 =
    AccountBalanceResponseV1(
        accountId = this.accountId,
        balance = this.balance,
    )

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/extensions/response/QueryResponseExtensions.kt =====
package com.restaurant.presentation.account.v1.extensions.response

import com.restaurant.application.account.query.dto.TransactionDto
import com.restaurant.common.core.query.dto.CursorPageDto
import com.restaurant.presentation.account.v1.query.dto.response.CursorPageResponseV1
import com.restaurant.presentation.account.v1.query.dto.response.TransactionResponseV1

// CursorPageDto<TransactionDto> 확장 함수
fun CursorPageDto<TransactionDto>.toResponse(): CursorPageResponseV1<TransactionResponseV1> =
    CursorPageResponseV1(
        items = this.items.map { it.toResponse() },
        nextCursor = this.nextCursor,
        hasNext = this.hasNext,
    )

// TransactionDto 확장 함수
fun TransactionDto.toResponse(): TransactionResponseV1 =
    TransactionResponseV1(
        id = this.id,
        accountId = this.accountId,
        type = this.type,
        amount = this.amount,
        orderId = this.orderId,
        timestamp = this.timestamp,
        dateTime = this.dateTime,
    )

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/query/AccountQueryControllerV1.kt =====
package com.restaurant.presentation.account.v1.query

import com.restaurant.application.account.query.GetAccountBalanceQuery
import com.restaurant.application.account.query.GetAccountTransactionsQuery
import com.restaurant.application.account.query.dto.AccountBalanceDto
import com.restaurant.application.account.query.dto.TransactionDto
import com.restaurant.application.account.query.handler.GetAccountBalanceQueryHandler
import com.restaurant.application.account.query.handler.GetAccountTransactionsQueryHandler
import com.restaurant.common.core.query.dto.CursorPageDto
import com.restaurant.common.presentation.dto.response.InternalServerErrorResponse
import com.restaurant.common.presentation.dto.response.NotFoundErrorResponse
import com.restaurant.common.presentation.dto.response.ValidationErrorResponse
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.constraints.Max
import jakarta.validation.constraints.Min
import org.springframework.hateoas.CollectionModel
import org.springframework.hateoas.EntityModel
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@Tag(
    name = "계좌 쿼리 API",
    description = "계좌 관련 정보를 조회하는 API",
)
@RestController
@RequestMapping("/api/v1/accounts")
@Validated
class AccountQueryControllerV1(
    private val getAccountBalanceQueryHandler: GetAccountBalanceQueryHandler,
    private val getAccountTransactionsQueryHandler: GetAccountTransactionsQueryHandler,
) {
    @Operation(
        summary = "계좌 잔액 조회",
        description = "계좌의 현재 잔액을 조회합니다.",
    )
    @ApiResponse(
        responseCode = "200",
        description = "잔액 조회 성공",
        content = [Content(schema = Schema(implementation = AccountBalanceDto::class))],
    )
    @ApiResponse(
        responseCode = "404",
        description = "계좌를 찾을 수 없음",
        content = [Content(schema = Schema(implementation = NotFoundErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "500",
        description = "서버 내부 오류",
        content = [Content(schema = Schema(implementation = InternalServerErrorResponse::class))],
    )
    @GetMapping("/{accountId}/balance")
    fun getAccountBalance(
        @Parameter(description = "계좌 ID")
        @PathVariable accountId: Long,
    ): ResponseEntity<EntityModel<AccountBalanceDto>> {
        val query = GetAccountBalanceQuery(accountId)
        val result = getAccountBalanceQueryHandler.handle(query)

        // HATEOAS 링크 생성
        val selfLink = linkTo(methodOn(this::class.java).getAccountBalance(accountId)).withSelfRel()
        val transactionsLink =
            linkTo(methodOn(this::class.java).getAccountTransactions(accountId, null, 10))
                .withRel("transactions")

        // EntityModel 생성
        val entityModel =
            EntityModel.of(
                result,
                selfLink,
                transactionsLink,
            )

        return ResponseEntity.ok(entityModel)
    }

    @Operation(
        summary = "계좌 트랜잭션 목록 조회",
        description = "계좌의 트랜잭션 내역을 커서 기반 페이지네이션으로 조회합니다.",
    )
    @ApiResponse(
        responseCode = "200",
        description = "트랜잭션 목록 조회 성공",
        content = [Content(schema = Schema(implementation = TransactionDto::class))],
    )
    @ApiResponse(
        responseCode = "400",
        description = "잘못된 요청 파라미터",
        content = [Content(schema = Schema(implementation = ValidationErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "404",
        description = "계좌를 찾을 수 없음",
        content = [Content(schema = Schema(implementation = NotFoundErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "500",
        description = "서버 내부 오류",
        content = [Content(schema = Schema(implementation = InternalServerErrorResponse::class))],
    )
    @GetMapping("/{accountId}/transactions")
    fun getAccountTransactions(
        @Parameter(description = "계좌 ID")
        @PathVariable accountId: Long,
        @Parameter(description = "페이지네이션 커서")
        @RequestParam(required = false) cursor: String?,
        @Parameter(description = "한 페이지당 항목 수 (1-100)")
        @Min(1)
        @Max(100)
        @RequestParam(defaultValue = "10") limit: Int,
    ): ResponseEntity<CollectionModel<EntityModel<TransactionDto>>> {
        val query =
            GetAccountTransactionsQuery(
                accountId = accountId,
                cursor = cursor,
                limit = limit,
            )
        val result: CursorPageDto<TransactionDto> = getAccountTransactionsQueryHandler.handle(query)

        // 개별 TransactionDto를 EntityModel로 변환
        val transactionModels =
            result.items.map { transaction ->
                EntityModel.of(
                    transaction,
                    linkTo(methodOn(this::class.java).getTransactionDetail(accountId, transaction.id))
                        .withSelfRel(),
                )
            }

        // 페이지 링크 생성
        val selfLink =
            linkTo(methodOn(this::class.java).getAccountTransactions(accountId, cursor, limit))
                .withSelfRel()
        val links = mutableListOf(selfLink)
        if (result.hasNext) {
            val nextLink =
                linkTo(methodOn(this::class.java).getAccountTransactions(accountId, result.nextCursor, limit))
                    .withRel("next")
            links.add(nextLink)
        }

        // CollectionModel 생성
        val collectionModel =
            CollectionModel.of(
                transactionModels,
                links,
            )

        return ResponseEntity.ok(collectionModel)
    }

    @Operation(
        summary = "트랜잭션 상세 조회",
        description = "특정 트랜잭션의 상세 정보를 조회합니다.",
    )
    @ApiResponse(
        responseCode = "200",
        description = "트랜잭션 상세 조회 성공",
        content = [Content(schema = Schema(implementation = TransactionDto::class))],
    )
    @ApiResponse(
        responseCode = "404",
        description = "트랜잭션을 찾을 수 없음",
        content = [Content(schema = Schema(implementation = NotFoundErrorResponse::class))],
    )
    @ApiResponse(
        responseCode = "500",
        description = "서버 내부 오류",
        content = [Content(schema = Schema(implementation = InternalServerErrorResponse::class))],
    )
    @GetMapping("/{accountId}/transactions/{transactionId}")
    fun getTransactionDetail(
        @Parameter(description = "계좌 ID")
        @PathVariable accountId: Long,
        @Parameter(description = "트랜잭션 ID")
        @PathVariable transactionId: Long,
    ): ResponseEntity<EntityModel<TransactionDto>> {
        // 실제 상세 조회 로직 구현...
        throw UnsupportedOperationException("Not implemented yet")
    }
}

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/query/dto/response/AccountBalanceResponseV1.kt =====
package com.restaurant.presentation.account.v1.query.dto.response

import java.math.BigDecimal

/**
 * 계좌 잔액 정보 응답 DTO
 *
 * @property accountId 계좌 ID
 * @property balance 현재 잔액
 */
data class AccountBalanceResponseV1(
    val accountId: Long,
    val balance: BigDecimal,
)

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/query/dto/response/CursorPageResponseV1.kt =====
package com.restaurant.presentation.account.v1.query.dto.response

/**
 * 커서 기반 페이징 응답 DTO
 *
 * @property items 조회된 아이템 목록
 * @property nextCursor 다음 페이지 요청 시 사용할 커서 (null이면 마지막 페이지)
 * @property hasNext 다음 페이지 존재 여부
 */
data class CursorPageResponseV1<T>(
    val items: List<T>,
    val nextCursor: String?,
    val hasNext: Boolean,
)

// ===== ./domains/account/presentation/src/main/kotlin/com/restaurant/presentation/account/v1/query/dto/response/TransactionResponseV1.kt =====
package com.restaurant.presentation.account.v1.query.dto.response

import java.math.BigDecimal
import java.time.LocalDateTime

/**
 * 트랜잭션 정보 응답 DTO
 *
 * @property id 트랜잭션 ID
 * @property accountId 계좌 ID
 * @property type 트랜잭션 타입 (DEBIT, CREDIT)
 * @property amount 금액
 * @property orderId 주문 ID
 * @property timestamp 트랜잭션 발생 시간 (밀리초)
 * @property dateTime 트랜잭션 발생 시간 (LocalDateTime)
 */
data class TransactionResponseV1(
    val id: Long,
    val accountId: Long,
    val type: String,
    val amount: BigDecimal,
    val orderId: String,
    val timestamp: Long,
    val dateTime: LocalDateTime,
)

// ===== ./domains/common/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    // 필수 Spring Framework 의존성만 유지
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    // Swagger
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/error/ErrorCode.kt =====
package com.restaurant.common.core.error

/**
 * 모든 에러 코드가 구현해야 하는 공통 인터페이스
 */
interface ErrorCode {
    /**
     * 에러 코드 (예: USER-001)
     */
    val code: String

    /**
     * 에러 메시지
     */
    val message: String
}

abstract class BaseErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    companion object {
        fun fromCode(
            errorCodes: List<ErrorCode>,
            code: String?,
        ): ErrorCode? = errorCodes.find { it.code == code }
    }
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/exception/ApplicationException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 애플리케이션 레이어에서 발생하는 기술적 또는 외부 요인 관련 예외의 기본 클래스.
 */
abstract class ApplicationException(
    message: String,
    cause: Throwable? = null, // 원인 예외를 포함할 수 있도록 cause 추가
) : RuntimeException(message, cause) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/exception/DomainException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 도메인 비즈니스 규칙 위반 시 발생하는 기본 예외 클래스.
 */
abstract class DomainException(
    message: String,
) : RuntimeException(message) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/exception/InfrastructureException.kt =====
package com.restaurant.common.core.exception

open class InfrastructureException(
    message: String,
) : RuntimeException(message)

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/exception/PresentationException.kt =====
package com.restaurant.common.core.exception

open class PresentationException(
    message: String,
) : RuntimeException(message)

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/query/QueryResult.kt =====
package com.restaurant.common.core.query

data class QueryResult<T>(
    val success: Boolean,
    val data: T? = null,
    val errorCode: String? = null,
)

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/core/query/dto/CursorPageDto.kt =====
package com.restaurant.common.core.query.dto

/**
 * 커서 기반 페이징 결과 DTO
 *
 * @property items 조회된 아이템 목록
 * @property nextCursor 다음 페이지 요청 시 사용할 커서 (null이면 마지막 페이지)
 * @property hasNext 다음 페이지 존재 여부
 */
data class CursorPageDto<T>(
    val items: List<T>,
    val nextCursor: String?,
    val hasNext: Boolean,
)

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt =====
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    protected fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }

    fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    fun clearDomainEvents() {
        domainEvents.clear()
    }
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt =====
package com.restaurant.common.domain.event

import java.time.LocalDateTime

/**
 * 모든 도메인 이벤트가 구현해야 하는 공통 인터페이스.
 */
interface DomainEvent {
    /**
     * 이벤트가 발생한 Aggregate의 루트 엔티티 ID (UUID의 문자열 표현).
     */
    val aggregateId: String

    /**
     * 이벤트가 발생한 Aggregate의 타입 이름.
     */
    val aggregateType: String // 예: "User", "Order"

    /**
     * 이벤트 발생 시각.
     */
    val occurredAt: LocalDateTime

    /**
     * 이벤트 고유 ID.
     */
    val eventId: String
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/infrastructure/mapper/EntityMapper.kt =====
package com.restaurant.common.infrastructure.mapper

interface EntityMapper<D, E> {
    fun toEntity(domain: D): E

    fun toDomain(entity: E): D
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt =====
package com.restaurant.common.presentation

import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.common.core.exception.DomainException
import com.restaurant.common.core.exception.InfrastructureException
import com.restaurant.common.core.exception.PresentationException
import jakarta.validation.ConstraintViolationException
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.context.request.WebRequest
import java.net.URI
import java.time.Instant
import java.util.UUID

@ControllerAdvice
class GlobalExceptionHandler(
    @Value("\${app.problem.base-url:https://api.restaurant.com/problems}") private val problemBaseUrl: String,
) {
    private val log = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)

    /**
     * 에러 코드에 따른 HTTP 상태 코드 매핑
     */
    private fun determineHttpStatusFromCode(code: String): HttpStatus =
        when {
            // 인증/인가 관련 에러
            code.startsWith("AUTH-") -> HttpStatus.UNAUTHORIZED
            code.contains("-AUTH-") -> HttpStatus.UNAUTHORIZED
            code.contains("-FORBIDDEN-") -> HttpStatus.FORBIDDEN

            // 리소스 찾을 수 없음
            code.contains("-NOT-FOUND") -> HttpStatus.NOT_FOUND
            code.endsWith("-404") -> HttpStatus.NOT_FOUND

            // 중복/충돌
            code.contains("-DUPLICATE-") -> HttpStatus.CONFLICT
            code.contains("-CONFLICT-") -> HttpStatus.CONFLICT
            code.endsWith("-409") -> HttpStatus.CONFLICT

            // 유효성 검증 실패
            code.contains("-INVALID-") -> HttpStatus.BAD_REQUEST
            code.contains("-VALIDATION-") -> HttpStatus.BAD_REQUEST
            code.endsWith("-400") -> HttpStatus.BAD_REQUEST

            // 비즈니스 규칙 위반
            code.startsWith("BIZ-") -> HttpStatus.UNPROCESSABLE_ENTITY
            code.contains("-RULE-") -> HttpStatus.UNPROCESSABLE_ENTITY
            code.endsWith("-422") -> HttpStatus.UNPROCESSABLE_ENTITY

            // 시스템/인프라 에러
            code.startsWith("SYS-") -> HttpStatus.INTERNAL_SERVER_ERROR
            code.contains("-SYSTEM-") -> HttpStatus.INTERNAL_SERVER_ERROR
            code.endsWith("-500") -> HttpStatus.INTERNAL_SERVER_ERROR

            // 기본값
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }

    private fun createProblemDetail(
        status: HttpStatus,
        code: String,
        title: String,
        detail: String?,
        request: WebRequest,
    ): ProblemDetail {
        val correlationId = request.getHeader("X-Correlation-Id") ?: UUID.randomUUID().toString()
        return ProblemDetail.forStatus(status).apply {
            type = URI.create("$problemBaseUrl/${code.lowercase()}")
            this.title = title
            this.detail = detail ?: "오류가 발생했습니다."
            setProperty("errorCode", code)
            setProperty("timestamp", Instant.now().toString())
            setProperty("correlationId", correlationId)
        }
    }

    private fun getCorrelationId(request: WebRequest): String = request.getHeader("X-Correlation-Id") ?: "N/A"

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val code = ex.errorCode.code
        val status = determineHttpStatusFromCode(code)
        val title = ex.errorCode.message

        log.warn(
            "Domain Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(
        ex: ApplicationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val code = ex.errorCode.code
        val status = determineHttpStatusFromCode(code)
        val title = ex.errorCode.message

        log.error(
            "Application Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(InfrastructureException::class)
    fun handleInfrastructureException(
        ex: InfrastructureException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "INFRASTRUCTURE_ERROR"
        val title = "Infrastructure Error"
        val detail = ex.message ?: "인프라스트럭처 처리 중 오류가 발생했습니다."

        log.error(
            "Infrastructure Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(PresentationException::class)
    fun handlePresentationException(
        ex: PresentationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "PRESENTATION_ERROR"
        val title = "Presentation Error"
        val detail = ex.message ?: "프레젠테이션 처리 중 오류가 발생했습니다."

        log.warn(
            "Presentation Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(
        ex: MethodArgumentNotValidException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.bindingResult.fieldErrors.map {
                mapOf("field" to it.field, "reason" to (it.defaultMessage ?: "유효하지 않은 값입니다."))
            }
        log.warn(
            "Validation Exception Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams.toString(),
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(
        ex: ConstraintViolationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.constraintViolations.map {
                mapOf("field" to it.propertyPath.toString(), "reason" to it.message)
            }
        log.warn(
            "Constraint Violation Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleMessageNotReadableException(
        ex: HttpMessageNotReadableException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "MESSAGE_NOT_READABLE"
        val title = "Invalid Request Body"
        val detail = "요청 본문의 형식이 잘못되었거나 읽을 수 없습니다."
        log.warn(
            "Message Not Readable Exception Handled: correlationId={}, error={}",
            correlationId,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(
        ex: Exception,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "SYSTEM_ERROR"
        val title = "Internal Server Error"
        val detail = "서버에서 예상치 못한 오류가 발생했습니다."
        log.error(
            "Unhandled Exception: correlationId={}, error={}",
            correlationId,
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }
}

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt =====
package com.restaurant.common.presentation.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "커맨드 실행 결과 응답")
data class CommandResultResponse(
    @field:Schema(description = "처리 상태", example = "SUCCESS", required = true)
    val status: String,
    @field:Schema(description = "결과 메시지", example = "처리가 성공적으로 완료되었습니다.", required = true)
    val message: String,
    @field:Schema(description = "상관 관계 ID", example = "123e4567-e89b-12d3-a456-426614174000", required = true)
    val correlationId: String,
) : RepresentationModel<CommandResultResponse>()

// ===== ./domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/ValidationErrorResponse.kt =====
package com.restaurant.common.presentation.dto.response

import org.springframework.hateoas.RepresentationModel

data class ValidationErrorResponse(
    val type: String,
    val title: String,
    val detail: String,
    val errorCode: String,
    val timestamp: String,
    val correlationId: String?,
    val invalidParams: List<InvalidParam>,
) : RepresentationModel<ValidationErrorResponse>() {
    data class InvalidParam(
        val field: String,
        val reason: String,
    )
}

// ===== ./domains/user/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:infrastructure"))

    // Spring Boot 버전을 통일
    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-security:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.5")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/ChangePasswordCommand.kt =====
package com.restaurant.application.user.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteAddressCommand.kt =====
package com.restaurant.application.user.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteUserCommand.kt =====
package com.restaurant.application.user.command

data class DeleteUserCommand(
    val userId: String,
    val password: String,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/LoginCommand.kt =====
package com.restaurant.application.user.command

data class LoginCommand(
    val email: String,
    val password: String,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterAddressCommand.kt =====
package com.restaurant.application.user.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterUserCommand.kt =====
package com.restaurant.application.user.command

data class RegisterUserCommand(
    val email: String,
    val password: String,
    val name: String,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateAddressCommand.kt =====
package com.restaurant.application.user.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateProfileCommand.kt =====
package com.restaurant.application.user.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/command/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.dto.LoginResult
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): LoginResult {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (LoginResult 반환)
            val userId = user.id.value.toString()
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, userId)

            // 실제 구현에서는 JWT 토큰 생성 로직이 들어갈 것임
            return LoginResult(
                userId = userId,
                accessToken = "jwt.access.token.$userId", // 임시 구현
                refreshToken = "jwt.refresh.token.$userId", // 임시 구현
            )
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/LoginResult.kt =====
package com.restaurant.application.user.dto

import java.util.UUID

// 로그인 결과를 담는 데이터 클래스
data class LoginResult(
    val userId: String,
    val accessToken: String = UUID.randomUUID().toString(), // 임시 구현
    val refreshToken: String = UUID.randomUUID().toString(), // 임시 구현
)

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/UserProfileDto.kt =====
package com.restaurant.application.user.dto

import java.time.LocalDateTime

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val addresses: List<AddressDto> = emptyList(),
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime,
) {
    data class AddressDto(
        val id: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/error/UserApplicationErrorCode.kt =====
package com.restaurant.application.user.error

import com.restaurant.common.core.error.ErrorCode
import org.springframework.http.HttpStatus

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val status: HttpStatus,
    override val message: String,
) : ErrorCode {
    INVALID_INPUT("USER-APPLICATION-001", HttpStatus.BAD_REQUEST, "입력값이 유효하지 않습니다."),
    AUTHENTICATION_FAILED("USER-APPLICATION-002", HttpStatus.UNAUTHORIZED, "인증에 실패했습니다."), // 예시: JWT 토큰 검증 실패 등
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-003", HttpStatus.INTERNAL_SERVER_ERROR, "외부 서비스 호출에 실패했습니다."),
    SYSTEM_ERROR("USER-APPLICATION-999", HttpStatus.INTERNAL_SERVER_ERROR, "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/exception/UserApplicationException.kt =====
package com.restaurant.application.user.exception

import com.restaurant.application.user.error.UserApplicationErrorCode
import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException

sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    final override val message: String = errorCode.message,
) : ApplicationException(message) {
    data class InvalidInput(
        val details: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.INVALID_INPUT,
            if (details != null) "유효하지 않은 입력: $details" else UserApplicationErrorCode.INVALID_INPUT.message,
        )

    data class AuthenticationFailed(
        val reason: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.AUTHENTICATION_FAILED,
            if (reason != null) "인증 실패: $reason" else UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        )

    data class ExternalServiceError(
        val serviceName: String,
        val causeError: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR,
            "외부 서비스($serviceName) 호출 오류${causeError?.let { ": $it" } ?: ""}",
        )

    data class SystemError(
        val causeException: Throwable? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.SYSTEM_ERROR,
            "시스템 오류 발생${causeException?.message?.let { ": $it" } ?: ""}",
        )
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/extensions/UserDtoExtensions.kt =====
package com.restaurant.application.user.extensions

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.model.Address

/**
 * Domain 객체를 Application DTO로 변환하는 확장 함수들
 */

fun User.toUserProfileDto(): UserProfileDto =
    UserProfileDto(
        id = this.id.value.toString(),
        email = this.email.value,
        name = this.name.value,
        addresses = this.addresses.map { it.toAddressDto() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

fun Address.toAddressDto(): UserProfileDto.AddressDto =
    UserProfileDto.AddressDto(
        id = this.addressId.value.toString(),
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/ChangePasswordCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(ChangePasswordCommandHandler::class.java)

    @Transactional
    fun handle(
        command: ChangePasswordCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: Create VOs outside try-catch
        val userId = UserId.fromString(command.userId)
        Password.validateRaw(command.newPassword)
        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.fromEncoded(encodedNewPassword)

        log.debug("Attempting password change, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for password change, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 현재 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.currentPassword, user.password.encodedValue)) {
                log.warn("Password change failed: Current password mismatch, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("현재 비밀번호가 일치하지 않습니다.")
            }

            // 비밀번호 변경 (Aggregate 호출)
            val updatedUser = user.changePassword(newPasswordVo)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info("Password changed successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during password change, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during password change, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug("Attempting to delete address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address deletion, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 삭제 (Aggregate 호출 - 내부에서 AddressNotFound 예외 발생 가능)
            val updatedUser = user.removeAddress(addressId)
            // 저장
            userRepository.save(updatedUser)

            log.info("Address deleted successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                command.addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                command.userId,
                command.addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 삭제 커맨드 핸들러
 */
@Service
class DeleteUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to delete address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address deletion, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 주소 삭제 (Domain 로직 호출)
            val updatedUser = user.removeAddress(addressId)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address deleted successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(DeleteUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteUserCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        log.debug("Attempting user deletion, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for deletion, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Password mismatch during user deletion, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("비밀번호가 일치하지 않습니다.")
            }

            // 사용자 삭제
            userRepository.delete(user)

            log.info("User deleted successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user deletion, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 시스템 오류
            log.error(
                "System error during user deletion, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/GetUserProfileQueryHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.application.user.extensions.toUserProfileDto
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(GetUserProfileQueryHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        query: GetUserProfileQuery,
        correlationId: String? = null,
    ): UserProfileDto {
        val userId = UserId.fromString(query.userId)
        log.debug("Attempting to get user profile, correlationId={}, userId={}", correlationId, userId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for profile query, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = query.userId)
                }
        val result = user.toUserProfileDto()
        log.debug("User profile retrieved successfully, correlationId={}, userId={}", correlationId, userId)
        return result
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): String {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (UserId 반환)
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, user.id.value)
            return user.id.value.toString()
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(RegisterAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 및 Domain Entity 생성
        val userId = UserId.fromString(command.userId)
        val address =
            Address.create(
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )

        log.debug("Attempting to register address, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address registration, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 추가 (Aggregate 호출)
            val updatedUser = user.addAddress(address)
            // 저장 (Repository)
            userRepository.save(updatedUser)

            log.info("Address registered successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address registration, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address registration, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import org.slf4j.LoggerFactory
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(RegisterUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterUserCommand,
        correlationId: String? = null,
    ): String {
        // Validate raw inputs and create VOs
        val email = Email.of(command.email)
        Password.validateRaw(command.password) // Validate raw password
        val name = Name.of(command.name)
        // Encode password and create Password VO
        val encodedPassword = passwordEncoder.encode(command.password)
        val password = Password.fromEncoded(encodedPassword)

        // 이메일 중복 검증 (Domain 예외 사용)
        if (userRepository.existsByEmail(email)) {
            // DuplicateEmail 예외는 ErrorCode를 내부적으로 가지므로 별도 로깅 불필요
            throw UserDomainException.User.DuplicateEmail(email = command.email)
        }

        try {
            // 사용자 생성 (이제 User 인스턴스만 반환)
            val newUser = User.create(email, password, name)

            // 사용자 저장 (Repository에서 이벤트 처리)
            val savedUser = userRepository.save(newUser)

            log.info("사용자 등록 성공, correlationId={}, email={}", correlationId, email)
            // Return UUID instead of Long
            return savedUser.id.value.toString()
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user registration, correlationId={}, errorCode={}, error: {}",
                correlationId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (dive: DataIntegrityViolationException) {
            // Catch potential unique constraint violations not caught by existsByEmail (race condition)
            log.error(
                "Data integrity violation during user registration, possibly duplicate email race condition, correlationId={}, error: {}",
                correlationId,
                dive.message,
                dive,
            )
            // Re-throw as duplicate email domain exception
            throw UserDomainException.User.DuplicateEmail(email.value)
        } catch (e: Exception) {
            // 기타 예상치 못한 오류
            log.error("사용자 등록 중 시스템 오류 발생, correlationId={}, error={}", correlationId, e.message, e)
            // Wrap as ApplicationException.SystemError before propagating
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)
        val updatedAddressData =
            Address.reconstitute(
                addressId = addressId,
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )
        log.debug("Attempting to update address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for address update, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }
        val updatedUser = user.updateAddress(addressId, updatedAddressData)
        userRepository.save(updatedUser)
        log.info("Address updated successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateProfileCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        try {
            // 사용자 조회 - DomainException (NotFound)는 상위로 전파
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("사용자를 찾을 수 없음, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 프로필 업데이트
            val updatedUser = user.updateProfile(name = name)
            userRepository.save(updatedUser)

            log.info("사용자 프로필 업데이트 성공, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            log.error(
                "사용자 프로필 업데이트 중 도메인 오류 발생, correlationId={}, errorCode={}, error={}",
                correlationId,
                de.errorCode.code,
                de.message,
                de,
            )
            throw de
        } catch (e: Exception) {
            log.error(
                "사용자 프로필 업데이트 중 시스템 오류 발생, correlationId={}, error={}",
                correlationId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to update address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 업데이트할 주소 객체 생성
            val updatedAddress =
                Address.reconstitute(
                    addressId = addressId,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            // 현재 주소를 찾고 업데이트
            val updatedUser = user.updateAddress(addressId, updatedAddress)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address updated successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address update, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address update, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserProfileCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 프로필 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        log.debug(
            "Attempting to update user profile, correlationId={}, userId={}",
            correlationId,
            userId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for profile update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 프로필 업데이트 (Domain 로직 호출)
            val updatedUser = user.updateProfile(name)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "User profile updated successfully, correlationId={}, userId={}",
                correlationId,
                userId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during profile update, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during profile update, correlationId={}, userId={}, error={}",
                correlationId,
                userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== ./domains/user/application/src/main/kotlin/com/restaurant/application/user/query/GetUserProfileQuery.kt =====
package com.restaurant.application.user.query

data class GetUserProfileQuery(
    val userId: String,
)

// ===== ./domains/user/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/user/apps/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt =====
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories

@SpringBootApplication
@ComponentScan(
    basePackages = [
        "com.restaurant.apps.user",
        "com.restaurant.presentation.user",
        "com.restaurant.application.user",
        "com.restaurant.infrastructure.user",
        "com.restaurant.common",
        "com.restaurant.independent.outbox",
    ],
)
@EntityScan(
    basePackages = [
        "com.restaurant.infrastructure.user.entity",
        "com.restaurant.independent.outbox.infrastructure.entity",
    ],
)
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.infrastructure.user.repository",
        "com.restaurant.independent.outbox.infrastructure.persistence",
    ],
)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

// ===== ./domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SecurityConfig.kt =====
package com.restaurant.apps.user.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() } // 개발 편의상 CSRF 비활성화 (실제 환경에서는 필요에 따라 설정)
            .authorizeHttpRequests { authz ->
                authz.anyRequest().permitAll() // 개발 편의상 모든 요청 허용 (실제 환경에서는 인증/인가 필요)
            }
        return http.build()
    }
}

// ===== ./domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SwaggerConfig.kt =====
package com.restaurant.apps.user.config

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import org.springdoc.core.models.GroupedOpenApi
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfig {
    @Bean
    fun publicApi(): GroupedOpenApi =
        GroupedOpenApi
            .builder()
            .group("user-api-v1")
            .pathsToMatch("/api/v1/users/**")
            .build()

    @Bean
    fun springOpenAPI(): OpenAPI =
        OpenAPI()
            .info(
                Info()
                    .title("User Service API")
                    .description("User Service API Documentation")
                    .version("v1"),
            )
}

// ===== ./domains/user/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.
    // NOTE: HttpStatus 사용을 위해 임시로 추가 (Rule 10 위반 가능성)

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/aggregate/User.kt =====
package com.restaurant.domain.user.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.domain.user.event.UserEvent
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime
import java.util.UUID

data class User
    private constructor(
        val id: UserId,
        val email: Email,
        val password: Password,
        val name: Name,
        val addresses: List<Address> = emptyList(),
        val createdAt: LocalDateTime = LocalDateTime.now(),
        val updatedAt: LocalDateTime = LocalDateTime.now(),
    ) : AggregateRoot() {
        companion object {
            fun create(
                email: Email,
                password: Password,
                name: Name,
            ): User {
                val userId = UserId.generate()
                val user = User(id = userId, email = email, password = password, name = name)
                val event =
                    UserEvent.Created(
                        userId = userId,
                        email = email.value,
                        name = name.value,
                        eventId = UUID.randomUUID().toString(),
                        occurredAt = user.createdAt,
                    )
                user.addDomainEvent(event)
                return user
            }

            fun reconstitute(
                id: UserId,
                email: Email,
                password: Password,
                name: Name,
                addresses: List<Address> = emptyList(),
                createdAt: LocalDateTime,
                updatedAt: LocalDateTime,
            ): User =
                User(
                    id = id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
        }

        fun updateProfile(name: Name): User {
            val updated = this.copy(name = name, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.ProfileUpdated(
                    userId = this.id,
                    name = name.value,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun changePassword(encodedPassword: Password): User {
            val updated = this.copy(password = encodedPassword, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.PasswordChanged(
                    userId = this.id,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun addAddress(address: Address): User {
            val newAddresses =
                if (address.isDefault) {
                    addresses.map { it.update(isDefault = false) } + address
                } else {
                    if (addresses.isEmpty()) {
                        listOf(address.update(isDefault = true))
                    } else {
                        addresses + address
                    }
                }
            val updated = this.copy(addresses = newAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressAdded(
                    userId = this.id,
                    addressId = address.addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun updateAddress(
            addressId: AddressId,
            updatedAddress: Address,
        ): User {
            if (addressId != updatedAddress.addressId) {
                throw UserDomainException.Validation.InvalidAddressFormat(
                    "수정하려는 주소의 ID(${addressId.value})와 전달된 주소 데이터의 ID(${updatedAddress.addressId.value})가 일치하지 않습니다.",
                )
            }

            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            val newAddresses =
                if (updatedAddress.isDefault) {
                    addresses.map {
                        when {
                            it.addressId == addressId -> updatedAddress
                            else -> it.update(isDefault = false)
                        }
                    }
                } else {
                    val currentDefault = addresses.find { it.isDefault }
                    if (currentDefault?.addressId == addressId) {
                        val addressesWithoutOriginal = addresses.filter { it.addressId != addressId }
                        val updatedList = addressesWithoutOriginal + updatedAddress
                        if (updatedList.size > 1) {
                            val firstOther = updatedList.first { it.addressId != addressId }
                            updatedList.map { adr ->
                                if (adr.addressId == firstOther.addressId) adr.update(isDefault = true) else adr
                            }
                        } else {
                            listOf(updatedAddress.update(isDefault = true))
                        }
                    } else {
                        addresses.map { if (it.addressId == addressId) updatedAddress else it }
                    }
                }

            val ensuredAddresses =
                if (newAddresses.none { it.isDefault } && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressUpdated(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun removeAddress(addressId: AddressId): User {
            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            if (addresses.size == 1) {
                throw UserDomainException.Address.CannotRemoveLastAddress(
                    addressId = addressId.value.toString(),
                )
            }

            val newAddresses = addresses.filter { it.addressId != addressId }
            val ensuredAddresses =
                if (existingAddress.isDefault && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressRemoved(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        private fun copy(
            email: Email = this.email,
            password: Password = this.password,
            name: Name = this.name,
            addresses: List<Address> = this.addresses,
            createdAt: LocalDateTime = this.createdAt,
            updatedAt: LocalDateTime = this.updatedAt,
        ): User {
            val copiedUser =
                User(
                    id = this.id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
            return copiedUser
        }
    }

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/error/UserDomainErrorCodes.kt =====
package com.restaurant.domain.user.error

import com.restaurant.common.core.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-003", "비밀번호가 일치하지 않습니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-004", "주소를 찾을 수 없습니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-005", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-006", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-007", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-008", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_INPUT("USER-DOMAIN-009", "입력값이 유효하지 않습니다."),
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/event/UserEvent.kt =====
package com.restaurant.domain.user.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime

sealed class UserEvent(
    open val userId: UserId,
    override val eventId: String,
    override val occurredAt: LocalDateTime,
) : DomainEvent {
    override val aggregateId: String
        get() = userId.value.toString()
    override val aggregateType: String
        get() = User::class.java.simpleName

    data class Created(
        override val userId: UserId,
        val email: String,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class ProfileUpdated(
        override val userId: UserId,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class PasswordChanged(
        override val userId: UserId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressAdded(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressUpdated(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressRemoved(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/exception/UserDomainException.kt =====
package com.restaurant.domain.user.exception

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.DomainException
import com.restaurant.domain.user.error.UserDomainErrorCodes

// sealed class UserDomainException(...): DomainException(...) 제거

// 최상위 sealed class 는 marker 역할만 하거나, 공통 필드(message)만 가질 수 있음
sealed class UserDomainException(
    message: String,
) : DomainException(message) {
    // Rule 68, 73: 상위 클래스 DomainException의 abstract val errorCode를 override로 명시
    abstract override val errorCode: ErrorCode

    sealed class Validation(
        message: String,
        override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
    ) : UserDomainException(message) {
        data class InvalidEmailFormat(
            val email: String,
        ) : Validation("이메일 형식이 올바르지 않습니다: $email")

        data class InvalidPasswordFormat(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
        ) : Validation("비밀번호 형식이 올바르지 않습니다: $reason")

        data class InvalidNameFormat(
            val name: String,
        ) : Validation("이름 형식이 올바르지 않습니다: $name")

        data class InvalidAddressFormat(
            val reason: String,
        ) : Validation("주소 형식이 올바르지 않습니다: $reason")

        data class InvalidPhoneNumberFormat(
            val phoneNumber: String,
        ) : Validation("전화번호 형식이 올바르지 않습니다: $phoneNumber")
    }

    // 각 하위 sealed class 또는 data class 에서 errorCode 를 override
    sealed class User(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String,
            // Rule 68: errorCode 를 override 로 명시적 지정
            override val errorCode: ErrorCode = UserDomainErrorCodes.USER_NOT_FOUND,
        ) : User("사용자를 찾을 수 없습니다: $userId") // 생성자에서 message 전달

        data class DuplicateEmail(
            val email: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.DUPLICATE_EMAIL,
        ) : User("이미 등록된 이메일입니다: $email")

        data class InvalidCredentials(
            override val errorCode: ErrorCode = UserDomainErrorCodes.PASSWORD_MISMATCH,
        ) : User(errorCode.message) // ErrorCode의 기본 메시지 사용

        data class InvalidInput(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
        ) : User("잘못된 사용자 입력: $reason")
    }

    sealed class Address(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String, // 사용자 ID도 String으로 변경
            val addressId: String, // Long -> String (AddressId.value.toString())
            override val errorCode: ErrorCode = UserDomainErrorCodes.ADDRESS_NOT_FOUND,
        ) : Address("사용자($userId)의 주소($addressId)를 찾을 수 없습니다.")

        data class MaxLimitExceeded(
            val userId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
        ) : Address("사용자($userId)의 최대 주소 등록 개수를 초과했습니다.")

        data class DefaultAddressRemovalAttempt(
            val addressId: String, // Long -> String
            override val errorCode: ErrorCode = UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
        ) : Address("기본 주소($addressId)는 삭제할 수 없습니다.")

        data class CannotRemoveLastAddress(
            val addressId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
        ) : Address("마지막 주소($addressId)는 삭제할 수 없습니다.")
    }
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/model/Address.kt =====
package com.restaurant.domain.user.model

import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.vo.AddressId

data class Address
    private constructor(
        val addressId: AddressId,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    ) {
        init {
            if (street.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("도로명 주소는 비어있을 수 없습니다.")
            }
            if (zipCode.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("우편번호는 비어있을 수 없습니다.")
            }
        }

        companion object {
            fun create(
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean = false,
            ): Address =
                Address(
                    addressId = AddressId.generate(),
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )

            fun reconstitute(
                addressId: AddressId,
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean,
            ): Address =
                Address(
                    addressId = addressId,
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )
        }

        fun update(
            street: String = this.street,
            detail: String = this.detail,
            zipCode: String = this.zipCode,
            isDefault: Boolean = this.isDefault,
        ): Address =
            Address(
                addressId = this.addressId,
                street = street,
                detail = detail,
                zipCode = zipCode,
                isDefault = isDefault,
            )
    }

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/repository/UserRepository.kt =====
package com.restaurant.domain.user.repository

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId

interface UserRepository {
    fun save(user: User): User

    fun findById(id: UserId): User?

    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun delete(user: User)
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/AddressId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class AddressId private constructor(
    val value: UUID,
) {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun fromString(value: String): AddressId = AddressId(UUID.fromString(value))

        fun of(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Email.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Email private constructor(
    val value: String,
) {
    init {
        if (!value.matches(EMAIL_REGEX)) {
            throw UserDomainException.Validation.InvalidEmailFormat(value)
        }
    }

    companion object {
        private val EMAIL_REGEX = Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+$")

        fun of(value: String): Email = Email(value)
    }

    override fun toString(): String = value
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Name.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Name private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        fun of(name: String): Name = Name(name)
    }

    override fun toString(): String = value
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Password.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Password private constructor(
    val encodedValue: String,
) {
    init {
        if (encodedValue.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호 값(인코딩 또는 raw)은 비어있을 수 없습니다.")
        }
    }

    companion object {
        private const val MIN_RAW_LENGTH = 8

        fun validateRaw(rawPassword: String) {
            if (rawPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 비어있을 수 없습니다.")
            }
            if (rawPassword.length < MIN_RAW_LENGTH) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 최소 ${MIN_RAW_LENGTH}글자 이상이어야 합니다.")
            }
        }

        fun fromEncoded(encodedPassword: String): Password {
            if (encodedPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("인코딩된 비밀번호 값은 비어있을 수 없습니다.")
            }
            return Password(encodedPassword)
        }
    }

    override fun toString(): String = "********"
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/PhoneNumber.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class PhoneNumber private constructor(
    val value: String,
) {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^\\d{3}-\\d{3,4}-\\d{4}$")

        fun of(value: String): PhoneNumber = PhoneNumber(value)
    }

    override fun toString(): String = value
}

// ===== ./domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/UserId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class UserId private constructor(
    val value: UUID,
) {
    companion object {
        fun of(value: UUID): UserId = UserId(value)

        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromString(value: String): UserId = UserId(UUID.fromString(value))
    }

    override fun toString(): String = value.toString()
}

// ===== ./domains/user/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1"
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))
    implementation(project(":independent:outbox:application")) // OutboxEventRepository 사용을 위한 의존성 추가

    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.persistence:jakarta.persistence-api:3.1.0")
    implementation("org.mapstruct:mapstruct:1.6.3")

    // Avro & Kafka
    implementation("org.apache.avro:avro:1.11.3")
    implementation("io.confluent:kafka-avro-serializer:7.5.3")
    implementation("io.confluent:kafka-schema-registry-client:7.5.3")
    implementation("org.apache.kafka:kafka-clients")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// Avro 플러그인 설정
avro {
    isCreateSetters.set(false)
    fieldVisibility.set("PRIVATE")
    isCreateOptionalGetters.set(false)
    isGettersReturnOptional.set(false)
    outputCharacterEncoding.set("UTF-8")
    stringType.set("String")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    source(tasks.withType<com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask>().map { it.outputs })
}

tasks.named("compileKotlin") {
    dependsOn("generateAvroJava")
}

repositories {
    mavenCentral()
    maven {
        url = uri("https://packages.confluent.io/maven/")
    }
}

// ===== ./domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/AddressEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.util.UUID

@Entity
@Table(name = "user_addresses")
class AddressEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "address_id", nullable = false, unique = true) val addressId: UUID,
    @Column(nullable = false) val street: String,
    @Column val detail: String,
    @Column(name = "zip_code", nullable = false) val zipCode: String,
    @Column(name = "is_default", nullable = false) val isDefault: Boolean,
    @Version
    @Column(nullable = false)
    val version: Long = 0,
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AddressEntity

        // 도메인 ID로 비교
        return addressId == other.addressId
    }

    override fun hashCode(): Int {
        // 도메인 ID 기반 해시코드
        return addressId.hashCode()
    }

    override fun toString(): String =
        "AddressEntity(id=$id, addressId=$addressId, street='$street', detail='$detail', zipCode='$zipCode', isDefault=$isDefault, version=$version)"
}

// ===== ./domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/UserEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.LocalDateTime
import java.util.ArrayList
import java.util.UUID

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false) val email: String,
    @Column(nullable = false) val password: String,
    @Column(nullable = false) val name: String,
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime = LocalDateTime.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: LocalDateTime = LocalDateTime.now(),
    @Version
    @Column(nullable = false)
    val version: Long = 0,
) {
    // JPA 필드는 private으로 설정
    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    private var addressEntities: MutableList<AddressEntity> = ArrayList()

    // 주소 목록에 대한 불변 뷰 제공 (프로퍼티로 제공)
    val addresses: List<AddressEntity>
        get() = addressEntities.toList()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UserEntity

        if (id != other.id) return false
        if (email != other.email) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + email.hashCode()
        return result
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, email='$email', name='$name', createdAt=$createdAt, updatedAt=$updatedAt, addresses=${addressEntities.size}, version=$version)"
}

// ===== ./domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/AddressEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.infrastructure.user.entity.AddressEntity

// AddressEntity -> Address 변환
fun AddressEntity.toDomain(): Address {
    // val id = this.id ?: throw IllegalStateException("영속화된 AddressEntity의 ID는 null일 수 없습니다") // Long id 제거

    return Address.reconstitute(
        // id = id, // Long id 제거
        addressId = AddressId.of(this.addressId), // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
    )
}

// Address -> AddressEntity 변환 (UserEntity 참조 없이)
fun Address.toEntity(): AddressEntity =
    AddressEntity(
        id = null, // JPA가 Long ID를 관리하도록 null 전달 (기존 id 필드 사용 제거)
        addressId = this.addressId.value, // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
        user = null, // Will be set when added to UserEntity
        // version은 JPA가 관리하거나, 필요시 Domain 객체에서 전달받아 설정
    )

// ===== ./domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/UserEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import com.restaurant.infrastructure.user.entity.UserEntity

// UserEntity -> User 변환
fun UserEntity.toDomain(): User {
    // addresses는 Lazy Loading이므로 트랜잭션 경계 내에서만 접근해야 함
    val domainAddresses = this.addresses.map { it.toDomain() } // addresses getter is already List

    return User.reconstitute(
        id = UserId.of(this.domainId), // Use domainId for UserId
        email = Email.of(email),
        password = Password.fromEncoded(password),
        name = Name.of(name),
        addresses = domainAddresses,
        createdAt = createdAt,
        updatedAt = updatedAt,
    )
}

// User -> UserEntity 변환
fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            id = null, // Let JPA handle the Long ID generation
            domainId =
                this.id?.value
                    ?: throw IllegalArgumentException(
                        "User Domain ID cannot be null for entity conversion",
                    ), // Use UUID from Domain
            email = email.value,
            password = password.encodedValue,
            name = name.value,
            createdAt = createdAt,
            updatedAt = updatedAt,
        )
    // Set addresses manually, establishing the bidirectional link
    this.addresses.map { address ->
        // 람다 파라미터를 새 줄로 이동
        address.toEntity().apply { user = entity } // Set back-reference
    }
    // JPA Cascade 설정에 의존하여 저장하므로 별도 설정 불필요
    return entity
}

// ===== ./domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/SpringDataJpaUserRepository.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.infrastructure.user.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByDomainId(domainId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    fun existsByEmail(email: String): Boolean
}

// ===== ./domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/UserRepositoryImpl.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.infrastructure.user.avro.UserEventPayload
import com.restaurant.infrastructure.user.extensions.toDomain
import com.restaurant.infrastructure.user.extensions.toEntity
import org.apache.avro.io.EncoderFactory
import org.apache.avro.specific.SpecificDatumWriter
import org.springframework.stereotype.Repository
import java.io.ByteArrayOutputStream
import java.util.UUID
import com.restaurant.infrastructure.user.avro.Address as AvroAddress

@Repository
class UserRepositoryImpl(
    private val jpaRepository: SpringDataJpaUserRepository,
    private val outboxMessageRepository: OutboxMessageRepository,
) : UserRepository {
    override fun save(user: User): User {
        val domainEvents = user.getDomainEvents().toList()

        val entity = user.toEntity()
        val savedEntity = jpaRepository.save(entity)

        if (domainEvents.isNotEmpty()) {
            val aggregateId = user.id.value.toString()
            val aggregateType = "User"
            val correlationId = UUID.randomUUID().toString() // TODO: MDC에서 가져오기

            val outboxMessages =
                domainEvents.map { domainEvent ->
                    val avroPayload = createAvroPayload(user)
                    val payload = serializeAvroPayload(avroPayload)
                    val topic = resolveTopic(domainEvent)
                    val headers =
                        mapOf(
                            "correlationId" to correlationId,
                            "aggregateType" to aggregateType,
                            "aggregateId" to aggregateId,
                            "eventType" to domainEvent::class.java.simpleName,
                            "eventId" to UUID.randomUUID().toString(),
                        )
                    OutboxMessage(
                        payload = payload,
                        topic = topic,
                        headers = headers,
                    )
                }
            outboxMessageRepository.saveAll(outboxMessages)
        }

        user.clearDomainEvents()
        return savedEntity.toDomain()
    }

    override fun findById(id: UserId): User? = jpaRepository.findByDomainId(id.value)?.toDomain()

    override fun findByEmail(email: Email): User? = jpaRepository.findByEmail(email.value)?.toDomain()

    override fun existsByEmail(email: Email): Boolean = jpaRepository.existsByEmail(email.value)

    override fun delete(user: User) {
        jpaRepository.deleteByDomainId(user.id.value)
    }

    private fun createAvroPayload(user: User): UserEventPayload =
        UserEventPayload
            .newBuilder()
            .setUserId(user.id.value.toString())
            .setEmail(user.email.value)
            .setName(user.name.value)
            .setAddresses(
                user.addresses.map { address ->
                    AvroAddress
                        .newBuilder()
                        .setAddressId(address.id.value.toString())
                        .setZipCode(address.zipCode)
                        .setStreet(address.street)
                        .setDetail(address.detail)
                        .setIsDefault(address.isDefault)
                        .build()
                },
            ).build()

    private fun serializeAvroPayload(payload: UserEventPayload): ByteArray {
        val writer = SpecificDatumWriter(UserEventPayload::class.java)
        val out = ByteArrayOutputStream()
        val encoder = EncoderFactory.get().binaryEncoder(out, null)
        writer.write(payload, encoder)
        encoder.flush()
        out.close()
        return out.toByteArray()
    }

    private fun resolveTopic(event: DomainEvent): String {
        val environment = "dev" // TODO: 설정에서 가져오기
        val domain = "user"
        val eventType = "domain-event"
        val entity = "user"
        val version = "v1"
        return "$environment.$domain.$eventType.$entity.$version"
    }
}

// ===== ./domains/user/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.3.2")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserAddressCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1

// RegisterAddressRequestV1 -> RegisterAddressCommand 변환
fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// UpdateAddressRequestV1 -> UpdateAddressCommand 변환
fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1

// RegisterUserRequestV1 -> RegisterUserCommand 변환
fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
    )

// LoginRequestV1 -> LoginCommand 변환
fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

// UpdateProfileRequestV1 -> UpdateProfileCommand 변환
fun UpdateProfileRequestV1.toCommand(userId: String): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId,
        name = this.name,
    )

// ChangePasswordRequestV1 -> ChangePasswordCommand 변환
fun ChangePasswordRequestV1.toCommand(userId: String): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId,
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

// DeleteUserRequestV1 -> DeleteUserCommand 변환
fun DeleteUserRequestV1.toCommand(userId: String): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId,
        password = this.currentPassword,
    )

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserQueryRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.query.GetUserProfileQuery

// String (UUID) -> GetUserProfileQuery 변환
fun String.toGetUserProfileQuery(): GetUserProfileQuery =
    GetUserProfileQuery(
        userId = this,
    )

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/response/UserQueryResponseExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.response

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.presentation.user.v1.query.dto.response.AddressResponseV1
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1

// UserProfileDto -> UserProfileResponseV1 변환
fun UserProfileDto.toResponse(): UserProfileResponseV1 =
    UserProfileResponseV1(
        id = this.id,
        email = this.email,
        name = this.name,
        addresses = this.addresses.map { it.toResponse() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

// UserProfileDto.AddressDto -> AddressResponseV1 변환
fun UserProfileDto.AddressDto.toResponse(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// List<UserProfileDto.AddressDto> -> List<AddressResponseV1> 변환
fun List<UserProfileDto.AddressDto>.toResponse(): List<AddressResponseV1> = map { it.toResponse() }

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserAddressControllerV1.kt =====
package com.restaurant.presentation.user.v1.command

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.command.handler.DeleteAddressCommandHandler
import com.restaurant.application.user.command.handler.RegisterAddressCommandHandler
import com.restaurant.application.user.command.handler.UpdateAddressCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
@Tag(name = "주소 관리", description = "사용자의 배달 주소 등록, 수정, 삭제 API")
class UserAddressControllerV1(
    private val registerAddressCommandHandler: RegisterAddressCommandHandler,
    private val updateAddressCommandHandler: UpdateAddressCommandHandler,
    private val deleteAddressCommandHandler: DeleteAddressCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserAddressControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping
    @Operation(summary = "주소 등록", description = "사용자의 새로운 배달 주소를 등록합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "주소 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId)

        registerAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PutMapping("/{addressId}")
    @Operation(summary = "주소 수정", description = "등록된 배달 주소를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
        @Valid @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId, addressId)

        updateAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{addressId}")
    @Operation(summary = "주소 삭제", description = "등록된 배달 주소를 삭제합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = DeleteAddressCommand(userId, addressId)

        deleteAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 삭제되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }
}

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserCommandControllerV1.kt =====
package com.restaurant.presentation.user.v1.command
import com.restaurant.application.user.command.handler.UpdateProfileCommandHandler
import com.restaurant.application.user.handler.ChangePasswordCommandHandler
import com.restaurant.application.user.handler.DeleteUserCommandHandler
import com.restaurant.application.user.handler.LoginCommandHandler
import com.restaurant.application.user.handler.RegisterUserCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.presentation.user.v1.command.dto.response.LoginResponseV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 관리", description = "사용자 등록, 로그인, 프로필 관리 API")
class UserCommandControllerV1(
    private val registerUserCommandHandler: RegisterUserCommandHandler,
    private val loginCommandHandler: LoginCommandHandler,
    private val updateProfileCommandHandler: UpdateProfileCommandHandler,
    private val changePasswordCommandHandler: ChangePasswordCommandHandler,
    private val deleteUserCommandHandler: DeleteUserCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserCommandControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping("/register")
    @Operation(summary = "사용자 등록", description = "신규 사용자를 시스템에 등록합니다. 이메일, 이름, 비밀번호가 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "사용자 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "409",
                description = "이미 존재하는 이메일",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 등록 요청: email={}, correlationId={}", request.email, correlationId)

        // extension 함수 사용
        val userId = registerUserCommandHandler.handle(request.toCommand(), correlationId)

        log.info("사용자 등록 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자가 성공적으로 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "로그인", description = "이메일과 비밀번호로 로그인합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그인 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = LoginResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "로그인 실패 (이메일 또는 비밀번호 불일치)",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun login(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: LoginRequestV1,
    ): ResponseEntity<LoginResponseV1> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그인 요청: email={}, correlationId={}", request.email, correlationId)

        val loginResult = loginCommandHandler.handle(request.toCommand(), correlationId)

        log.info("로그인 성공: userId={}, correlationId={}", loginResult, correlationId)

        val response =
            LoginResponseV1(
                status = "SUCCESS",
                message = "로그인 성공",
                userId = loginResult,
                accessToken = "",
                refreshToken = "",
                correlationId = correlationId,
            )

        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(loginResult, correlationId)).withRel("user-profile"),
        )

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "프로필 수정", description = "사용자 프로필 정보를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateProfile(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("프로필 수정 요청: userId={}, correlationId={}", userId, correlationId)

        updateProfileCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("프로필 수정 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "프로필이 성공적으로 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "비밀번호 변경", description = "사용자 비밀번호를 변경합니다. 현재 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "비밀번호 변경 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "현재 비밀번호가 일치하지 않음",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun changePassword(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("비밀번호 변경 요청: userId={}, correlationId={}", userId, correlationId)

        changePasswordCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("비밀번호 변경 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "비밀번호가 성공적으로 변경되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "사용자 탈퇴", description = "사용자 계정을 삭제합니다. 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "사용자 탈퇴 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "비밀번호가 일치하지 않음",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 탈퇴 요청: userId={}, correlationId={}", userId, correlationId)

        deleteUserCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("사용자 탈퇴 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자 계정이 성공적으로 삭제되었습니다.",
                correlationId = correlationId,
            )

        return ResponseEntity.ok(response)
    }

    @PostMapping("/logout")
    @Operation(summary = "로그아웃", description = "현재 사용자 세션을 종료합니다. (토큰 기반 인증에서는 클라이언트 측 토큰 삭제로 처리)")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그아웃 요청 처리됨",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
        ],
    )
    fun logout(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그아웃 요청: correlationId={}", correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "로그아웃 요청이 처리되었습니다.",
                correlationId = correlationId,
            )
        response.add(
            linkTo(methodOn(UserCommandControllerV1::class.java).login(correlationId, LoginRequestV1("", ""))).withRel("login"),
        )

        return ResponseEntity.ok(response)
    }
}

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/ChangePasswordRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

// 주소 삭제 시 별도 요청 본문이 필요 없을 수 있으나, ktlint 규칙상 파일 생성
data class DeleteAddressRequestV1(
    // 필요한 필드가 있다면 추가
    val dummy: String? = null, // ktlint 회피용 임시 필드
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/LoginRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterUserRequestV1(
    @field:Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val password: String,
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateProfileRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/response/LoginResponseV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답")
data class LoginResponseV1(
    @Schema(description = "상태", example = "SUCCESS") val status: String,
    @Schema(description = "메시지", example = "로그인 성공") val message: String,
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val userId: String,
    @Schema(description = "액세스 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val accessToken: String,
    @Schema(description = "리프레시 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val refreshToken: String,
    @Schema(description = "상관 관계 ID", example = "correlationId-123") val correlationId: String,
) : RepresentationModel<LoginResponseV1>()

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/UserQueryControllerV1.kt =====
package com.restaurant.presentation.user.v1.query

import com.restaurant.application.user.handler.GetUserProfileQueryHandler
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.presentation.user.extensions.v1.response.toResponse
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 조회", description = "사용자 프로필 조회 API")
class UserQueryControllerV1(
    private val getUserProfileQueryHandler: GetUserProfileQueryHandler,
) {
    private val log = LoggerFactory.getLogger(UserQueryControllerV1::class.java)

    @GetMapping("/{userId}")
    @Operation(summary = "사용자 프로필 조회", description = "사용자 ID를 통해 프로필 정보를 조회합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 조회 성공",
                content = [Content(mediaType = "application/json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema =
                            io.swagger.v3.oas.annotations.media
                                .Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationId: String? = null,
    ): ResponseEntity<UserProfileResponseV1> {
        val finalCorrelationId =
            correlationId ?: java.util.UUID
                .randomUUID()
                .toString()
        log.debug("사용자 프로필 조회 요청, correlationId={}, userId={}", finalCorrelationId, userId)
        val query = GetUserProfileQuery(userId)
        val result = getUserProfileQueryHandler.handle(query, finalCorrelationId)
        val response = result.toResponse()
        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, finalCorrelationId)).withSelfRel(),
        )
        log.info("사용자 프로필 조회 성공, correlationId={}, userId={}", finalCorrelationId, userId)
        return ResponseEntity.ok(response)
    }
}

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/AddressResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

// ===== ./domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/UserProfileResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import java.time.LocalDateTime

@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: LocalDateTime,
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: LocalDateTime,
) : RepresentationModel<UserProfileResponseV1>()

// ===== ./independent/outbox/application/build.gradle.kts =====
plugins {
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(platform("org.springframework.boot:spring-boot-dependencies:3.3.2"))

    // Core dependencies
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.slf4j:slf4j-api:2.0.12")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.springframework:spring-tx")
    implementation("org.springframework:spring-web")
    implementation("org.springframework:spring-context")
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("jakarta.validation:jakarta.validation-api")

    // Test dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.mockito:mockito-core")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.2.1")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.springframework:spring-test")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
        jvmTarget = "21"
    }
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxPoller.kt =====
package com.restaurant.independent.outbox.application

import com.restaurant.independent.outbox.application.error.OutboxException
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.OutboxMessageSenderPort
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox 메시지를 주기적으로 폴링하여 처리하는 컴포넌트.
 */
@Component
class OutboxPoller(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSenderPort,
    @Value("\${outbox.polling.max-retries:3}")
    private val maxRetries: Int = 3,
    @Value("\${outbox.polling.batch-size:100}")
    private val batchSize: Int = 100,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * 대기 중인 메시지를 처리합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어합니다.
     */
    @Scheduled(fixedDelayString = "\${outbox.polling.interval:1000}")
    @Transactional
    fun pollMessages() {
        try {
            // PENDING 상태의 메시지를 조회하고 처리
            val messages = outboxMessageRepository.findByStatus(OutboxMessageStatus.PENDING, batchSize)
            messages.forEach { message ->
                try {
                    processMessage(message)
                } catch (e: Exception) {
                    handleMessageProcessingError(message, e)
                }
            }

            // 실패한 메시지 중 재시도 가능한 것들을 처리
            val failedMessages = outboxMessageRepository.findByStatus(OutboxMessageStatus.FAILED, batchSize)
            failedMessages.forEach { message ->
                try {
                    if (message.retryCount < maxRetries) {
                        processMessage(message)
                    } else {
                        // 최대 재시도 횟수를 초과한 메시지는 DEAD_LETTERED 상태로 변경
                        outboxMessageRepository.updateStatus(
                            id = message.id,
                            newStatus = OutboxMessageStatus.DEAD_LETTERED,
                        )
                        log.warn("Message ${message.id} marked as dead-lettered after ${message.retryCount} retries")
                    }
                } catch (e: Exception) {
                    handleMessageProcessingError(message, e)
                }
            }
        } catch (e: Exception) {
            log.error("Error during message polling", e)
            throw OutboxException.PollingException(
                message = "Failed to poll messages: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 단일 메시지를 처리합니다.
     */
    private fun processMessage(message: OutboxMessage) {
        try {
            // 메시지를 PROCESSING 상태로 변경
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.PROCESSING,
            )

            // Kafka로 메시지 전송
            outboxMessageSender.send(message)

            // 전송 성공 시 SENT 상태로 변경
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.SENT,
            )

            log.info("Successfully processed message ${message.id}")
        } catch (e: Exception) {
            log.error("Failed to process message ${message.id}", e)
            throw OutboxException.MessageSendException(
                message = "Failed to send message to Kafka: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 메시지 처리 오류를 처리합니다.
     */
    private fun handleMessageProcessingError(
        message: OutboxMessage,
        error: Exception,
    ) {
        try {
            // 실패 상태로 변경하고 재시도 횟수 증가
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.FAILED,
                incrementRetry = true,
            )

            if (message.retryCount >= maxRetries) {
                log.error(
                    "Max retry count ($maxRetries) exceeded for message ${message.id}",
                    error,
                )
                throw OutboxException.MaxRetriesExceededException(
                    message = "Max retry count ($maxRetries) exceeded for message ${message.id}",
                    cause = error,
                )
            }

            log.warn(
                "Failed to process message ${message.id}, will retry later. Current retry count: ${message.retryCount}",
                error,
            )
        } catch (e: Exception) {
            log.error("Error while handling message processing failure for message ${message.id}", e)
            throw e
        }
    }
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt =====
package com.restaurant.independent.outbox.application

import com.restaurant.independent.outbox.application.error.OutboxException
import com.restaurant.independent.outbox.application.event.OutboxDomainEvent
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox를 통해 도메인 이벤트를 발행하는 서비스.
 */
@Service
class OutboxService(
    private val outboxMessageRepository: OutboxMessageRepository,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * 단일 도메인 이벤트를 발행합니다.
     * @param event 발행할 도메인 이벤트
     * @return 저장된 Outbox 메시지
     */
    @Transactional
    fun publish(event: OutboxDomainEvent): OutboxMessage {
        try {
            val message = createOutboxMessage(event)
            return outboxMessageRepository.save(message)
        } catch (e: Exception) {
            log.error("Failed to publish domain event", e)
            throw OutboxException.MessageSaveException(
                message = "Failed to publish domain event: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 여러 도메인 이벤트를 발행합니다.
     * @param events 발행할 도메인 이벤트 목록
     * @return 저장된 Outbox 메시지 목록
     */
    @Transactional
    fun publishAll(events: List<OutboxDomainEvent>): List<OutboxMessage> {
        try {
            val messages = events.map { createOutboxMessage(it) }
            return outboxMessageRepository.saveAll(messages)
        } catch (e: Exception) {
            log.error("Failed to publish domain events", e)
            throw OutboxException.MessageSaveException(
                message = "Failed to publish domain events: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 도메인 이벤트를 Outbox 메시지로 변환합니다.
     */
    private fun createOutboxMessage(event: OutboxDomainEvent): OutboxMessage {
        try {
            return OutboxMessage(
                payload = event.payload,
                topic = event.topic,
                headers = buildHeaders(event),
            )
        } catch (e: Exception) {
            log.error("Failed to create outbox message from domain event", e)
            throw OutboxException.MessageSerializationException(
                message = "Failed to create outbox message from domain event: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 도메인 이벤트로부터 메시지 헤더를 생성합니다.
     */
    private fun buildHeaders(event: OutboxDomainEvent): Map<String, String> =
        mapOf(
            "eventId" to event.eventId.toString(),
            "aggregateType" to event.aggregateType,
            "aggregateId" to event.aggregateId,
            "eventType" to event.eventType,
            "eventVersion" to event.eventVersion,
        )
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/config/OutboxConfig.kt =====
package com.restaurant.independent.outbox.application.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import org.springframework.scheduling.annotation.EnableScheduling

/**
 * Outbox 모듈의 설정을 제공하는 설정 클래스.
 */
@Configuration
@EnableScheduling
@ConfigurationProperties(prefix = "outbox.polling")
class OutboxConfig {
    /**
     * 메시지 처리 배치 크기
     */
    var batchSize: Int = 100

    /**
     * 최대 재시도 횟수
     */
    var maxRetries: Int = 3

    /**
     * 대기 중인 메시지 폴링 간격 (밀리초)
     */
    var pendingMessagesInterval: Long = 5000

    /**
     * 실패한 메시지 폴링 간격 (밀리초)
     */
    var failedMessagesInterval: Long = 60000
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxErrorCode.kt =====
package com.restaurant.independent.outbox.application.error

import org.springframework.http.HttpStatus

/**
 * Outbox 모듈의 자체적인 에러 코드 정의
 * Rule 67, 80에 따라 common 모듈의 ErrorCode와 독립적으로 정의
 */
enum class OutboxErrorCode(
    val code: String,
    val message: String,
    val status: HttpStatus,
) {
    // Message 저장 관련 오류
    MESSAGE_SAVE_FAILED(
        code = "OUTBOX-001",
        message = "Failed to save outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),
    MESSAGE_SERIALIZATION_FAILED(
        code = "OUTBOX-002",
        message = "Failed to serialize outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),

    // Message 전송 관련 오류
    MESSAGE_SEND_FAILED(
        code = "OUTBOX-003",
        message = "Failed to send outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),
    MAX_RETRIES_EXCEEDED(
        code = "OUTBOX-004",
        message = "Maximum retry attempts exceeded for outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),

    // Polling 관련 오류
    POLLING_ERROR(
        code = "OUTBOX-005",
        message = "Error occurred during message polling",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),

    // 기타 시스템 오류
    UNEXPECTED_ERROR(
        code = "OUTBOX-999",
        message = "Unexpected error occurred in outbox processing",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxException.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Outbox 모듈의 자체적인 예외 클래스 정의
 * Rule 67, 68, 80에 따라 common 모듈의 예외와 독립적으로 정의
 */
sealed class OutboxException(
    message: String,
    cause: Throwable? = null,
    val errorCode: OutboxErrorCode,
) : RuntimeException(message, cause) {
    /**
     * 메시지 저장 실패 예외
     */
    class MessageSaveException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SAVE_FAILED,
        )

    /**
     * 메시지 직렬화 실패 예외
     */
    class MessageSerializationException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SERIALIZATION_FAILED,
        )

    /**
     * 메시지 전송 실패 예외
     */
    class MessageSendException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SEND_FAILED,
        )

    /**
     * 최대 재시도 횟수 초과 예외
     */
    class MaxRetriesExceededException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MAX_RETRIES_EXCEEDED,
        )

    /**
     * 메시지 폴링 실패 예외
     */
    class PollingException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.POLLING_ERROR,
        )

    /**
     * 예상치 못한 시스템 오류 예외
     */
    class UnexpectedErrorException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.UNEXPECTED_ERROR,
        )
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxStorageException.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Exception thrown when outbox message storage operations fail.
 * This is a module-specific exception that does not depend on any domain exceptions.
 */
class OutboxStorageException : RuntimeException {
    /**
     * Creates a new OutboxStorageException with the specified error message.
     *
     * @param message The error message
     */
    constructor(message: String) : super(message)

    /**
     * Creates a new OutboxStorageException with the specified error message and cause.
     *
     * @param message The error message
     * @param cause The underlying cause of the failure
     */
    constructor(message: String, cause: Throwable) : super(message, cause)
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxEventRepository.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.event.OutboxDomainEvent

interface OutboxEventRepository {
    fun save(
        events: List<OutboxDomainEvent>,
        aggregateType: String,
        aggregateId: String,
    )
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxMessageRepository.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.error.OutboxStorageException
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import java.util.UUID

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 * 이 인터페이스는 Outbox 메시지의 저장, 조회, 상태 업데이트 등의 작업을 정의합니다.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다.
     *
     * @param message 저장할 메시지
     * @return 저장된 메시지
     * @throws OutboxStorageException 저장 작업 실패 시
     */
    @Throws(OutboxStorageException::class)
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     * @return 저장된 메시지 목록
     * @throws OutboxStorageException 저장 작업 실패 시
     */
    @Throws(OutboxStorageException::class)
    fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage>

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: UUID): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어해야 합니다.
     *
     * @param status 조회할 메시지 상태
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다.
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID
     * @param newStatus 새로운 상태
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 시간 이전에 생성된 실패 상태의 메시지들을 조회합니다.
     *
     * @param maxRetries 최대 재시도 횟수
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxMessageSenderPort.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import java.util.concurrent.CompletableFuture

/**
 * Outbox 메시지 전송을 위한 Port 인터페이스 (Application Layer)
 */
interface OutboxMessageSenderPort {
    /**
     * 단일 Outbox 메시지를 비동기적으로 전송한다.
     * 실제 Kafka 전송 성공 여부는 Future를 통해 확인해야 한다.
     */
    fun send(message: OutboxMessage): CompletableFuture<*>
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxDomainEvent.kt =====
package com.restaurant.independent.outbox.application.port.model

/**
 * Outbox를 통해 발행될 도메인 이벤트를 나타내는 인터페이스.
 * 이 인터페이스는 도메인 이벤트가 Outbox 메시지로 변환되기 위해 필요한 정보를 정의합니다.
 */
interface OutboxDomainEvent {
    /**
     * 이벤트가 발행될 Kafka 토픽을 반환합니다.
     */
    fun getTopic(): String

    /**
     * 이벤트의 헤더 정보를 반환합니다.
     * 헤더에는 correlationId, aggregateType, aggregateId 등이 포함될 수 있습니다.
     */
    fun getHeaders(): Map<String, String>

    /**
     * 이벤트 페이로드를 바이트 배열로 직렬화하여 반환합니다.
     * 이 메서드는 이벤트 객체를 Avro 또는 다른 형식으로 직렬화해야 합니다.
     */
    fun serialize(): ByteArray
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxMessage.kt =====
package com.restaurant.independent.outbox.application.port.model

import java.time.Instant
import java.util.UUID

// Add import for OutboxMessageStatus
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus

/**
 * Represents a message to be stored in the outbox.
 * This is a technology-agnostic model that contains all necessary information for message delivery.
 *
 * @property id Unique identifier for the message
 * @property payload The serialized message content as a byte array
 * @property topic The target Kafka topic for message delivery
 * @property headers Additional message headers including correlationId, aggregateType, aggregateId, etc.
 * @property status Current status of the message
 * @property retryCount Number of retry attempts made
 * @property createdAt When the message was created
 * @property updatedAt When the message was last updated
 * @property lastAttemptTime When the last delivery attempt was made
 */
data class OutboxMessage(
    val id: UUID = UUID.randomUUID(),
    val payload: ByteArray,
    val topic: String,
    val headers: Map<String, String>,
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val createdAt: Instant = Instant.now(),
    val updatedAt: Instant = createdAt,
    val lastAttemptTime: Instant? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String =
        "OutboxMessage(" +
            "id=$id, " +
            "topic='$topic', " +
            "headers=$headers, " +
            "status=$status, " +
            "retryCount=$retryCount, " +
            "createdAt=$createdAt, " +
            "updatedAt=$updatedAt, " +
            "lastAttemptTime=$lastAttemptTime" +
            ")"
}

// ===== ./independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxMessageStatus.kt =====
package com.restaurant.independent.outbox.application.port.model

/**
 * Outbox 메시지의 상태를 나타내는 enum
 */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,
}

// ===== ./independent/outbox/build.gradle.kts =====
plugins {
    id("org.springframework.boot") version "3.3.2"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    kotlin("plugin.jpa") version "2.1.20"
    kotlin("plugin.allopen") version "2.1.20"
    // id("org.jlleitschuh.gradle.ktlint")
    // id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Avro plugin - Rule 106/109 위반으로 제거
}

group = "com.restaurant.independent"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
    // Confluent repository for Kafka Avro Serializer etc.
    maven { url = uri("https://packages.confluent.io/maven/") }
}

// Define versions
object Versions {
    const val SPRING_BOOT = "3.3.2"
    const val KOTLIN_LOGGING = "3.0.5"
    const val MOCKK = "1.13.9"
    const val SPRING_MOCKK = "4.0.2"
}

dependencies {
    // Spring Boot
    implementation(platform("org.springframework.boot:spring-boot-dependencies:${Versions.SPRING_BOOT}"))
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.kafka:spring-kafka")

    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")

    // Logging
    implementation("io.github.microutils:kotlin-logging-jvm:${Versions.KOTLIN_LOGGING}")

    // Project Dependencies

    // Spring Boot Starters
    // implementation("org.springframework.boot:spring-boot-starter-validation") // Optional, as per instructions

    // Kafka & Avro
    // implementation("org.apache.avro:avro:$avroVersion")
    // implementation("io.confluent:kafka-avro-serializer:$kafkaAvroSerializerVersion")
    // implementation("io.confluent:kafka-schema-registry-client:$kafkaAvroSerializerVersion")

    // MapStruct (Optional - for DTO mapping, e.g., DomainEvent <-> Avro)
    // implementation("org.mapstruct:mapstruct:$mapstructVersion")
    // kapt("org.mapstruct:mapstruct-processor:$mapstructVersion")

    // Database (Test scope)
    testRuntimeOnly("com.h2database:h2")

    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("io.mockk:mockk:${Versions.MOCKK}")
    testImplementation("org.springframework.kafka:spring-kafka-test")
    testImplementation("com.ninja-squad:springmockk:${Versions.SPRING_MOCKK}")
    testImplementation("org.testcontainers:junit-jupiter")
    testImplementation("org.testcontainers:kafka")
    // Add Kotest dependencies if needed
    // testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    // testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
}

kotlin {
    jvmToolchain(21)
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// Configure Kotlin JPA plugin
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

noArg {
    annotation("jakarta.persistence.Entity")
}

// If using MapStruct, configure kapt
// kapt {
//    correctErrorTypes = true
// }

// ===== ./independent/outbox/infrastructure/build.gradle.kts =====
plugins {
    id("org.springframework.boot") version "3.3.2"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    kotlin("plugin.jpa") version "2.1.20"
}

dependencies {
    implementation(project(":independent:outbox:application"))

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.kafka:spring-kafka-test")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs += "-Xjsr305=strict"
        jvmTarget = "21"
    }
}

tasks.bootJar {
    enabled = false
}

tasks.jar {
    enabled = true
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/config/KafkaConfig.kt =====
package com.restaurant.independent.outbox.infrastructure.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

@Configuration
class KafkaConfig {
    @Value("\${spring.kafka.bootstrap-servers}")
    private lateinit var bootstrapServers: String

    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> {
        val configProps =
            mapOf(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                // 추가 설정
                ProducerConfig.ACKS_CONFIG to "all",
                ProducerConfig.RETRIES_CONFIG to 3,
                ProducerConfig.RETRY_BACKOFF_MS_CONFIG to 1000,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1,
            )
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(producerFactory())
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/entity/OutboxEventEntity.kt =====
package com.restaurant.independent.outbox.infrastructure.entity

import jakarta.persistence.*
import java.time.Instant

/**
 * Outbox 이벤트 엔티티
 */
@Entity
@Table(name = "outbox_events")
class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val payload: ByteArray,
    @Column(nullable = false)
    val eventType: String,
    @Column(nullable = false)
    val topic: String,
    @Column(nullable = false)
    val aggregateType: String,
    @Column(nullable = false)
    val aggregateId: String,
    @Column(nullable = false)
    val correlationId: String,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    var status: OutboxEventStatus = OutboxEventStatus.PENDING,
    @Column(nullable = false)
    val createdAt: Instant = Instant.now(),
    @Column(nullable = true)
    var lastAttemptTime: Instant? = null,
    @Column(nullable = false)
    var retryCount: Int = 0,
    @Version
    var version: Long = 0,
) {
    enum class OutboxEventStatus {
        PENDING,
        PROCESSING,
        SENT,
        FAILED,
    }

    fun incrementRetryCount() {
        retryCount++
        lastAttemptTime = Instant.now()
    }

    fun markAsProcessing() {
        status = OutboxEventStatus.PROCESSING
        lastAttemptTime = Instant.now()
    }

    fun markAsSent() {
        status = OutboxEventStatus.SENT
        lastAttemptTime = Instant.now()
    }

    fun markAsFailed() {
        status = OutboxEventStatus.FAILED
        lastAttemptTime = Instant.now()
    }
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/entity/OutboxMessageEntity.kt =====
package com.restaurant.independent.outbox.infrastructure.entity

import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.Id
import jakarta.persistence.Table
import java.time.Instant
import java.util.UUID

/**
 * Outbox 메시지의 JPA 엔티티.
 */
@Entity
@Table(name = "outbox_messages")
data class OutboxMessageEntity(
    @Id
    val id: UUID,
    @Column(nullable = false)
    val payload: ByteArray,
    @Column(nullable = false)
    val topic: String,
    @Column(nullable = false)
    val headers: Map<String, String>,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    val status: OutboxMessageStatus,
    @Column(nullable = false)
    val retryCount: Int,
    @Column(nullable = false)
    val createdAt: Instant,
    @Column(nullable = false)
    val updatedAt: Instant,
    @Column(nullable = true)
    val lastAttemptTime: Instant?,
) {
    /**
     * ByteArray 필드가 포함된 엔티티의 equals/hashCode 구현
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessageEntity

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/extensions/OutboxMessageExtensions.kt =====
package com.restaurant.independent.outbox.infrastructure.extensions

import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity

/**
 * OutboxMessage 모델과 OutboxMessageEntity 간의 변환을 위한 확장 함수들.
 */

/**
 * Converts an OutboxMessage domain model to an OutboxMessageEntity.
 */
fun OutboxMessage.toEntity(): OutboxMessageEntity =
    OutboxMessageEntity(
        id = this.id,
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

/**
 * Converts an OutboxMessageEntity to an OutboxMessage domain model.
 */
fun OutboxMessageEntity.toDomainModel(): OutboxMessage =
    OutboxMessage(
        id = this.id,
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/kafka/KafkaConfig.kt =====
package com.restaurant.independent.outbox.infrastructure.kafka

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Outbox 모듈의 Kafka 설정을 제공하는 설정 클래스.
 */
@Configuration
class KafkaConfig(
    @Value("\${spring.kafka.bootstrap-servers}")
    private val bootstrapServers: String,
    @Value("\${spring.kafka.producer.client-id}")
    private val clientId: String,
    @Value("\${spring.kafka.producer.acks}")
    private val acks: String,
    @Value("\${spring.kafka.producer.retries}")
    private val retries: Int,
    @Value("\${spring.kafka.producer.batch-size}")
    private val batchSize: Int,
    @Value("\${spring.kafka.producer.buffer-memory}")
    private val bufferMemory: Long,
    @Value("\${spring.kafka.producer.compression-type}")
    private val compressionType: String,
    @Value("\${spring.kafka.producer.max-in-flight-requests-per-connection}")
    private val maxInFlightRequestsPerConnection: Int,
    @Value("\${spring.kafka.producer.max-request-size}")
    private val maxRequestSize: Int,
    @Value("\${spring.kafka.producer.request-timeout-ms}")
    private val requestTimeoutMs: Int,
    @Value("\${spring.kafka.producer.enable-idempotence}")
    private val enableIdempotence: Boolean,
) {
    /**
     * Kafka Producer 설정을 생성합니다.
     */
    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> =
        DefaultKafkaProducerFactory(
            mapOf<String, Any>(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.CLIENT_ID_CONFIG to clientId,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                ProducerConfig.ACKS_CONFIG to acks,
                ProducerConfig.RETRIES_CONFIG to retries,
                ProducerConfig.BATCH_SIZE_CONFIG to batchSize,
                ProducerConfig.BUFFER_MEMORY_CONFIG to bufferMemory,
                ProducerConfig.COMPRESSION_TYPE_CONFIG to compressionType,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to maxInFlightRequestsPerConnection,
                ProducerConfig.MAX_REQUEST_SIZE_CONFIG to maxRequestSize,
                ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG to requestTimeoutMs,
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG to enableIdempotence,
                ProducerConfig.TRANSACTION_TIMEOUT_CONFIG to 900000, // 15 minutes
                ProducerConfig.TRANSACTIONAL_ID_CONFIG to "outbox-tx-",
            ),
        )

    /**
     * KafkaTemplate을 생성합니다.
     */
    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(producerFactory())
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/kafka/OutboxMessageSender.kt =====
package com.restaurant.independent.outbox.infrastructure.kafka

import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity
import com.restaurant.independent.outbox.infrastructure.error.OutboxErrorCodes
import com.restaurant.independent.outbox.infrastructure.error.OutboxException
import org.apache.kafka.clients.producer.ProducerRecord
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Component

/**
 * Outbox 메시지를 Kafka로 전송하는 컴포넌트.
 */
@Component
class OutboxMessageSender(
    private val kafkaTemplate: KafkaTemplate<String, ByteArray>,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    fun send(message: OutboxMessageEntity) {
        try {
            val record =
                ProducerRecord(
                    message.topic,
                    null, // partition
                    message.aggregateId, // key
                    message.payload, // value
                    message.headers.map { (key, value) ->
                        org.apache.kafka.common.header.internals
                            .RecordHeader(key, value.toByteArray())
                    },
                )

            kafkaTemplate
                .send(record)
                .whenComplete { result, ex ->
                    if (ex != null) {
                        log.error("Failed to send message to Kafka. Topic: ${message.topic}, AggregateId: ${message.aggregateId}", ex)
                        throw OutboxException(
                            errorCode = OutboxErrorCodes.KAFKA_SEND_ERROR,
                            message = "Failed to send message to Kafka",
                            cause = ex,
                        )
                    } else {
                        log.debug("Successfully sent message to Kafka. Topic: ${message.topic}, Offset: ${result.recordMetadata.offset()}")
                    }
                }
        } catch (e: Exception) {
            log.error("Error while preparing Kafka message. Topic: ${message.topic}, AggregateId: ${message.aggregateId}", e)
            throw OutboxException(
                errorCode = OutboxErrorCodes.KAFKA_MESSAGE_PREPARATION_ERROR,
                message = "Error while preparing Kafka message",
                cause = e,
            )
        }
    }
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/persistence/OutboxMessageRepositoryImpl.kt =====
package com.restaurant.independent.outbox.infrastructure.persistence

import com.restaurant.independent.outbox.application.error.OutboxStorageException
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.independent.outbox.infrastructure.repository.JpaOutboxMessageRepository
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.util.UUID

/**
 * OutboxMessageRepository 인터페이스의 JPA 구현체.
 */
@Repository
class OutboxMessageRepositoryImpl(
    private val jpaOutboxMessageRepository: JpaOutboxMessageRepository,
) : OutboxMessageRepository {
    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        try {
            val entity = jpaOutboxMessageRepository.save(message.toEntity())
            return entity.toDomainModel()
        } catch (e: Exception) {
            throw OutboxStorageException(
                message = "Failed to save outbox message: ${e.message}",
                cause = e,
            )
        }
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage> {
        try {
            val entities = jpaOutboxMessageRepository.saveAll(messages.map { it.toEntity() })
            return entities.map { it.toDomainModel() }
        } catch (e: Exception) {
            throw OutboxStorageException(
                message = "Failed to save outbox messages: ${e.message}",
                cause = e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: UUID): OutboxMessage? =
        jpaOutboxMessageRepository
            .findById(id)
            .map { it.toDomainModel() }
            .orElse(null)

    @Transactional(readOnly = true)
    override fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatusOrderByCreatedAtAsc(status, limit)
            .map { it.toDomainModel() }

    @Transactional
    override fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        val entity =
            jpaOutboxMessageRepository.findById(id).orElse(null)
                ?: return null

        val updatedEntity =
            entity.copy(
                status = newStatus,
                retryCount = if (incrementRetry) entity.retryCount + 1 else entity.retryCount,
                updatedAt = Instant.now(),
                lastAttemptTime = if (newStatus == OutboxMessageStatus.PROCESSING) Instant.now() else entity.lastAttemptTime,
            )

        return jpaOutboxMessageRepository.save(updatedEntity).toDomainModel()
    }

    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> {
        val entities = jpaOutboxMessageRepository.findAndLockByStatus(status, limit)
        entities.forEach { entity ->
            entity.status = OutboxMessageStatus.PROCESSING
            entity.updatedAt = Instant.now()
            entity.lastAttemptTime = Instant.now()
        }
        return jpaOutboxMessageRepository.saveAll(entities).map { it.toDomainModel() }
    }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long = jpaOutboxMessageRepository.countByStatus(status)

    @Transactional
    override fun incrementRetryCount(id: UUID): OutboxMessage? {
        val entity = jpaOutboxMessageRepository.findByIdOrNull(id) ?: return null
        entity.retryCount++
        entity.updatedAt = Instant.now()
        entity.lastAttemptTime = Instant.now()
        return jpaOutboxMessageRepository.save(entity).toDomainModel()
    }

    @Transactional(readOnly = true)
    override fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
                OutboxMessageStatus.FAILED,
                maxRetries,
                limit,
            ).map { it.toDomainModel() }
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/persistence/SpringDataJpaOutboxMessageRepository.kt =====
package com.restaurant.independent.outbox.infrastructure.persistence

import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.util.UUID

/**
 * Outbox 메시지 엔티티를 위한 Spring Data JPA Repository 인터페이스.
 */
interface SpringDataJpaOutboxMessageRepository : JpaRepository<OutboxMessageEntity, UUID> {
    /**
     * 특정 상태의 메시지들을 조회합니다.
     */
    fun findByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessageEntity>

    /**
     * 특정 상태의 메시지들을 처리 중 상태로 업데이트하고 조회합니다.
     * 동시성 제어를 위해 SELECT FOR UPDATE SKIP LOCKED를 사용합니다.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        value = "SELECT o FROM OutboxMessageEntity o WHERE o.status = :status ORDER BY o.createdAt ASC LIMIT :limit",
        nativeQuery = false,
    )
    fun findAndLockByStatus(
        @Param("status") status: OutboxMessageStatus,
        @Param("limit") limit: Int,
    ): List<OutboxMessageEntity>

    /**
     * 특정 상태의 메시지 수를 조회합니다.
     */
    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 특정 재시도 횟수를 초과한 실패 상태의 메시지들을 조회합니다.
     */
    fun findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        retryCount: Int,
        limit: Int,
    ): List<OutboxMessageEntity>
}

// ===== ./independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/repository/OutboxEventJpaRepository.kt =====
package com.restaurant.independent.outbox.infrastructure.repository

import com.restaurant.independent.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.stereotype.Repository
import java.time.Instant

@Repository
interface OutboxEventJpaRepository : JpaRepository<OutboxEventEntity, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = 'PENDING' 
        AND (e.lastAttemptTime IS NULL OR e.lastAttemptTime < :cutoffTime)
        AND e.retryCount < :maxRetries
        ORDER BY e.createdAt ASC
        """,
    )
    fun findPendingEventsForProcessing(
        cutoffTime: Instant,
        maxRetries: Int,
    ): List<OutboxEventEntity>
}

// ===== ./settings.gradle.kts =====
rootProject.name = "restaurant"

include(
    // Common
    ":domains:common",

    // Account
    ":domains:account:domain",
    ":domains:account:application",
    ":domains:account:infrastructure",
    ":domains:account:presentation",
    ":domains:account:apps",

    // User
    ":domains:user:domain",
    ":domains:user:application",
    ":domains:user:infrastructure",
    ":domains:user:presentation",
    ":domains:user:apps",

    // Independent modules
    ":independent:outbox:application",
    ":independent:outbox:infrastructure",

    // Test
    ":test"
)

// include(":domains:restaurant:application")
// // include(":domains:restaurant:apps")
// include(":domains:restaurant:domain")
// include(":domains:restaurant:infrastructure")
// include(":domains:restaurant:presentation")

// include("libs:outbox")
// include("support:common")

// ===== ./temp/delivery/application/build.gradle.kts =====

// ===== ./temp/delivery/apps/build.gradle.kts =====

// ===== ./temp/delivery/apps/src/main/kotlin/com/restaurant/apps/delivery/DeliveryApplication.kt =====

// ===== ./temp/delivery/apps/src/main/kotlin/com/restaurant/apps/delivery/config/SwaggerConfig.kt =====

// ===== ./temp/delivery/domain/build.gradle.kts =====

// ===== ./temp/delivery/domain/src/main/kotlin/com/restaurant/domain/delivery/aggregate/Delivery.kt =====

// ===== ./temp/delivery/domain/src/main/kotlin/com/restaurant/domain/delivery/exception/DeliveryDomainException.kt =====

// ===== ./temp/delivery/domain/src/main/kotlin/com/restaurant/domain/delivery/repository/DeliveryRepository.kt =====

// ===== ./temp/delivery/infrastructure/build.gradle.kts =====

// ===== ./temp/delivery/infrastructure/src/main/kotlin/com/restaurant/infrastructure/delivery/entity/DeliveryEntity.kt =====

// ===== ./temp/delivery/infrastructure/src/main/kotlin/com/restaurant/infrastructure/delivery/repository/DeliveryRepositoryImpl.kt =====

// ===== ./temp/delivery/presentation/build.gradle.kts =====

// ===== ./temp/delivery/presentation/src/main/kotlin/com/restaurant/presentation/delivery/v1/command/DeliveryCommandControllerV1.kt =====

// ===== ./temp/delivery/presentation/src/main/kotlin/com/restaurant/presentation/delivery/v1/query/DeliveryQueryControllerV1.kt =====

// ===== ./temp/order/application/build.gradle.kts =====

// ===== ./temp/order/apps/build.gradle.kts =====

// ===== ./temp/order/apps/src/main/kotlin/com/restaurant/apps/order/OrderApplication.kt =====

// ===== ./temp/order/apps/src/main/kotlin/com/restaurant/apps/order/config/SwaggerConfig.kt =====

// ===== ./temp/order/domain/build.gradle.kts =====

// ===== ./temp/order/domain/src/main/kotlin/com/restaurant/domain/order/aggregate/Order.kt =====

// ===== ./temp/order/domain/src/main/kotlin/com/restaurant/domain/order/exception/OrderDomainException.kt =====

// ===== ./temp/order/domain/src/main/kotlin/com/restaurant/domain/order/repository/OrderRepository.kt =====

// ===== ./temp/order/infrastructure/build.gradle.kts =====

// ===== ./temp/order/infrastructure/src/main/kotlin/com/restaurant/infrastructure/order/entity/OrderEntity.kt =====

// ===== ./temp/order/infrastructure/src/main/kotlin/com/restaurant/infrastructure/order/repository/OrderRepositoryImpl.kt =====

// ===== ./temp/order/presentation/build.gradle.kts =====

// ===== ./temp/order/presentation/src/main/kotlin/com/restaurant/presentation/order/v1/command/OrderCommandControllerV1.kt =====

// ===== ./temp/order/presentation/src/main/kotlin/com/restaurant/presentation/order/v1/query/OrderQueryControllerV1.kt =====

// ===== ./temp/payment/application/build.gradle.kts =====

// ===== ./temp/payment/apps/build.gradle.kts =====

// ===== ./temp/payment/apps/src/main/kotlin/com/restaurant/apps/payment/PaymentApplication.kt =====

// ===== ./temp/payment/apps/src/main/kotlin/com/restaurant/apps/payment/config/SwaggerConfig.kt =====

// ===== ./temp/payment/domain/build.gradle.kts =====

// ===== ./temp/payment/domain/src/main/kotlin/com/restaurant/domain/payment/aggregate/Payment.kt =====

// ===== ./temp/payment/domain/src/main/kotlin/com/restaurant/domain/payment/exception/PaymentDomainException.kt =====

// ===== ./temp/payment/domain/src/main/kotlin/com/restaurant/domain/payment/repository/PaymentRepository.kt =====

// ===== ./temp/payment/infrastructure/build.gradle.kts =====

// ===== ./temp/payment/infrastructure/src/main/kotlin/com/restaurant/infrastructure/payment/entity/PaymentEntity.kt =====

// ===== ./temp/payment/infrastructure/src/main/kotlin/com/restaurant/infrastructure/payment/repository/PaymentRepositoryImpl.kt =====

// ===== ./temp/payment/presentation/build.gradle.kts =====

// ===== ./temp/payment/presentation/src/main/kotlin/com/restaurant/presentation/payment/v1/command/PaymentCommandControllerV1.kt =====

// ===== ./temp/payment/presentation/src/main/kotlin/com/restaurant/presentation/payment/v1/query/PaymentQueryControllerV1.kt =====

// ===== ./temp/restaurant/application/build.gradle.kts =====

// ===== ./temp/restaurant/apps/build.gradle.kts =====

// ===== ./temp/restaurant/apps/src/main/kotlin/com/restaurant/apps/restaurant/RestaurantApplication.kt =====

// ===== ./temp/restaurant/apps/src/main/kotlin/com/restaurant/apps/restaurant/config/SwaggerConfig.kt =====

// ===== ./temp/restaurant/domain/build.gradle.kts =====

// ===== ./temp/restaurant/domain/src/main/kotlin/com/restaurant/domain/restaurant/aggregate/Restaurant.kt =====

// ===== ./temp/restaurant/domain/src/main/kotlin/com/restaurant/domain/restaurant/exception/RestaurantDomainException.kt =====

// ===== ./temp/restaurant/domain/src/main/kotlin/com/restaurant/domain/restaurant/repository/RestaurantRepository.kt =====

// ===== ./temp/restaurant/infrastructure/build.gradle.kts =====

// ===== ./temp/restaurant/infrastructure/src/main/kotlin/com/restaurant/infrastructure/restaurant/entity/RestaurantEntity.kt =====

// ===== ./temp/restaurant/infrastructure/src/main/kotlin/com/restaurant/infrastructure/restaurant/repository/RestaurantRepositoryImpl.kt =====

// ===== ./temp/restaurant/presentation/build.gradle.kts =====

// ===== ./temp/restaurant/presentation/src/main/kotlin/com/restaurant/presentation/restaurant/v1/command/RestaurantCommandControllerV1.kt =====

// ===== ./temp/restaurant/presentation/src/main/kotlin/com/restaurant/presentation/restaurant/v1/query/RestaurantQueryControllerV1.kt =====

// ===== domains/common/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    // 필수 Spring Framework 의존성만 유지
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    // Swagger
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/error/ErrorCode.kt =====
package com.restaurant.common.core.error

/**
 * 모든 에러 코드가 구현해야 하는 공통 인터페이스
 */
interface ErrorCode {
    /**
     * 에러 코드 (예: USER-001)
     */
    val code: String

    /**
     * 에러 메시지
     */
    val message: String
}

abstract class BaseErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    companion object {
        fun fromCode(
            errorCodes: List<ErrorCode>,
            code: String?,
        ): ErrorCode? = errorCodes.find { it.code == code }
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/ApplicationException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 애플리케이션 레이어에서 발생하는 기술적 또는 외부 요인 관련 예외의 기본 클래스.
 */
abstract class ApplicationException(
    message: String,
    cause: Throwable? = null, // 원인 예외를 포함할 수 있도록 cause 추가
) : RuntimeException(message, cause) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/DomainException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 도메인 비즈니스 규칙 위반 시 발생하는 기본 예외 클래스.
 */
abstract class DomainException(
    message: String,
) : RuntimeException(message) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/InfrastructureException.kt =====
package com.restaurant.common.core.exception

open class InfrastructureException(
    message: String,
) : RuntimeException(message)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/PresentationException.kt =====
package com.restaurant.common.core.exception

open class PresentationException(
    message: String,
) : RuntimeException(message)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/query/QueryResult.kt =====
package com.restaurant.common.core.query

data class QueryResult<T>(
    val success: Boolean,
    val data: T? = null,
    val errorCode: String? = null,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/query/dto/CursorPageDto.kt =====
package com.restaurant.common.core.query.dto

/**
 * 커서 기반 페이징 결과 DTO
 *
 * @property items 조회된 아이템 목록
 * @property nextCursor 다음 페이지 요청 시 사용할 커서 (null이면 마지막 페이지)
 * @property hasNext 다음 페이지 존재 여부
 */
data class CursorPageDto<T>(
    val items: List<T>,
    val nextCursor: String?,
    val hasNext: Boolean,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt =====
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    protected fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }

    fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    fun clearDomainEvents() {
        domainEvents.clear()
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt =====
package com.restaurant.common.domain.event

import java.time.LocalDateTime

/**
 * 모든 도메인 이벤트가 구현해야 하는 공통 인터페이스.
 */
interface DomainEvent {
    /**
     * 이벤트가 발생한 Aggregate의 루트 엔티티 ID (UUID의 문자열 표현).
     */
    val aggregateId: String

    /**
     * 이벤트가 발생한 Aggregate의 타입 이름.
     */
    val aggregateType: String // 예: "User", "Order"

    /**
     * 이벤트 발생 시각.
     */
    val occurredAt: LocalDateTime

    /**
     * 이벤트 고유 ID.
     */
    val eventId: String
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/infrastructure/mapper/EntityMapper.kt =====
package com.restaurant.common.infrastructure.mapper

interface EntityMapper<D, E> {
    fun toEntity(domain: D): E

    fun toDomain(entity: E): D
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt =====
package com.restaurant.common.presentation

import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.common.core.exception.DomainException
import com.restaurant.common.core.exception.InfrastructureException
import com.restaurant.common.core.exception.PresentationException
import jakarta.validation.ConstraintViolationException
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.context.request.WebRequest
import java.net.URI
import java.time.Instant
import java.util.UUID

@ControllerAdvice
class GlobalExceptionHandler(
    @Value("\${app.problem.base-url:https://api.restaurant.com/problems}") private val problemBaseUrl: String,
) {
    private val log = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)

    /**
     * 에러 코드에 따른 HTTP 상태 코드 매핑
     */
    private fun determineHttpStatusFromCode(code: String): HttpStatus =
        when {
            // 인증/인가 관련 에러
            code.startsWith("AUTH-") -> HttpStatus.UNAUTHORIZED
            code.contains("-AUTH-") -> HttpStatus.UNAUTHORIZED
            code.contains("-FORBIDDEN-") -> HttpStatus.FORBIDDEN

            // 리소스 찾을 수 없음
            code.contains("-NOT-FOUND") -> HttpStatus.NOT_FOUND
            code.endsWith("-404") -> HttpStatus.NOT_FOUND

            // 중복/충돌
            code.contains("-DUPLICATE-") -> HttpStatus.CONFLICT
            code.contains("-CONFLICT-") -> HttpStatus.CONFLICT
            code.endsWith("-409") -> HttpStatus.CONFLICT

            // 유효성 검증 실패
            code.contains("-INVALID-") -> HttpStatus.BAD_REQUEST
            code.contains("-VALIDATION-") -> HttpStatus.BAD_REQUEST
            code.endsWith("-400") -> HttpStatus.BAD_REQUEST

            // 비즈니스 규칙 위반
            code.startsWith("BIZ-") -> HttpStatus.UNPROCESSABLE_ENTITY
            code.contains("-RULE-") -> HttpStatus.UNPROCESSABLE_ENTITY
            code.endsWith("-422") -> HttpStatus.UNPROCESSABLE_ENTITY

            // 시스템/인프라 에러
            code.startsWith("SYS-") -> HttpStatus.INTERNAL_SERVER_ERROR
            code.contains("-SYSTEM-") -> HttpStatus.INTERNAL_SERVER_ERROR
            code.endsWith("-500") -> HttpStatus.INTERNAL_SERVER_ERROR

            // 기본값
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }

    private fun createProblemDetail(
        status: HttpStatus,
        code: String,
        title: String,
        detail: String?,
        request: WebRequest,
    ): ProblemDetail {
        val correlationId = request.getHeader("X-Correlation-Id") ?: UUID.randomUUID().toString()
        return ProblemDetail.forStatus(status).apply {
            type = URI.create("$problemBaseUrl/${code.lowercase()}")
            this.title = title
            this.detail = detail ?: "오류가 발생했습니다."
            setProperty("errorCode", code)
            setProperty("timestamp", Instant.now().toString())
            setProperty("correlationId", correlationId)
        }
    }

    private fun getCorrelationId(request: WebRequest): String = request.getHeader("X-Correlation-Id") ?: "N/A"

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val code = ex.errorCode.code
        val status = determineHttpStatusFromCode(code)
        val title = ex.errorCode.message

        log.warn(
            "Domain Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(
        ex: ApplicationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val code = ex.errorCode.code
        val status = determineHttpStatusFromCode(code)
        val title = ex.errorCode.message

        log.error(
            "Application Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(InfrastructureException::class)
    fun handleInfrastructureException(
        ex: InfrastructureException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "INFRASTRUCTURE_ERROR"
        val title = "Infrastructure Error"
        val detail = ex.message ?: "인프라스트럭처 처리 중 오류가 발생했습니다."

        log.error(
            "Infrastructure Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(PresentationException::class)
    fun handlePresentationException(
        ex: PresentationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "PRESENTATION_ERROR"
        val title = "Presentation Error"
        val detail = ex.message ?: "프레젠테이션 처리 중 오류가 발생했습니다."

        log.warn(
            "Presentation Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(
        ex: MethodArgumentNotValidException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.bindingResult.fieldErrors.map {
                mapOf("field" to it.field, "reason" to (it.defaultMessage ?: "유효하지 않은 값입니다."))
            }
        log.warn(
            "Validation Exception Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams.toString(),
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(
        ex: ConstraintViolationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.constraintViolations.map {
                mapOf("field" to it.propertyPath.toString(), "reason" to it.message)
            }
        log.warn(
            "Constraint Violation Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleMessageNotReadableException(
        ex: HttpMessageNotReadableException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "MESSAGE_NOT_READABLE"
        val title = "Invalid Request Body"
        val detail = "요청 본문의 형식이 잘못되었거나 읽을 수 없습니다."
        log.warn(
            "Message Not Readable Exception Handled: correlationId={}, error={}",
            correlationId,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(
        ex: Exception,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "SYSTEM_ERROR"
        val title = "Internal Server Error"
        val detail = "서버에서 예상치 못한 오류가 발생했습니다."
        log.error(
            "Unhandled Exception: correlationId={}, error={}",
            correlationId,
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt =====
package com.restaurant.common.presentation.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "커맨드 실행 결과 응답")
data class CommandResultResponse(
    @field:Schema(description = "처리 상태", example = "SUCCESS", required = true)
    val status: String,
    @field:Schema(description = "결과 메시지", example = "처리가 성공적으로 완료되었습니다.", required = true)
    val message: String,
    @field:Schema(description = "상관 관계 ID", example = "123e4567-e89b-12d3-a456-426614174000", required = true)
    val correlationId: String,
) : RepresentationModel<CommandResultResponse>()

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/ValidationErrorResponse.kt =====
package com.restaurant.common.presentation.dto.response

import org.springframework.hateoas.RepresentationModel

data class ValidationErrorResponse(
    val type: String,
    val title: String,
    val detail: String,
    val errorCode: String,
    val timestamp: String,
    val correlationId: String?,
    val invalidParams: List<InvalidParam>,
) : RepresentationModel<ValidationErrorResponse>() {
    data class InvalidParam(
        val field: String,
        val reason: String,
    )
}

// ===== domains/user/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:infrastructure"))

    // Spring Boot 버전을 통일
    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-security:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.5")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/ChangePasswordCommand.kt =====
package com.restaurant.application.user.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteAddressCommand.kt =====
package com.restaurant.application.user.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteUserCommand.kt =====
package com.restaurant.application.user.command

data class DeleteUserCommand(
    val userId: String,
    val password: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/LoginCommand.kt =====
package com.restaurant.application.user.command

data class LoginCommand(
    val email: String,
    val password: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterAddressCommand.kt =====
package com.restaurant.application.user.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterUserCommand.kt =====
package com.restaurant.application.user.command

data class RegisterUserCommand(
    val email: String,
    val password: String,
    val name: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateAddressCommand.kt =====
package com.restaurant.application.user.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateProfileCommand.kt =====
package com.restaurant.application.user.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.dto.LoginResult
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): LoginResult {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (LoginResult 반환)
            val userId = user.id.value.toString()
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, userId)

            // 실제 구현에서는 JWT 토큰 생성 로직이 들어갈 것임
            return LoginResult(
                userId = userId,
                accessToken = "jwt.access.token.$userId", // 임시 구현
                refreshToken = "jwt.refresh.token.$userId", // 임시 구현
            )
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/LoginResult.kt =====
package com.restaurant.application.user.dto

import java.util.UUID

// 로그인 결과를 담는 데이터 클래스
data class LoginResult(
    val userId: String,
    val accessToken: String = UUID.randomUUID().toString(), // 임시 구현
    val refreshToken: String = UUID.randomUUID().toString(), // 임시 구현
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/UserProfileDto.kt =====
package com.restaurant.application.user.dto

import java.time.LocalDateTime

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val addresses: List<AddressDto> = emptyList(),
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime,
) {
    data class AddressDto(
        val id: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/error/UserApplicationErrorCode.kt =====
package com.restaurant.application.user.error

import com.restaurant.common.core.error.ErrorCode
import org.springframework.http.HttpStatus

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val status: HttpStatus,
    override val message: String,
) : ErrorCode {
    INVALID_INPUT("USER-APPLICATION-001", HttpStatus.BAD_REQUEST, "입력값이 유효하지 않습니다."),
    AUTHENTICATION_FAILED("USER-APPLICATION-002", HttpStatus.UNAUTHORIZED, "인증에 실패했습니다."), // 예시: JWT 토큰 검증 실패 등
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-003", HttpStatus.INTERNAL_SERVER_ERROR, "외부 서비스 호출에 실패했습니다."),
    SYSTEM_ERROR("USER-APPLICATION-999", HttpStatus.INTERNAL_SERVER_ERROR, "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/exception/UserApplicationException.kt =====
package com.restaurant.application.user.exception

import com.restaurant.application.user.error.UserApplicationErrorCode
import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException

sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    final override val message: String = errorCode.message,
) : ApplicationException(message) {
    data class InvalidInput(
        val details: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.INVALID_INPUT,
            if (details != null) "유효하지 않은 입력: $details" else UserApplicationErrorCode.INVALID_INPUT.message,
        )

    data class AuthenticationFailed(
        val reason: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.AUTHENTICATION_FAILED,
            if (reason != null) "인증 실패: $reason" else UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        )

    data class ExternalServiceError(
        val serviceName: String,
        val causeError: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR,
            "외부 서비스($serviceName) 호출 오류${causeError?.let { ": $it" } ?: ""}",
        )

    data class SystemError(
        val causeException: Throwable? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.SYSTEM_ERROR,
            "시스템 오류 발생${causeException?.message?.let { ": $it" } ?: ""}",
        )
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/extensions/UserDtoExtensions.kt =====
package com.restaurant.application.user.extensions

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.model.Address

/**
 * Domain 객체를 Application DTO로 변환하는 확장 함수들
 */

fun User.toUserProfileDto(): UserProfileDto =
    UserProfileDto(
        id = this.id.value.toString(),
        email = this.email.value,
        name = this.name.value,
        addresses = this.addresses.map { it.toAddressDto() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

fun Address.toAddressDto(): UserProfileDto.AddressDto =
    UserProfileDto.AddressDto(
        id = this.addressId.value.toString(),
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/ChangePasswordCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(ChangePasswordCommandHandler::class.java)

    @Transactional
    fun handle(
        command: ChangePasswordCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: Create VOs outside try-catch
        val userId = UserId.fromString(command.userId)
        Password.validateRaw(command.newPassword)
        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.fromEncoded(encodedNewPassword)

        log.debug("Attempting password change, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for password change, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 현재 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.currentPassword, user.password.encodedValue)) {
                log.warn("Password change failed: Current password mismatch, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("현재 비밀번호가 일치하지 않습니다.")
            }

            // 비밀번호 변경 (Aggregate 호출)
            val updatedUser = user.changePassword(newPasswordVo)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info("Password changed successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during password change, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during password change, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug("Attempting to delete address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address deletion, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 삭제 (Aggregate 호출 - 내부에서 AddressNotFound 예외 발생 가능)
            val updatedUser = user.removeAddress(addressId)
            // 저장
            userRepository.save(updatedUser)

            log.info("Address deleted successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                command.addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                command.userId,
                command.addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 삭제 커맨드 핸들러
 */
@Service
class DeleteUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to delete address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address deletion, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 주소 삭제 (Domain 로직 호출)
            val updatedUser = user.removeAddress(addressId)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address deleted successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(DeleteUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteUserCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        log.debug("Attempting user deletion, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for deletion, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Password mismatch during user deletion, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("비밀번호가 일치하지 않습니다.")
            }

            // 사용자 삭제
            userRepository.delete(user)

            log.info("User deleted successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user deletion, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 시스템 오류
            log.error(
                "System error during user deletion, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/GetUserProfileQueryHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.application.user.extensions.toUserProfileDto
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(GetUserProfileQueryHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        query: GetUserProfileQuery,
        correlationId: String? = null,
    ): UserProfileDto {
        val userId = UserId.fromString(query.userId)
        log.debug("Attempting to get user profile, correlationId={}, userId={}", correlationId, userId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for profile query, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = query.userId)
                }
        val result = user.toUserProfileDto()
        log.debug("User profile retrieved successfully, correlationId={}, userId={}", correlationId, userId)
        return result
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): String {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (UserId 반환)
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, user.id.value)
            return user.id.value.toString()
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(RegisterAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 및 Domain Entity 생성
        val userId = UserId.fromString(command.userId)
        val address =
            Address.create(
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )

        log.debug("Attempting to register address, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address registration, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 추가 (Aggregate 호출)
            val updatedUser = user.addAddress(address)
            // 저장 (Repository)
            userRepository.save(updatedUser)

            log.info("Address registered successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address registration, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address registration, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import org.slf4j.LoggerFactory
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(RegisterUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterUserCommand,
        correlationId: String? = null,
    ): String {
        // Validate raw inputs and create VOs
        val email = Email.of(command.email)
        Password.validateRaw(command.password) // Validate raw password
        val name = Name.of(command.name)
        // Encode password and create Password VO
        val encodedPassword = passwordEncoder.encode(command.password)
        val password = Password.fromEncoded(encodedPassword)

        // 이메일 중복 검증 (Domain 예외 사용)
        if (userRepository.existsByEmail(email)) {
            // DuplicateEmail 예외는 ErrorCode를 내부적으로 가지므로 별도 로깅 불필요
            throw UserDomainException.User.DuplicateEmail(email = command.email)
        }

        try {
            // 사용자 생성 (이제 User 인스턴스만 반환)
            val newUser = User.create(email, password, name)

            // 사용자 저장 (Repository에서 이벤트 처리)
            val savedUser = userRepository.save(newUser)

            log.info("사용자 등록 성공, correlationId={}, email={}", correlationId, email)
            // Return UUID instead of Long
            return savedUser.id.value.toString()
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user registration, correlationId={}, errorCode={}, error: {}",
                correlationId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (dive: DataIntegrityViolationException) {
            // Catch potential unique constraint violations not caught by existsByEmail (race condition)
            log.error(
                "Data integrity violation during user registration, possibly duplicate email race condition, correlationId={}, error: {}",
                correlationId,
                dive.message,
                dive,
            )
            // Re-throw as duplicate email domain exception
            throw UserDomainException.User.DuplicateEmail(email.value)
        } catch (e: Exception) {
            // 기타 예상치 못한 오류
            log.error("사용자 등록 중 시스템 오류 발생, correlationId={}, error={}", correlationId, e.message, e)
            // Wrap as ApplicationException.SystemError before propagating
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)
        val updatedAddressData =
            Address.reconstitute(
                addressId = addressId,
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )
        log.debug("Attempting to update address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for address update, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }
        val updatedUser = user.updateAddress(addressId, updatedAddressData)
        userRepository.save(updatedUser)
        log.info("Address updated successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateProfileCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        try {
            // 사용자 조회 - DomainException (NotFound)는 상위로 전파
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("사용자를 찾을 수 없음, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 프로필 업데이트
            val updatedUser = user.updateProfile(name = name)
            userRepository.save(updatedUser)

            log.info("사용자 프로필 업데이트 성공, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            log.error(
                "사용자 프로필 업데이트 중 도메인 오류 발생, correlationId={}, errorCode={}, error={}",
                correlationId,
                de.errorCode.code,
                de.message,
                de,
            )
            throw de
        } catch (e: Exception) {
            log.error(
                "사용자 프로필 업데이트 중 시스템 오류 발생, correlationId={}, error={}",
                correlationId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to update address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 업데이트할 주소 객체 생성
            val updatedAddress =
                Address.reconstitute(
                    addressId = addressId,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            // 현재 주소를 찾고 업데이트
            val updatedUser = user.updateAddress(addressId, updatedAddress)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address updated successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address update, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address update, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserProfileCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 프로필 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        log.debug(
            "Attempting to update user profile, correlationId={}, userId={}",
            correlationId,
            userId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for profile update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 프로필 업데이트 (Domain 로직 호출)
            val updatedUser = user.updateProfile(name)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "User profile updated successfully, correlationId={}, userId={}",
                correlationId,
                userId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during profile update, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during profile update, correlationId={}, userId={}, error={}",
                correlationId,
                userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/query/GetUserProfileQuery.kt =====
package com.restaurant.application.user.query

data class GetUserProfileQuery(
    val userId: String,
)

// ===== domains/user/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt =====
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories

@SpringBootApplication
@ComponentScan(
    basePackages = [
        "com.restaurant.apps.user",
        "com.restaurant.presentation.user",
        "com.restaurant.application.user",
        "com.restaurant.infrastructure.user",
        "com.restaurant.common",
        "com.restaurant.independent.outbox",
    ],
)
@EntityScan(
    basePackages = [
        "com.restaurant.infrastructure.user.entity",
        "com.restaurant.independent.outbox.infrastructure.entity",
    ],
)
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.infrastructure.user.repository",
        "com.restaurant.independent.outbox.infrastructure.persistence",
    ],
)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SecurityConfig.kt =====
package com.restaurant.apps.user.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() } // 개발 편의상 CSRF 비활성화 (실제 환경에서는 필요에 따라 설정)
            .authorizeHttpRequests { authz ->
                authz.anyRequest().permitAll() // 개발 편의상 모든 요청 허용 (실제 환경에서는 인증/인가 필요)
            }
        return http.build()
    }
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SwaggerConfig.kt =====
package com.restaurant.apps.user.config

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import org.springdoc.core.models.GroupedOpenApi
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfig {
    @Bean
    fun publicApi(): GroupedOpenApi =
        GroupedOpenApi
            .builder()
            .group("user-api-v1")
            .pathsToMatch("/api/v1/users/**")
            .build()

    @Bean
    fun springOpenAPI(): OpenAPI =
        OpenAPI()
            .info(
                Info()
                    .title("User Service API")
                    .description("User Service API Documentation")
                    .version("v1"),
            )
}

// ===== domains/user/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.
    // NOTE: HttpStatus 사용을 위해 임시로 추가 (Rule 10 위반 가능성)

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/aggregate/User.kt =====
package com.restaurant.domain.user.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.domain.user.event.UserEvent
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime
import java.util.UUID

data class User
    private constructor(
        val id: UserId,
        val email: Email,
        val password: Password,
        val name: Name,
        val addresses: List<Address> = emptyList(),
        val createdAt: LocalDateTime = LocalDateTime.now(),
        val updatedAt: LocalDateTime = LocalDateTime.now(),
    ) : AggregateRoot() {
        companion object {
            fun create(
                email: Email,
                password: Password,
                name: Name,
            ): User {
                val userId = UserId.generate()
                val user = User(id = userId, email = email, password = password, name = name)
                val event =
                    UserEvent.Created(
                        userId = userId,
                        email = email.value,
                        name = name.value,
                        eventId = UUID.randomUUID().toString(),
                        occurredAt = user.createdAt,
                    )
                user.addDomainEvent(event)
                return user
            }

            fun reconstitute(
                id: UserId,
                email: Email,
                password: Password,
                name: Name,
                addresses: List<Address> = emptyList(),
                createdAt: LocalDateTime,
                updatedAt: LocalDateTime,
            ): User =
                User(
                    id = id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
        }

        fun updateProfile(name: Name): User {
            val updated = this.copy(name = name, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.ProfileUpdated(
                    userId = this.id,
                    name = name.value,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun changePassword(encodedPassword: Password): User {
            val updated = this.copy(password = encodedPassword, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.PasswordChanged(
                    userId = this.id,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun addAddress(address: Address): User {
            val newAddresses =
                if (address.isDefault) {
                    addresses.map { it.update(isDefault = false) } + address
                } else {
                    if (addresses.isEmpty()) {
                        listOf(address.update(isDefault = true))
                    } else {
                        addresses + address
                    }
                }
            val updated = this.copy(addresses = newAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressAdded(
                    userId = this.id,
                    addressId = address.addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun updateAddress(
            addressId: AddressId,
            updatedAddress: Address,
        ): User {
            if (addressId != updatedAddress.addressId) {
                throw UserDomainException.Validation.InvalidAddressFormat(
                    "수정하려는 주소의 ID(${addressId.value})와 전달된 주소 데이터의 ID(${updatedAddress.addressId.value})가 일치하지 않습니다.",
                )
            }

            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            val newAddresses =
                if (updatedAddress.isDefault) {
                    addresses.map {
                        when {
                            it.addressId == addressId -> updatedAddress
                            else -> it.update(isDefault = false)
                        }
                    }
                } else {
                    val currentDefault = addresses.find { it.isDefault }
                    if (currentDefault?.addressId == addressId) {
                        val addressesWithoutOriginal = addresses.filter { it.addressId != addressId }
                        val updatedList = addressesWithoutOriginal + updatedAddress
                        if (updatedList.size > 1) {
                            val firstOther = updatedList.first { it.addressId != addressId }
                            updatedList.map { adr ->
                                if (adr.addressId == firstOther.addressId) adr.update(isDefault = true) else adr
                            }
                        } else {
                            listOf(updatedAddress.update(isDefault = true))
                        }
                    } else {
                        addresses.map { if (it.addressId == addressId) updatedAddress else it }
                    }
                }

            val ensuredAddresses =
                if (newAddresses.none { it.isDefault } && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressUpdated(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun removeAddress(addressId: AddressId): User {
            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            if (addresses.size == 1) {
                throw UserDomainException.Address.CannotRemoveLastAddress(
                    addressId = addressId.value.toString(),
                )
            }

            val newAddresses = addresses.filter { it.addressId != addressId }
            val ensuredAddresses =
                if (existingAddress.isDefault && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressRemoved(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        private fun copy(
            email: Email = this.email,
            password: Password = this.password,
            name: Name = this.name,
            addresses: List<Address> = this.addresses,
            createdAt: LocalDateTime = this.createdAt,
            updatedAt: LocalDateTime = this.updatedAt,
        ): User {
            val copiedUser =
                User(
                    id = this.id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
            return copiedUser
        }
    }

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/error/UserDomainErrorCodes.kt =====
package com.restaurant.domain.user.error

import com.restaurant.common.core.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-003", "비밀번호가 일치하지 않습니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-004", "주소를 찾을 수 없습니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-005", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-006", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-007", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-008", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_INPUT("USER-DOMAIN-009", "입력값이 유효하지 않습니다."),
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/event/UserEvent.kt =====
package com.restaurant.domain.user.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime

sealed class UserEvent(
    open val userId: UserId,
    override val eventId: String,
    override val occurredAt: LocalDateTime,
) : DomainEvent {
    override val aggregateId: String
        get() = userId.value.toString()
    override val aggregateType: String
        get() = User::class.java.simpleName

    data class Created(
        override val userId: UserId,
        val email: String,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class ProfileUpdated(
        override val userId: UserId,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class PasswordChanged(
        override val userId: UserId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressAdded(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressUpdated(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressRemoved(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/exception/UserDomainException.kt =====
package com.restaurant.domain.user.exception

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.DomainException
import com.restaurant.domain.user.error.UserDomainErrorCodes

// sealed class UserDomainException(...): DomainException(...) 제거

// 최상위 sealed class 는 marker 역할만 하거나, 공통 필드(message)만 가질 수 있음
sealed class UserDomainException(
    message: String,
) : DomainException(message) {
    // Rule 68, 73: 상위 클래스 DomainException의 abstract val errorCode를 override로 명시
    abstract override val errorCode: ErrorCode

    sealed class Validation(
        message: String,
        override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
    ) : UserDomainException(message) {
        data class InvalidEmailFormat(
            val email: String,
        ) : Validation("이메일 형식이 올바르지 않습니다: $email")

        data class InvalidPasswordFormat(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
        ) : Validation("비밀번호 형식이 올바르지 않습니다: $reason")

        data class InvalidNameFormat(
            val name: String,
        ) : Validation("이름 형식이 올바르지 않습니다: $name")

        data class InvalidAddressFormat(
            val reason: String,
        ) : Validation("주소 형식이 올바르지 않습니다: $reason")

        data class InvalidPhoneNumberFormat(
            val phoneNumber: String,
        ) : Validation("전화번호 형식이 올바르지 않습니다: $phoneNumber")
    }

    // 각 하위 sealed class 또는 data class 에서 errorCode 를 override
    sealed class User(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String,
            // Rule 68: errorCode 를 override 로 명시적 지정
            override val errorCode: ErrorCode = UserDomainErrorCodes.USER_NOT_FOUND,
        ) : User("사용자를 찾을 수 없습니다: $userId") // 생성자에서 message 전달

        data class DuplicateEmail(
            val email: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.DUPLICATE_EMAIL,
        ) : User("이미 등록된 이메일입니다: $email")

        data class InvalidCredentials(
            override val errorCode: ErrorCode = UserDomainErrorCodes.PASSWORD_MISMATCH,
        ) : User(errorCode.message) // ErrorCode의 기본 메시지 사용

        data class InvalidInput(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
        ) : User("잘못된 사용자 입력: $reason")
    }

    sealed class Address(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String, // 사용자 ID도 String으로 변경
            val addressId: String, // Long -> String (AddressId.value.toString())
            override val errorCode: ErrorCode = UserDomainErrorCodes.ADDRESS_NOT_FOUND,
        ) : Address("사용자($userId)의 주소($addressId)를 찾을 수 없습니다.")

        data class MaxLimitExceeded(
            val userId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
        ) : Address("사용자($userId)의 최대 주소 등록 개수를 초과했습니다.")

        data class DefaultAddressRemovalAttempt(
            val addressId: String, // Long -> String
            override val errorCode: ErrorCode = UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
        ) : Address("기본 주소($addressId)는 삭제할 수 없습니다.")

        data class CannotRemoveLastAddress(
            val addressId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
        ) : Address("마지막 주소($addressId)는 삭제할 수 없습니다.")
    }
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/model/Address.kt =====
package com.restaurant.domain.user.model

import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.vo.AddressId

data class Address
    private constructor(
        val addressId: AddressId,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    ) {
        init {
            if (street.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("도로명 주소는 비어있을 수 없습니다.")
            }
            if (zipCode.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("우편번호는 비어있을 수 없습니다.")
            }
        }

        companion object {
            fun create(
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean = false,
            ): Address =
                Address(
                    addressId = AddressId.generate(),
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )

            fun reconstitute(
                addressId: AddressId,
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean,
            ): Address =
                Address(
                    addressId = addressId,
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )
        }

        fun update(
            street: String = this.street,
            detail: String = this.detail,
            zipCode: String = this.zipCode,
            isDefault: Boolean = this.isDefault,
        ): Address =
            Address(
                addressId = this.addressId,
                street = street,
                detail = detail,
                zipCode = zipCode,
                isDefault = isDefault,
            )
    }

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/repository/UserRepository.kt =====
package com.restaurant.domain.user.repository

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId

interface UserRepository {
    fun save(user: User): User

    fun findById(id: UserId): User?

    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun delete(user: User)
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/AddressId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class AddressId private constructor(
    val value: UUID,
) {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun fromString(value: String): AddressId = AddressId(UUID.fromString(value))

        fun of(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Email.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Email private constructor(
    val value: String,
) {
    init {
        if (!value.matches(EMAIL_REGEX)) {
            throw UserDomainException.Validation.InvalidEmailFormat(value)
        }
    }

    companion object {
        private val EMAIL_REGEX = Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+$")

        fun of(value: String): Email = Email(value)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Name.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Name private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        fun of(name: String): Name = Name(name)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Password.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Password private constructor(
    val encodedValue: String,
) {
    init {
        if (encodedValue.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호 값(인코딩 또는 raw)은 비어있을 수 없습니다.")
        }
    }

    companion object {
        private const val MIN_RAW_LENGTH = 8

        fun validateRaw(rawPassword: String) {
            if (rawPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 비어있을 수 없습니다.")
            }
            if (rawPassword.length < MIN_RAW_LENGTH) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 최소 ${MIN_RAW_LENGTH}글자 이상이어야 합니다.")
            }
        }

        fun fromEncoded(encodedPassword: String): Password {
            if (encodedPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("인코딩된 비밀번호 값은 비어있을 수 없습니다.")
            }
            return Password(encodedPassword)
        }
    }

    override fun toString(): String = "********"
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/PhoneNumber.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class PhoneNumber private constructor(
    val value: String,
) {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^\\d{3}-\\d{3,4}-\\d{4}$")

        fun of(value: String): PhoneNumber = PhoneNumber(value)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/UserId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class UserId private constructor(
    val value: UUID,
) {
    companion object {
        fun of(value: UUID): UserId = UserId(value)

        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromString(value: String): UserId = UserId(UUID.fromString(value))
    }

    override fun toString(): String = value.toString()
}

// ===== domains/user/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1"
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))
    implementation(project(":independent:outbox:application")) // OutboxEventRepository 사용을 위한 의존성 추가

    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.persistence:jakarta.persistence-api:3.1.0")
    implementation("org.mapstruct:mapstruct:1.6.3")

    // Avro & Kafka
    implementation("org.apache.avro:avro:1.11.3")
    implementation("io.confluent:kafka-avro-serializer:7.5.3")
    implementation("io.confluent:kafka-schema-registry-client:7.5.3")
    implementation("org.apache.kafka:kafka-clients")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// Avro 플러그인 설정
avro {
    isCreateSetters.set(false)
    fieldVisibility.set("PRIVATE")
    isCreateOptionalGetters.set(false)
    isGettersReturnOptional.set(false)
    outputCharacterEncoding.set("UTF-8")
    stringType.set("String")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    source(tasks.withType<com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask>().map { it.outputs })
}

tasks.named("compileKotlin") {
    dependsOn("generateAvroJava")
}

repositories {
    mavenCentral()
    maven {
        url = uri("https://packages.confluent.io/maven/")
    }
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/AddressEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.util.UUID

@Entity
@Table(name = "user_addresses")
class AddressEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "address_id", nullable = false, unique = true) val addressId: UUID,
    @Column(nullable = false) val street: String,
    @Column val detail: String,
    @Column(name = "zip_code", nullable = false) val zipCode: String,
    @Column(name = "is_default", nullable = false) val isDefault: Boolean,
    @Version
    @Column(nullable = false)
    val version: Long = 0,
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AddressEntity

        // 도메인 ID로 비교
        return addressId == other.addressId
    }

    override fun hashCode(): Int {
        // 도메인 ID 기반 해시코드
        return addressId.hashCode()
    }

    override fun toString(): String =
        "AddressEntity(id=$id, addressId=$addressId, street='$street', detail='$detail', zipCode='$zipCode', isDefault=$isDefault, version=$version)"
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/UserEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.LocalDateTime
import java.util.ArrayList
import java.util.UUID

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false) val email: String,
    @Column(nullable = false) val password: String,
    @Column(nullable = false) val name: String,
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime = LocalDateTime.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: LocalDateTime = LocalDateTime.now(),
    @Version
    @Column(nullable = false)
    val version: Long = 0,
) {
    // JPA 필드는 private으로 설정
    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    private var addressEntities: MutableList<AddressEntity> = ArrayList()

    // 주소 목록에 대한 불변 뷰 제공 (프로퍼티로 제공)
    val addresses: List<AddressEntity>
        get() = addressEntities.toList()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UserEntity

        if (id != other.id) return false
        if (email != other.email) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + email.hashCode()
        return result
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, email='$email', name='$name', createdAt=$createdAt, updatedAt=$updatedAt, addresses=${addressEntities.size}, version=$version)"
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/AddressEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.infrastructure.user.entity.AddressEntity

// AddressEntity -> Address 변환
fun AddressEntity.toDomain(): Address {
    // val id = this.id ?: throw IllegalStateException("영속화된 AddressEntity의 ID는 null일 수 없습니다") // Long id 제거

    return Address.reconstitute(
        // id = id, // Long id 제거
        addressId = AddressId.of(this.addressId), // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
    )
}

// Address -> AddressEntity 변환 (UserEntity 참조 없이)
fun Address.toEntity(): AddressEntity =
    AddressEntity(
        id = null, // JPA가 Long ID를 관리하도록 null 전달 (기존 id 필드 사용 제거)
        addressId = this.addressId.value, // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
        user = null, // Will be set when added to UserEntity
        // version은 JPA가 관리하거나, 필요시 Domain 객체에서 전달받아 설정
    )

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/UserEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import com.restaurant.infrastructure.user.entity.UserEntity

// UserEntity -> User 변환
fun UserEntity.toDomain(): User {
    // addresses는 Lazy Loading이므로 트랜잭션 경계 내에서만 접근해야 함
    val domainAddresses = this.addresses.map { it.toDomain() } // addresses getter is already List

    return User.reconstitute(
        id = UserId.of(this.domainId), // Use domainId for UserId
        email = Email.of(email),
        password = Password.fromEncoded(password),
        name = Name.of(name),
        addresses = domainAddresses,
        createdAt = createdAt,
        updatedAt = updatedAt,
    )
}

// User -> UserEntity 변환
fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            id = null, // Let JPA handle the Long ID generation
            domainId =
                this.id?.value
                    ?: throw IllegalArgumentException(
                        "User Domain ID cannot be null for entity conversion",
                    ), // Use UUID from Domain
            email = email.value,
            password = password.encodedValue,
            name = name.value,
            createdAt = createdAt,
            updatedAt = updatedAt,
        )
    // Set addresses manually, establishing the bidirectional link
    this.addresses.map { address ->
        // 람다 파라미터를 새 줄로 이동
        address.toEntity().apply { user = entity } // Set back-reference
    }
    // JPA Cascade 설정에 의존하여 저장하므로 별도 설정 불필요
    return entity
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/SpringDataJpaUserRepository.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.infrastructure.user.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByDomainId(domainId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    fun existsByEmail(email: String): Boolean
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/UserRepositoryImpl.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.infrastructure.user.avro.UserEventPayload
import com.restaurant.infrastructure.user.extensions.toDomain
import com.restaurant.infrastructure.user.extensions.toEntity
import org.apache.avro.io.EncoderFactory
import org.apache.avro.specific.SpecificDatumWriter
import org.springframework.stereotype.Repository
import java.io.ByteArrayOutputStream
import java.util.UUID
import com.restaurant.infrastructure.user.avro.Address as AvroAddress

@Repository
class UserRepositoryImpl(
    private val jpaRepository: SpringDataJpaUserRepository,
    private val outboxMessageRepository: OutboxMessageRepository,
) : UserRepository {
    override fun save(user: User): User {
        val domainEvents = user.getDomainEvents().toList()

        val entity = user.toEntity()
        val savedEntity = jpaRepository.save(entity)

        if (domainEvents.isNotEmpty()) {
            val aggregateId = user.id.value.toString()
            val aggregateType = "User"
            val correlationId = UUID.randomUUID().toString() // TODO: MDC에서 가져오기

            val outboxMessages =
                domainEvents.map { domainEvent ->
                    val avroPayload = createAvroPayload(user)
                    val payload = serializeAvroPayload(avroPayload)
                    val topic = resolveTopic(domainEvent)
                    val headers =
                        mapOf(
                            "correlationId" to correlationId,
                            "aggregateType" to aggregateType,
                            "aggregateId" to aggregateId,
                            "eventType" to domainEvent::class.java.simpleName,
                            "eventId" to UUID.randomUUID().toString(),
                        )
                    OutboxMessage(
                        payload = payload,
                        topic = topic,
                        headers = headers,
                    )
                }
            outboxMessageRepository.saveAll(outboxMessages)
        }

        user.clearDomainEvents()
        return savedEntity.toDomain()
    }

    override fun findById(id: UserId): User? = jpaRepository.findByDomainId(id.value)?.toDomain()

    override fun findByEmail(email: Email): User? = jpaRepository.findByEmail(email.value)?.toDomain()

    override fun existsByEmail(email: Email): Boolean = jpaRepository.existsByEmail(email.value)

    override fun delete(user: User) {
        jpaRepository.deleteByDomainId(user.id.value)
    }

    private fun createAvroPayload(user: User): UserEventPayload =
        UserEventPayload
            .newBuilder()
            .setUserId(user.id.value.toString())
            .setEmail(user.email.value)
            .setName(user.name.value)
            .setAddresses(
                user.addresses.map { address ->
                    AvroAddress
                        .newBuilder()
                        .setAddressId(address.id.value.toString())
                        .setZipCode(address.zipCode)
                        .setStreet(address.street)
                        .setDetail(address.detail)
                        .setIsDefault(address.isDefault)
                        .build()
                },
            ).build()

    private fun serializeAvroPayload(payload: UserEventPayload): ByteArray {
        val writer = SpecificDatumWriter(UserEventPayload::class.java)
        val out = ByteArrayOutputStream()
        val encoder = EncoderFactory.get().binaryEncoder(out, null)
        writer.write(payload, encoder)
        encoder.flush()
        out.close()
        return out.toByteArray()
    }

    private fun resolveTopic(event: DomainEvent): String {
        val environment = "dev" // TODO: 설정에서 가져오기
        val domain = "user"
        val eventType = "domain-event"
        val entity = "user"
        val version = "v1"
        return "$environment.$domain.$eventType.$entity.$version"
    }
}

// ===== domains/user/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-web:3.3.2")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.3.2")
    implementation("org.slf4j:slf4j-api:2.0.13")
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas:3.3.2")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.3.2")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserAddressCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1

// RegisterAddressRequestV1 -> RegisterAddressCommand 변환
fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// UpdateAddressRequestV1 -> UpdateAddressCommand 변환
fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1

// RegisterUserRequestV1 -> RegisterUserCommand 변환
fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
    )

// LoginRequestV1 -> LoginCommand 변환
fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

// UpdateProfileRequestV1 -> UpdateProfileCommand 변환
fun UpdateProfileRequestV1.toCommand(userId: String): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId,
        name = this.name,
    )

// ChangePasswordRequestV1 -> ChangePasswordCommand 변환
fun ChangePasswordRequestV1.toCommand(userId: String): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId,
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

// DeleteUserRequestV1 -> DeleteUserCommand 변환
fun DeleteUserRequestV1.toCommand(userId: String): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId,
        password = this.currentPassword,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserQueryRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.query.GetUserProfileQuery

// String (UUID) -> GetUserProfileQuery 변환
fun String.toGetUserProfileQuery(): GetUserProfileQuery =
    GetUserProfileQuery(
        userId = this,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/response/UserQueryResponseExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.response

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.presentation.user.v1.query.dto.response.AddressResponseV1
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1

// UserProfileDto -> UserProfileResponseV1 변환
fun UserProfileDto.toResponse(): UserProfileResponseV1 =
    UserProfileResponseV1(
        id = this.id,
        email = this.email,
        name = this.name,
        addresses = this.addresses.map { it.toResponse() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

// UserProfileDto.AddressDto -> AddressResponseV1 변환
fun UserProfileDto.AddressDto.toResponse(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// List<UserProfileDto.AddressDto> -> List<AddressResponseV1> 변환
fun List<UserProfileDto.AddressDto>.toResponse(): List<AddressResponseV1> = map { it.toResponse() }

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserAddressControllerV1.kt =====
package com.restaurant.presentation.user.v1.command

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.command.handler.DeleteAddressCommandHandler
import com.restaurant.application.user.command.handler.RegisterAddressCommandHandler
import com.restaurant.application.user.command.handler.UpdateAddressCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
@Tag(name = "주소 관리", description = "사용자의 배달 주소 등록, 수정, 삭제 API")
class UserAddressControllerV1(
    private val registerAddressCommandHandler: RegisterAddressCommandHandler,
    private val updateAddressCommandHandler: UpdateAddressCommandHandler,
    private val deleteAddressCommandHandler: DeleteAddressCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserAddressControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping
    @Operation(summary = "주소 등록", description = "사용자의 새로운 배달 주소를 등록합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "주소 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId)

        registerAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PutMapping("/{addressId}")
    @Operation(summary = "주소 수정", description = "등록된 배달 주소를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
        @Valid @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId, addressId)

        updateAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{addressId}")
    @Operation(summary = "주소 삭제", description = "등록된 배달 주소를 삭제합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = DeleteAddressCommand(userId, addressId)

        deleteAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 삭제되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserCommandControllerV1.kt =====
package com.restaurant.presentation.user.v1.command
import com.restaurant.application.user.command.handler.UpdateProfileCommandHandler
import com.restaurant.application.user.handler.ChangePasswordCommandHandler
import com.restaurant.application.user.handler.DeleteUserCommandHandler
import com.restaurant.application.user.handler.LoginCommandHandler
import com.restaurant.application.user.handler.RegisterUserCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.presentation.user.v1.command.dto.response.LoginResponseV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 관리", description = "사용자 등록, 로그인, 프로필 관리 API")
class UserCommandControllerV1(
    private val registerUserCommandHandler: RegisterUserCommandHandler,
    private val loginCommandHandler: LoginCommandHandler,
    private val updateProfileCommandHandler: UpdateProfileCommandHandler,
    private val changePasswordCommandHandler: ChangePasswordCommandHandler,
    private val deleteUserCommandHandler: DeleteUserCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserCommandControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping("/register")
    @Operation(summary = "사용자 등록", description = "신규 사용자를 시스템에 등록합니다. 이메일, 이름, 비밀번호가 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "사용자 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "409",
                description = "이미 존재하는 이메일",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 등록 요청: email={}, correlationId={}", request.email, correlationId)

        // extension 함수 사용
        val userId = registerUserCommandHandler.handle(request.toCommand(), correlationId)

        log.info("사용자 등록 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자가 성공적으로 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "로그인", description = "이메일과 비밀번호로 로그인합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그인 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = LoginResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "로그인 실패 (이메일 또는 비밀번호 불일치)",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun login(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: LoginRequestV1,
    ): ResponseEntity<LoginResponseV1> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그인 요청: email={}, correlationId={}", request.email, correlationId)

        val loginResult = loginCommandHandler.handle(request.toCommand(), correlationId)

        log.info("로그인 성공: userId={}, correlationId={}", loginResult, correlationId)

        val response =
            LoginResponseV1(
                status = "SUCCESS",
                message = "로그인 성공",
                userId = loginResult,
                accessToken = "",
                refreshToken = "",
                correlationId = correlationId,
            )

        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(loginResult, correlationId)).withRel("user-profile"),
        )

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "프로필 수정", description = "사용자 프로필 정보를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateProfile(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("프로필 수정 요청: userId={}, correlationId={}", userId, correlationId)

        updateProfileCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("프로필 수정 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "프로필이 성공적으로 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "비밀번호 변경", description = "사용자 비밀번호를 변경합니다. 현재 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "비밀번호 변경 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "현재 비밀번호가 일치하지 않음",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun changePassword(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("비밀번호 변경 요청: userId={}, correlationId={}", userId, correlationId)

        changePasswordCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("비밀번호 변경 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "비밀번호가 성공적으로 변경되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "사용자 탈퇴", description = "사용자 계정을 삭제합니다. 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "사용자 탈퇴 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "비밀번호가 일치하지 않음",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 탈퇴 요청: userId={}, correlationId={}", userId, correlationId)

        deleteUserCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("사용자 탈퇴 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자 계정이 성공적으로 삭제되었습니다.",
                correlationId = correlationId,
            )

        return ResponseEntity.ok(response)
    }

    @PostMapping("/logout")
    @Operation(summary = "로그아웃", description = "현재 사용자 세션을 종료합니다. (토큰 기반 인증에서는 클라이언트 측 토큰 삭제로 처리)")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그아웃 요청 처리됨",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
        ],
    )
    fun logout(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그아웃 요청: correlationId={}", correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "로그아웃 요청이 처리되었습니다.",
                correlationId = correlationId,
            )
        response.add(
            linkTo(methodOn(UserCommandControllerV1::class.java).login(correlationId, LoginRequestV1("", ""))).withRel("login"),
        )

        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/ChangePasswordRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

// 주소 삭제 시 별도 요청 본문이 필요 없을 수 있으나, ktlint 규칙상 파일 생성
data class DeleteAddressRequestV1(
    // 필요한 필드가 있다면 추가
    val dummy: String? = null, // ktlint 회피용 임시 필드
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/LoginRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterUserRequestV1(
    @field:Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val password: String,
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateProfileRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/response/LoginResponseV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답")
data class LoginResponseV1(
    @Schema(description = "상태", example = "SUCCESS") val status: String,
    @Schema(description = "메시지", example = "로그인 성공") val message: String,
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val userId: String,
    @Schema(description = "액세스 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val accessToken: String,
    @Schema(description = "리프레시 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val refreshToken: String,
    @Schema(description = "상관 관계 ID", example = "correlationId-123") val correlationId: String,
) : RepresentationModel<LoginResponseV1>()

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/UserQueryControllerV1.kt =====
package com.restaurant.presentation.user.v1.query

import com.restaurant.application.user.handler.GetUserProfileQueryHandler
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.presentation.user.extensions.v1.response.toResponse
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 조회", description = "사용자 프로필 조회 API")
class UserQueryControllerV1(
    private val getUserProfileQueryHandler: GetUserProfileQueryHandler,
) {
    private val log = LoggerFactory.getLogger(UserQueryControllerV1::class.java)

    @GetMapping("/{userId}")
    @Operation(summary = "사용자 프로필 조회", description = "사용자 ID를 통해 프로필 정보를 조회합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 조회 성공",
                content = [Content(mediaType = "application/json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema =
                            io.swagger.v3.oas.annotations.media
                                .Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationId: String? = null,
    ): ResponseEntity<UserProfileResponseV1> {
        val finalCorrelationId =
            correlationId ?: java.util.UUID
                .randomUUID()
                .toString()
        log.debug("사용자 프로필 조회 요청, correlationId={}, userId={}", finalCorrelationId, userId)
        val query = GetUserProfileQuery(userId)
        val result = getUserProfileQueryHandler.handle(query, finalCorrelationId)
        val response = result.toResponse()
        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, finalCorrelationId)).withSelfRel(),
        )
        log.info("사용자 프로필 조회 성공, correlationId={}, userId={}", finalCorrelationId, userId)
        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/AddressResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/UserProfileResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import java.time.LocalDateTime

@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: LocalDateTime,
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: LocalDateTime,
) : RepresentationModel<UserProfileResponseV1>()

// ===== independent/outbox/application/build.gradle.kts =====
plugins {
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(platform("org.springframework.boot:spring-boot-dependencies:3.3.2"))

    // Core dependencies
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.slf4j:slf4j-api:2.0.12")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.springframework:spring-tx")
    implementation("org.springframework:spring-web")
    implementation("org.springframework:spring-context")
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("jakarta.validation:jakarta.validation-api")

    // Test dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
    testImplementation("org.mockito:mockito-core")
    testImplementation("org.mockito.kotlin:mockito-kotlin:5.2.1")
    testImplementation("org.assertj:assertj-core:3.25.3")
    testImplementation("org.springframework:spring-test")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
        jvmTarget = "21"
    }
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxPoller.kt =====
package com.restaurant.independent.outbox.application

import com.restaurant.independent.outbox.application.error.OutboxException
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.OutboxMessageSenderPort
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox 메시지를 주기적으로 폴링하여 처리하는 컴포넌트.
 */
@Component
class OutboxPoller(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSenderPort,
    @Value("\${outbox.polling.max-retries:3}")
    private val maxRetries: Int = 3,
    @Value("\${outbox.polling.batch-size:100}")
    private val batchSize: Int = 100,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * 대기 중인 메시지를 처리합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어합니다.
     */
    @Scheduled(fixedDelayString = "\${outbox.polling.interval:1000}")
    @Transactional
    fun pollMessages() {
        try {
            // PENDING 상태의 메시지를 조회하고 처리
            val messages = outboxMessageRepository.findByStatus(OutboxMessageStatus.PENDING, batchSize)
            messages.forEach { message ->
                try {
                    processMessage(message)
                } catch (e: Exception) {
                    handleMessageProcessingError(message, e)
                }
            }

            // 실패한 메시지 중 재시도 가능한 것들을 처리
            val failedMessages = outboxMessageRepository.findByStatus(OutboxMessageStatus.FAILED, batchSize)
            failedMessages.forEach { message ->
                try {
                    if (message.retryCount < maxRetries) {
                        processMessage(message)
                    } else {
                        // 최대 재시도 횟수를 초과한 메시지는 DEAD_LETTERED 상태로 변경
                        outboxMessageRepository.updateStatus(
                            id = message.id,
                            newStatus = OutboxMessageStatus.DEAD_LETTERED,
                        )
                        log.warn("Message ${message.id} marked as dead-lettered after ${message.retryCount} retries")
                    }
                } catch (e: Exception) {
                    handleMessageProcessingError(message, e)
                }
            }
        } catch (e: Exception) {
            log.error("Error during message polling", e)
            throw OutboxException.PollingException(
                message = "Failed to poll messages: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 단일 메시지를 처리합니다.
     */
    private fun processMessage(message: OutboxMessage) {
        try {
            // 메시지를 PROCESSING 상태로 변경
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.PROCESSING,
            )

            // Kafka로 메시지 전송
            outboxMessageSender.send(message)

            // 전송 성공 시 SENT 상태로 변경
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.SENT,
            )

            log.info("Successfully processed message ${message.id}")
        } catch (e: Exception) {
            log.error("Failed to process message ${message.id}", e)
            throw OutboxException.MessageSendException(
                message = "Failed to send message to Kafka: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 메시지 처리 오류를 처리합니다.
     */
    private fun handleMessageProcessingError(
        message: OutboxMessage,
        error: Exception,
    ) {
        try {
            // 실패 상태로 변경하고 재시도 횟수 증가
            outboxMessageRepository.updateStatus(
                id = message.id,
                newStatus = OutboxMessageStatus.FAILED,
                incrementRetry = true,
            )

            if (message.retryCount >= maxRetries) {
                log.error(
                    "Max retry count ($maxRetries) exceeded for message ${message.id}",
                    error,
                )
                throw OutboxException.MaxRetriesExceededException(
                    message = "Max retry count ($maxRetries) exceeded for message ${message.id}",
                    cause = error,
                )
            }

            log.warn(
                "Failed to process message ${message.id}, will retry later. Current retry count: ${message.retryCount}",
                error,
            )
        } catch (e: Exception) {
            log.error("Error while handling message processing failure for message ${message.id}", e)
            throw e
        }
    }
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/OutboxService.kt =====
package com.restaurant.independent.outbox.application

import com.restaurant.independent.outbox.application.error.OutboxException
import com.restaurant.independent.outbox.application.event.OutboxDomainEvent
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox를 통해 도메인 이벤트를 발행하는 서비스.
 */
@Service
class OutboxService(
    private val outboxMessageRepository: OutboxMessageRepository,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    /**
     * 단일 도메인 이벤트를 발행합니다.
     * @param event 발행할 도메인 이벤트
     * @return 저장된 Outbox 메시지
     */
    @Transactional
    fun publish(event: OutboxDomainEvent): OutboxMessage {
        try {
            val message = createOutboxMessage(event)
            return outboxMessageRepository.save(message)
        } catch (e: Exception) {
            log.error("Failed to publish domain event", e)
            throw OutboxException.MessageSaveException(
                message = "Failed to publish domain event: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 여러 도메인 이벤트를 발행합니다.
     * @param events 발행할 도메인 이벤트 목록
     * @return 저장된 Outbox 메시지 목록
     */
    @Transactional
    fun publishAll(events: List<OutboxDomainEvent>): List<OutboxMessage> {
        try {
            val messages = events.map { createOutboxMessage(it) }
            return outboxMessageRepository.saveAll(messages)
        } catch (e: Exception) {
            log.error("Failed to publish domain events", e)
            throw OutboxException.MessageSaveException(
                message = "Failed to publish domain events: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 도메인 이벤트를 Outbox 메시지로 변환합니다.
     */
    private fun createOutboxMessage(event: OutboxDomainEvent): OutboxMessage {
        try {
            return OutboxMessage(
                payload = event.payload,
                topic = event.topic,
                headers = buildHeaders(event),
            )
        } catch (e: Exception) {
            log.error("Failed to create outbox message from domain event", e)
            throw OutboxException.MessageSerializationException(
                message = "Failed to create outbox message from domain event: ${e.message}",
                cause = e,
            )
        }
    }

    /**
     * 도메인 이벤트로부터 메시지 헤더를 생성합니다.
     */
    private fun buildHeaders(event: OutboxDomainEvent): Map<String, String> =
        mapOf(
            "eventId" to event.eventId.toString(),
            "aggregateType" to event.aggregateType,
            "aggregateId" to event.aggregateId,
            "eventType" to event.eventType,
            "eventVersion" to event.eventVersion,
        )
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/config/OutboxConfig.kt =====
package com.restaurant.independent.outbox.application.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.context.annotation.Configuration
import org.springframework.scheduling.annotation.EnableScheduling

/**
 * Outbox 모듈의 설정을 제공하는 설정 클래스.
 */
@Configuration
@EnableScheduling
@ConfigurationProperties(prefix = "outbox.polling")
class OutboxConfig {
    /**
     * 메시지 처리 배치 크기
     */
    var batchSize: Int = 100

    /**
     * 최대 재시도 횟수
     */
    var maxRetries: Int = 3

    /**
     * 대기 중인 메시지 폴링 간격 (밀리초)
     */
    var pendingMessagesInterval: Long = 5000

    /**
     * 실패한 메시지 폴링 간격 (밀리초)
     */
    var failedMessagesInterval: Long = 60000
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxErrorCode.kt =====
package com.restaurant.independent.outbox.application.error

import org.springframework.http.HttpStatus

/**
 * Outbox 모듈의 자체적인 에러 코드 정의
 * Rule 67, 80에 따라 common 모듈의 ErrorCode와 독립적으로 정의
 */
enum class OutboxErrorCode(
    val code: String,
    val message: String,
    val status: HttpStatus,
) {
    // Message 저장 관련 오류
    MESSAGE_SAVE_FAILED(
        code = "OUTBOX-001",
        message = "Failed to save outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),
    MESSAGE_SERIALIZATION_FAILED(
        code = "OUTBOX-002",
        message = "Failed to serialize outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),

    // Message 전송 관련 오류
    MESSAGE_SEND_FAILED(
        code = "OUTBOX-003",
        message = "Failed to send outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),
    MAX_RETRIES_EXCEEDED(
        code = "OUTBOX-004",
        message = "Maximum retry attempts exceeded for outbox message",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),

    // Polling 관련 오류
    POLLING_ERROR(
        code = "OUTBOX-005",
        message = "Error occurred during message polling",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),

    // 기타 시스템 오류
    UNEXPECTED_ERROR(
        code = "OUTBOX-999",
        message = "Unexpected error occurred in outbox processing",
        status = HttpStatus.INTERNAL_SERVER_ERROR,
    ),
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxException.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Outbox 모듈의 자체적인 예외 클래스 정의
 * Rule 67, 68, 80에 따라 common 모듈의 예외와 독립적으로 정의
 */
sealed class OutboxException(
    message: String,
    cause: Throwable? = null,
    val errorCode: OutboxErrorCode,
) : RuntimeException(message, cause) {
    /**
     * 메시지 저장 실패 예외
     */
    class MessageSaveException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SAVE_FAILED,
        )

    /**
     * 메시지 직렬화 실패 예외
     */
    class MessageSerializationException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SERIALIZATION_FAILED,
        )

    /**
     * 메시지 전송 실패 예외
     */
    class MessageSendException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MESSAGE_SEND_FAILED,
        )

    /**
     * 최대 재시도 횟수 초과 예외
     */
    class MaxRetriesExceededException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.MAX_RETRIES_EXCEEDED,
        )

    /**
     * 메시지 폴링 실패 예외
     */
    class PollingException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.POLLING_ERROR,
        )

    /**
     * 예상치 못한 시스템 오류 예외
     */
    class UnexpectedErrorException(
        message: String,
        cause: Throwable? = null,
    ) : OutboxException(
            message = message,
            cause = cause,
            errorCode = OutboxErrorCode.UNEXPECTED_ERROR,
        )
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/error/OutboxStorageException.kt =====
package com.restaurant.independent.outbox.application.error

/**
 * Exception thrown when outbox message storage operations fail.
 * This is a module-specific exception that does not depend on any domain exceptions.
 */
class OutboxStorageException : RuntimeException {
    /**
     * Creates a new OutboxStorageException with the specified error message.
     *
     * @param message The error message
     */
    constructor(message: String) : super(message)

    /**
     * Creates a new OutboxStorageException with the specified error message and cause.
     *
     * @param message The error message
     * @param cause The underlying cause of the failure
     */
    constructor(message: String, cause: Throwable) : super(message, cause)
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxEventRepository.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.event.OutboxDomainEvent

interface OutboxEventRepository {
    fun save(
        events: List<OutboxDomainEvent>,
        aggregateType: String,
        aggregateId: String,
    )
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxMessageRepository.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.error.OutboxStorageException
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import java.util.UUID

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 * 이 인터페이스는 Outbox 메시지의 저장, 조회, 상태 업데이트 등의 작업을 정의합니다.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다.
     *
     * @param message 저장할 메시지
     * @return 저장된 메시지
     * @throws OutboxStorageException 저장 작업 실패 시
     */
    @Throws(OutboxStorageException::class)
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     * @return 저장된 메시지 목록
     * @throws OutboxStorageException 저장 작업 실패 시
     */
    @Throws(OutboxStorageException::class)
    fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage>

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: UUID): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     * FOR UPDATE SKIP LOCKED를 사용하여 동시성을 제어해야 합니다.
     *
     * @param status 조회할 메시지 상태
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다.
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID
     * @param newStatus 새로운 상태
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 시간 이전에 생성된 실패 상태의 메시지들을 조회합니다.
     *
     * @param maxRetries 최대 재시도 횟수
     * @param limit 조회할 최대 메시지 수
     * @return 조회된 메시지 목록
     */
    fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/OutboxMessageSenderPort.kt =====
package com.restaurant.independent.outbox.application.port

import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import java.util.concurrent.CompletableFuture

/**
 * Outbox 메시지 전송을 위한 Port 인터페이스 (Application Layer)
 */
interface OutboxMessageSenderPort {
    /**
     * 단일 Outbox 메시지를 비동기적으로 전송한다.
     * 실제 Kafka 전송 성공 여부는 Future를 통해 확인해야 한다.
     */
    fun send(message: OutboxMessage): CompletableFuture<*>
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxDomainEvent.kt =====
package com.restaurant.independent.outbox.application.port.model

/**
 * Outbox를 통해 발행될 도메인 이벤트를 나타내는 인터페이스.
 * 이 인터페이스는 도메인 이벤트가 Outbox 메시지로 변환되기 위해 필요한 정보를 정의합니다.
 */
interface OutboxDomainEvent {
    /**
     * 이벤트가 발행될 Kafka 토픽을 반환합니다.
     */
    fun getTopic(): String

    /**
     * 이벤트의 헤더 정보를 반환합니다.
     * 헤더에는 correlationId, aggregateType, aggregateId 등이 포함될 수 있습니다.
     */
    fun getHeaders(): Map<String, String>

    /**
     * 이벤트 페이로드를 바이트 배열로 직렬화하여 반환합니다.
     * 이 메서드는 이벤트 객체를 Avro 또는 다른 형식으로 직렬화해야 합니다.
     */
    fun serialize(): ByteArray
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxMessage.kt =====
package com.restaurant.independent.outbox.application.port.model

import java.time.Instant
import java.util.UUID

// Add import for OutboxMessageStatus
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus

/**
 * Represents a message to be stored in the outbox.
 * This is a technology-agnostic model that contains all necessary information for message delivery.
 *
 * @property id Unique identifier for the message
 * @property payload The serialized message content as a byte array
 * @property topic The target Kafka topic for message delivery
 * @property headers Additional message headers including correlationId, aggregateType, aggregateId, etc.
 * @property status Current status of the message
 * @property retryCount Number of retry attempts made
 * @property createdAt When the message was created
 * @property updatedAt When the message was last updated
 * @property lastAttemptTime When the last delivery attempt was made
 */
data class OutboxMessage(
    val id: UUID = UUID.randomUUID(),
    val payload: ByteArray,
    val topic: String,
    val headers: Map<String, String>,
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val createdAt: Instant = Instant.now(),
    val updatedAt: Instant = createdAt,
    val lastAttemptTime: Instant? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }

    override fun toString(): String =
        "OutboxMessage(" +
            "id=$id, " +
            "topic='$topic', " +
            "headers=$headers, " +
            "status=$status, " +
            "retryCount=$retryCount, " +
            "createdAt=$createdAt, " +
            "updatedAt=$updatedAt, " +
            "lastAttemptTime=$lastAttemptTime" +
            ")"
}

// ===== independent/outbox/application/src/main/kotlin/com/restaurant/independent/outbox/application/port/model/OutboxMessageStatus.kt =====
package com.restaurant.independent.outbox.application.port.model

/**
 * Outbox 메시지의 상태를 나타내는 enum
 */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,
}

// ===== independent/outbox/build.gradle.kts =====
plugins {
    id("org.springframework.boot") version "3.3.2"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    kotlin("plugin.jpa") version "2.1.20"
    kotlin("plugin.allopen") version "2.1.20"
    // id("org.jlleitschuh.gradle.ktlint")
    // id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Avro plugin - Rule 106/109 위반으로 제거
}

group = "com.restaurant.independent"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
    // Confluent repository for Kafka Avro Serializer etc.
    maven { url = uri("https://packages.confluent.io/maven/") }
}

// Define versions
object Versions {
    const val SPRING_BOOT = "3.3.2"
    const val KOTLIN_LOGGING = "3.0.5"
    const val MOCKK = "1.13.9"
    const val SPRING_MOCKK = "4.0.2"
}

dependencies {
    // Spring Boot
    implementation(platform("org.springframework.boot:spring-boot-dependencies:${Versions.SPRING_BOOT}"))
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.kafka:spring-kafka")

    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")

    // Logging
    implementation("io.github.microutils:kotlin-logging-jvm:${Versions.KOTLIN_LOGGING}")

    // Project Dependencies

    // Spring Boot Starters
    // implementation("org.springframework.boot:spring-boot-starter-validation") // Optional, as per instructions

    // Kafka & Avro
    // implementation("org.apache.avro:avro:$avroVersion")
    // implementation("io.confluent:kafka-avro-serializer:$kafkaAvroSerializerVersion")
    // implementation("io.confluent:kafka-schema-registry-client:$kafkaAvroSerializerVersion")

    // MapStruct (Optional - for DTO mapping, e.g., DomainEvent <-> Avro)
    // implementation("org.mapstruct:mapstruct:$mapstructVersion")
    // kapt("org.mapstruct:mapstruct-processor:$mapstructVersion")

    // Database (Test scope)
    testRuntimeOnly("com.h2database:h2")

    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("io.mockk:mockk:${Versions.MOCKK}")
    testImplementation("org.springframework.kafka:spring-kafka-test")
    testImplementation("com.ninja-squad:springmockk:${Versions.SPRING_MOCKK}")
    testImplementation("org.testcontainers:junit-jupiter")
    testImplementation("org.testcontainers:kafka")
    // Add Kotest dependencies if needed
    // testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    // testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
}

kotlin {
    jvmToolchain(21)
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// Configure Kotlin JPA plugin
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

noArg {
    annotation("jakarta.persistence.Entity")
}

// If using MapStruct, configure kapt
// kapt {
//    correctErrorTypes = true
// }

// ===== independent/outbox/infrastructure/build.gradle.kts =====
plugins {
    id("org.springframework.boot") version "3.3.2"
    id("io.spring.dependency-management") version "1.1.7"
    kotlin("jvm") version "2.1.20"
    kotlin("plugin.spring") version "2.1.20"
    kotlin("plugin.jpa") version "2.1.20"
}

dependencies {
    implementation(project(":independent:outbox:application"))

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.kafka:spring-kafka-test")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs += "-Xjsr305=strict"
        jvmTarget = "21"
    }
}

tasks.bootJar {
    enabled = false
}

tasks.jar {
    enabled = true
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/config/KafkaConfig.kt =====
package com.restaurant.independent.outbox.infrastructure.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

@Configuration
class KafkaConfig {
    @Value("\${spring.kafka.bootstrap-servers}")
    private lateinit var bootstrapServers: String

    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> {
        val configProps =
            mapOf(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                // 추가 설정
                ProducerConfig.ACKS_CONFIG to "all",
                ProducerConfig.RETRIES_CONFIG to 3,
                ProducerConfig.RETRY_BACKOFF_MS_CONFIG to 1000,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1,
            )
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(producerFactory())
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/entity/OutboxEventEntity.kt =====
package com.restaurant.independent.outbox.infrastructure.entity

import jakarta.persistence.*
import java.time.Instant

/**
 * Outbox 이벤트 엔티티
 */
@Entity
@Table(name = "outbox_events")
class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false)
    val payload: ByteArray,
    @Column(nullable = false)
    val eventType: String,
    @Column(nullable = false)
    val topic: String,
    @Column(nullable = false)
    val aggregateType: String,
    @Column(nullable = false)
    val aggregateId: String,
    @Column(nullable = false)
    val correlationId: String,
    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    var status: OutboxEventStatus = OutboxEventStatus.PENDING,
    @Column(nullable = false)
    val createdAt: Instant = Instant.now(),
    @Column(nullable = true)
    var lastAttemptTime: Instant? = null,
    @Column(nullable = false)
    var retryCount: Int = 0,
    @Version
    var version: Long = 0,
) {
    enum class OutboxEventStatus {
        PENDING,
        PROCESSING,
        SENT,
        FAILED,
    }

    fun incrementRetryCount() {
        retryCount++
        lastAttemptTime = Instant.now()
    }

    fun markAsProcessing() {
        status = OutboxEventStatus.PROCESSING
        lastAttemptTime = Instant.now()
    }

    fun markAsSent() {
        status = OutboxEventStatus.SENT
        lastAttemptTime = Instant.now()
    }

    fun markAsFailed() {
        status = OutboxEventStatus.FAILED
        lastAttemptTime = Instant.now()
    }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/entity/OutboxMessageEntity.kt =====
package com.restaurant.independent.outbox.infrastructure.entity

import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.Id
import jakarta.persistence.Table
import java.time.Instant
import java.util.UUID

/**
 * Outbox 메시지의 JPA 엔티티.
 */
@Entity
@Table(name = "outbox_messages")
data class OutboxMessageEntity(
    @Id
    val id: UUID,
    @Column(nullable = false)
    val payload: ByteArray,
    @Column(nullable = false)
    val topic: String,
    @Column(nullable = false)
    val headers: Map<String, String>,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    val status: OutboxMessageStatus,
    @Column(nullable = false)
    val retryCount: Int,
    @Column(nullable = false)
    val createdAt: Instant,
    @Column(nullable = false)
    val updatedAt: Instant,
    @Column(nullable = true)
    val lastAttemptTime: Instant?,
) {
    /**
     * ByteArray 필드가 포함된 엔티티의 equals/hashCode 구현
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessageEntity

        if (id != other.id) return false
        if (!payload.contentEquals(other.payload)) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false
        if (lastAttemptTime != other.lastAttemptTime) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + updatedAt.hashCode()
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        return result
    }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/extensions/OutboxMessageExtensions.kt =====
package com.restaurant.independent.outbox.infrastructure.extensions

import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity

/**
 * OutboxMessage 모델과 OutboxMessageEntity 간의 변환을 위한 확장 함수들.
 */

/**
 * Converts an OutboxMessage domain model to an OutboxMessageEntity.
 */
fun OutboxMessage.toEntity(): OutboxMessageEntity =
    OutboxMessageEntity(
        id = this.id,
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

/**
 * Converts an OutboxMessageEntity to an OutboxMessage domain model.
 */
fun OutboxMessageEntity.toDomainModel(): OutboxMessage =
    OutboxMessage(
        id = this.id,
        payload = this.payload,
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        lastAttemptTime = this.lastAttemptTime,
    )

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/kafka/KafkaConfig.kt =====
package com.restaurant.independent.outbox.infrastructure.kafka

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.ByteArraySerializer
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Outbox 모듈의 Kafka 설정을 제공하는 설정 클래스.
 */
@Configuration
class KafkaConfig(
    @Value("\${spring.kafka.bootstrap-servers}")
    private val bootstrapServers: String,
    @Value("\${spring.kafka.producer.client-id}")
    private val clientId: String,
    @Value("\${spring.kafka.producer.acks}")
    private val acks: String,
    @Value("\${spring.kafka.producer.retries}")
    private val retries: Int,
    @Value("\${spring.kafka.producer.batch-size}")
    private val batchSize: Int,
    @Value("\${spring.kafka.producer.buffer-memory}")
    private val bufferMemory: Long,
    @Value("\${spring.kafka.producer.compression-type}")
    private val compressionType: String,
    @Value("\${spring.kafka.producer.max-in-flight-requests-per-connection}")
    private val maxInFlightRequestsPerConnection: Int,
    @Value("\${spring.kafka.producer.max-request-size}")
    private val maxRequestSize: Int,
    @Value("\${spring.kafka.producer.request-timeout-ms}")
    private val requestTimeoutMs: Int,
    @Value("\${spring.kafka.producer.enable-idempotence}")
    private val enableIdempotence: Boolean,
) {
    /**
     * Kafka Producer 설정을 생성합니다.
     */
    @Bean
    fun producerFactory(): ProducerFactory<String, ByteArray> =
        DefaultKafkaProducerFactory(
            mapOf<String, Any>(
                ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to bootstrapServers,
                ProducerConfig.CLIENT_ID_CONFIG to clientId,
                ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
                ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to ByteArraySerializer::class.java,
                ProducerConfig.ACKS_CONFIG to acks,
                ProducerConfig.RETRIES_CONFIG to retries,
                ProducerConfig.BATCH_SIZE_CONFIG to batchSize,
                ProducerConfig.BUFFER_MEMORY_CONFIG to bufferMemory,
                ProducerConfig.COMPRESSION_TYPE_CONFIG to compressionType,
                ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to maxInFlightRequestsPerConnection,
                ProducerConfig.MAX_REQUEST_SIZE_CONFIG to maxRequestSize,
                ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG to requestTimeoutMs,
                ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG to enableIdempotence,
                ProducerConfig.TRANSACTION_TIMEOUT_CONFIG to 900000, // 15 minutes
                ProducerConfig.TRANSACTIONAL_ID_CONFIG to "outbox-tx-",
            ),
        )

    /**
     * KafkaTemplate을 생성합니다.
     */
    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, ByteArray> = KafkaTemplate(producerFactory())
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/kafka/OutboxMessageSender.kt =====
package com.restaurant.independent.outbox.infrastructure.kafka

import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity
import com.restaurant.independent.outbox.infrastructure.error.OutboxErrorCodes
import com.restaurant.independent.outbox.infrastructure.error.OutboxException
import org.apache.kafka.clients.producer.ProducerRecord
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Component

/**
 * Outbox 메시지를 Kafka로 전송하는 컴포넌트.
 */
@Component
class OutboxMessageSender(
    private val kafkaTemplate: KafkaTemplate<String, ByteArray>,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    fun send(message: OutboxMessageEntity) {
        try {
            val record =
                ProducerRecord(
                    message.topic,
                    null, // partition
                    message.aggregateId, // key
                    message.payload, // value
                    message.headers.map { (key, value) ->
                        org.apache.kafka.common.header.internals
                            .RecordHeader(key, value.toByteArray())
                    },
                )

            kafkaTemplate
                .send(record)
                .whenComplete { result, ex ->
                    if (ex != null) {
                        log.error("Failed to send message to Kafka. Topic: ${message.topic}, AggregateId: ${message.aggregateId}", ex)
                        throw OutboxException(
                            errorCode = OutboxErrorCodes.KAFKA_SEND_ERROR,
                            message = "Failed to send message to Kafka",
                            cause = ex,
                        )
                    } else {
                        log.debug("Successfully sent message to Kafka. Topic: ${message.topic}, Offset: ${result.recordMetadata.offset()}")
                    }
                }
        } catch (e: Exception) {
            log.error("Error while preparing Kafka message. Topic: ${message.topic}, AggregateId: ${message.aggregateId}", e)
            throw OutboxException(
                errorCode = OutboxErrorCodes.KAFKA_MESSAGE_PREPARATION_ERROR,
                message = "Error while preparing Kafka message",
                cause = e,
            )
        }
    }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/persistence/OutboxMessageRepositoryImpl.kt =====
package com.restaurant.independent.outbox.infrastructure.persistence

import com.restaurant.independent.outbox.application.error.OutboxStorageException
import com.restaurant.independent.outbox.application.port.OutboxMessageRepository
import com.restaurant.independent.outbox.application.port.model.OutboxMessage
import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.independent.outbox.infrastructure.repository.JpaOutboxMessageRepository
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant
import java.util.UUID

/**
 * OutboxMessageRepository 인터페이스의 JPA 구현체.
 */
@Repository
class OutboxMessageRepositoryImpl(
    private val jpaOutboxMessageRepository: JpaOutboxMessageRepository,
) : OutboxMessageRepository {
    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        try {
            val entity = jpaOutboxMessageRepository.save(message.toEntity())
            return entity.toDomainModel()
        } catch (e: Exception) {
            throw OutboxStorageException(
                message = "Failed to save outbox message: ${e.message}",
                cause = e,
            )
        }
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>): List<OutboxMessage> {
        try {
            val entities = jpaOutboxMessageRepository.saveAll(messages.map { it.toEntity() })
            return entities.map { it.toDomainModel() }
        } catch (e: Exception) {
            throw OutboxStorageException(
                message = "Failed to save outbox messages: ${e.message}",
                cause = e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: UUID): OutboxMessage? =
        jpaOutboxMessageRepository
            .findById(id)
            .map { it.toDomainModel() }
            .orElse(null)

    @Transactional(readOnly = true)
    override fun findByStatus(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatusOrderByCreatedAtAsc(status, limit)
            .map { it.toDomainModel() }

    @Transactional
    override fun updateStatus(
        id: UUID,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        val entity =
            jpaOutboxMessageRepository.findById(id).orElse(null)
                ?: return null

        val updatedEntity =
            entity.copy(
                status = newStatus,
                retryCount = if (incrementRetry) entity.retryCount + 1 else entity.retryCount,
                updatedAt = Instant.now(),
                lastAttemptTime = if (newStatus == OutboxMessageStatus.PROCESSING) Instant.now() else entity.lastAttemptTime,
            )

        return jpaOutboxMessageRepository.save(updatedEntity).toDomainModel()
    }

    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> {
        val entities = jpaOutboxMessageRepository.findAndLockByStatus(status, limit)
        entities.forEach { entity ->
            entity.status = OutboxMessageStatus.PROCESSING
            entity.updatedAt = Instant.now()
            entity.lastAttemptTime = Instant.now()
        }
        return jpaOutboxMessageRepository.saveAll(entities).map { it.toDomainModel() }
    }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long = jpaOutboxMessageRepository.countByStatus(status)

    @Transactional
    override fun incrementRetryCount(id: UUID): OutboxMessage? {
        val entity = jpaOutboxMessageRepository.findByIdOrNull(id) ?: return null
        entity.retryCount++
        entity.updatedAt = Instant.now()
        entity.lastAttemptTime = Instant.now()
        return jpaOutboxMessageRepository.save(entity).toDomainModel()
    }

    @Transactional(readOnly = true)
    override fun findFailedMessagesExceedingRetryCount(
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        jpaOutboxMessageRepository
            .findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
                OutboxMessageStatus.FAILED,
                maxRetries,
                limit,
            ).map { it.toDomainModel() }
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/persistence/SpringDataJpaOutboxMessageRepository.kt =====
package com.restaurant.independent.outbox.infrastructure.persistence

import com.restaurant.independent.outbox.application.port.model.OutboxMessageStatus
import com.restaurant.independent.outbox.infrastructure.entity.OutboxMessageEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.util.UUID

/**
 * Outbox 메시지 엔티티를 위한 Spring Data JPA Repository 인터페이스.
 */
interface SpringDataJpaOutboxMessageRepository : JpaRepository<OutboxMessageEntity, UUID> {
    /**
     * 특정 상태의 메시지들을 조회합니다.
     */
    fun findByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessageEntity>

    /**
     * 특정 상태의 메시지들을 처리 중 상태로 업데이트하고 조회합니다.
     * 동시성 제어를 위해 SELECT FOR UPDATE SKIP LOCKED를 사용합니다.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        value = "SELECT o FROM OutboxMessageEntity o WHERE o.status = :status ORDER BY o.createdAt ASC LIMIT :limit",
        nativeQuery = false,
    )
    fun findAndLockByStatus(
        @Param("status") status: OutboxMessageStatus,
        @Param("limit") limit: Int,
    ): List<OutboxMessageEntity>

    /**
     * 특정 상태의 메시지 수를 조회합니다.
     */
    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 특정 재시도 횟수를 초과한 실패 상태의 메시지들을 조회합니다.
     */
    fun findByStatusAndRetryCountGreaterThanOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        retryCount: Int,
        limit: Int,
    ): List<OutboxMessageEntity>
}

// ===== independent/outbox/infrastructure/src/main/kotlin/com/restaurant/independent/outbox/infrastructure/repository/OutboxEventJpaRepository.kt =====
package com.restaurant.independent.outbox.infrastructure.repository

import com.restaurant.independent.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.stereotype.Repository
import java.time.Instant

@Repository
interface OutboxEventJpaRepository : JpaRepository<OutboxEventEntity, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = 'PENDING' 
        AND (e.lastAttemptTime IS NULL OR e.lastAttemptTime < :cutoffTime)
        AND e.retryCount < :maxRetries
        ORDER BY e.createdAt ASC
        """,
    )
    fun findPendingEventsForProcessing(
        cutoffTime: Instant,
        maxRetries: Int,
    ): List<OutboxEventEntity>
}
