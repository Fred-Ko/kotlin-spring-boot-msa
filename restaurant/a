## 프로젝트 기술 문서 규칙

### I. 일반 원칙 및 프로젝트 구조

#### 1.1. 기본 원칙

1.  **모든 규칙의 필수 준수**: 프로젝트 기술 문서에 명시된 모든 규칙과 패턴은 선택 사항이 아닌 필수이며, 모든 구성원은 예외 없이 이를 준수해야 한다. 규칙 위반 시 즉시 코드 리뷰에서 반려된다. **단, 극히 예외적인 상황에서 규칙 준수가 프로젝트 목표 달성에 심각한 방해가 된다고 판단될 경우, 아키텍처 위원회(또는 지정된 검토 그룹)의 공식적인 승인을 통해 제한적으로 예외를 허용할 수 있다.**

#### 1.2. 모듈화 원칙

2.  **레이어별 모듈 분리**: 프로젝트는 반드시 Presentation, Application, Domain, Infrastructure 레이어로 모듈을 분리해야 하며, 각 레이어는 별도의 Gradle 모듈로 관리된다. **`domains/` 디렉토리 아래의 모든 모듈 (`domains/common` 포함)은 이 4계층 아키텍처 구조를 따라야 합니다. 각 레이어는 해당 모듈 내에서 규칙 141에 정의된 명확한 패키지 및 디렉토리 구조를 가져야 합니다.** Infrastructure 레이어는 책임(예: 영속성, 메시징)에 따라 하위 모듈로 분리되지 않고, 단일 `infrastructure` Gradle 모듈로 관리된다.
3.  **도메인별 모듈화**: 각 비즈니스 도메인은 `domains/` 최상위 폴더 아래 독립적인 폴더로 구성해야 한다 (예: `domains/user`, `domains/order`). 도메인 간 직접적인 의존성은 명시적으로 금지된다.
4.  **공통 모듈 및 독립 모듈 관리**: 공통 유틸리티, 공유 추상 클래스, 인터페이스 (`DomainEvent`, `AggregateRoot` 등), 공통 예외 및 ErrorCode 등 시스템 전반에 걸쳐 사용되는 **기반** 개념은 `domains/common` 모듈에 포함되며, 특정 도메인 로직을 포함하지 않아야 한다. **이 `domains/common` 모듈은 다른 특정 도메인 모듈(예: `domains/user`)이나 `independent/` 하위 모듈에 의존해서는 안 됩니다.** `domains/common` 모듈 내의 코드들은 Rule 141에 따라 해당 코드가 속하는 아키텍처 레이어(Domain, Application, Presentation, Infrastructure 및 그 하위 모듈)에 따른 패키지 및 디렉토리 구조 내에 위치해야 합니다. 예를 들어, 공통 AggregateRoot는 `domains/common/domain/aggregate/` 패키지에, 공통 GlobalExceptionHandler는 `domains/common/presentation/` 패키지 아래에 위치해야 합니다. `independent/` 폴더 아래에 위치하는 독립 모듈(예: `independent/outbox`)은 특정 기술적 기능이나 크로스 커팅 관심사를 담당하며, 이 독립 모듈은 **프로젝트 내의 어떤 특정 도메인 모듈 또는 `domains/common` 모듈에도 의존하지 않습니다 (규칙 9 참조).** **독립 모듈들은 자체적으로 완전하고(self-contained) 다른 프로젝트에 최소한의 수정으로 이식 및 재사용 가능하도록 설계되어야 합니다.** **다른 도메인 모듈(예: `domains/user`)은 필요에 따라 `domains/common` 모듈의 공통 요소와 `independent/` 모듈의 Application Layer Use Case 인터페이스를 의존하여 사용할 수 있습니다.** 공통 모듈 의존은 최소화하여 "공통 모듈 지옥"을 방지한다. `independent/` 모듈은 Rule 141의 패키지/디렉토리 구조 규칙을 따르지 않으며, 자체적인 구조 규칙(Rule 80 참조)을 정의하고 사용합니다.

#### 1.3. 모듈 간 의존성

9.  **모듈 간 의존성 명확화**: 모듈 간 의존성은 단방향으로 제한된다.
    *   **계층 간 의존성**: Domain 레이어는 다른 레이어를 의존하지 않는다. Application 레이어는 Domain을 의존하며 Infrastructure의 구체적인 구현체 대신 Domain 레이어의 Repository 인터페이스를 의존한다. Infrastructure는 Domain만 의존 가능하며, **Infrastructure 내 컴포넌트(예: 영속성 구현체)는 동일 도메인의 다른 Infrastructure 컴포넌트(예: 메시징 관련 변환기)에 정의된 요소를 의존할 수 있다.**
    *   **`domains/common` 모듈의 의존성**: `domains/common` 모듈은 시스템 전반의 기반 개념을 제공하며, **다른 특정 도메인 모듈(예: `domains/user`, `domains/order`)이나 `independent/` 하위 모듈에 의존하지 않습니다.**
    *   **개별 도메인 모듈 (`domains/{domain-name}`)의 의존성**: 각 개별 도메인 모듈(예: `domains/user`, `domains/order`)은 필요에 따라 `domains/common` 모듈의 공통 요소와 독립 모듈(`independent/` 하위 모듈)의 **Application Layer Use Case 인터페이스**를 의존하여 사용할 수 있습니다. **도메인 간 직접적인 의존성은 명시적으로 금지됩니다 (규칙 3 참조).**
    *   **독립 모듈 (`independent/`)의 의존성**: 독립 모듈(예: `independent/outbox` - Rule 80 참조)은 자체적인 레이어 구조를 가질 수 있으며, **프로젝트 내의 다른 어떤 모듈(다른 특정 도메인 모듈, `domains/common` 모듈, 심지어 다른 `independent` 모듈 포함)에도 의존하지 않도록 설계되어** 완전한 독립성과 이식성을 보장해야 합니다. 다른 모듈들은 이 독립 모듈의 **Application Layer Use Case 인터페이스**만을 의존합니다.
    *   **기타 의존성 관리**: 모듈 간 `@ComponentScan`은 제한적으로 사용되며, 특히 Application 모듈의 테스트 설정 외에는 지양한다. 의존성 주입은 Spring `@Bean` 또는 `@Component`를 통해 명시적으로 관리한다.
122. **공통 모듈 의존성**: **특정 도메인 모듈(예: `domains/user`)이 `domains/common` 모듈을 사용하고자 할 때는** `dependencies { implementation project(":domains:common") }` 와 같이 의존성을 추가한다. **`domains/common` 모듈 자체는 다른 특정 도메인 모듈이나 `independent/` 모듈에 의존하지 않습니다 (규칙 9 참조).** **독립 모듈(`independent/` 하위 모듈)은 `domains/common` 모듈에 의존하지 않는다 (규칙 4, 9, 80 참조).**

#### 1.4. 확장 함수 (Extensions)

5.  **Extensions 폴더 구조 및 사용 원칙**: 각 레이어(Presentation, Application, Infrastructure)는 해당 레이어 관련 확장 함수를 모아두기 위한 `extensions` 폴더를 포함할 수 있다. 확장 함수는 해당 클래스가 정의된 모듈이나, 관련 기능이 집중된 레이어의 `extensions` 폴더에 위치시켜 코드의 논리적 흐름과 물리적 위치 간의 일관성을 고려한다. **Presentation 레이어의 경우, CQRS 패턴을 명확히 구분하기 위해 Command/Query 관련 DTO 변환 확장 함수는 Rule 141에 정의된 Presentation 레이어 경로(`domains/{domain}/presentation/...`) 내의 버전별 폴더(`v1/`, `v2/` 등) 바로 아래의 `command/` 또는 `query/` 폴더 내에 위치하는 `extensions/` 폴더에 정의해야 한다.** **`vX/command/extensions/` 폴더 하위에는 `dto/request/` 폴더를, `vX/query/extensions/` 폴더 하위에는 `dto/request/` 및 `dto/response/` 폴더를 필수로 가져야 한다.** 이 구조는 Rule 141.5에 정의된 Presentation 레이어 내 필수적인 하위 구조입니다.
6.  **Extensions 기능별 폴더**: Rule 5에 정의된 각 `extensions` 하위 폴더(예: `vX/command/extensions/dto/request/`)는 해당 기능의 확장 함수만 포함하며, 다른 유형의 코드를 포함해서는 안 된다.
7.  **Extensions 파일명 규칙**: 확장 함수 파일명은 `도메인명+기능명+Extensions.kt` 형식을 따른다 (예: `UserMappingExtensions.kt`, `OrderValidationExtensions.kt`). **Presentation 레이어의 DTO 변환 확장 함수 파일명은 Rule 5 및 7에 따라 해당 구조를 반영하여 `UserCommandRequestExtensions.kt`, `UserProfileQueryResponseExtensions.kt` 등으로 명명해야 하며, 파일명은 해당 폴더 구조(command/query)의 의미를 포함하도록 명확하게 작성한다.**
8.  **확장 함수 위치**: 확장 함수는 가능한 해당 클래스가 정의된 모듈이나, 해당 기능을 확장하는 레이어의 `extensions` 폴더에 위치시킨다. 특정 레이어에 강제로 제한하기보다 코드의 가독성과 응집성을 우선하여 결정한다. **단, Rule 5에 명시된 Presentation 레이어의 DTO 변환 확장 함수는 해당 규칙에 명시된 구조와 위치를 필수로 준수해야 한다.**

#### 1.5. 필수 패키지 및 디렉토리 구조 규칙 (도메인 모듈)

**141. 필수 패키지 및 디렉토리 구조 규칙 (도메인 모듈)**

*   **141.1 (적용 범위 및 절대적 지위):** 이 규칙은 `domains/` 디렉토리 아래에 위치하는 모든 모듈 (`domains/common` 포함)에 **필수적으로 적용**되며, 해당 모듈 내 모든 소스 코드, 리소스 파일, 테스트 코드는 이 규칙에 정의된 레이어 및 패키지 구조를 **예외 없이 따라야 합니다.** 본 문서의 다른 규칙에서 특정 요소의 위치를 언급할 때, 해당 위치는 **별도의 명시적인 구조가 정의되지 않는 한** 항상 이 규칙 141에 정의된 레이어 구조 내의 하위 경로를 의미합니다. `independent/` 디렉토리 아래의 모듈에는 이 규칙이 적용되지 않으며 (Rule 80 참조), 해당 모듈은 자체적인 구조 규칙을 정의합니다.
*   **141.2 (최상위 패키지):** 각 도메인 모듈의 최상위 Kotlin/Java 소스 패키지는 `com.restaurant.{domain-name}` 형식을 따라야 합니다 (예: `com.restaurant.user`, `com.restaurant.common`).
*   **141.3 (레이어 패키지):** Rule 141.1에 따라, 각 아키텍처 레이어(Presentation, Application, Domain, Infrastructure)에 속하는 모든 코드는 반드시 해당 레이어 이름을 딴 하위 패키지 내에 위치해야 합니다. 형식은 `com.restaurant.{domain-name}.{layer-name}` 입니다 (예: `com.restaurant.user.domain`, `com.restaurant.common.presentation`, `com.restaurant.user.infrastructure`).
*   **141.4 (물리적 경로 일치):** 위 141.3에서 정의된 패키지 구조는 `src/main/kotlin/` (또는 `src/main/java/`) 아래의 물리적 디렉토리 구조와 **정확히 일치**해야 합니다. 예를 들어, `com.restaurant.user.domain` 패키지의 코드는 반드시 `domains/user/domain/src/main/kotlin/com/restaurant/user/domain/` 디렉토리 아래에 위치해야 합니다.
*   **141.5 (레이어 내 표준 하위 패키지):** 각 레이어 패키지 내에서는 코드의 종류에 따라 다음과 같은 표준 하위 패키지 사용을 **필수로 준수**해야 합니다. (디렉토리 구조 예시 참조)
    *   `domain` (`domains/{domain}/domain/` - Rule 141 준수): `aggregate`, `entity` (Domain Entity), `vo`, `event` (Rule 33, 34, VII.1 참조), `repository` (Interface), `error` (Rule 67 준수), `exception` (Rule 68 준수)
    *   `application` (`domains/{domain}/application/` - Rule 141 준수):
        *   `command/`: Command 관련 로직 그룹핑.
            *   `usecase/`: Command Use Case 인터페이스.
            *   `handler/`: Command Use Case 구현체.
            *   `dto/`: Command 입력 DTO.
        *   `query/`: Query 관련 로직 그룹핑.
            *   `usecase/`: Query Use Case 인터페이스.
            *   `handler/`: Query Use Case 구현체.
            *   `dto/`: Query 입력 DTO 및 결과 DTO.
    *   `presentation` (`domains/{domain}/presentation/` - Rule 141 준수): **Rule 57에 따라 버전별 폴더 (`v1/`, `v2/` 등)가 필수로 존재해야 하며, 이 버전별 폴더 바로 아래에 CQRS 역할을 명확히 구분하는 필수적인 `command/` 및 `query/` 하위 폴더를 포함합니다.**
        *   `vX/`:
            *   `command/`: `controller` (Command Controllers), `dto` (`request`), `extensions` (`dto/request` - Rule 5 준수)
            *   `query/`: `controller` (Query Controllers), `dto` (`request`, `response`), `extensions` (`dto/request`, `dto/response` - Rule 5 준수)
            *   `config`: (버전별 공통 설정)
            *   `filter`: (버전별 필터)
    *   `infrastructure` (`domains/{domain}/infrastructure/` - Rule 141 준수): `entity` (JPA Entity), `repository` (Implementation), `mapper` (또는 `extensions` - Rule 24, Rule 85, VII.1 참조), `config`, `error`, `exception`
*   **141.6 (패키지명 일관성):** 모든 패키지 명명은 소문자를 사용하고, 여러 단어 조합 시에는 일반적으로 붙여씁니다 (예: `userdomain` 대신 `user.domain`).

**디렉터리 구조**

```
/
├── buildSrc/ # Gradle 빌드 로직 및 태스크 정의 (rule VII.1.3.2 참조)
│   └── src/
│       └── main/
│           └── kotlin/
│               └── GenerateJsonSchemaTask.kt # Kotlinx.serialization 기반 이벤트 클래스용 JSON 스키마 생성 태스크
├── independent/ # 독립 모듈 그룹핑 폴더 (다른 프로젝트 재사용성/이식성 고려) (rule 4, 79, 80, 141.1 미적용)
│ └── outbox/ # Outbox 독립 모듈 - NO dependencies on domains/* or common/* or other independent/* (rule 9, 80, 122, 141.1 미적용) # Package: com.restaurant.outbox (예시)
│ ├── src/
│ │ ├── main/
│ │ │ ├── kotlin/
│ │ │ │ └── com/
│ │ │ │ └── restaurant/
│ │ │ │ └── outbox/
│ │ │ │ ├── application/ # Application 레이어 (rule 80)
│ │ │ │ │ ├── usecase/ # Outbox Use Case 인터페이스 (권장)
│ │ │ │ │ │ └── ProcessOutboxEventsUseCase.kt
│ │ │ │ │ ├── handler/ # Outbox Use Case 구현체 (권장)
│ │ │ │ │ │ └── ProcessOutboxEventsUseCaseHandler.kt
│ │ │ │ │ ├── dto/ # Outbox 관련 DTO (권장)
│ │ │ │ │ │ └── OutboxMessage.kt # Outbox 메시지 구조 정의 (payload: String (kotlinx.serialization JSON) - rule 81, VII.1)
│ │ │ │ │ │ └── OutboxMessageStatus.kt
│ │ │ │ │ └── # 기타 Outbox Application 로직 (예: OutboxPoller.kt - rule 86)
│ │ │ │ └── infrastructure/ # Infrastructure 레이어 (rule 80)
│ │ │ │ ├── entity/ # Outbox 이벤트 엔티티 (rule 83)
│ │ │ │ │ └── OutboxEventEntity.kt # Stores kotlinx.serialization JSON payload (String), topic, headers etc.
│ │ │ │ ├── repository/ # Outbox 메시지 저장 Repository 구현체 (rule 82)
│ │ │ │ │ ├── JpaOutboxMessageRepository.kt # Implements OutboxMessageRepository (defined in application/dto)
│ │ │ │ │ └── converter/ # JPA Converter (rule 83)
│ │ │ │ │ └── StringMapConverter.kt
│ │ │ │ ├── messaging/ # 메시지 브로커 전송 컴포넌트 (rule 88, VII.1, VII.2.6)
│ │ │ │ │ ├── OutboxMessageSender.kt # KafkaTemplate<String, String>을 사용하여 Kafka로 메시지 전송 (kotlinx.serialization JSON 페이로드 사용, Rule VII.1)
│ │ │ │ │ └── config/
│ │ │ │ │ └── KafkaProducerConfig.kt # Outbox KafkaTemplate 관련 설정 (application.yml에 설정, StringSerializer 사용)
│ │ │ │ ├── error/ # Outbox 자체 에러 코드 (rule 67, 80, 90)
│ │ │ │ │ └── OutboxErrorCodes.kt # Enum for Outbox errors
│ │ │ │ ├── exception/ # Outbox 자체 예외 (rule 68, 80, 90)
│ │ │ │ │ └── OutboxException.kt # Base exception for Outbox failures
│ │ │ │ └── resources/ # Outbox 관련 리소스
│ │ │ │ │ └── # (JSON 스키마 파일은 각 도메인 모듈에서 관리 - rule VII.1)
│ │ │ │ └── test/
│ └── build.gradle.kts # Depends only on standard libraries/frameworks (JPA, spring-kafka, kotlinx-serialization etc.)
├── domains/ # 도메인별 모듈 그룹 (rule 3, 141 필수 적용)
│ ├── common/ # 공통 모듈 (rule 4, 122, 141 필수 적용) # Package: com.restaurant.common (예시) (rule 141.2)
│ │ ├── src/ # NO dependencies on specific domains (e.g., user) or independent/* (rule 4, 9, 122)
│ │ │ ├── main/
│ │ │ │ ├── kotlin/ # Package: com.restaurant.common (예시)
│ │ │ │ │ └── com/
│ │ │ │ │ └── restaurant/
│ │ │ │ │ └── common/
│ │ │ │ │ ├── domain/ # Domain 레이어 (rule 141.3)
│ │ │ │ │ │ ├── aggregate/ # (rule 141.5)
│ │ │ │ │ │ │ └── AggregateRoot.kt # (rule 17, 18)
│ │ │ │ │ │ ├── event/ # (rule 141.5)
│ │ │ │ │ │ │ └── DomainEvent.kt # (rule 32, kotlinx.serialization @Serializable 대상)
│ │ │ │ │ │ ├── error/ # (rule 141.5)
│ │ │ │ │ │ │ ├── ErrorCode.kt # (rule 67)
│ │ │ │ │ │ │ └── CommonSystemErrorCode.kt # (rule 67)
│ │ │ │ │ │ └── exception/ # (rule 141.5)
│ │ │ │ │ │ └── DomainException.kt # Common Base Domain Exception (rule 68, 73)
│ │ │ │ │ ├── application/ # Application 레이어 (rule 141.3)
│ │ │ │ │ │ ├── exception/ # (rule 141.5)
│ │ │ │ │ │ │ └── ApplicationException.kt # Common Base Application Exception (rule 68, 73)
│ │ │ │ │ │ └── # 기타 공통 Application 요소 (예: 공통 Use Case 인터페이스)
│ │ │ │ │ ├── presentation/ # Presentation 레이어 (rule 141.3)
│ │ │ │ │ │ ├── GlobalExceptionHandler.kt # (rule 51, 52, 73, 141.5)
│ │ │ │ │ │ ├── config/ # (rule 141.5)
│ │ │ │ │ │ │ └── SecurityConfig.kt
│ │ │ │ │ │ └── dto/ # (rule 141.5)
│ │ │ │ │ │ └── response/
│ │ │ │ │ │ └── CommandResultResponse.kt # (rule 35)
│ │ │ │ │ └── infrastructure/ # Infrastructure 레이어 (rule 141.3)
│ │ │ │ │ │ ├── entity/ # (rule 141.5)
│ │ │ │ │ │ │ └── BaseEntity.kt
│ │ │ │ │ │ └── # 기타 공통 인프라 컴포넌트
│ │ │ │ │ └── test/
│ │ │ │ └── resources/ # Common Module Resources (rule 141.4)
│ │ │ │ │ └── # (JSON 스키마 파일은 각 도메인 모듈에서 관리 - rule VII.1)
│ │ └── build.gradle.kts
│ ├── user/ # 예시 도메인 (rule 3, 141 필수 적용) # Package: com.restaurant.user (예시) (rule 141.2)
│ │ ├── apps/ # 애플리케이션 실행 모듈 (일반적으로 도메인 레이어 구조와 분리)
│ │ │ ├── src/
│ │ │ │ ├── main/
│ │ │ │ │ ├── kotlin/ # Package: com.restaurant.apps.user (예시)
│ │ │ │ │ │ └── com/
│ │ │ │ │ │ └── restaurant/
│ │ │ │ │ │ └── apps/
│ │ │ │ │ │ └── user/
│ │ │ │ │ │ └── UserApplication.kt # Spring Boot Application 진입점
│ │ │ │ │ ├── resources/
│ │ │ │ │ │ └── application.yml # 애플리케이션별 설정
│ │ │ │ │ └── test/
│ │ ├── domain/ # Domain 레이어 모듈 (rule 2, 10, 141 필수 적용) # Package: com.restaurant.user.domain (예시) (rule 141.3)
│ │ │ ├── src/ # Can depend on domains/common (rule 4, 9)
│ │ │ │ ├── main/
│ │ │ │ │ ├── kotlin/ # Package: com.restaurant.user.domain (예시)
│ │ │ │ │ │ └── com/
│ │ │ │ │ │ └── restaurant/
│ │ │ │ │ │ └── user/
│ │ │ │ │ │ └── domain/ # (rule 141.4)
│ │ │ │ │ │ ├── aggregate/ # (rule 141.5)
│ │ │ │ │ │ │ ├── User.kt # AggregateRoot 상속, Immutable, id: UserId 필드 포함
│ │ │ │ │ │ │ ├── UserStatus.kt
│ │ │ │ │ │ │ └── UserType.kt
│ │ │ │ │ │ ├── entity/ # Domain Entity (rule 11, 141.5)
│ │ │ │ │ │ │ └── Address.kt # AddressId 포함
│ │ │ │ │ │ ├── vo/ # Value Object (rule 11, 141.5)
│ │ │ │ │ │ │ ├── AddressId.kt
│ │ │ │ │ │ │ ├── Email.kt # validation throws DomainException (rule 14, 61)
│ │ │ │ │ │ │ ├── Name.kt
│ │ │ │ │ │ │ ├── Password.kt # validation throws DomainException, toString 마스킹 (rule 14, 15, 61)
│ │ │ │ │ │ │ ├── PhoneNumber.kt
│ │ │ │ │ │ │ ├── UserId.kt # UUID 기반 ID VO (rule 10)
│ │ │ │ │ │ │ └── Username.kt
│ │ │ │ │ │ ├── event/ # Domain Event (rule 33, 34, VII.1, 141.5)
│ │ │ │ │ │ │ └── UserEvent.kt # Aggregate별 sealed class 이벤트 그룹 (kotlinx.serialization @Serializable, JSON 직렬화 대상 - rule 33, 34, VII.1)
│ │ │ │ │ │ ├── repository/ # Repository Interface (rule 137, 141.5)
│ │ │ │ │ │ │ └── UserRepository.kt
│ │ │ │ │ │ ├── error/ # Domain Error Code (rule 67, 141.5)
│ │ │ │ │ │ │ └── UserDomainErrorCodes.kt # Implements ErrorCode
│ │ │ │ │ │ └── exception/ # Domain Exception (rule 68, 141.5)
│ │ │ │ └── test/
│ │ ├── application/ # Application 레이어 모듈 (rule 2, 141 필수 적용) # Package: com.restaurant.user.application (예시) (rule 141.3)
│ │ │ ├── src/ # Can depend on domains/common and independent/*/application (rule 4, 9)
│ │ │ │ ├── main/
│ │ │ │ │ ├── kotlin/ # Package: com.restaurant.user.application (예시)
│ │ │ │ │ │ └── com/
│ │ │ │ │ │ └── restaurant/
│ │ │ │ │ │ └── user/
│ │ │ │ │ │ └── application/ # (rule 141.4)
│ │ │ │ │ │ ├── command/ # Command Use Cases (rule 141.5)
│ │ │ │ │ │ │ ├── usecase/ # Command Use Case Interfaces
│ │ │ │ │ │ │ │ └── CreateUserUseCase.kt
│ │ │ │ │ │ │ ├── handler/ # Command Use Case Implementations (Handlers)
│ │ │ │ │ │ │ │ └── CreateUserUseCaseHandler.kt
│ │ │ │ │ │ │ └── dto/ # Command Input DTOs
│ │ │ │ │ │ │ │ └── CreateUserCommand.kt
│ │ │ │ │ │ ├── query/ # Query Use Cases (rule 141.5)
│ │ │ │ │ │ │ ├── usecase/ # Query Use Case Interfaces
│ │ │ │ │ │ │ │ └── GetUserProfileByIdUseCase.kt
│ │ │ │ │ │ │ ├── handler/ # Query Use Case Implementations (Handlers)
│ │ │ │ │ │ │ │ └── GetUserProfileByIdUseCaseHandler.kt
│ │ │ │ │ │ │ └── dto/ # Query Input/Result DTOs
│ │ │ │ │ │ │ │ ├── GetUserProfileByIdQuery.kt
│ │ │ │ │ │ │ │ ├── LoginResult.kt
│ │ │ │ │ │ │ │ └── UserProfileDto.kt
│ │ │ │ │ │ ├── error/ # Application Error Code (rule 67, 141.5)
│ │ │ │ │ │ │ └── UserApplicationErrorCode.kt # Implements ErrorCode
│ │ │ │ │ │ └── exception/ # Application Exception (rule 68, 141.5)
│ │ │ │ │ │ └── UserApplicationException.kt # Sealed class, Has 'errorCode: ErrorCode'
│ │ │ │ │ └── resources/ # Application Resources (rule 141.4)
│ │ │ │ │ └── test/
│ │ ├── infrastructure/ # Infrastructure 레이어 모듈 (rule 2, 141 필수 적용) # Package: com.restaurant.user.infrastructure (예시) (rule 141.3)
│ │ │ ├── src/ # Can depend on domains/common and independent/outbox (rule 4, 9, 84)
│ │ │ │ ├── main/
│ │ │ │ │ ├── kotlin/ # Package: com.restaurant.user.infrastructure (예시)
│ │ │ │ │ │ └── com/
│ │ │ │ │ │ └── restaurant/
│ │ │ │ │ │ └── user/
│ │ │ │ │ │ └── infrastructure/ # (rule 141.4)
│ │ │ │ │ │ ├── entity/ # JPA Entity (rule 19, 141.5)
│ │ │ │ │ │ │ ├── UserEntity.kt
│ │ │ │ │ │ │ └── AddressEntity.kt
│ │ │ │ │ │ ├── repository/ # Repository Implementation (rule 138, 139, 140, 141.5)
│ │ │ │ │ │ │ ├── SpringDataJpaUserRepository.kt
│ │ │ │ │ │ │ └── UserRepositoryImpl.kt # Implements UserRepository, depends on OutboxMessageRepository & DomainEventToOutboxMessageConverter
│ │ │ │ │ │ ├── mapper/ # Entity Conversion & Event Conversion (rule 24, 85, 141.5, VII.1)
│ │ │ │ │ │ │ ├── UserEntityMapper.kt # (rule 25)
│ │ │ │ │ │ │ └── DomainEventToOutboxMessageConverter.kt # (rule 85, DomainEvent data class -> kotlinx.serialization JSON String payload for OutboxMessage - VII.1)
│ │ │ │ │ │ ├── config/ # Infrastructure Configuration (rule 141.5)
│ │ │ │ │ │ │ ├── JpaConfig.kt
│ │ │ │ │ │ │ └── KafkaConsumerConfig.kt # Kafka Listener 관련 설정 (@EnableKafka, ConsumerFactory 등 - Rule VII.2.24, StringDeserializer 또는 KafkaJsonSchemaDeserializer 사용)
│ │ │ │ │ │ └── messaging/ # 메시지 소비 관련 컴포넌트 (예: @KafkaListener) (rule VII.1.3.5, VII.2.24)
│ │ │ │ │ │ │ └── UserEventConsumer.kt # 예시: @KafkaListener(topics = "...", groupId = "...")
│ │ │ │ │ └── resources/ # Infrastructure Resources (rule 141.4) (예: DB 마이그레이션 스크립트)
│ │ │ │ │ │ └── schemas/ # JSON 스키마 파일 저장 위치 (rule VII.1.3.2)
│ │ │ │ │ │ └── user_event.json # 예시: UserEvent에 대한 JSON 스키마 (GenerateJsonSchemaTask.kt에 의해 생성)
│ │ │ │ │ └── test/
│ │ │ │ └── build.gradle.kts # Infrastructure module build script (kafka-schema-registry-gradle-plugin 설정 포함 - Rule VII.1.3.3)
│ │ ├── presentation/ # Presentation 레이어 모듈 (rule 2, 141 필수 적용) # Package: com.restaurant.user.presentation (예시) (rule 141.3)
│ │ │ ├── src/ # Can depend on domains/common and domains/user/application (rule 4, 9)
│ │ │ │ ├── main/
│ │ │ │ │ ├── kotlin/ # Package: com.restaurant.user.presentation (예시)
│ │ │ │ │ │ └── com/
│ │ │ │ │ │ └── restaurant/
│ │ │ │ │ │ └── user/
│ │ │ │ │ │ └── presentation/ # (rule 141.4)
│ │ │ │ │ │ ├── v1/ # API Version (rule 57, 141.5)
│ │ │ │ │ │ │ ├── command/ # Command related (rule 141.5)
│ │ │ │ │ │ │ │ ├── controller/ # Command Controllers (rule 141.5) - e.g. UserController for POST, PUT, DELETE
│ │ │ │ │ │ │ │ │ └── UserController.kt
│ │ │ │ │ │ │ │ ├── dto/ # Command Request DTOs (rule 44, 46, 141.5)
│ │ │ │ │ │ │ │ │ └── request/
│ │ │ │ │ │ │ │ │ └── CreateUserRequestV1.kt
│ │ │ │ │ │ │ │ └── extensions/ # Command DTO Conversion Extensions (rule 5, 6, 7, 8, 58, 59, 141.5)
│ │ │ │ │ │ │ │ │ └── dto/
│ │ │ │ │ │ │ │ │ └── request/ # Presentation Request -> Application Command DTO conversion
│ │ │ │ │ │ │ │ │ └── UserCommandRequestExtensions.kt # (rule 7, 59)
│ │ │ │ │ │ │ └── query/ # Query related (rule 141.5)
│ │ │ │ │ │ │ │ ├── controller/ # Query Controllers (rule 141.5) - e.g. UserQueryController for GET
│ │ │ │ │ │ │ │ │ └── UserQueryController.kt
│ │ │ │ │ │ │ │ ├── dto/ # Query Request/Response DTOs (rule 44, 46, 141.5)
│ │ │ │ │ │ │ │ │ ├── request/ # Query Request DTOs/Parameters
│ │ │ │ │ │ │ │ │ │ └── GetUserProfileByIdRequestV1.kt # Example for complex query params
│ │ │ │ │ │ │ │ │ └── response/ # Query Response DTOs
│ │ │ │ │ │ │ │ │ └── UserProfileResponseV1.kt
│ │ │ │ │ │ │ │ └── extensions/ # Query DTO Conversion Extensions (rule 5, 6, 7, 8, 58, 59, 141.5)
│ │ │ │ │ │ │ │ │ └── dto/
│ │ │ │ │ │ │ │ │ ├── request/ # Presentation Request -> Application Query DTO conversion (Optional if params are simple)
│ │ │ │ │ │ │ │ │ │ └── UserQueryRequestExtensions.kt
│ │ │ │ │ │ │ │ │ └── response/ # Application Query Result -> Presentation Response DTO conversion
│ │ │ │ │ │ │ │ │ └── UserQueryResponseExtensions.kt # (rule 7, 59)
│ │ │ │ │ │ ├── config/ # Version-specific Presentation config (e.g., Swagger specific to v1) (rule 141.5)
│ │ │ │ │ │ │ └── v1SwaggerConfig.kt
│ │ │ │ │ │ └── filter/ # Version-specific Presentation filters (rule 141.5)
│ │ │ │ │ │ └── V1AuthFilter.kt
│ │ │ │ │ └── resources/ # Presentation Resources (rule 141.4)
│ │ │ │ │ └── test/
│ │ └── build.gradle.kts # User 모듈의 각 하위 모듈(domain, application, infrastructure, presentation)이 common 및 independent(usecase/dto)에 대한 의존성을 가질 수 있음
# 다른 도메인 모듈들 (order 등) 도 user 도메인과 유사한 구조 (rule 3, 141 필수 적용)
└── build.gradle.kts
```

### II. 도메인 계층 개발 원칙

#### 2.1. 도메인 레이어 독립성 및 순수성

10. **도메인 레이어 독립성**: Domain 레이어 (`domains/{domain}/domain/` - Rule 141 준수)는 Presentation, Application, Infrastructure, 독립 모듈(`independent/`) 레이어를 절대 참조해서는 안 됩니다. 또한, Spring, JPA, Kafka 클라이언트, **HTTP 관련 API (`HttpStatus` 등)** 등 특정 **기술 구현 프레임워크 또는 프로토콜**에 대한 직접적인 의존성(로직, 어노테이션 포함)을 가져서는 안 됩니다. 하지만, 도메인 모델링 자체를 본질적으로 지원하는 **필수적인 표준 라이브러리 또는 유틸리티 라이브러리**(예: `kotlin-stdlib`, `java.time` API, 표준 Validation API - `jakarta.validation-api`, Guava 등 검증된 유틸리티)의 사용은 **최소한의 범위 내에서 신중하게 허용**될 수 있습니다. **`DomainEvent` `data class`는 Kotlinx Serialization 라이브러리 (`@Serializable` 어노테이션 사용)를 통해 JSON으로 직렬화될 수 있으며, 이는 특정 메시징 기술에 대한 직접적인 의존성을 유발하지 않으므로 Domain 레이어 내 사용이 허용됩니다 (Rule 33, Rule VII.1 참조).** 이러한 라이브러리 사용 결정은 코드 리뷰를 통해 그 필요성과 도메인 순수성 침해 여부를 엄격히 검토해야 합니다. `domains/common` 모듈의 공통 도메인 요소(`AggregateRoot`, `DomainEvent` 인터페이스 등 - `domains/common/domain/` - Rule 141 준수)에 대한 의존성은 허용됩니다. Domain 모델의 고유 식별자는 UUID와 같은 기술 독립적인 타입의 Value Object로 캡슐화하여 사용해야 한다 (예: `UserId`, `OrderId`). 데이터베이스 자동 생성 식별자(예: Long)는 Infrastructure 레이어에서만 관리되며, Domain 모델에 노출되지 않는다.

#### 2.2. Aggregate, Entity, Value Object (VO)

##### 2.2.1. 정의, 위치 및 순수성

11. **Aggregate, Entity, VO 위치 및 순수성**: Aggregate, Domain Entity, Value Object (VO)는 반드시 해당 도메인 모듈의 Domain 레이어 (`domains/{domain}/domain/` - Rule 141 준수)에 정의하며, **특정 기술 구현 프레임워크**(JPA, Spring 등)의 로직이나 어노테이션에 의존하지 않고 순수하게 유지한다. **단, `DomainEvent` `data class`의 경우 JSON 직렬화를 위한 Kotlinx Serialization 라이브러리와의 호환성은 Rule 10에 따라 허용된다 (Rule 33, Rule VII.1 참조).** **이때, Domain Entity (Aggregate Root 포함)와 Value Object를 구분하는 핵심 기준은 '고유 식별자(identity)'의 유무이다. Domain Entity는 고유한 식별자를 가지며 자체적인 생명주기(lifecycle)를 통해 추적 및 변경 관리되는 반면, Value Object는 기술적인 식별자를 갖지 않고 오직 구성 속성들의 값으로만 정의된다.** 기술적 영속화 관련 상세(DB 자동 생성 ID 매핑, Fetch 전략 등)는 해당 도메인 모듈의 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)** 의 JPA Entity에만 정의한다. **Aggregate는 불변 객체로 설계한다.**

##### 2.2.2. Aggregate Root 식별자 (ID)

11.5. **Aggregate Root 식별자 (ID) 정의**: 모든 Aggregate Root 클래스는 해당 Aggregate의 고유 식별자를 나타내는 필드를 가져야 하며, 이 필드는 Rule 10에 따라 Domain ID Value Object 타입으로 정의되어야 한다. 이 식별자 필드는 `val`로 선언되어야 하며, 생성 시점에 할당된 이후 변경될 수 없다. 해당 필드는 외부 레이어(Application, Infrastructure)에서 Aggregate를 식별하고 참조할 수 있도록 `public val` 또는 `internal val`로 노출해야 한다.

##### 2.2.3. Aggregate VO 사용 제한

12. **Aggregate VO 사용 제한**: 도메인 내 Aggregate의 Value Object는 Domain 레이어 외부에서 참조하거나 직접 사용하지 않아야 한다. 외부 레이어에서는 DTO로 변환하여 사용한다.

##### 2.2.4. VO 불변성 및 생성

13. **VO 불변성 및 생성 제어**: 모든 VO는 불변 객체로 설계하며, `private` 생성자와 `companion object`의 `of` 메서드 (또는 `ofString` 등 의미있는 정적 팩토리 메서드)를 통해 생성을 제어해야 한다.
61. **VO 생성 규칙**: VO는 `companion object`의 `of` 메서드 (또는 `ofString` 등 의미있는 정적 팩토리 메서드) 로만 생성하며, `private` 생성자를 사용하여 직접 생성을 차단한다. VO 생성 시 발생하는 유효성 검사 실패는 Rule 14에 따라 해당 도메인 모듈의 **Domain Layer (`domains/{domain}/domain/exception/` - Rule 141 준수)에 정의된 InvalidInput 관련 `DomainException`을 상속하는 특정 유효성 검사 예외 타입** (Rule 68 참조)으로 발생되어 상위로 전파되어야 한다.

##### 2.2.5. VO 유효성 검사

14. **VO 유효성 검사**: VO의 유효성 검사는 `init` 블록 또는 팩토리 메서드에서 수행하며, 유효성 검사 실패 시 해당 도메인 레이어에 정의된 **`DomainException`을 상속하는 특정 유효성 검사 예외 타입** (Rule 68 참조)을 던져야 한다. 이러한 유효성 검사 예외는 Rule 68에 명시된 Validation 관련 베이스 예외 타입(예: `UserDomainException.Validation`)을 상속해야 한다. **표준 Validation API 어노테이션(`jakarta.validation.constraints.*`)을 VO 필드에 명시하는 것은 허용될 수 있으나, 실제 검증 로직 실행 및 예외 발생 책임은 여전히 `init` 또는 팩토리 메서드 내에 있어야 합니다.**

##### 2.2.6. VO toString 오버라이드

15. **VO toString 오버라이드**: VO의 `toString()` 메서드는 디버깅 및 로깅을 위해 값 자체를 명확히 표현하도록 재정의하거나, 민감 정보(예: 비밀번호)는 보안을 위해 마스킹 처리할 수 있다. (예: `Password.toString()`은 `********` 반환)

##### 2.2.7. Aggregate 팩토리 함수

16. **Aggregate 팩토리 함수**: Aggregate 및 Domain Entity는 `companion object`에 `create` (신규 생성) 및 `reconstitute` (영속성 로딩 후 재구성) 팩토리 함수를 정의해야 한다. `reconstitute`는 Domain 식별자 Value Object를 인자로 받아야 한다. **`reconstitute` 팩토리 함수는 오직 해당 도메인 모듈의 Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수) 내 Repository 구현체 내부에서, 데이터베이스 등 영속성 저장소로부터 읽어온 데이터(예: JPA Entity)를 기반으로 Domain Aggregate 객체를 메모리 상에 재구성(rehydrate)할 목적으로만 사용되어야 한다.** Application 레이어나 다른 Domain 객체 내에서 이 메서드를 직접 호출해서는 안 된다. `create` 팩토리 함수는 애그리거트의 초기 상태를 생성하며, 이 과정에서 발생하는 초기 상태 변경(`UserCreated` 등)에 대한 `DomainEvent`를 애그리거트 내부의 이벤트 목록에 `addDomainEvent()` 메서드를 통해 추가한다.

##### 2.2.8. 공통 AggregateRoot 상속

17. **공통 AggregateRoot 상속**: 모든 도메인 Aggregate 클래스는 `domains/common` 모듈의 domain 레이어 (`domains/common/domain/` - Rule 141 준수)에 정의된 추상 클래스 `AggregateRoot`를 상속받아야 한다.

##### 2.2.9. AggregateRoot 이벤트 관리

18. **AggregateRoot 이벤트 관리**: `AggregateRoot` 베이스 클래스는 발생한 `DomainEvent` 객체들을 저장하기 위한 컬렉션(예: `private val domainEvents: MutableList<DomainEvent> = mutableListOf()`)을 내부에 가져야 하며, 이벤트를 추가하는 `addDomainEvent(event: DomainEvent)`, 읽기 전용 목록을 노출하는 `fun getDomainEvents(): List<DomainEvent>`, 이벤트 목록을 초기화하는 `fun clearDomainEvents()` 메서드를 제공해야 한다. **`addDomainEvent(event: DomainEvent)` 메서드는 `internal` 가시성을 가져야 하며, Aggregate의 상태 변경 메서드나 `create` 팩토리 함수 내에서만 호출되어야 한다.** Immutable Aggregate의 상태 변경 메서드는 변경된 Aggregate의 *새로운 인스턴스*를 반환한다. 이 새로운 인스턴스는 해당 변경으로 인해 발생한 이벤트를 자신의 내부 이벤트 목록에 포함해야 한다. `create` 팩토리 함수도 초기 상태 변경에 대한 `DomainEvent`를 생성하여 `addDomainEvent()`를 호출한다. Repository 구현체는 애그리거트 저장 전 최종 Aggregate 인스턴스의 `getDomainEvents()`로 이벤트를 수집하고 Rule 85에 따라 Outbox 저장을 위한 변환 및 저장을 위임한다. 저장 성공 후 `clearDomainEvents()`를 호출한다.
    *   Aggregate 내 상태 변경 메서드 (Immutable) 예시:
        *   `fun changeName(newName: String): User` 와 같은 메서드는 `this.copy(...)`를 사용하여 새로운 인스턴스를 생성한다.
        *   상태 변경에 따른 `DomainEvent` (예: `UserEvent.NameChanged`)를 생성하여 새로운 인스턴스의 `addDomainEvent()`를 호출한다.
        *   변경된 새로운 인스턴스를 반환한다.
    *   `AggregateRoot` 내 `addDomainEvent` (internal 가시성) 예시:
        *   `internal fun addDomainEvent(event: DomainEvent) { this.domainEvents.add(event) }`

#### 2.3. 도메인 이벤트

##### 2.3.1. 공통 DomainEvent 인터페이스

32. **공통 DomainEvent 인터페이스 정의**: 모든 도메인 이벤트가 구현해야 할 `DomainEvent` 인터페이스는 `domains/common` 모듈의 domain 레이어 패키지(`domains/common/domain/event/DomainEvent.kt` - Rule 141 준수)에 정의하며, 기술 독립적이어야 한다. 이 인터페이스를 구현하는 클래스는 Kotlinx Serialization을 위해 `@Serializable` 어노테이션을 가질 수 있다. `independent/outbox` 모듈은 이 인터페이스를 **직접 의존하지 않는다** (Rule 80 참조, Rule 141 미적용). 도메인 Infrastructure 레이어는 이 인터페이스를 구현하는 구체적인 이벤트를 처리한다.

##### 2.3.2. 도메인 이벤트 정의 및 위치

33. **도메인 이벤트 정의 위치**: 도메인 이벤트 클래스는 해당 도메인 모듈의 `domain/event/` 패키지 (`domains/{domain}/domain/event/` - Rule 141 준수)에 정의하며, 순수 Kotlin `data class`로 구현하고 `DomainEvent` 인터페이스를 구현해야 한다. **이 `data class`는 Kotlinx Serialization 라이브러리(`org.jetbrains.kotlinx:kotlinx-serialization-json`)를 사용하여 JSON으로 직렬화/역직렬화 가능해야 하며, 이벤트 클래스는 `@Serializable` 어노테이션을 가져야 한다 (Rule 10, Rule VII.1 참조).** 이벤트 페이로드는 불변 타입 및 불변 컬렉션(`List`, `Map` 등)만을 포함해야 한다. 모든 이벤트에는 공통 필드(`id`, `eventId`, `occurredAt`)가 포함되며, `type` 필드는 이벤트 타입을 구분하는 식별자 역할을 하며 Kotlinx Serialization의 다형성 처리에 사용될 수 있다.

##### 2.3.3. Aggregate별 이벤트 그룹화

34. **Aggregate별 이벤트 그룹화**: 각 Aggregate (또는 도메인 엔티티)와 관련된 모든 도메인 이벤트는 해당 Aggregate의 이름 뒤에 `Events`를 붙인 파일명(예: `UserEvent.kt`)으로, 해당 도메인 모듈의 `domain/event/` 패키지 (`domains/{domain}/domain/event/` - Rule 141 준수) 내에 정의한다. 이벤트들은 하나의 `sealed class`로 상위 타입을 정의하고 (예: `sealed class UserEvent(...) : DomainEvent`), 실제 발행 이벤트들은 해당 `sealed class` 내부에 `@Serializable` 어노테이션을 가진 `data class`로 중첩하여 구현한다 (예: `data class UserEvent.Created(...) : UserEvent(...)`). **이 중첩된 `data class`들 또한 Kotlinx Serialization을 통해 JSON으로 직렬화/역직렬화 가능해야 한다 (Rule 10, Rule VII.1 참조).** 중첩된 이벤트는 상위 `sealed class`의 생성자를 통해 공통 필드(예: `occurredAt`, 관련 Aggregate 식별자 Value Object 등)를 상속받아 관리한다. 특히 `userId`와 같은 관련 Aggregate 식별자는 상위 `sealed class UserEvent`의 추상 프로퍼티나 생성자 인자로 정의하고, 하위 이벤트 데이터 클래스들이 이를 상속받아 사용한다. 이벤트 페이로드에는 Infrastructure-specific ID(예: `Long`)를 포함하지 않고 Domain적인 의미를 가지는 데이터만 포함한다.

### III. 애플리케이션 계층 개발 원칙

#### 3.1. 애플리케이션 서비스 (Use Case)

*   **Command/Query 분리 및 의존성**: Application 레이어 내 `command` 패키지와 `query` 패키지 간 직접적인 의존성은 명시적으로 금지된다. Command 처리 로직과 Query 처리 로직 간 코드 공유가 필요한 경우, 해당 도메인의 `application/common/` (또는 `application/shared/`) 패키지나 `domains/common/application/`에 공유 유틸리티/서비스를 정의하여 사용한다. 이 공유 로직은 특정 Command나 Query에 종속되지 않아야 하며, 코드 중복은 일정 수준 감수한다.

#### 3.2. 예외 처리 및 전파

69. **Application 계층 예외 전파**: Application 레이어의 Command Handler와 Query Handler는 DomainException 및 그 하위 예외를 절대 `catch` 하거나 다른 예외로 변환하지 않는다. 비즈니스 규칙 위반 발생 시 DomainException은 Application 레이어를 그대로 통과하여 상위 계층(Presentation/GlobalExceptionHandler)으로 전파되어야 한다.
70. **Application 계층 자체 예외 처리**: Application 핸들러는 자신의 책임 범위 내에서 발생하는 문제(예: Command/Query DTO 기반의 입력값 형식 오류 *전* 처리, 외부 서비스 호출 실패 시 Resilience4j 예외, 복구 불가능한 예상치 못한 시스템 오류 등 기술적 오류)에 대해서만 해당 도메인 모듈의 `ApplicationException` sealed class (기술적 오류 관련 data class - `domains/{domain}/application/exception/` - Rule 141 준수)를 발생시키고 상위로 전파한다. Domain 로직 위반으로 인한 예외(예: VO `init` 블록 `require` 실패)를 ApplicationException으로 래핑하지 않도록 한다.

#### 3.3. 재시도 및 Resilience

75. **재시도 로직 포함**: Application 레이어 (`domains/{domain}/application/` - Rule 141 준수)는 일시적 오류(예: 외부 API 호출 실패)에 대해 최대 3회 재시도 로직을 포함하며, 재시도 실패 시 해당 도메인 모듈의 `ApplicationException` sealed class (기술적 오류 관련 data class - `domains/{domain}/application/exception/` - Rule 141 준수)를 발생시킨다. (Resilience4j `@Retry` 사용 권장)
76. **Resilience4j 회로 차단기**: 외부 시스템 호출은 Resilience4j를 사용하여 회로 차단기 패턴을 적용하며, 기본 타임아웃은 5초로 설정한다. 회로 차단기 설정은 `@CircuitBreaker` 어노테이션을 사용하고, 폴백 메서드를 정의하여 장애 시 기본 응답을 반환한다.
77. **Resilience4j 재시도 설정**: Resilience4j의 `@Retry` 어노테이션을 사용하여 일시적 오류에 대해 최대 3회 재시도하며, 재시도 간격은 지수 백오프(exponential backoff) 전략을 따른다.

#### 3.4. 컬렉션 사용

65. **불변 컬렉션 사용 의무화**: Domain 및 Application 레이어의 모든 공개 메서드 (public, internal) 및 생성자는 `MutableList` 또는 `MutableMap` 타입을 반환하거나 파라미터로 사용해서는 안 된다. 대신 Kotlin의 불변 컬렉션 타입인 `List`, `Map` 또는 Guava의 `ImmutableList`, `ImmutableMap` 등과 같이 불변성이 보장된 컬렉션 타입을 사용해야 한다.
66. **Infrastructure 경계에서의 Mutable 컬렉션 사용**: Infrastructure 레이어에서 JPA 엔티티와 Domain 객체 또는 DTO 간의 데이터 변환이 발생하는 모듈 경계에서는 데이터 구조 변환을 위해 필요한 경우 mutable 컬렉션 타입의 사용이 제한적으로 허용될 수 있다. 하지만 변환 완료 후 Domain 또는 Application 레이어로 전달될 때는 반드시 불변 컬렉션으로 변환하여 전달해야 한다.

### IV. Presentation 계층 및 API 개발 규칙

#### 4.1. API 응답 형식

35. **Command 요청 동기 응답**: Command 요청의 동기 응답은 JSON 형식으로 `status` (예: "SUCCESS"), `message` (결과 메시지)를 필수로 포함한다. Command 실행 성공 응답은 Common 모듈의 Presentation 레이어에 정의된 `CommandResultResponse` DTO (`domains/common/presentation/dto/response/CommandResultResponse.kt` - Rule 141 준수)를 사용한다.
36. **Command 요청 비동기 응답**: 비동기 Command 응답은 `status`, `message`, `jobId` (작업 ID)를 포함한다.
42. **다건 조회 페이지네이션**: 다건 조회 API는 반드시 페이지네이션을 구현하며, 응답은 `content`, `page`, `size`, `totalElements`, `totalPages` 필드를 포함한다.
43. **커서 페이지네이션 우선**: 페이지네이션은 커서 기반 페이지네이션을 기본으로 사용하며, 오프셋 페이지네이션은 성능 검증 후 사용한다.

#### 4.2. API 유효성 검사 (Validation)

44. **Presentation Validation**: 해당 도메인 모듈의 Presentation 레이어 (`domains/{domain}/presentation/` - Rule 141 준수) 내의 버전별 폴더(`vX/`) 아래의 **`command/dto/request/` 및 `query/dto/request/` 하위**에 정의된 **요청 DTO**의 유효성 검사는 `jakarta.validation.constraints` 어노테이션(예: `@NotNull`, `@Size`)을 사용하여 수행한다.
45. **Validation 의존성**: 프로젝트는 `spring-boot-starter-validation`을 의존성에 반드시 추가한다.
46. **Request DTO Validation**: 모든 해당 도메인 모듈의 Presentation 레이어 (`domains/{domain}/presentation/` - Rule 141 준수) 내의 버전별 폴더(`vX/`) 아래의 **`command/dto/request/` 및 `query/dto/request/` 하위**에 정의된 **요청 DTO** 필드는 적절한 검증 어노테이션을 반드시 적용하며, 검증 로직은 어노테이션으로 처리한다.
47. **Controller `@Valid` 사용**: Controller 메서드는 **요청 DTO (Rule 44, 46에 명시된 위치)** 에 `@Valid` 어노테이션을 적용하여 유효성 검사를 트리거한다.

#### 4.3. API 에러 처리 및 응답

48. **Validation 에러 응답**: Validation 실패 시 RFC 9457 `ProblemDetail` 형식을 따르며, `invalid-params` 필드에 필드별 에러 메시지(예: `[{ "field": "name", "reason": "cannot be empty" }]`를 포함한다.
49. **에러 응답 형식**: 모든 에러 응답은 RFC 9457을 준수하며, `ProblemDetail` 클래스를 사용하여 `type`, `title`, `detail`, `errorCode`, `timestamp`를 포함해야 한다.
50. **ProblemDetail 속성 설정**: `ProblemDetail`은 `.apply { ... }` 람다 블록으로 속성을 설정하며, `ResponseEntity.status(determinedHttpStatus).body(problemDetail)`로 반환한다. HTTP 상태 코드는 Common 모듈의 GlobalExceptionHandler (`domains/common/presentation/GlobalExceptionHandler.kt` - Rule 141 준수)가 발생한 예외(및 ErrorCode)에 기반하여 **자체 매핑 로직으로 결정한 값(`determinedHttpStatus`)**을 사용한다.
51. **GlobalExceptionHandler 구현**: 모든 프로젝트는 Common 모듈의 Presentation 레이어 (`domains/common/presentation/GlobalExceptionHandler.kt` - Rule 141 준수)에 `GlobalExceptionHandler` 클래스를 구현하며, 다음 예외를 반드시 처리한다: `MethodArgumentNotValidException` (규칙 48 상세 포함), `HttpMessageNotReadableException`, `DomainException`, `ApplicationException`, `OptimisticLockException`, `Exception`. GlobalExceptionHandler는 처리하는 모든 예외에 대해 Rule 49, 50에 따라 `ProblemDetail` 응답을 생성한다.
52. **컨트롤러 및 글로벌 예외 처리**: 컨트롤러 레벨(`@ExceptionHandler` in ControllerAdvice) 예외 처리는 특정 컨트롤러에 국한되는 경우에만 제한적으로 사용하고, DomainException, ApplicationException, OptimisticLockException을 포함한 대부분의 예외 처리는 Common 모듈의 GlobalExceptionHandler (`domains/common/presentation/GlobalExceptionHandler.kt` - Rule 141 준수)에서 수행하여 일관된 응답 형식을 유지한다. DomainException과 ApplicationException은 Application 레이어에서 잡지 않고 Presentation/GlobalExceptionHandler까지 전파되어 일관된 응답 형식으로 변환된다.
73. **Presentation/Global 예외 처리 및 HTTP 상태 코드 매핑 책임**: Common 모듈의 Presentation 레이어에 위치한 `ControllerAdvice` 또는 `GlobalExceptionHandler` (`domains/common/presentation/GlobalExceptionHandler.kt` - Rule 141 준수)는 Application 레이어에서 전파된 `DomainException`과 `ApplicationException`, Infrastructure 레이어에서 전파된 `OptimisticLockException`, **`independent/outbox` 모듈의 Infrastructure 레이어 내 `exception` 패키지 (`independent/outbox/infrastructure/exception/` - Rule 80 참조, Rule 141 미적용)에서 전파된 Outbox 관련 예외**를 모두 catch한다. **이 핸들러는 catch한 예외(및 그 안의 `errorCode`)의 타입이나 `code` 값, 또는 표준 예외 타입(`OptimisticLockException`, `MethodArgumentNotValidException` 등)을 기반으로, 자체적인 매핑 로직(예: `when` 문, Map 등)을 통해 적절한 `HttpStatus`를 결정하고, 이를 사용하여 Rule 50에 따라 `ResponseEntity`를 생성하는 책임을 진다.** 또한, 예외 객체가 가진 `errorCode` 정보를 사용하여 RFC 9457 `ProblemDetail` 형식의 응답 본문을 구성한다. GlobalExceptionHandler에서 `errorCode` 정보에 접근하기 위해 Common 모듈의 `DomainException` (`domains/common/domain/exception/DomainException.kt` - Rule 141 준수) 및 `ApplicationException` (`domains/common/application/exception/ApplicationException.kt` - Rule 141 준수) 클래스에 `abstract val errorCode: ErrorCode` 추상 프로퍼티를 유지한다. GlobalExceptionHandler는 특히 Rule 68에서 정의된 Validation 관련 `DomainException` 하위 타입을 식별하여, Rule 48의 `invalid-params` 필드 등 유효성 검사 실패에 특화된 응답 상세를 포함할 수 있다. **Outbox 예외의 경우, 해당 예외 타입 및 포함된 에러 정보를 기반으로 `GlobalExceptionHandler` 내 매핑 로직을 통해 적절한 `HttpStatus` 및 `ProblemDetail`을 구성한다.**

#### 4.4. API 문서화 (Swagger)

53. **API 문서화 Swagger**: API 문서화는 `springdoc-openapi` 라이브러리를 사용하여 Swagger로 구현한다.
54. **Swagger 어노테이션**: Controller의 모든 엔드포인트는 `@Operation` (설명), `@ApiResponse` (응답), `@Parameter` (파라미터) 어노테이션을 적용한다.
55. **Swagger 에러 응답**: Swagger 문서는 RFC 9457 `ProblemDetail` 형식을 반영한다.

#### 4.5. API 버전 관리

57. **API 버전 관리**: API는 해당 도메인 모듈의 Presentation 레이어 경로 (`domains/{domain}/presentation/` - Rule 141 준수) 하위에 `/v1/` 접두사를 사용하여 버전을 관리하며, 이 버전별 경로 바로 아래에 CQRS 역할을 명확히 구분하는 **`command/` 및 `query/` 폴더 구조를 필수로 가진다**. 새로운 주요 변경 시 버전(`vX`)을 증가시킨다 (예: `/v2/command/...`).

#### 4.6. DTO 변환

58. **DTO 변환**: Presentation 레이어의 **요청 DTO (Rule 44에 명시된 위치)** 는 Application 레이어의 `command/dto` 또는 `query/dto`에 정의된 DTO로 변환되며, 이 변환은 Presentation 레이어의 해당 버전(`vX/command/extensions/dto/request/` 또는 `vX/query/extensions/dto/request/` - Rule 141 및 Rule 5 준수)의 확장 함수로 구현한다. Application 레이어의 `query/dto`에 정의된 Query Result DTO는 Presentation 레이어의 **응답 DTO (Rule 141.5의 `presentation/vX/query/dto/response/` 하위)** 로 변환되며, 이 변환은 Presentation 레이어의 해당 버전(`vX/query/extensions/dto/response/` - Rule 141 및 Rule 5 준수)의 확장 함수로 구현한다. **이러한 변환 함수는 Rule 5에 명시된 구조와 위치를 필수로 준수해야 한다.**
59. **DTO 변환 파일명**: DTO 변환 확장 함수 파일은 `{Domain}DtoExtensions.kt` 또는 `{Domain}RequestExtensions.kt` 형식을 따를 수 있다. **Presentation 레이어의 DTO 변환 확장 함수 파일명은 Rule 5 및 7에 따라 해당 구조를 반영하여 `UserCommandRequestExtensions.kt` (request to command DTO), `UserProfileQueryRequestExtensions.kt` (request to query DTO), `UserProfileQueryResponseExtensions.kt` (query result to response DTO) 등으로 명명해야 하며, 파일명은 해당 폴더 구조(command/query)의 의미를 포함하도록 명확하게 작성한다.**
60. **데이터 변환 일관성**: 모든 데이터 변환(예: DTO, 엔티티, Domain Entity/VO 간)은 확장 함수를 사용하며, 변환 로직은 단일 책임 원칙을 준수해야 한다. **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)** 변환 함수는 Domain ID (Value Object)와 Persistence ID (Long, UUID) 매핑을 처리해야 한다. **또한 Infrastructure 레이어는 Domain Event를 메시지 브로커(예: Kafka)로 전송하기 위한 페이로드로 변환하는 역할을 담당한다 (Rule 85, Rule VII.1 참조).**

### V. Infrastructure 계층 개발 원칙

#### 5.1. JPA 엔티티

##### 5.1.1. 위치 및 책임

19. **JPA 엔티티 위치**: JPA 엔티티는 반드시 해당 도메인 모듈의 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)의 `entity` 패키지**에 정의하며, 도메인 로직을 포함하지 않는다. `independent/outbox` 등 독립 모듈의 JPA 엔티티는 해당 모듈의 Infrastructure 레이어 (`independent/outbox/infrastructure/entity/` - Rule 80 참조, Rule 141 미적용)에 정의한다. JPA 엔티티는 Domain 모델과 1:1로 매핑되지 않고 영속화 구조를 반영한다. Domain ID (Value Object)와 JPA Long ID는 Infrastructure에서 매핑된다.
30. **JPA 도메인 로직 배제**: JPA 엔티티에는 비즈니스 로직을 포함시키지 않으며, 로직은 Domain 레이어의 Aggregate 또는 Domain Entity에서 처리한다.

##### 5.1.2. 불변성 및 Lazy Loading

20. **JPA 엔티티 불변성 및 Lazy Loading 공존**: JPA 엔티티의 기본 필드는 가능한 `val`로 선언하여 불변성을 유지하며, Setter 메서드는 절대 사용하지 않는다. 연관 관계 필드는 `@OneToMany`, `@ManyToOne` 등에 `fetch = FetchType.LAZY`를 설정한다. Hibernate 프록시를 통한 지연 로딩 시 Kotlin `val` 필드 접근 문제가 발생할 수 있으므로, 영속성 컨텍스트 외부에서 사용하거나 성능 최적화가 필요한 경우 Projection (인터페이스 기반 DTO) 또는 EntityGraph를 사용하여 필요한 데이터를 명시적으로 조회하도록 설계한다. `lateinit var`나 `@JvmField` 사용은 최소화하고 신중하게 적용한다. `kotlin-jpa` 및 `kotlin-allopen` 플러그인을 반드시 적용한다. JPA 엔티티 클래스 자체에는 `@ConsistentCopyVisibility` 어노테이션을 사용하지 않는다.

##### 5.1.3. ID 필드

21. **JPA 엔티티 ID 필드**: JPA 엔티티는 DB 자동 생성 키에 매핑되는 `val id: Long? = null` 필드와 함께, Domain 모델의 고유 식별자(예: `UserId` Value Object가 캡슐화한 `UUID`)에 매핑되는 `val domainId: UUID`와 같은 필드를 포함해야 한다.

##### 5.1.4. 테이블명 및 컬럼 속성

22. **JPA 엔티티 테이블명**: JPA 엔티티의 테이블명은 `@Table` 어노테이션으로 명시하며, 소문자 복수형을 사용한다 (예: `@Table(name = "users")`).
23. **JPA 엔티티 컬럼 속성**: JPA 엔티티의 컬럼은 `@Column` 어노테이션으로 제약 조건을 명시하며, 데이터베이스 스키마와 일치해야 한다 (예: `@Column(nullable = false, length = 50)`).
63. **데이터베이스 스키마 일치**: JPA 엔티티의 `@Table`, `@Column` 정의는 데이터베이스 스키마와 1:1로 일치해야 하며, 스키마 변경 시 엔티티를 동기화한다.

##### 5.1.5. 관계 설정 및 Fetch 전략

26. **JPA 관계 설정**: JPA 엔티티의 관계는 단방향을 우선하며, 양방향 관계는 명확한 필요성(예: 비즈니스 요구사항)이 있을 때만 사용한다.
27. **JPA Fetch 전략**: JPA 엔티티 관계는 기본적으로 `@ManyToOne`, `@OneToMany` 등에 `fetch = FetchType.LAZY`를 설정하며, Eager 로딩은 성능 검증 후 사용한다. Repository 메서드에 `@EntityGraph`를 사용하여 필요한 연관 엔티티를 함께 로딩한다.
62. **JPA 엔티티 관계 Lazy 로딩**: JPA 엔티티 관계는 `FetchType.LAZY`를 기본으로 설정하며, 관계 접근 시 N+1 문제를 방지하기 위해 `@EntityGraph` 또는 JPQL, Projection을 사용한다. Repository 메서드에서 Domain 객체로 변환 시 연관 객체가 필요한 경우, `@EntityGraph`를 사용하여 Eager 로딩하고 Domain 객체로 변환한다.

##### 5.1.6. Kotlin 플러그인

28. **JPA Kotlin 플러그인**: `kotlin-jpa`와 `kotlin-allopen` 플러그인을 반드시 적용하여 JPA 요구사항을 충족한다.

##### 5.1.7. 동시성 제어

31. **JPA 동시성 제어**: 모든 JPA 엔티티는 낙관적 잠금을 기본으로 사용하며, `@Version` 어노테이션을 필수로 포함하여 동시성 충돌을 관리한다. 낙관적 잠금 실패 시 발생하는 `OptimisticLockException`은 상위 레이어(Presentation/GlobalExceptionHandler)로 전파되어 일관된 응답으로 변환된다.

#### 5.2. 데이터 변환 (JPA 엔티티와 도메인 매핑)

24. **JPA 엔티티와 도메인 매핑**: JPA 엔티티와 도메인 Aggregate/Entity/VO 간 변환은 해당 도메인 모듈의 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)의 `mapper` (또는 `extensions`) 폴더**에서 코틀린 확장 함수로 정의한다 (예: `UserEntity.toDomain()`). 이 변환 함수는 Domain ID (Value Object)와 Persistence ID (Long, UUID) 간의 매핑을 처리해야 한다. (규칙 60의 일부)
25. **JPA 매핑 파일명**: JPA 매핑 확장 함수 파일은 `{Domain}EntityMapper.kt` 또는 `{Domain}EntityExtensions.kt` 형식을 따라야 한다 (예: `UserEntityMapper.kt`).

#### 5.3. 리포지토리 (Repository)

##### 5.3.1. 인터페이스 정의

137. **리포지토리 인터페이스 정의**: Domain 레이어의 리포지토리 (`domains/{domain}/domain/repository/` - Rule 141 준수)는 순수한 인터페이스 역할을 수행하며, 특정 영속화 기술에 종속되지 않는 인터페이스로 정의한다 (예: `UserRepository`). 이 인터페이스는 Domain 모델 객체 (Immutable Aggregate의 경우 업데이트된 상태를 반영하는 *새로운 인스턴스*)를 반환/사용해야 한다.

##### 5.3.2. 구현체 위치 및 네이밍

138. **리포지토리 구현체 위치**: Domain 레이어 (`domains/{domain}/domain/` - Rule 141 준수)에서 정의된 리포지토리 인터페이스의 실제 구현체는 해당 도메인 모듈의 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)의 `repository` 패키지**에 위치한다.
139. **리포지토리 구현체 네이밍 및 책임**: **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)의 `repository` 패키지**에 위치한 리포지토리 구현체는 사용하는 기술 스택을 명시하는 접미사를 붙인다 (예: Spring Data JPA 사용 시 `SpringDataJpaUserRepository`, 커스텀 구현 시 `UserRepositoryImpl`). `SpringDataJpaUserRepository`는 Spring Data JPA가 요구하는 인터페이스를 상속받고, `UserRepositoryImpl`은 Domain 레이어의 `UserRepository` 인터페이스를 구현하며 `SpringDataJpaUserRepository`와 독립적인 `independent/outbox` 모듈의 Outbox 메시지 저장 Repository 인터페이스(Rule 81 참조), **그리고 동일 도메인 모듈 Infrastructure 레이어의 이벤트 변환 컴포넌트(예: `DomainEventToOutboxMessageConverter` - Rule 85 참조)** 를 주입받아 사용한다. Repository 구현체는 JPA Entity 저장 시 Rule 85에 따라 Aggregate에서 발생한 Domain Events를 읽어와 **이벤트 변환 컴포넌트(`DomainEventToOutboxMessageConverter`)에 전달하여, 메시지 브로커(예: Kafka) 전송을 위한 `OutboxMessage` 객체 목록을 생성하고**, 이를 독립적인 `independent/outbox` 모듈의 `OutboxMessageRepository` (Rule 80 참조)를 통해 저장한다. JPA Entity 저장 후 반환된 Entity를 Domain Aggregate (Immutable Aggregate의 경우 *새로운 인스턴스*)로 변환하여 Domain Repository 인터페이스의 `save` 메서드 반환 타입 요구사항을 만족해야 한다. 또한 Domain 객체 (Domain ID Value Object 포함)와 JPA Entity 간의 변환을 담당하며, **Rule 85에 명시된 대로 이벤트 처리 위임 및 Outbox 저장 로직**을 포함한다. 조회 시에는 Domain ID (Value Object가 캡슐화한 UUID)를 사용하여 JPA Entity의 `domainId` 필드를 조회하는 쿼리 메서드를 정의하고 사용한다.

##### 5.3.3. JPA 리포지토리 사용

140. **JPA 리포지토리 사용**: Spring Data JPA 등의 기술별 리포지토리 인터페이스는 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)의 `repository` 패키지**에서 정의하고 사용한다 (예: `interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long>`). Domain 레이어는 이 기술별 인터페이스나 구현체를 직접 참조하지 않는다. Repository 구현체는 이 기술별 인터페이스를 사용하여 실제 DB 접근을 수행한다.

### VI. 트랜잭셔널 아웃박스 패턴

78. **트랜잭셔널 아웃박스 패턴 도입**: 애플리케이션 상태 변경과 이벤트 발행의 원자성 보장을 위해 트랜잭셔널 아웃박스 패턴을 사용한다. Domain Aggregate에서 발생한 이벤트는 Repository를 통해 저장 시 Database의 Outbox 테이블에 함께 기록된다.
79. **독립적인 Outbox 모듈 정의**: Outbox 패턴 구현 및 관리를 위해 프로젝트 최상위 레벨의 `independent/` 폴더 내에 별도의 독립 모듈(예: `independent/outbox/` - Rule 80 참조, Rule 141 미적용)을 정의한다.
80. **Outbox 모듈 책임 및 독립성**: Outbox 모듈 (`independent/outbox/`)은 도메인 이벤트를 담고 있는 메시지(`OutboxMessage`)의 데이터베이스 저장, 주기적인 조회, 메시지 브로커 전송 처리, 관련 상태 관리 및 오류 처리를 담당한다. 이 모듈은 자체적인 레이어 구조(application, infrastructure 등)를 가질 수 있으며, **프로젝트 내의 어떤 특정 도메인 모듈 또는 `domains/common` 모듈에도 의존하지 않아 (규칙 9 참조) 완전한 독립성과 이식성을 보장해야 합니다. Kafka 메시징에는 `org.springframework.kafka:spring-kafka` 라이브러리의 `KafkaTemplate<String, String>`을 사용하며, 메시지 값(value)은 Kotlinx Serialization으로 직렬화된 JSON 문자열이므로 프로듀서 측에서는 `org.apache.kafka.common.serialization.StringSerializer`를 사용합니다.** `independent/outbox` 모듈의 Infrastructure 레이어는 `spring-kafka`, `kafka-clients` 라이브러리에 의존할 수 있습니다. Outbox 모듈 자체는 특정 JSON 스키마 정의를 포함하지 않고, 범용적인 `String` 페이로드(Kotlinx Serialization으로 직렬화된 JSON)를 처리합니다 (Rule VII.1 참조). Outbox 모듈은 자체적인 예외(`OutboxException`) 및 에러 코드 체계를 각각 **해당 모듈의 Infrastructure 레이어 내 `exception` 및 `error` 패키지** (`independent/outbox/infrastructure/exception/`, `independent/outbox/infrastructure/error/` - Rule 67, 68, 90 참조) 내에 정의하고 사용한다.
81. **Outbox 메시지 저장 Repository 인터페이스 및 메시지 구조 정의**: Outbox 모듈의 Application 레이어 내 DTO 패키지 (`independent/outbox/application/dto/` - Rule 80 참조, Rule 141 미적용)에 Outbox에 저장될 메시지 목록 저장을 위한 기술 독립적인 Repository 인터페이스를 정의한다 (예: `OutboxMessageRepository.kt`). 이 인터페이스는 `List<OutboxMessage>`를 받아 저장하는 메서드를 제공해야 한다. 저장될 메시지의 구조는 `OutboxMessage` data class로 정의하며, 이는 `independent/outbox/application/dto/OutboxMessage.kt` (Rule 80 참조, Rule 141 미적용)에 위치한다. `OutboxMessage`는 메시지 브로커 전송에 필요한 모든 정보(payload `String` (Kotlinx Serialization으로 직렬화된 이벤트 객체의 JSON 문자열), target topic name `String`, headers `Map<String, String>` - including `aggregateType`, `aggregateId` (String), event type name, `contentType` (예: `application/json`) 등)를 포함해야 하며, 프로젝트의 `DomainEvent` 인터페이스나 특정 도메인의 구체적인 `DomainEvent` 클래스에 의존하지 않는다 (Rule VII.1 참조). `aggregateId` 필드 값은 Kafka 메시지의 키로 사용된다.
82. **Outbox 메시지 저장 Repository 구현체**: Outbox 메시지 저장 Repository 인터페이스의 구현체는 Outbox 모듈의 Infrastructure 레이어 내 repository 패키지 (`independent/outbox/infrastructure/repository/` - Rule 80 참조, Rule 141 미적용)에 위치한다 (예: `JpaOutboxMessageRepository.kt`). 이 구현체는 JPA 등의 기술을 사용하여 `OutboxEventEntity`를 데이터베이스에 저장하는 로직을 포함한다. `OutboxMessage`를 받아 `OutboxEventEntity`로 변환하여 저장한다.
83. **Outbox 이벤트 엔티티**: Outbox 메시지를 저장하기 위한 `OutboxEventEntity`는 Outbox 모듈의 Infrastructure 레이어 내 entity 패키지 (`independent/outbox/infrastructure/entity/OutboxEventEntity.kt` - Rule 80 참조, Rule 141 미적용)에 정의한다. 이 엔티티는 Rule 81의 `OutboxMessage` 구조에 대응하여 최소한 이벤트 payload (`String` (Kotlinx Serialization으로 직렬화된 JSON 문자열)), 이벤트 타입명(`String`), 타겟 토픽명(`String`), 헤더(`Map<String, String>`), 생성 시간, 상태 (Pending, Sent, Failed 등), 재시도 횟수 등을 포함해야 한다 (Rule VII.1 참조).
84. **리포지토리 구현체의 Outbox 의존성**: 각 도메인의 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)** 에 위치한 Repository 구현체(예: `domains/user/infrastructure/repository/UserRepositoryImpl.kt`)는 독립적인 `independent/outbox` 모듈의 Outbox 메시지 저장 Repository 인터페이스 (`OutboxMessageRepository` - `independent/outbox/application/dto/` - Rule 80 참조, Rule 141 미적용)를 의존성으로 주입받아 사용한다.
85. **Repository 저장 시 이벤트 처리 및 메시지 변환 책임**: Repository 구현체(**Infrastructure 레이어** - `domains/{domain}/infrastructure/` - Rule 141 준수)는 Aggregate 저장 시, 해당 Aggregate의 `aggregateRoot.getDomainEvents()` 메서드를 통해 발생한 이벤트 목록을 읽어온다. **이 이벤트 목록을 동일 도메인 모듈의 Infrastructure 레이어 내 `mapper` 패키지 (`domains/{domain}/infrastructure/mapper/DomainEventToOutboxMessageConverter.kt` - Rule 141 준수)에 정의된 컴포넌트(예: `DomainEventToOutboxMessageConverter`)에 전달하여, 해당 컴포넌트가 각 `DomainEvent` 객체에 대해 다음을 수행하여 `OutboxMessage` 객체를 생성하도록 해야 한다:**
    1.  **`DomainEvent` 객체 (Rule 33, 34에 따라 정의된 `@Serializable` `data class`)를 Kotlinx Serialization 라이브러리(`org.jetbrains.kotlinx:kotlinx-serialization-json`)를 사용하여 JSON 문자열로 직렬화하여 `OutboxMessage`의 `payload`를 생성한다 (Rule VII.1 참조).**
    2.  타겟 메시지 브로커 토픽명을 결정한다. (Rule VII.2.6 참조)
    3.  메시지 헤더 정보(aggregateType, aggregateId, eventTypeName, **`contentType` (예: `application/json`)** 등)를 준비한다. aggregateId는 Aggregate의 Domain ID Value Object의 문자열 표현을 사용한다.
    4.  Rule 81에 정의된 `OutboxMessage` 객체 (`independent/outbox/application/dto/OutboxMessage.kt` - Rule 80 참조)를 생성한다.
    준비된 `OutboxMessage` 객체 목록을 동일 트랜잭션 내에서 독립적인 `independent/outbox` 모듈의 Outbox 메시지 저장 Repository (`outboxMessageRepository.save(listOfOutboxMessages)`)를 호출하여 저장해야 한다. 이벤트 저장이 완료된 후에는 `aggregateRoot.clearDomainEvents()`를 호출하여 Aggregate 내부의 이벤트 목록을 초기화해야 한다.
86. **Outbox 폴링/전송 컴포넌트**: Outbox 모듈의 Application 레이어 (`independent/outbox/application/` - Rule 80 참조, Rule 141 미적용)에 Outbox 테이블에서 이벤트를 주기적으로 조회하는 컴포넌트(예: `OutboxPoller.kt`)를 구현하고, Infrastructure 레이어 (`independent/outbox/infrastructure/messaging/` - Rule 80 참조)에 조회된 메시지를 메시지 브로커로 전송하는 `OutboxMessageSender.kt` (Rule 88 참조, `KafkaTemplate<String, String>` 사용)를 구현한다.
87. **Outbox 폴링 동시성 제어**: Outbox 폴러는 여러 인스턴스가 동시에 실행될 수 있으므로, 이벤트를 읽어올 때 데이터베이스 수준의 잠금(`FOR UPDATE SKIP LOCKED` 등)을 사용하여 동일한 이벤트가 여러 번 처리되지 않도록 해야 한다. 이 로직은 `independent/outbox` 모듈 내에서 관리된다 (Rule 80 참조).
88. **Outbox 메시지 전송**: `independent/outbox` 모듈의 Infrastructure 레이어에 위치한 `OutboxMessageSender`는 `OutboxEventEntity`를 읽어와 `OutboxMessage` 객체를 재구성한다. **`org.springframework.kafka.core.KafkaTemplate<String, String>`을 사용하여 `OutboxMessage` (payload는 Kotlinx Serialization으로 직렬화된 JSON 문자열)를 해당 `OutboxEventEntity`에 저장된 target topic으로 전송한다. 메시지 키는 `OutboxMessage.aggregateId` 값을 사용한다. 메시지 헤더에는 `OutboxMessage.headers` 맵의 내용과 함께 `outbox-message-id`, `aggregate-type`, `event-type`, `created-at` 등의 표준 메타데이터를 `org.apache.kafka.common.header.internals.RecordHeader` 형태로 추가하여 전송한다.** `OutboxMessageSender`는 특정 도메인 이벤트 타입이나 특정 직렬화 스키마를 직접 참조하지 않는다. 필요한 메시지 브로커 관련 설정은 `independent/outbox` 모듈의 `application.yml` (또는 이에 준하는 설정 파일) 내 `spring.kafka.*` 설정을 통해 관리되며, 프로듀서의 값(value) 직렬화기는 `org.apache.kafka.common.serialization.StringSerializer`를 사용한다 (Rule 80, Rule VII.1, Rule VII.2.17 참조). 전송 결과는 `CompletableFuture`로 처리되며, 실패 시 예외 로깅 및 재발생 처리한다.
89. **Outbox 이벤트 상태 업데이트**: Outbox 프로세서는 메시지 전송 결과에 따라 Outbox Event Entity (`independent/outbox/infrastructure/entity/OutboxEventEntity.kt` - Rule 80 참조)의 상태를 업데이트한다.
90. **Outbox 프로세서 재시도/실패 처리**: Outbox 프로세서의 메시지 전송 실패는 `independent/outbox` 모듈 내에서 정의된 재시도 정책에 따른다 (Rule 80 참조). `OutboxEventEntity`의 `retryCount` 필드를 증가시키며 지수 백오프(exponential backoff) 등 적절한 간격으로 재시도를 수행한다. 정의된 최대 재시도 횟수를 초과한 이벤트는 DLQ로 보내거나 별도의 실패 테이블/메커니즘으로 관리한다. 실패 처리 시 **`independent/outbox` 모듈의 Infrastructure 레이어 내 `exception` 패키지 (`independent/outbox/infrastructure/exception/` - Rule 80 참조) 내에서 정의된 자체 예외 및 Infrastructure 레이어 내 `error` 패키지 (`independent/outbox/infrastructure/error/` - Rule 80 참조) 내에서 정의된 에러 코드**를 사용한다.

### VII. 메시징 시스템 (Kafka - Kotlinx Serialization 및 JSON Schema 기반)

#### VII.1. Kotlinx Serialization 및 JSON Schema 기반 메시징 원칙 및 워크플로우 (Spring for Apache Kafka 기반)

##### VII.1.1. 개요 및 핵심 철학

*   **VII.1.1.1. 이벤트 객체 중심**: 코틀린 `data class` (주로 `@Serializable` 어노테이션이 적용된 `DomainEvent` - Rule 33, 34 참조)를 Kafka 메시지 내용의 핵심으로 삼는다.
*   **VII.1.1.2. 스키마 생성 및 관리 방식**: 코틀린 `data class`를 먼저 정의한다. JSON 스키마(`.json` 파일)는 **`buildSrc/src/main/kotlin/GenerateJsonSchemaTask.kt`에 정의된 `GenerateJsonSchemaTask` Gradle 태스크에 의해 생성된다.** 이 태스크는 **내부에 하드코딩된 JSON Schema 정의 맵(Map)을 기반으로** 스키마 파일을 출력한다. 따라서, **Kotlin 이벤트 클래스의 실제 구조와 JSON 스키마 내용은 개발자가 수동으로 일치시켜야 한다.** 생성된 스키마는 Confluent Schema Registry에 등록되며, 주로 메시지 소비 과정에서 스키마 유효성 검증에 활용될 수 있다.
*   **VII.1.1.3. 주요 장점 및 고려사항**: 스키마 기반의 메시지 유효성 검증(주로 컨슈머 측), 스키마 진화 관리 용이성 (Schema Registry 활용 시). 단, 스키마가 코드로부터 자동 생성되지 않으므로, 코드와 스키마 간의 불일치 위험을 인지하고 관리해야 한다.

##### VII.1.2. 주요 기술 및 라이브러리

*   **VII.1.2.1. 필수 라이브러리**:
    *   `org.springframework.kafka:spring-kafka`: Spring 애플리케이션 내 Kafka 프로듀서 및 컨슈머 개발 간소화.
    *   `org.apache.kafka:kafka-clients`: Kafka 클러스터와 직접 통신하기 위한 저수준 공식 클라이언트.
    *   `org.jetbrains.kotlinx:kotlinx-serialization-json`: Kotlin 객체의 JSON 직렬화/역직렬화.
    *   `org.jetbrains.kotlin:kotlin-reflect`: `GenerateJsonSchemaTask`에서 Kotlin 클래스 정보를 로드하는 데 필요할 수 있음.
    *   `io.confluent:kafka-schema-registry-client`: Confluent Schema Registry 연동 클라이언트 (주로 컨슈머 측 또는 Gradle 플러그인에서 사용).
    *   `io.confluent:kafka-json-schema-serializer` / `io.confluent:kafka-json-schema-deserializer`: Kafka 메시지 값을 JSON 스키마에 맞춰 직렬화/역직렬화 (프로듀서는 `StringSerializer` 사용, 컨슈머는 `StringDeserializer` 후 수동 파싱 또는 `KafkaJsonSchemaDeserializer` 사용 가능).
    *   `com.github.imflog:kafka-schema-registry-gradle-plugin`: Gradle 빌드 과정에서 스키마 레지스트리 작업(등록, 호환성 검사 등) 자동화.
    *   Kotlin (2.x 이상 권장), Confluent Kafka (7.x 이상, Kafka 브로커 및 Schema Registry), Gradle.

##### VII.1.3. 주요 빌드 및 메시징 워크플로우

*   **VII.1.3.1. `DomainEvent` `data class` 정의**:
    *   `DomainEvent`는 Rule 33 및 Rule 34에 따라 코틀린 `data class`로 정의하며, Kotlinx Serialization 라이브러리가 JSON으로 직렬화/역직렬화할 수 있도록 `@Serializable` 어노테이션을 사용한다.
    *   Optional 필드는 nullable(`?`)로, 기본값 지정이 가능하다.
    *   `type` 필드는 이벤트 타입을 구분하는 식별자 역할을 하며, Kotlinx Serialization의 다형성 처리에 사용될 수 있다. 이 `type` 필드 값에 따라 요구되는 추가 필드가 JSON 스키마에 정의된다.
*   **VII.1.3.2. 빌드 시점 JSON 스키마 생성 (Gradle 태스크)**:
    *   각 도메인 모듈의 `build.gradle.kts` 파일에서 `buildSrc`에 정의된 `GenerateJsonSchemaTask` (예: `tasks.register<GenerateJsonSchemaTask>("generateUserEventJsonSchema") { ... }`)를 호출하여 JSON 스키마(`.json` 파일)를 생성한다.
    *   **`GenerateJsonSchemaTask` (`buildSrc/src/main/kotlin/GenerateJsonSchemaTask.kt`)는 Kotlin 이벤트 데이터 클래스를 로드하고 `kotlinx.serialization` 호환성을 검증할 수 있으나, 핵심적으로는 태스크 코드 내에 하드코딩된 JSON Schema 정의 맵(Map)을 읽어 지정된 경로에 `.json` 파일로 출력한다.**
    *   생성된 JSON 스키마는 해당 도메인 모듈의 `infrastructure/src/main/resources/schemas/` 디렉토리 (예: `domains/user/infrastructure/src/main/resources/schemas/user_event.json`)에 저장된다 (Rule 141.5 준수).
    *   이 태스크는 `processResources` 태스크 이전에 실행되도록 의존성을 설정한다.
    *   **주의: Kotlin 이벤트 클래스의 변경 사항은 `GenerateJsonSchemaTask.kt` 내의 하드코딩된 스키마 정의에 수동으로 반영해야 한다.**
*   **VII.1.3.3. CI/CD를 통한 Schema Registry 등록 및 호환성 검사 (Gradle 플러그인)**:
    *   루트 또는 각 도메인 모듈의 `build.gradle.kts`에 `com.github.imflog.kafka-schema-registry-gradle-plugin` (예: 버전 2.3.2)을 설정한다.
    *   플러그인의 `register` 태스크(예: `registerSchemasTask`)는 VII.1.3.2에서 생성된 `.json` 스키마 파일을 읽어 Confluent Schema Registry (예: 개발 환경 `http://localhost:8081`)에 자동으로 등록한다.
    *   Schema Registry의 Subject Naming Strategy를 고려하여 Subject 이름을 결정한다 (예: **`dev.user-team.user.event.user-created-value`**). 스키마 타입은 `JSON`으로 명시한다.
    *   플러그인 설정에서 스키마 호환성 검사 규칙(예: `BACKWARD`)을 지정하여, 스키마 등록 시 기존 버전과의 호환성을 자동으로 검사한다. 호환성 위반 시 빌드가 실패하도록 설정한다.
    *   이 태스크는 `generateJsonSchema` 태스크 완료 후에 실행되도록 의존성을 설정하며 (예: `registerSchemasTask.dependsOn(generateUserEventJsonSchema)`), 애플리케이션 빌드(JAR 패키징) 이전에 실행되어야 한다.
*   **VII.1.3.4. Kafka 메시지 발행 (페이로드 직렬화 및 `KafkaTemplate`을 통한 전송)**:
    *   **`DomainEventToOutboxMessageConverter` 책임 (Rule 85 수정사항 반영)**: 해당 도메인의 Infrastructure 레이어 (`domains/{domain}/infrastructure/mapper/`)에 위치한 `DomainEventToOutboxMessageConverter`는 `@Serializable` `DomainEvent` `data class` 인스턴스를 Kotlinx Serialization의 `Json` 객체를 사용하여 JSON 문자열로 직렬화한다. 이 결과물은 `OutboxMessage`의 `payload` 필드에 저장되며, `OutboxMessage` 헤더에는 `contentType`으로 `application/json`을 명시한다.
    *   **`OutboxMessageSender` 책임 (Rule 88 수정사항 반영)**: `independent/outbox` 모듈의 Infrastructure 레이어 (`independent/outbox/infrastructure/messaging/`)에 위치한 `OutboxMessageSender`는 `OutboxEventEntity`로부터 Kotlinx Serialization으로 직렬화된 JSON 페이로드(문자열)와 헤더 정보를 읽어온다. `org.springframework.kafka.core.KafkaTemplate<String, String>`을 사용하여 Kafka 메시지를 전송한다. 메시지 키는 `OutboxMessage.aggregateId`를, 값은 `OutboxMessage.payload` (JSON 문자열)를 사용한다. Rule 88에 명시된 표준 헤더들이 추가된다.
    *   **`spring-kafka` Producer 설정 (`application.yml`)**:
        *   `spring.kafka.bootstrap-servers`: Kafka 브로커 주소 설정.
        *   `spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer`.
        *   `spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer`.
        *   `spring.kafka.producer.properties.schema.registry.url`: Schema Registry 주소 설정 (Gradle 플러그인 및 컨슈머 측에서 주로 사용).
        *   `spring.kafka.producer.properties.auto.register.schemas=false` (스키마 등록은 Gradle 플러그인이 담당).
        *   `spring.kafka.producer.properties.use.latest.version=true` (컨슈머가 스키마 레지스트리 사용 시 영향).
        *   기타 필요한 Kafka Producer 속성을 `spring.kafka.producer.properties` 하위에 설정한다.
*   **VII.1.3.5. Kafka 메시지 소비 및 `data class`로 역직렬화 (`@KafkaListener` 방식)**:
    *   **동일 `DomainEvent` `@Serializable` `data class` 사용**: 발행 측과 동일한 `DomainEvent` `data class` 정의 (Rule 33, 34)를 소비 측 애플리케이션(해당 도메인의 Infrastructure 레이어 또는 다른 도메인 모듈)에서도 사용한다.
    *   **`spring-kafka` Consumer 설정 (`application.yml`)**:
        *   `spring.kafka.bootstrap-servers`: Kafka 브로커 주소 설정.
        *   `spring.kafka.consumer.group-id`: Consumer group 설정.
        *   `spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer`.
        *   `spring.kafka.consumer.value-deserializer`:
            *   `org.apache.kafka.common.serialization.StringDeserializer`: JSON 문자열로 받은 후, Kotlinx Serialization (`Json.decodeFromString`)을 사용하여 수동으로 `data class`로 역직렬화.
            *   또는 `io.confluent.kafka.serializers.json.KafkaJsonSchemaDeserializer`: Schema Registry를 통해 스키마를 가져와 유효성 검사 및 역직렬화 수행. 이 경우 `spring.kafka.consumer.properties.json.value.type`에 소비하려는 `data class`의 FQCN (예: `com.restaurant.user.domain.event.UserEvent.Created`)을 명시하거나 `@KafkaListener`에서 타입 정보를 제공해야 한다.
        *   `spring.kafka.consumer.properties.schema.registry.url`: `KafkaJsonSchemaDeserializer` 사용 시 Schema Registry 주소 설정.
        *   기타 필요한 Kafka Consumer 속성을 `spring.kafka.consumer.properties` 하위에 설정한다.
    *   **`@KafkaListener` 기반 메시지 핸들러**:
        *   해당 도메인 모듈의 `infrastructure/messaging/` 패키지 (Rule 141.5 참조)에 `@KafkaListener` 어노테이션을 사용하여 메시지 컨슈머를 정의한다.
        *   예시 (`StringDeserializer` 사용 시): `@KafkaListener(topics = "dev.user-team.user.event.user-created", groupId = "my-group") fun handleUserEvent(jsonPayload: String) { val event = Json.decodeFromString<UserEvent.Created>(jsonPayload); /* 로직 처리 */ }`.
        *   예시 (`KafkaJsonSchemaDeserializer` 사용 시): `@KafkaListener(topics = "dev.user-team.user.event.user-created", groupId = "my-group") fun handleUserEvent(event: UserEvent.Created) { /* 로직 처리 */ }`.
        *   `KafkaJsonSchemaDeserializer`는 Schema Registry 정보를 활용하여 수신된 JSON 메시지를 지정된 `data class` 타입으로 자동 역직렬화한다. 프로듀서가 스키마 ID를 포함하지 않으므로, 컨슈머는 토픽명 기반의 서브젝트 이름 조회 전략을 사용해야 한다.

##### VII.1.4. 컴파일 타임 및 빌드 타임 검증 메커니즘

*   **VII.1.4.1. 코틀린 컴파일러 타입 체크**: `@Serializable` `data class` 필드 참조 오류, 타입 불일치 등은 코틀린 컴파일러가 컴파일 시점에 감지한다.
*   **VII.1.4.2. CI/CD 빌드 파이프라인의 스키마 호환성 검증**: Gradle 플러그인(`kafka-schema-registry-gradle-plugin`)을 통해 `GenerateJsonSchemaTask.kt`에서 생성된 JSON 스키마와 Schema Registry의 기존 스키마 간 호환성을 빌드 시점에 검증한다. 불일치 시 빌드를 실패시켜 런타임 오류를 사전에 방지한다. **단, 이는 스키마 파일 자체의 호환성을 검증하는 것이며, Kotlin `data class`와 `GenerateJsonSchemaTask.kt` 내 하드코딩된 스키마 정의 간의 불일치는 감지하지 못한다.**

##### VII.1.5. 한계점 및 주의사항

*   **VII.1.5.1. 의미론적 변경 감지 불가**: 필드 타입/이름/필수 여부 변경 없이 값의 의미만 변경되는 경우는 자동화된 스키마 검증으로 감지할 수 없다. 이는 통합 테스트, 계약 테스트 등으로 보완해야 한다.
*   **VII.1.5.2. 환경 설정 오류**: `schema.registry.url`, `bootstrap.servers` 등 Kafka 관련 환경 설정 오류는 여전히 런타임에 발생할 수 있다.
*   **VII.1.5.3. 코드-스키마 수동 동기화**: JSON 스키마가 `GenerateJsonSchemaTask.kt` 내 하드코딩된 맵에서 생성되므로, Kotlin `DomainEvent` `data class`의 변경 사항은 반드시 `GenerateJsonSchemaTask.kt`의 스키마 정의에도 수동으로 반영되어야 한다. 이 동기화가 누락될 경우, 스키마 레지스트리에 등록된 스키마와 실제 메시지 페이로드 구조 간의 불일치로 인해 컨슈머 측에서 역직렬화 오류 또는 데이터 유실이 발생할 수 있다.

#### VII.2. Kafka 메시징 시스템 일반 원칙 (`spring-kafka` 기반)

*   **VII.2.1. 메시징 시스템**: 외부 시스템과의 통신을 위한 메시징 시스템으로 Apache Kafka를 사용한다.
*   **VII.2.2. Kafka 클라이언트**: `Spring for Apache Kafka (org.springframework.kafka:spring-kafka)` 라이브러리를 사용하여 Kafka와 연동하며, `independent/outbox` 모듈의 `OutboxMessageSender`는 `KafkaTemplate<String, String>`을 사용한다. 관련 설정은 주로 메시지 발행을 담당하는 `independent/outbox` 모듈 (Rule 80, Rule VII.1 참조) 또는 메시지 소비를 담당하는 모듈 (해당 도메인 `infrastructure` 레이어 등 - Rule 141 준수, Rule VII.1.3.5 참조)의 `application.yml` (또는 이에 준하는 설정 파일) 및 Java/Kotlin 설정 클래스(`@Configuration` 빈 정의 등)에서 이루어진다.
*   **VII.2.3. Kafka 사용 범위**: 모든 도메인 이벤트 발행(Aggregate 내 `addDomainEvent`로 추가된 이벤트)은 트랜잭셔널 아웃박스 패턴을 통해 처리된다. Database의 Outbox 테이블에 이벤트가 기록된 후, `independent/outbox` 모듈의 프로세서 (Rule 80, 86 참조)가 이를 조회하여 `KafkaTemplate<String, String>`을 통해 Kafka 토픽으로 전송한다 (Rule VII.1 참조). Kafka는 내부 및 외부 시스템 간의 비동기/이벤트 기반 통신 채널로 사용된다.
*   **VII.2.4. 분산 트랜잭션**: 분산 트랜잭션 처리가 필요한 경우 Saga 패턴을 적용하며, 상태 변경 명령과 보상 트랜잭션을 Kafka 이벤트를 통해 전달한다. Saga 오케스트레이션/코레오그래피는 `independent/outbox` 패턴 (Rule 80 참조)을 통해 메시지를 발행한다.
*   **VII.2.5. 요청-응답 패턴**: Kafka를 사용한 동기적 요청-응답 패턴은 `spring-kafka`의 `ReplyingKafkaTemplate` 또는 별도 HTTP API 연동을 고려하며, 비동기 이벤트는 `independent/outbox` 모듈 (Rule 80 참조)을 통해 `KafkaTemplate<String, String>`을 사용하여 Kafka 토픽으로 발행한다.
*   **VII.2.6. Kafka 토픽 이름**: Kafka 토픽 이름은 다음 형식을 **반드시** 따른다: **`{environment}.{team}.{domain}.{data-type}[.{action}]`**. 예를 들어, `user` 도메인의 `UserCreated` 이벤트는 **`dev.user-team.user.event.user-created`** 와 같이 명명될 수 있다. 토픽명 결정 및 메시지 구성은 Rule 85에 따라 해당 도메인 모듈의 **Infrastructure 레이어 (`domains/{domain}/infrastructure/` - Rule 141 준수)** 에서 수행되어 `OutboxMessage`에 포함되며, `KafkaTemplate.send(topic, ...)` 호출 시 또는 `@KafkaListener(topics = "...")` 어노테이션에 이 토픽명이 사용된다.
*   **VII.2.7. 토픽 네이밍 컨벤션 - environment**: `environment`는 운영 환경을 나타낸다 (예: `prod`, `staging`, `dev`).
*   **VII.2.8. 토픽 네이밍 컨벤션 - domain**: `domain`은 도메인 이름을 나타낸다 (예: `user`, `order`, `payment`).
*   **VII.2.9. 토픽 네이밍 컨벤션 - team**: **`team`은 해당 메시지를 발행하는 주체인 팀 또는 조직을 소문자로 명시한다 (예: `user-team`, `order-team`, `payment-gateway`).**
*   **VII.2.10. 토픽 네이밍 컨벤션 - data-type**: **`data-type`은 메시지가 담고 있는 데이터의 유형을 명시한다 (예: `event`, `command`, `saga`, `notification`).**
*   **VII.2.11. 토픽 네이밍 컨벤션 - action**: **`action`은 [선택사항]으로, 메시지의 구체적인 행위나 이벤트의 종류를 나타낸다. 분리 토픽 전략(Rule VII.2.20)에 따라 이벤트 유형별로 토픽을 생성할 때 사용된다 (예: `user-created`, `order-paid`, `start-shipping`).**
*   **VII.2.12. 외부 도메인 이벤트 토픽**: 외부 시스템으로 발행되는 도메인 이벤트는 `data-type`을 `event`로 한정한다.
*   **VII.2.13. Kafka 토픽 이름 제약**: Kafka 토픽 이름은 소문자와 하이픈(`-`)만 사용하고, 최대 249자로 제한한다.
*   **VII.2.14. Saga 토픽 네이밍**: Saga 패턴 관련 Kafka 토픽은 `data-type`을 `saga`로 하여 새로운 네이밍 컨벤션을 따른다. (예: **`dev.payment-team.order.saga.compensate-payment`**)
*   **VII.2.15. Request/Response 토픽 네이밍**: Request & Response 패턴 관련 Kafka 요청 토픽은 `data-type`을 `request`로, 응답 토픽은 `response`로 하여 새로운 네이밍 컨벤션을 따른다. (예: 요청-**`dev.search-team.product.request.get-stock`**, 응답-**`dev.inventory-team.product.response.get-stock`**)
*   **VII.2.16. Request/Response Correlation**: Request & Response 패턴 구현 시 요청과 응답 매핑을 위해 메시지 헤더의 `correlationId` (Spring Messaging 표준 `KafkaHeaders.CORRELATION_ID`) 또는 커스텀 `eventId` 필드를 사용한다. `spring-kafka`는 헤더 전파를 지원한다.
*   **VII.2.17. Kafka 설정**: Kafka 관련 설정은 주로 `application.yml` (또는 `.properties`) 파일의 `spring.kafka` 네임스페이스 아래에 정의한다.
    *   **공통 설정**: `spring.kafka.bootstrap-servers` (Kafka 브로커 주소).
    *   **Producer 설정**: `spring.kafka.producer.*` (예: `key-serializer=org.apache.kafka.common.serialization.StringSerializer`, `value-serializer=org.apache.kafka.common.serialization.StringSerializer`). (Rule VII.1.3.4 참조)
    *   **Consumer 설정**: `spring.kafka.consumer.*` (예: `group-id`, `key-deserializer`, `value-deserializer`는 `StringDeserializer` 또는 `KafkaJsonSchemaDeserializer`, `properties.schema.registry.url`은 `KafkaJsonSchemaDeserializer` 사용 시, `properties.json.value.type`은 `KafkaJsonSchemaDeserializer` 사용 시). (Rule VII.1.3.5 참조)
    *   **Listener 설정**: `spring.kafka.listener.*` (예: `ack-mode`, `concurrency`).
    *   **Schema Registry 설정**: Producer/Consumer의 `properties.schema.registry.url`을 통해 Confluent Schema Registry 주소를 설정한다 (`KafkaJsonSchemaDeserializer` 사용 시 또는 Gradle 플러그인 설정 시).
    *   **Java/Kotlin 설정 클래스**: `KafkaTemplate` 빈, `ConsumerFactory`, `ProducerFactory`, `@KafkaListenerContainerFactory` 등의 커스텀 빈 정의, `@EnableKafka` 어노테이션 설정 등에 사용될 수 있다.
*   **VII.2.18. Kafka 설정 - Bootstrap Servers**: Kafka Bootstrap 서버 주소는 `spring.kafka.bootstrap-servers` 속성을 통해 `application.yml`에 설정한다.
*   **VII.2.19. Kafka 설정 - Key/Value Serializer/Deserializer**:
    *   프로듀서: `spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer`, `spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer`.
    *   컨슈머: `spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer`. 값(value)에는 `org.apache.kafka.common.serialization.StringDeserializer` (수동 역직렬화 필요) 또는 `io.confluent.kafka.serializers.json.KafkaJsonSchemaDeserializer` (Schema Registry 연동)를 사용한다.
*   **VII.2.20. 토픽 세분화**: **분리 토픽(Separate Topic) 전략을 원칙으로 한다. 즉, 하나의 이벤트 유형은 반드시 하나의 독립된 Kafka 토픽에 1:1로 매핑되어야 한다.** (예: `UserCreated` 이벤트는 `...event.user-created` 토픽으로, `UserNameChanged` 이벤트는 `...event.user-name-changed` 토픽으로 발행). **단, 이벤트 소싱(Event Sourcing)과 같이 특정 Aggregate의 모든 이벤트를 순서대로 저장해야 하는 명확하고 예외적인 경우에는, 아키텍처 위원회의 승인 하에 단일 토픽(예: `...event.user-aggregate`)을 사용할 수 있다.**
*   **VII.2.21. 통합 테스트**: Kafka를 포함한 통합 테스트는 Testcontainers (Embedded Kafka 포함) 또는 `spring-kafka-test` 라이브러리의 `@EmbeddedKafka` 어노테이션을 사용하여 작성한다.
*   **VII.2.22. 이벤트 타임스탬프**: 이벤트 `timestamp`는 **마이크로초** 단위로 기록하고, 시스템 간 시간 동기화 (NTP 등)를 고려한다. Kafka 메시지 자체의 타임스탬프 또는 페이로드 내의 필드를 활용할 수 있다.
*   **VII.2.23. 모니터링**: 스키마 버전 불일치, 메시지 처리 실패 등 잠재적 오류를 감지하기 위한 모니터링 설정을 구축한다. `spring-kafka`는 Micrometer를 통한 메트릭 수집을 지원한다. `independent/outbox` 모듈 자체의 메트릭(저장된 메시지 수, 전송 실패 수 등)도 모니터링 대상이다 (Rule 80 참조).
*   **VII.2.24. `@KafkaListener` 기반 메시지 처리**: 메시지 소비는 가급적 `@KafkaListener` 어노테이션을 사용하여 해당 도메인 모듈의 `infrastructure/messaging/` 패키지 내 클래스 메서드에서 처리한다.
    *   메서드 파라미터 타입은 `StringDeserializer` 사용 시 `String` (JSON 페이로드), `KafkaJsonSchemaDeserializer` 사용 시 직접적인 페이로드 타입 `T` (예: `@Serializable` `DomainEvent` `data class`) 또는 `ConsumerRecord<K, V>`, `Message<T>` 등을 사용할 수 있다. (Rule VII.1.3.5 참조)
    *   에러 핸들링은 `spring-kafka`의 `DefaultErrorHandler`, `@RetryableTopic` 어노테이션을 활용한 재시도 및 DLQ (Dead Letter Queue) 설정을 통해 구성한다. `application.yml`에서 관련 속성(`spring.kafka.listener.retry-topic.*`, `spring.kafka.consumer.properties.isolation.level` 등)을 설정할 수 있다.
*   **VII.2.25. Content-Type 및 JSON 스키마 참조**:
    *   메시지 발행 시 `KafkaTemplate<String, String>`을 사용할 때, 메시지 헤더에 `contentType`으로 `application/json`을 명시할 수 있다 (Rule 88 참조).
    *   프로듀서는 `StringSerializer`를 사용하므로 메시지에 스키마 ID를 직접 포함하지 않는다.
    *   컨슈머가 `KafkaJsonSchemaDeserializer`를 사용하는 경우, Schema Registry와 통신하여 토픽명 기반의 서브젝트 이름 조회 전략을 통해 메시지에 사용된 스키마 정보를 확인/등록하며, 이 과정은 주로 자동으로 처리된다.

### VIII. 애플리케이션 핸들러 예외 처리 규칙 (sealed class & ErrorCode 규칙 적용)

67. **ErrorCode 인터페이스 및 구현체 정의**:
    *   **ErrorCode Interface**: 모든 에러 코드가 구현해야 할 `ErrorCode` 인터페이스는 `domains/common` 모듈의 **Domain 레이어** 내 **`error` 패키지** (`domains/common/domain/error/ErrorCode.kt` - Rule 141 준수)에 정의하며, 이 인터페이스는 **`val code: String` 및 `val message: String` 속성**만 정의한다.
    *   **Domain ErrorCode**: 모든 도메인 비즈니스 규칙 위반 관련 에러 코드는 각 도메인 모듈의 **Domain 레이어** 내 **`error` 패키지** (`domains/{domain}/domain/error/` - Rule 141 준수)에 정의된 Enum 클래스(예: `domains/user/domain/error/UserDomainErrorCodes.kt`)로 구현한다. 이 Enum은 Rule 67에 정의된 `ErrorCode` 인터페이스를 구현해야 하며, **`code: String` 및 `message: String` 필드**를 포함해야 한다. ErrorCode의 `code` 필드는 `{DOMAIN}-{LAYER}-{NUMBER}` 형태의 패턴을 따른다 (예: `USER-DOMAIN-001`). **HTTP 상태 코드 정보는 포함하지 않는다.**
    *   **Application ErrorCode**: Application 레이어에서 발생하는 기술적 오류(예: 외부 서비스 연동 실패 등)는 각 도메인 모듈의 **Application 레이어** 내 **`error` 패키지** (`domains/{domain}/application/error/` - Rule 141 준수)에 정의된 Enum(예: `domains/user/application/error/UserApplicationErrorCode.kt`)으로 정의한다. 이 Enum도 Rule 67에 정의된 `ErrorCode` 인터페이스를 구현해야 하며, **`code: String` 및 `message: String` 필드**를 포함해야 한다. ErrorCode의 `code` 필드는 `{DOMAIN}-{LAYER}-{NUMBER}` 형태의 패턴을 따른다 (예: `USER-APPLICATION-101`). **HTTP 상태 코드 정보는 포함하지 않는다.**
    *   **Common System ErrorCode**: 공통적인 시스템 오류(예: 동시성 충돌, 기본적인 입력 형식 오류 등)에 대한 공통 ErrorCode Enum은 `domains/common` 모듈의 **Domain 레이어** 내 **`error` 패키지** (`domains/common/domain/error/CommonSystemErrorCode.kt` - Rule 141 준수)에 정의한다. 이 Enum도 Rule 67에 정의된 `ErrorCode` 인터페이스를 구현해야 하며, **`code: String` 및 `message: String` 필드**를 포함해야 한다. ErrorCode의 `code` 필드는 `{DOMAIN}-{LAYER}-{NUMBER}` 형태의 패턴을 따른다 (예: `COMMON-DOMAIN-001` 또는 `COMMON-SYSTEM-500`). **HTTP 상태 코드 정보는 포함하지 않는다.** (이 에러 코드는 시스템 수준 오류지만, DomainException을 통해 전달될 수 있으므로 Domain 레이어에 위치시킨다.)
    *   **Independent Module ErrorCode**: `independent/outbox` 모듈과 같은 독립 모듈은 자체적인 ErrorCode Enum 및 체계를 해당 모듈의 **Infrastructure 레이어** 내 **`error` 패키지** (`independent/outbox/infrastructure/error/OutboxErrorCodes.kt` - Rule 80 참조, Rule 141 미적용) 내에 정의하고 사용한다. 독립 모듈의 ErrorCode는 `domains/common`의 `ErrorCode` 인터페이스를 구현하지 않을 수 있으며, 자체적으로 필요한 정보(예: 내부 처리 상태 코드)를 가질 수 있다.

    > **[ErrorCode 선택 가이드라인]**
    >
    > 예외 상황 발생 시 적절한 ErrorCode(및 Exception 타입)를 선택하기 위해 다음 질문을 고려하십시오:
    >
    > 1.  **핵심 비즈니스 규칙이나 정책 위반인가?** (예: 사용자 이름 중복, 잔고 부족, VO 유효성 검사 실패)
    >     *   **Yes** -> 해당 도메인의 `DomainException` 및 `DomainErrorCode` 사용 (예: `UserDomainException.DuplicateUsername`, `OrderDomainException.InsufficientBalance` - `domains/{domain}/domain/exception/`, `domains/{domain}/domain/error/` - Rule 141 준수)
    > 2.  **Application 레이어의 책임 범위 내 기술적 문제 또는 외부 요인인가?** (예: 외부 서비스 연동 실패 후 재시도 소진, 요청 DTO 파싱/변환 오류, 예상치 못한 복구 불가능 오류)
    >     *   **Yes** -> 해당 도메인의 `ApplicationException` 및 `ApplicationErrorCode` 사용 (예: `PaymentApplicationException.ExternalApiFailure`, `UserApplicationException.UnexpectedError` - `domains/{domain}/application/exception/`, `domains/{domain}/application/error/` - Rule 141 준수)
    > 3.  **여러 도메인에 걸쳐 발생 가능하거나 특정 도메인과 무관한 시스템 수준의 문제인가?** (예: 낙관적 잠금 충돌, 기본적인 입력 형식 오류(Presentation 단계 처리 후에도 발생 시), 인증/인가 실패)
    >     *   **Yes** -> `domains/common` 모듈의 공통 ErrorCode (`domains/common/domain/error/CommonSystemErrorCode.kt` - Rule 141 준수) 또는 관련 표준 예외 처리 메커니즘(예: `OptimisticLockException` 처리) 활용 고려. (단, `independent/` 모듈은 자체 ErrorCode 체계 사용 - `independent/{module}/infrastructure/error/` - Rule 80 참조, Rule 141 미적용)

68. **DomainException 및 ApplicationException 정의**:
    *   **Common Base DomainException**: 모든 도메인별 `DomainException` sealed class의 상위 타입 역할을 하는 추상 `DomainException` 클래스는 `domains/common` 모듈의 **Domain 레이어** 내 **`exception` 패키지** (`domains/common/domain/exception/DomainException.kt` - Rule 141 준수)에 정의한다. 이 추상 클래스는 Rule 67에 정의된 `ErrorCode`를 참조하는 `abstract val errorCode: ErrorCode` 프로퍼티를 포함해야 한다.
    *   **Common Base ApplicationException**: 모든 도메인별 `ApplicationException` sealed class의 상위 타입 역할을 하는 추상 `ApplicationException` 클래스는 `domains/common` 모듈의 **Application 레이어** 내 **`exception` 패키지** (`domains/common/application/exception/ApplicationException.kt` - Rule 141 준수)에 정의한다. 이 추상 클래스도 Rule 67에 정의된 `ErrorCode`를 참조하는 `abstract val errorCode: ErrorCode` 프로퍼티를 포함해야 한다.
    *   **Domain Exception**: 비즈니스 로직에서 발생한 예외는 각 도메인 모듈의 **Domain 레이어** 내 **`exception` 패키지** (`domains/{domain}/domain/exception/` - Rule 141 준수)에서 정의된 sealed class (예: `domains/user/domain/exception/UserDomainException.kt`)를 사용한다. 이 sealed class는 Rule 68에 정의된 Common Base `DomainException`을 상속해야 하며, 해당 도메인의 Domain ErrorCode (Rule 67에 정의된 Enum 구현체)를 `errorCode: ErrorCode` 프로퍼티를 통해 참조해야 한다. **Domain 모델에서 발생하는 유효성 검사 실패를 나타내는 예외들은 `UserDomainException.Validation`과 같이 `DomainException` 하위에 특정 베이스 예외 타입(sealed class 또는 interface)을 정의하고 이를 상속하는 하위 data class로 정의해야 한다.** Domain 모델에서 발생하는 유효성 검사 실패(VO `init`, Aggregate 메서드 내 `require` 등)는 Rule 14 및 61에 따라 이 `DomainException`을 상속하는 특정 유효성 검사 예외 타입을 직접 던져야 한다.
    *   **Application Exception**: Application 레이어 자체에서 발생하는 예외(예: Command/Query DTO 기반의 입력값 형식 오류 *전* 처리, 외부 서비스 호출 실패 시 Resilience4j 예외, 복구 불가능한 예상치 못한 시스템 오류 등 기술적 오류)는 각 도메인 모듈의 **Application 레이어** 내 **`exception` 패키지** (`domains/{domain}/application/exception/` - Rule 141 준수)에서 정의된 sealed class (예: `domains/user/application/exception/UserApplicationException.kt`)를 사용한다. 이 sealed class는 Rule 68에 정의된 Common Base `ApplicationException`을 상속해야 하며, 해당 도메인의 Application ErrorCode (Rule 67에 정의된 Enum 구현체)를 `errorCode: ErrorCode` 프로퍼티를 통해 참조해야 한다. Domain 로직 위반으로 인한 예외를 ApplicationException으로 래핑하지 않도록 한다.
    *   **Independent Module Exception**: `independent/outbox` 모듈과 같은 독립 모듈은 자체적인 `OutboxException` 베이스 클래스 및 하위 예외들을 해당 모듈의 **Infrastructure 레이어** 내 **`exception` 패키지** (`independent/outbox/infrastructure/exception/OutboxException.kt` - Rule 80 참조, Rule 141 미적용) 내에 정의하고 사용한다. 독립 모듈의 예외는 `domains/common`의 예외 클래스를 상속하지 않을 수 있다.
71. **예외 발생 시 ErrorCode 로깅**: Application 레이어에서 예외 발생 시 SLF4J를 사용하여 예외 정보와 함께 발생한 예외 객체가 가진 `errorCode.code`를 명시적으로 로깅해야 한다 (예: `log.error("Failed to process command, errorCode={}, error={}", e.errorCode.code, e.message, e)`).
72. **예외 메시지 표준화**: 각 도메인 모듈의 `ApplicationException` 및 `DomainException` sealed class와 하위 data class (`domains/{domain}/{layer}/exception/` - Rule 141 준수)는 해당 예외가 가진 `ErrorCode` (Enum)를 참조하여 사용자 친화적인 메시지와 개발자용 디버깅 메시지를 관리하며, 메시지는 단일 언어로 명확히 정의한다. 각 예외 클래스의 기본 메시지는 연결된 `errorCode.message`를 사용하고, 필요시 오버라이드하여 상세 정보를 추가할 수 있다.
74. **비동기 Command 예외 처리**: 비동기 Command Handler는 예외 발생 시 `jobId`와 함께 예외 정보 및 `ErrorCode`를 별도의 `JobError` 엔티티에 저장하고, 상태 조회 API를 통해 클라이언트가 확인할 수 있도록 한다.
64. **로깅 표준화**: 모든 레이어에서 로깅은 SLF4J를 사용하며, 구조화된 로깅을 적용한다 (예: `log.info("Processing user creation")`).

====================================================================
모듈들의 전체 코드가 첨부되어있다.
코드를 보면 불완전 한 부분도 있고 규칙을 지키지 않는 부분도 있다.
따라서 코드에 기준으로 작업을 완료하려고 하면 완성이 안될꺼다. 왜냐하면 코드가 정말 엉망이기 떄문이다. 어떤 요구사항인지 잘생각해서 수정계획을 해야한다.
그래서 이를 수정하기 위한 작업 지시서가 필요하다. 작업 지시서를 만들어라.
- tree 구조를 보고 규칙에 맞지않는 부분을 찾아서 삭제할 파일, 이동할 파일에 대한 작업지시서는 최우선이다. 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 규칙을 지키지 않는 부분에 대한 작업지시서를 작성하라
- 프로그램이 정상적으로 동작하기위해 추가적으로 작업해야하는 작업지시서를 작성하라
- 작업지시서는 단계가 명확하게 표현되어야 한다. 하지만 작업의 순서를 잘생각해서 먼저되어야 하는건 꼭 먼저하도록 단계를 잘 생각하라.
- build.gradle.kts는 최상위 파일에 공통부분을 최대한 모아놓고 각 모듈별로 필요한 부분은 모듈 내부에 작성한다.
- 작업지시서에서는 Gradle 의존성에 대한 버전에 대해서 지적하지 않는다. 모두 최신버전으로 팀내에서 직접 관리하는 영역이다.
- 필요없는 파일은 삭제하도록 지시하라.
- 필요없는 코드는 주석보단 삭제를 하도록 지시하라.
- 현재 코드를 유지하는 경우는 작업지시서에 굳이 명시하지 않아도 된다.
- 작업지시서는 ~을 확인해라. 같은 모호한 문장은 절대로 안된다. ~을 어떻게 고쳐라 같이 매우 명시적이여야 한다.
- 작업지시서는 어떤 파일이 어떤 부분이 잘못작성되었고 어떻게 고쳐야한다. 그리고 근거는 무엇이다 라는 명시적 문장이 있어야 한다.
- 작업지시서에 코드 레벨을 너무 자세하게 설명하지 않아도 된다.
- 작업지시서 제일 하단에는 모든 작업이 끝나고 확인해야할 체크리스트를 작성한다.
- ktlint 는 사용하지 않는다. (현재 단계에서는 그 어떤 린트도 제외)

작업 지시서에 항상 상단에 첨부할 문구
```
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.
다음 작업 지시서를 그대로 따라서 수정작업을 진행하라. 최대한 다른 판단은 히지 않는다.

작업시 항상 기억해야할 규칙
- 파일을 수정할때는 import 구문이 완벽한지 한번씩 더 체크하도록 한다. 만약 확인이 필요하다면 다른 파일을 조회할 수 있다.
- 작업을 진행하는 도중에 작업지시서에 없는 수정사항은 일단 보류하고 작업지시서를 최우선으로 수정한다.
- 이런식의 참조는 금지한다. ( ex -> event: com.restaurant.domains.common.domain.event.DomainEvent ) 항상 import 구문을 추가해서 참조하도록 한다.
- com.restaurant.domains.common.* 과 같은 import는 절대로 금지한다.
- 공통으로 수정해야할 패턴이 확실하다면 커맨드 명령어로 한번에 처리한다. 단, 프로젝트 내부에 build,bin 같은 제외할 경로는 명확히 명시한다.
- 필요없는 코드는 주석처리 하지 말고 삭제하도록 하라.
- 파일을 생성 할때는 위치가 올바른지 확인하기 위해서 파일 구조도를 참고하도록 한다.
- 이동으로 처리할 일을 삭제후 생성으로 처리하지 말아라.
- 의존성 버전은 항상 tools 이용해서 최신 스테이블 버전을 활용하도록 한다.
- 확인하고 싶은 디렉토리 구조가 있다면 tree 명령어로 최대한 효율적이게 진행하라. 단 bin,build 는 제외한다.
- 패키지나 폴더 경로에 in은 예약어이니 input이나 이런걸로 피하라.
```

====================================================================n

> Task :buildSrc:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :buildSrc:compileKotlin UP-TO-DATE
> Task :buildSrc:compileJava NO-SOURCE
> Task :buildSrc:compileGroovy NO-SOURCE
> Task :buildSrc:pluginDescriptors UP-TO-DATE
> Task :buildSrc:processResources NO-SOURCE
> Task :buildSrc:classes UP-TO-DATE
> Task :buildSrc:jar UP-TO-DATE
> Task :independent:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:check
> Task :apps:user-app:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :apps:user-app:processResources
> Task :independent:outbox:processResources
> Task :domains:common:application:processResources NO-SOURCE
> Task :domains:common:domain:processResources NO-SOURCE
> Task :domains:common:infrastructure:processResources NO-SOURCE
> Task :domains:common:presentation:processResources NO-SOURCE
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:presentation:processResources NO-SOURCE
> Task :apps:user-app:check
> Task :domains:user:domain:check
> Task :domains:user:infrastructure:check
> Task :domains:user:presentation:check
> Task :independent:outbox:check
> Task :domains:common:domain:compileKotlin
> Task :domains:common:domain:compileJava NO-SOURCE
> Task :domains:common:domain:classes UP-TO-DATE
> Task :domains:common:domain:jar
> Task :domains:common:application:compileKotlin
> Task :domains:common:application:compileJava NO-SOURCE
> Task :domains:common:application:classes UP-TO-DATE
> Task :domains:common:application:jar
> Task :domains:common:infrastructure:compileKotlin
> Task :domains:common:infrastructure:compileJava NO-SOURCE
> Task :domains:common:infrastructure:classes UP-TO-DATE
> Task :domains:common:infrastructure:jar
> Task :independent:outbox:compileKotlin
> Task :independent:outbox:compileJava NO-SOURCE
> Task :independent:outbox:classes
> Task :independent:outbox:jar
> Task :independent:outbox:assemble
> Task :independent:outbox:build
> Task :domains:user:domain:compileKotlin
> Task :domains:user:domain:compileJava NO-SOURCE
> Task :domains:user:domain:classes UP-TO-DATE
> Task :domains:user:domain:jar
> Task :domains:user:domain:assemble
> Task :domains:user:domain:build
> Task :domains:common:presentation:compileKotlin
> Task :domains:common:presentation:compileJava NO-SOURCE
> Task :domains:common:presentation:classes UP-TO-DATE
> Task :domains:common:presentation:jar
> Task :domains:user:application:compileKotlin
> Task :domains:user:application:compileJava NO-SOURCE
> Task :domains:user:application:classes UP-TO-DATE
> Task :domains:user:application:jar
> Task :domains:user:application:assemble
> Task :domains:user:application:build
> Task :domains:user:infrastructure:compileKotlin
> Task :domains:user:infrastructure:compileJava NO-SOURCE
> Task :domains:user:infrastructure:generateJsonSchema UP-TO-DATE
> Task :domains:user:infrastructure:processResources
> Task :domains:user:infrastructure:classes
> Task :domains:user:infrastructure:jar
> Task :domains:user:infrastructure:assemble
> Task :domains:user:infrastructure:build
> Task :domains:user:presentation:compileKotlin
> Task :domains:user:presentation:compileJava NO-SOURCE
> Task :domains:user:presentation:classes UP-TO-DATE
> Task :domains:user:presentation:jar
> Task :domains:user:presentation:assemble
> Task :domains:user:presentation:build
> Task :apps:user-app:compileKotlin
> Task :apps:user-app:compileJava NO-SOURCE
> Task :apps:user-app:classes
> Task :apps:user-app:resolveMainClassName
> Task :apps:user-app:bootJar
> Task :apps:user-app:jar
> Task :apps:user-app:assemble
> Task :apps:user-app:build

BUILD SUCCESSFUL in 12s
29 actionable tasks: 25 executed, 4 up-to-date


==============================================================
 Gradle Build Completed: 2025-06-11 21:01:56 
==============================================================


==============================================================

# Project Structure

domains
├── common
│   ├── application
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── application
│   │                               ├── dto
│   │                               │   ├── Command.kt
│   │                               │   └── Query.kt
│   │                               ├── exception
│   │                               │   └── ApplicationException.kt
│   │                               └── usecase
│   │                                   ├── CommandUseCase.kt
│   │                                   └── QueryUseCase.kt
│   ├── domain
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── domain
│   │                               ├── aggregate
│   │                               │   └── AggregateRoot.kt
│   │                               ├── error
│   │                               │   ├── CommonSystemErrorCode.kt
│   │                               │   └── ErrorCode.kt
│   │                               ├── event
│   │                               │   └── DomainEvent.kt
│   │                               └── exception
│   │                                   └── DomainException.kt
│   ├── infrastructure
│   │   ├── build.gradle.kts
│   │   └── src
│   │       └── main
│   │           └── kotlin
│   │               └── com
│   │                   └── restaurant
│   │                       └── common
│   │                           └── infrastructure
│   │                               └── entity
│   │                                   └── BaseEntity.kt
│   └── presentation
│       ├── build.gradle.kts
│       └── src
│           └── main
│               └── kotlin
│                   └── com
│                       └── restaurant
│                           └── common
│                               └── presentation
│                                   ├── config
│                                   │   ├── OpenApiConfig.kt
│                                   │   └── PasswordEncoderConfig.kt
│                                   ├── dto
│                                   │   └── response
│                                   │       └── CommandResultResponse.kt
│                                   └── GlobalExceptionHandler.kt
└── user
    ├── application
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── application
    │                               ├── command
    │                               │   ├── dto
    │                               │   │   ├── ChangePasswordCommand.kt
    │                               │   │   ├── DeleteAddressCommand.kt
    │                               │   │   ├── DeleteUserCommand.kt
    │                               │   │   ├── LoginCommand.kt
    │                               │   │   ├── RegisterAddressCommand.kt
    │                               │   │   ├── RegisterUserCommand.kt
    │                               │   │   ├── UpdateAddressCommand.kt
    │                               │   │   └── UpdateProfileCommand.kt
    │                               │   ├── handler
    │                               │   │   ├── ChangePasswordCommandHandler.kt
    │                               │   │   ├── DeleteAddressCommandHandler.kt
    │                               │   │   ├── DeleteUserCommandHandler.kt
    │                               │   │   ├── LoginCommandHandler.kt
    │                               │   │   ├── RegisterAddressCommandHandler.kt
    │                               │   │   ├── RegisterUserCommandHandler.kt
    │                               │   │   ├── UpdateAddressCommandHandler.kt
    │                               │   │   └── UpdateProfileCommandHandler.kt
    │                               │   └── usecase
    │                               │       ├── ChangePasswordUseCase.kt
    │                               │       ├── DeleteAddressUseCase.kt
    │                               │       ├── DeleteUserUseCase.kt
    │                               │       ├── LoginUseCase.kt
    │                               │       ├── RegisterAddressUseCase.kt
    │                               │       ├── RegisterUserUseCase.kt
    │                               │       ├── UpdateAddressUseCase.kt
    │                               │       └── UpdateProfileUseCase.kt
    │                               ├── error
    │                               │   └── UserApplicationErrorCode.kt
    │                               ├── exception
    │                               │   └── UserApplicationException.kt
    │                               └── query
    │                                   ├── dto
    │                                   │   ├── AddressDto.kt
    │                                   │   ├── GetAddressByIdQuery.kt
    │                                   │   ├── GetUserAddressesQuery.kt
    │                                   │   ├── GetUserProfileByIdQuery.kt
    │                                   │   ├── LoginResult.kt
    │                                   │   └── UserProfileDto.kt
    │                                   ├── handler
    │                                   │   ├── GetAddressByIdQueryHandler.kt
    │                                   │   ├── GetUserAddressesQueryHandler.kt
    │                                   │   └── GetUserProfileQueryHandler.kt
    │                                   └── usecase
    │                                       ├── GetAddressByIdUseCase.kt
    │                                       ├── GetAllAddressesUseCase.kt
    │                                       ├── GetProfileByIdUseCase.kt
    │                                       ├── GetUserAddressesUseCase.kt
    │                                       └── GetUserProfileUseCase.kt
    ├── domain
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           └── kotlin
    │               └── com
    │                   └── restaurant
    │                       └── user
    │                           └── domain
    │                               ├── aggregate
    │                               │   └── User.kt
    │                               ├── entity
    │                               │   └── Address.kt
    │                               ├── error
    │                               │   └── UserDomainErrorCodes.kt
    │                               ├── event
    │                               │   └── UserEvent.kt
    │                               ├── exception
    │                               │   └── UserDomainException.kt
    │                               ├── repository
    │                               │   └── UserRepository.kt
    │                               └── vo
    │                                   ├── AddressId.kt
    │                                   ├── Email.kt
    │                                   ├── Name.kt
    │                                   ├── Password.kt
    │                                   ├── PhoneNumber.kt
    │                                   ├── UserId.kt
    │                                   ├── Username.kt
    │                                   ├── UserStatus.kt
    │                                   └── UserType.kt
    ├── infrastructure
    │   ├── build.gradle.kts
    │   └── src
    │       └── main
    │           ├── kotlin
    │           │   └── com
    │           │       └── restaurant
    │           │           └── user
    │           │               └── infrastructure
    │           │                   ├── entity
    │           │                   │   ├── AddressEntity.kt
    │           │                   │   └── UserEntity.kt
    │           │                   ├── mapper
    │           │                   │   ├── AddressEntityMapper.kt
    │           │                   │   ├── DomainEventToOutboxMessageConverter.kt
    │           │                   │   └── UserEntityMapper.kt
    │           │                   └── repository
    │           │                       ├── SpringDataJpaUserRepository.kt
    │           │                       └── UserRepositoryImpl.kt
    │           └── resources
    │               └── schemas
    └── presentation
        ├── build.gradle.kts
        └── src
            └── main
                └── kotlin
                    └── com
                        └── restaurant
                            └── user
                                └── presentation
                                    └── v1
                                        ├── command
                                        │   ├── controller
                                        │   │   ├── UserAddressController.kt
                                        │   │   └── UserController.kt
                                        │   ├── dto
                                        │   │   └── request
                                        │   │       ├── ChangePasswordRequestV1.kt
                                        │   │       ├── DeleteUserRequestV1.kt
                                        │   │       ├── LoginRequestV1.kt
                                        │   │       ├── RegisterAddressRequestV1.kt
                                        │   │       ├── RegisterUserRequestV1.kt
                                        │   │       ├── UpdateAddressRequestV1.kt
                                        │   │       └── UpdateProfileRequestV1.kt
                                        │   └── extensions
                                        │       └── dto
                                        │           └── request
                                        │               └── UserCommandRequestExtensions.kt
                                        └── query
                                            ├── controller
                                            │   ├── UserAddressQueryController.kt
                                            │   └── UserQueryController.kt
                                            ├── dto
                                            │   ├── request
                                            │   └── response
                                            │       ├── AddressDetailResponseV1.kt
                                            │       ├── AddressResponseV1.kt
                                            │       ├── LoginResponseV1.kt
                                            │       └── UserProfileResponseV1.kt
                                            └── extensions
                                                └── dto
                                                    ├── request
                                                    └── response
                                                        ├── UserAddressQueryResponseExtensions.kt
                                                        └── UserQueryResponseExtensions.kt
independent
└── outbox
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── outbox
            │               ├── application
            │               │   ├── dto
            │               │   │   ├── OutboxMessage.kt
            │               │   │   ├── OutboxMessageRepository.kt
            │               │   │   └── OutboxMessageStatus.kt
            │               │   ├── handler
            │               │   │   ├── OutboxMetricsHandler.kt
            │               │   │   ├── OutboxPoller.kt
            │               │   │   └── ProcessOutboxEventsUseCaseHandler.kt
            │               │   └── usecase
            │               │       └── ProcessOutboxEventsUseCase.kt
            │               └── infrastructure
            │                   ├── config
            │                   │   └── OutboxKafkaConfig.kt
            │                   ├── converter
            │                   │   └── StringMapConverter.kt
            │                   ├── entity
            │                   │   └── OutboxEventEntity.kt
            │                   ├── error
            │                   │   └── OutboxErrorCodes.kt
            │                   ├── exception
            │                   │   └── OutboxException.kt
            │                   ├── extensions
            │                   │   └── OutboxEventEntityExtensions.kt
            │                   ├── messaging
            │                   │   └── OutboxMessageSender.kt
            │                   └── repository
            │                       ├── JpaOutboxEventRepository.kt
            │                       ├── JpaOutboxMessageRepository.kt
            │                       └── OutboxMessageRepositoryImpl.kt
            └── resources
                └── db
                    └── migration
apps
└── user-app
    ├── build.gradle.kts
    └── src
        └── main
            ├── kotlin
            │   └── com
            │       └── restaurant
            │           └── apps
            │               └── user
            │                   ├── config
            │                   │   ├── KafkaConfig.kt
            │                   │   └── SerializationConfig.kt
            │                   └── UserApplication.kt
            └── resources
gradle
└── wrapper

154 directories, 125 files
==============================================================




====================================================================
 File: apps/user-app/build.gradle.kts
 Path: apps/user-app/build.gradle.kts
 Timestamp: 2025-06-11 12:01:56
====================================================================
plugins {
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    id("org.springframework.boot") version "3.5.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

// Force kotlinx-serialization versions before dependencies
configurations.all {
    resolutionStrategy {
        force("org.jetbrains.kotlinx:kotlinx-serialization-core:1.8.1")
        force("org.jetbrains.kotlinx:kotlinx-serialization-core-jvm:1.8.1")
        force("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.1")
        force("org.jetbrains.kotlinx:kotlinx-serialization-json-jvm:1.8.1")

        eachDependency {
            if (requested.group == "org.jetbrains.kotlinx" && requested.name.contains("serialization")) {
                if (requested.name.contains("bom")) {
                    // Skip BOM entirely
                    return@eachDependency
                }
                useVersion("1.8.1")
            }
        }
    }

    // Spring Cloud Function is required for StreamBridge to work properly
    // Previously excluded but needed for StreamBridge
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":domains:common:infrastructure"))
    implementation(project(":domains:common:presentation"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:user:presentation"))
    implementation(project(":independent:outbox"))

    // Spring Boot Starters
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-actuator")

    // Kafka
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // Database
    runtimeOnly("org.postgresql:postgresql")
    runtimeOnly("com.h2database:h2")
    implementation("org.flywaydb:flyway-core")

    // Resilience4j
    implementation("io.github.resilience4j:resilience4j-kotlin:2.2.0")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.2.0")

    // UUID Generator
    implementation("com.fasterxml.uuid:java-uuid-generator:5.1.0")
    implementation("io.confluent:kafka-avro-serializer:7.5.0")
    // implementation("io.confluent:kafka-json-schema-serializer:7.5.0")
    implementation("com.github.avro-kotlin.avro4k:avro4k-core:2.3.0")

    // SpringDoc OpenAPI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.6")

    // Jackson for JSON processing
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")

    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    implementation("org.jetbrains.kotlin:kotlin-stdlib")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.1")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.8.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.1")

    // Swagger Annotations
    implementation("io.swagger.core.v3:swagger-annotations-jakarta:2.2.31")
    implementation("org.webjars:swagger-ui:5.22.0")

    // Test Dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
    }
    testImplementation("org.springframework.security:spring-security-test")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:postgresql:1.21.0")
    testImplementation("org.testcontainers:kafka:1.21.0")
    testImplementation("org.awaitility:awaitility:4.2.1")
    testImplementation("org.springframework.kafka:spring-kafka-test")
}

tasks.bootJar {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

tasks.bootRun {
    jvmArgs = listOf(
        "-Xmx1024m",
        "-Xms512m",
        "-XX:MaxMetaspaceSize=256m",
        "-XX:+UseG1GC",
        "-XX:+HeapDumpOnOutOfMemoryError"
    )
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/KafkaConfig.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/KafkaConfig.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.apps.user.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

@Configuration
class KafkaConfig {
    @Value("\${spring.kafka.bootstrap-servers}")
    private lateinit var bootstrapServers: String

    @Value("\${spring.kafka.producer.properties.acks:all}")
    private lateinit var producerAcks: String

    @Bean
    fun stringProducerFactory(): ProducerFactory<String, String> {
        val configProps: MutableMap<String, Any> = HashMap()
        configProps[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = bootstrapServers
        configProps[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java
        configProps[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java
        configProps[ProducerConfig.ACKS_CONFIG] = producerAcks
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun stringKafkaTemplate(): KafkaTemplate<String, String> = KafkaTemplate(stringProducerFactory())
}

====================================================================


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/SerializationConfig.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/config/SerializationConfig.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.apps.user.config

import kotlinx.serialization.json.Json
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SerializationConfig {
    @Bean
    fun kotlinJson(): Json =
        Json {
            // 필요한 경우 kotlinx.serialization.json.Json 설정을 추가합니다.
            // 예: ignoreUnknownKeys = true, prettyPrint = false 등
            // 현재 UserEvent.kt의 kotlinx.serialization 어노테이션과 호환되도록 기본 설정을 사용합니다.
            // UserEvent의 @SerialName 등이 스키마와 일치하는지 중요합니다.
            isLenient = true // JSON 포맷이 조금 유연해야 할 경우
            ignoreUnknownKeys = true // 스키마에 없는 키가 있어도 무시
            // explicitNulls = false // null 값을 명시적으로 보내지 않을 경우 (스키마 호환성 확인 필요)
        }
}

====================================================================


====================================================================
 File: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Path: apps/user-app/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
/**
 * UserApplication entry point for the user service.
 *
 * Configures component scanning and enables scheduling for Outbox Poller.
 *
 * @author junoko
 */
package com.restaurant.apps.user

import org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration
import org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication(
    exclude = [
        SecurityAutoConfiguration::class,
        UserDetailsServiceAutoConfiguration::class,
        ManagementWebSecurityAutoConfiguration::class,
    ],
)
// Scan components in config, user.presentation, user.application, user.infra, outbox
@ComponentScan(
    basePackages = [
        "com.restaurant.common.presentation",
        "com.restaurant.user.presentation",
        "com.restaurant.user.application",
        "com.restaurant.user.infrastructure",
        "com.restaurant.apps.user.config",
        "com.restaurant.outbox.application",
        "com.restaurant.outbox.infrastructure",
    ],
)
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.user.infrastructure.repository",
        "com.restaurant.outbox.infrastructure.repository",
    ],
)
@EntityScan(
    basePackages = [
        "com.restaurant.user.infrastructure.entity",
        "com.restaurant.outbox.infrastructure.entity",
    ],
)
@EnableScheduling // Outbox Poller 활성화
open class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

====================================================================


====================================================================
 File: build.gradle.kts
 Path: build.gradle.kts
 Timestamp: 2025-06-11 12:01:56
====================================================================
/**
 * build.gradle.kts for the root project.
 *
 * Configures plugins, dependency management, and global build settings.
 *
 * @author junoko
 */

buildscript {
    repositories {
        gradlePluginPortal()
        maven("https://packages.confluent.io/maven/")
    }
}

plugins {
    // Only versions are declared here for subprojects
    kotlin("jvm") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.spring") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.jpa") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.allopen") version "2.1.0" apply false
    id("org.jetbrains.kotlin.plugin.serialization") version "2.1.0" apply false
    id("org.springframework.boot") version "3.5.0" apply false
    id("io.spring.dependency-management") version "1.1.7" apply false
    id("com.github.imflog.kafka-schema-registry-gradle-plugin") version "2.3.2" apply false
}


====================================================================


====================================================================
 File: domains/common/application/build.gradle.kts
 Path: domains/common/application/build.gradle.kts
 Timestamp: 2025-06-11 12:01:56
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
    id("org.springframework.boot") version "3.5.0"
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
    dependencies {
        dependency("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
        dependency("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
        dependency("io.github.resilience4j:resilience4j-spring-boot3:2.3.0")
        dependency("io.github.resilience4j:resilience4j-kotlin:2.3.0")
        dependency("org.springframework.boot:spring-boot-starter:3.5.0")
        dependency("org.springframework.boot:spring-boot-starter-validation:3.5.0")
        dependency("org.springframework.boot:spring-boot-starter-test:3.5.0")
        dependency("io.mockk:mockk:1.14.2")
        dependency("org.junit.jupiter:junit-jupiter:5.13.0-M3")
        dependency("org.assertj:assertj-core:4.0.0-M1")
    }
}

dependencies {
    implementation(project(":domains:common:domain"))
    
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.3.0")
    implementation("io.github.resilience4j:resilience4j-kotlin:2.3.0")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk")
    testImplementation("org.junit.jupiter:junit-jupiter")
    testImplementation("org.assertj:assertj-core")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.jar {
    enabled = true
}
tasks.bootJar {
    enabled = false
}

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Command.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Command.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.application.dto

interface Command

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Query.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/dto/Query.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.application.dto

interface Query

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/exception/ApplicationException.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.application.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom application exceptions.
 * Represents errors occurring in the application layer (e.g., use case execution failures).
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class ApplicationException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    /**
     * The error code associated with this application exception.
     */
    abstract val errorCode: ErrorCode
}

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/CommandUseCase.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/CommandUseCase.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.application.usecase

import com.restaurant.common.application.dto.Command

interface CommandUseCase<COMMAND : Command, RESULT> {
    fun execute(command: COMMAND): RESULT
}

====================================================================


====================================================================
 File: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/QueryUseCase.kt
 Path: domains/common/application/src/main/kotlin/com/restaurant/common/application/usecase/QueryUseCase.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.application.usecase

import com.restaurant.common.application.dto.Query

interface QueryUseCase<QUERY : Query, RESULT> {
    fun execute(query: QUERY): RESULT
}

====================================================================


====================================================================
 File: domains/common/domain/build.gradle.kts
 Path: domains/common/domain/build.gradle.kts
 Timestamp: 2025-06-11 12:01:56
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0"
    kotlin("plugin.allopen") version "2.1.0"
    kotlin("plugin.serialization") version "2.1.0"
    id("io.spring.dependency-management")
    id("org.springframework.boot") version "3.5.0"
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

dependencies {
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.1.0")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-core:1.8.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.1")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")
    implementation("jakarta.validation:jakarta.validation-api:3.1.1")
    implementation("com.fasterxml.uuid:java-uuid-generator:5.1.0")

    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

tasks.jar {
    enabled = true
}
tasks.bootJar {
    enabled = false
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

/**
 * Base class for all Aggregate Roots.
 * Provides methods to manage domain events.
 * Rule 17, 18
 */
abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    /**
     * Returns the list of recorded domain events.
     */
    open fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    /**
     * Clears the list of recorded domain events.
     */
    open fun clearDomainEvents() {
        domainEvents.clear()
    }

    /**
     * Adds a domain event to the list of recorded events.
     * This method is protected to ensure it's only called within the Aggregate implementation.
     */
    protected fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/CommonSystemErrorCode.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.domain.error

/**
 * Common system-level error codes.
 */
enum class CommonSystemErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    INTERNAL_SERVER_ERROR("COMMON-SYSTEM-001", "Internal server error"),
    INVALID_REQUEST("COMMON-SYSTEM-002", "Invalid request"),
    RESOURCE_NOT_FOUND("COMMON-SYSTEM-003", "Resource not found"),
    UNAUTHORIZED("COMMON-SYSTEM-004", "Unauthorized"),
    FORBIDDEN("COMMON-SYSTEM-005", "Forbidden"),
    VALIDATION_ERROR("COMMON-SYSTEM-006", "Validation error"),
    CONFLICT("COMMON-SYSTEM-007", "Conflict"),
    TOO_MANY_REQUESTS("COMMON-SYSTEM-008", "Too many requests"),
    SERVICE_UNAVAILABLE("COMMON-SYSTEM-009", "Service unavailable"),
    OPTIMISTIC_LOCK_ERROR("COMMON-SYSTEM-010", "Optimistic lock error"),
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/error/ErrorCode.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.domain.error

/**
 * Base interface for all error codes in the system.
 * Error codes should follow the format: {DOMAIN}-{LAYER}-{CODE}
 */
interface ErrorCode {
    /**
     * The unique code for this error.
     * Format: {DOMAIN}-{LAYER}-{CODE}
     * Example: USER-DOMAIN-001, USER-APP-002
     */
    val code: String

    /**
     * A human-readable message describing this error.
     */
    val message: String
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.domain.event

import java.time.Instant
import java.util.UUID

/**
 * Base interface for domain events. (Rule 32)
 */
interface DomainEvent {
    val eventId: UUID
    val occurredAt: Instant
    val aggregateId: String
    val aggregateType: String
    val version: Int
}

====================================================================


====================================================================
 File: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Path: domains/common/domain/src/main/kotlin/com/restaurant/common/domain/exception/DomainException.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.domain.exception

import com.restaurant.common.domain.error.ErrorCode

/**
 * Base class for all custom domain exceptions.
 * Requires subclasses to provide an ErrorCode. (Rule 68)
 */
abstract class DomainException(
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message, cause) {
    abstract val errorCode: ErrorCode
}

====================================================================


====================================================================
 File: domains/common/infrastructure/build.gradle.kts
 Path: domains/common/infrastructure/build.gradle.kts
 Timestamp: 2025-06-11 12:01:56
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    kotlin("plugin.serialization") version "2.1.0"
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

tasks.named("bootJar") {
    enabled = false
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0") // JPA 어노테이션 사용 목적
    implementation("org.springframework.kafka:spring-kafka:4.0.0-M2")

    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("org.springframework.kafka:spring-kafka-test:4.0.0-M2")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.testcontainers:testcontainers:1.21.0")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:kafka:1.21.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/entity/BaseEntity.kt
 Path: domains/common/infrastructure/src/main/kotlin/com/restaurant/common/infrastructure/entity/BaseEntity.kt
 Timestamp: 2025-06-11 12:01:56
====================================================================
package com.restaurant.common.infrastructure.entity

import jakarta.persistence.Column
import jakarta.persistence.MappedSuperclass
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import java.time.Instant

/**
 * Base entity class for JPA entities providing common fields like
 * creation and update timestamps.
 */
@MappedSuperclass
abstract class BaseEntity {
    @Column(name = "created_at", nullable = false, updatable = false)
    var createdAt: Instant = Instant.now()
        protected set

    @Column(name = "updated_at", nullable = false)
    var updatedAt: Instant = Instant.now()
        protected set

    @PrePersist
    protected fun onCreate() {
        createdAt = Instant.now()
        updatedAt = Instant.now()
    }

    @PreUpdate
    protected fun onUpdate() {
        updatedAt = Instant.now()
    }
}

====================================================================


====================================================================
 File: domains/common/presentation/build.gradle.kts
 Path: domains/common/presentation/build.gradle.kts
 Timestamp: 2025-06-11 12:01:56
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework.boot:spring-boot-starter-web:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")

    // implementation("org.springframework.boot:spring-boot-starter-security:3.2.3") // Spring Security 추가
    implementation("org.springframework.security:spring-security-crypto:6.5.0") // PasswordEncoder만 사용
    // JPA는 presentation 레이어에서 직접 사용하지 않지만, 예외 처리를 위해 compileOnly로 추가
    compileOnly("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0")
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7") // Kotlin Logging 추가

    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/OpenApiConfig.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/OpenApiConfig.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.common.presentation.config

import io.swagger.v3.oas.models.Components
import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Contact
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.info.License
import io.swagger.v3.oas.models.security.SecurityRequirement
import io.swagger.v3.oas.models.security.SecurityScheme
import io.swagger.v3.oas.models.servers.Server
import io.swagger.v3.oas.models.tags.Tag
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class OpenApiConfig {
    @Bean
    fun openAPI(): OpenAPI =
        OpenAPI()
            .info(
                Info()
                    .title("Restaurant User Service API")
                    .description(
                        """
                        ## 사용자 관리 서비스 API
                        
                        이 API는 레스토랑 플랫폼의 사용자 관리 기능을 제공합니다.
                        
                        ### 주요 기능
                        - 사용자 회원가입 및 로그인
                        - 사용자 프로필 관리
                        - 사용자 주소 관리
                        - 비밀번호 변경 및 계정 삭제
                        
                        ### 인증 방식
                        JWT Bearer Token을 사용합니다. 로그인 후 받은 accessToken을 Authorization 헤더에 포함시켜 주세요.
                        
                        ### 오류 응답
                        모든 오류 응답은 RFC 9457 ProblemDetail 형식을 따릅니다.
                        
                        ### API 버전 관리
                        - v1: 현재 안정 버전
                        - CQRS 패턴 적용: Command(생성/수정/삭제)와 Query(조회) 분리
                        """.trimIndent(),
                    ).version("1.0.0")
                    .contact(
                        Contact()
                            .name("Restaurant Development Team")
                            .email("dev@restaurant.com")
                            .url("https://restaurant.com"),
                    ).license(
                        License()
                            .name("MIT License")
                            .url("https://opensource.org/licenses/MIT"),
                    ),
            ).servers(
                listOf(
                    Server()
                        .url("http://localhost:8090")
                        .description("개발 서버 (Local)"),
                    Server()
                        .url("https://dev-api.restaurant.com")
                        .description("개발 환경 (Development)"),
                    Server()
                        .url("https://staging-api.restaurant.com")
                        .description("스테이징 환경 (Staging)"),
                    Server()
                        .url("https://api.restaurant.com")
                        .description("운영 환경 (Production)"),
                ),
            ).components(
                Components()
                    .addSecuritySchemes(
                        "bearerAuth",
                        SecurityScheme()
                            .type(SecurityScheme.Type.HTTP)
                            .scheme("bearer")
                            .bearerFormat("JWT")
                            .description("JWT Bearer Token 인증"),
                    ),
            ).security(
                listOf(
                    SecurityRequirement().addList("bearerAuth"),
                ),
            ).tags(
                listOf(
                    Tag().name("Health Check").description("애플리케이션 상태 확인 API"),
                    Tag().name("Simple").description("간단한 테스트 API"),
                    Tag().name("User Commands").description("사용자 계정 관리 API (생성/수정/삭제)"),
                    Tag().name("User Queries").description("사용자 정보 조회 API"),
                    Tag().name("User Address Commands").description("사용자 주소 관리 API (생성/수정/삭제)"),
                    Tag().name("User Address Queries").description("사용자 주소 조회 API"),
                ),
            )
}

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/PasswordEncoderConfig.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/config/PasswordEncoderConfig.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.common.presentation.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder

@Configuration
class PasswordEncoderConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()
}

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.common.presentation.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Command 요청 결과 응답")
data class CommandResultResponse(
    @Schema(description = "처리 상태", example = "SUCCESS")
    val status: String,
    @Schema(description = "결과 메시지", example = "요청이 성공적으로 처리되었습니다.")
    val message: String,
    @Schema(description = "생성/수정된 리소스의 ID (선택적)", example = "a1b2c3d4-e5f6-7890-1234-567890abcdef", nullable = true)
    val resourceId: String? = null // 필요에 따라 추가
)

====================================================================


====================================================================
 File: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Path: domains/common/presentation/src/main/kotlin/com/restaurant/common/presentation/GlobalExceptionHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.common.presentation

import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.common.domain.error.CommonSystemErrorCode
import com.restaurant.common.domain.error.ErrorCode
import com.restaurant.common.domain.exception.DomainException
import com.restaurant.outbox.infrastructure.error.OutboxErrorCodes
import com.restaurant.outbox.infrastructure.exception.OutboxException
import io.github.oshai.kotlinlogging.KotlinLogging
import jakarta.persistence.OptimisticLockException
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import java.net.URI
import java.time.Instant

private val log = KotlinLogging.logger {}

@RestControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValidException(
        ex: MethodArgumentNotValidException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.VALIDATION_ERROR
        log.error(ex) { "Validation failed, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.bindingResult.fieldErrors.joinToString(", ") { it.defaultMessage ?: "" }
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleHttpMessageNotReadableException(
        ex: HttpMessageNotReadableException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INVALID_REQUEST
        log.error(ex) { "Invalid request, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.message ?: "Invalid request body"
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(MethodArgumentTypeMismatchException::class)
    fun handleMethodArgumentTypeMismatchException(
        ex: MethodArgumentTypeMismatchException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INVALID_REQUEST
        log.error(ex) { "Invalid argument type, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = "Parameter '${ex.name}' has invalid value: '${ex.value}'"
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = ex.errorCode
        log.error(ex) { "Domain exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(
        ex: ApplicationException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = ex.errorCode
        log.error(ex) { "Application exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(determineHttpStatusFromErrorCode(errorCode))
        problemDetail.title = errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(OptimisticLockException::class)
    fun handleOptimisticLockException(
        ex: OptimisticLockException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.OPTIMISTIC_LOCK_ERROR
        log.error(ex) { "Optimistic lock exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.CONFLICT)
        problemDetail.title = "Optimistic Lock Error"
        problemDetail.detail = "The resource you are trying to update has been modified by another transaction. Please try again."
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(IllegalArgumentException::class)
    fun handleIllegalArgumentException(
        ex: IllegalArgumentException,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INVALID_REQUEST
        log.error(ex) { "Illegal argument exception occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST)
        problemDetail.title = "Bad Request"
        problemDetail.detail = ex.message ?: "Invalid argument provided."
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    @ExceptionHandler(OutboxException::class)
    fun handleOutboxException(
        ex: OutboxException,
        request: HttpServletRequest,
    ): ProblemDetail {
        log.error(ex) { "Outbox exception occurred, errorCode=${ex.errorCode.code}" }
        // OutboxErrorCodes를 기반으로 HttpStatus 직접 결정
        val httpStatus = determineHttpStatusFromOutboxErrorCode(ex.errorCode)
        val problemDetail = ProblemDetail.forStatus(httpStatus)
        problemDetail.title = ex.errorCode.message
        problemDetail.detail = ex.message ?: ""
        problemDetail.setProperty("errorCode", ex.errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    // 새로운 private 함수 추가 (OutboxErrorCodes 전용 HttpStatus 결정 로직)
    private fun determineHttpStatusFromOutboxErrorCode(errorCode: OutboxErrorCodes): HttpStatus =
        when (errorCode) {
            OutboxErrorCodes.MESSAGE_NOT_FOUND -> HttpStatus.NOT_FOUND
            OutboxErrorCodes.KAFKA_SEND_FAILED,
            OutboxErrorCodes.MESSAGE_PROCESSING_FAILED,
            OutboxErrorCodes.DATABASE_ERROR,
            OutboxErrorCodes.SERIALIZATION_ERROR,
            OutboxErrorCodes.DATABASE_OPERATION_FAILED,
            OutboxErrorCodes.UNEXPECTED_INFRA_ERROR,
            -> HttpStatus.INTERNAL_SERVER_ERROR
            OutboxErrorCodes.MAX_RETRIES_EXCEEDED -> HttpStatus.SERVICE_UNAVAILABLE
            OutboxErrorCodes.INVALID_MESSAGE_STATUS -> HttpStatus.BAD_REQUEST
        }

    @ExceptionHandler(Exception::class)
    fun handleAllExceptions(
        ex: Exception,
        request: HttpServletRequest,
    ): ProblemDetail {
        val errorCode = CommonSystemErrorCode.INTERNAL_SERVER_ERROR
        log.error(ex) { "An unexpected error occurred, errorCode=${errorCode.code}" }
        val problemDetail = ProblemDetail.forStatus(HttpStatus.INTERNAL_SERVER_ERROR)
        problemDetail.title = "Internal Server Error"
        problemDetail.detail = "An unexpected error occurred. Please try again later."
        problemDetail.setProperty("errorCode", errorCode.code)
        setCommonProblemProperties(problemDetail, request)
        return problemDetail
    }

    private fun determineHttpStatusFromErrorCode(errorCode: ErrorCode): HttpStatus =
        when (errorCode) {
            is CommonSystemErrorCode ->
                when (errorCode) {
                    CommonSystemErrorCode.VALIDATION_ERROR, CommonSystemErrorCode.INVALID_REQUEST -> HttpStatus.BAD_REQUEST
                    CommonSystemErrorCode.RESOURCE_NOT_FOUND -> HttpStatus.NOT_FOUND
                    CommonSystemErrorCode.UNAUTHORIZED -> HttpStatus.UNAUTHORIZED
                    CommonSystemErrorCode.FORBIDDEN -> HttpStatus.FORBIDDEN
                    CommonSystemErrorCode.CONFLICT, CommonSystemErrorCode.OPTIMISTIC_LOCK_ERROR -> HttpStatus.CONFLICT
                    CommonSystemErrorCode.TOO_MANY_REQUESTS -> HttpStatus.TOO_MANY_REQUESTS
                    CommonSystemErrorCode.SERVICE_UNAVAILABLE -> HttpStatus.SERVICE_UNAVAILABLE
                    else -> HttpStatus.INTERNAL_SERVER_ERROR
                }

            // OutboxErrorCodes는 별도의 determineHttpStatusFromOutboxErrorCode 함수에서 처리
            else -> HttpStatus.INTERNAL_SERVER_ERROR
        }

    private fun setCommonProblemProperties(
        problemDetail: ProblemDetail,
        request: HttpServletRequest,
    ) {
        problemDetail.type = URI.create("https://errors.restaurant.com/${problemDetail.properties?.get("errorCode")}")
        problemDetail.instance = URI.create(request.requestURI)
        problemDetail.setProperty("timestamp", Instant.now())
    }
}

====================================================================


====================================================================
 File: domains/user/application/build.gradle.kts
 Path: domains/user/application/build.gradle.kts
 Timestamp: 2025-06-11 12:01:57
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

dependencies {
    implementation("io.github.microutils:kotlin-logging-jvm:4.0.0-beta-2")
    implementation("org.springframework.security:spring-security-crypto:6.5.0")
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common:application"))
    implementation(project(":independent:outbox"))

    implementation("org.springframework:spring-tx:7.0.0-M5") // 트랜잭션 의존성 추가
    implementation("org.springframework.boot:spring-boot-starter:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")
    implementation("io.github.resilience4j:resilience4j-spring-boot3:2.3.0")
    implementation("io.github.resilience4j:resilience4j-kotlin:2.3.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

// Remove explicit task dependencies to avoid circular dependency
tasks.named("compileKotlin") {
    mustRunAfter(tasks.named("processResources"))
}

tasks.named("compileTestKotlin") {
    mustRunAfter(tasks.named("processTestResources"))
}

// Ensure test tasks use JUnit Platform
tasks.withType<Test> {
    useJUnitPlatform()
}

// Make jar task enabled
tasks.withType<Jar> {
    enabled = true
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/ChangePasswordCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/ChangePasswordCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteAddressCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/DeleteUserCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

import jakarta.validation.constraints.NotBlank

data class DeleteUserCommand(
    val userId: String,
    val reason: String? = null,
    @field:NotBlank(message = "비밀번호 확인은 필수입니다.")
    val password: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/LoginCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/LoginCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

data class LoginCommand(
    val email: String,
    val password: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterAddressCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

data class RegisterAddressCommand(
    val userId: String,
    val name: String,
    val street: String,
    val detail: String,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterUserCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/RegisterUserCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size
import jakarta.validation.constraints.Email as JakartaEmail

/**
 * Command DTO for registering a new user.
 * Rule App-Struct (dto/command)
 */
data class RegisterUserCommand(
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:JakartaEmail(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    val phoneNumber: String? = null,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateAddressCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateAddressCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val name: String,
    val street: String,
    val detail: String,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateProfileCommand.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/dto/UpdateProfileCommand.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.dto

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
    val phoneNumber: String?,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/ChangePasswordCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/ChangePasswordCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.ChangePasswordCommand
import com.restaurant.user.application.command.usecase.ChangePasswordUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.UserId
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : ChangePasswordUseCase {
    @Transactional
    override fun changePassword(command: ChangePasswordCommand) {
        try {
            val userId = UserId.ofString(command.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(command.userId)

            val currentPassword = Password.of(command.currentPassword)
            val encodedNewPassword = passwordEncoder.encode(command.newPassword)
            val newPassword = Password.of(encodedNewPassword)
            val updatedUser = user.changePassword(currentPassword, newPassword)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid password data format: ${iae.message}", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to change password due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteAddressCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.DeleteAddressCommand
import com.restaurant.user.application.command.usecase.DeleteAddressUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) : DeleteAddressUseCase {
    @Transactional
    override fun deleteAddress(command: DeleteAddressCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.deleteAddress(addressIdVo)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to delete address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/DeleteUserCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.DeleteUserCommand
import com.restaurant.user.application.command.usecase.DeleteUserUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
) : DeleteUserUseCase {
    @Transactional
    override fun deleteUser(command: DeleteUserCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser = user.withdraw()

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to delete user due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/LoginCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/LoginCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.LoginCommand
import com.restaurant.user.application.command.usecase.LoginUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.LoginResult
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : LoginUseCase {
    @Transactional(readOnly = true)
    override fun login(command: LoginCommand): LoginResult {
        try {
            val emailVo = Email.of(command.email)
            val user =
                userRepository.findByEmail(emailVo)
                    ?: throw UserDomainException.User.InvalidCredentials(command.email)

            if (!passwordEncoder.matches(command.password, user.password.value)) {
                throw UserDomainException.User.InvalidCredentials(command.email)
            }

            val accessToken = "dummy-access-token"
            val refreshToken = "dummy-refresh-token"

            return LoginResult(
                id = user.id.value.toString(),
                username = user.username.value,
                accessToken = accessToken,
                refreshToken = refreshToken,
            )
        } catch (de: UserDomainException.User.InvalidCredentials) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid email or password format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Login failed due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterAddressCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.RegisterAddressCommand
import com.restaurant.user.application.command.usecase.RegisterAddressUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) : RegisterAddressUseCase {
    @Transactional
    override fun registerAddress(command: RegisterAddressCommand): AddressId {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val addressId = AddressId.generate()
            val address =
                Address.create(
                    addressId = addressId,
                    name = command.name,
                    streetAddress = command.street,
                    detailAddress = command.detail,
                    city = command.city,
                    state = command.state,
                    country = command.country,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )
            val updatedUser = user.addAddress(address)
            userRepository.save(updatedUser)

            return updatedUser.addresses.first { it.addressId == address.addressId }.addressId
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to register address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterUserCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/RegisterUserCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.RegisterUserCommand
import com.restaurant.user.application.command.usecase.RegisterUserUseCase
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.UserType
import com.restaurant.user.domain.vo.Username
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) : RegisterUserUseCase {
    @Transactional
    override fun register(command: RegisterUserCommand): UserId {
        val username = Username.of(command.username)
        val email = Email.of(command.email)
        val name = Name.of(command.name)
        val password = Password.of(passwordEncoder.encode(command.password))
        val phoneNumberVo = command.phoneNumber?.let { PhoneNumber.of(it) }
        val user =
            User.create(
                id = UserId.generate(),
                username = username,
                password = password,
                email = email,
                name = name,
                phoneNumber = phoneNumberVo,
                userType = UserType.CUSTOMER,
            )
        userRepository.save(user)
        return user.id
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateAddressCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateAddressCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.UpdateAddressCommand
import com.restaurant.user.application.command.usecase.UpdateAddressUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) : UpdateAddressUseCase {
    @Transactional
    override fun updateAddress(command: UpdateAddressCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val addressIdVo = AddressId.ofString(command.addressId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val updatedUser =
                user.updateAddress(
                    addressId = addressIdVo,
                    name = Name.of(command.name),
                    streetAddress = command.street,
                    detailAddress = command.detail,
                    city = command.city,
                    state = command.state,
                    country = command.country,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to update address due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateProfileCommandHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/handler/UpdateProfileCommandHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.handler

import com.restaurant.user.application.command.dto.UpdateProfileCommand
import com.restaurant.user.application.command.usecase.UpdateProfileUseCase
import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) : UpdateProfileUseCase {
    @Transactional
    override fun updateProfile(command: UpdateProfileCommand) {
        try {
            val userIdVo = UserId.ofString(command.userId)
            val user = userRepository.findById(userIdVo) ?: throw UserDomainException.User.NotFound(userIdVo.toString())

            val name = Name.of(command.name)
            val phoneNumber = command.phoneNumber?.let { PhoneNumber.of(it) }

            val updatedUser = user.updateProfile(name, phoneNumber)

            userRepository.save(updatedUser)
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid input format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to update profile due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/ChangePasswordUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/ChangePasswordUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.ChangePasswordCommand

interface ChangePasswordUseCase {
    fun changePassword(command: ChangePasswordCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteAddressUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.DeleteAddressCommand

/**
 * 주소 삭제 유스케이스 인터페이스
 */
interface DeleteAddressUseCase {
    fun deleteAddress(command: DeleteAddressCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/DeleteUserUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.DeleteUserCommand

/**
 * 사용자 삭제 유스케이스 인터페이스
 */
interface DeleteUserUseCase {
    fun deleteUser(command: DeleteUserCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/LoginUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/LoginUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.LoginCommand
import com.restaurant.user.application.query.dto.LoginResult

/**
 * 로그인 유스케이스 인터페이스
 */
interface LoginUseCase {
    fun login(command: LoginCommand): LoginResult
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterAddressUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.RegisterAddressCommand
import com.restaurant.user.domain.vo.AddressId

/**
 * 주소 등록 유스케이스 인터페이스
 */
interface RegisterAddressUseCase {
    fun registerAddress(command: RegisterAddressCommand): AddressId
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterUserUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/RegisterUserUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.RegisterUserCommand
import com.restaurant.user.domain.vo.UserId

/**
 * 사용자 등록 유스케이스 인터페이스
 */
interface RegisterUserUseCase {
    fun register(command: RegisterUserCommand): UserId
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateAddressUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateAddressUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.UpdateAddressCommand

/**
 * 주소 업데이트 유스케이스 인터페이스
 */
interface UpdateAddressUseCase {
    fun updateAddress(command: UpdateAddressCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/command/usecase/UpdateProfileUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.command.usecase

import com.restaurant.user.application.command.dto.UpdateProfileCommand

/**
 * 프로필 업데이트 유스케이스 인터페이스
 */
interface UpdateProfileUseCase {
    fun updateProfile(command: UpdateProfileCommand)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/error/UserApplicationErrorCode.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val message: String,
) : ErrorCode {
    BAD_REQUEST("USER-APPLICATION-001", "Bad request received by application."),
    INVALID_INPUT("USER-APPLICATION-002", "Invalid input provided to application."),
    AUTHENTICATION_FAILED("USER-APPLICATION-003", "Authentication failed."),
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-004", "External service communication error."),
    UNEXPECTED_ERROR("USER-APPLICATION-500", "An unexpected error occurred in the application."),
    USER_NOT_FOUND_BY_EMAIL("USER-APPLICATION-005", "User not found by email"),
    INVALID_CREDENTIALS("USER-APPLICATION-006", "Invalid username or password"),
    USER_INACTIVE("USER-APPLICATION-007", "User account is inactive"),
    SYSTEM_ERROR("USER-APPLICATION-999", "처리 중 오류가 발생했습니다."),
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/exception/UserApplicationException.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.exception

import com.restaurant.common.domain.error.ErrorCode
import com.restaurant.common.application.exception.ApplicationException
import com.restaurant.user.application.error.UserApplicationErrorCode

/**
 * User Application 레이어 관련 예외 정의 (Rule 68)
 */
sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    message: String? = null,
    cause: Throwable? = null,
) : ApplicationException(message ?: errorCode.message, cause) {
    /**
     * 인증 실패 관련 예외
     */
    class AuthenticationFailed(
        message: String? = UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.AUTHENTICATION_FAILED, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - e.g., Invalid UUID format
     */
    class BadRequest(
        message: String? = UserApplicationErrorCode.BAD_REQUEST.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.BAD_REQUEST, message, cause)

    /**
     * 잘못된 입력값 관련 예외 (Application 레벨) - more specific than BadRequest
     */
    class InvalidInput(
        message: String? = UserApplicationErrorCode.INVALID_INPUT.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.INVALID_INPUT, message, cause)

    /**
     * 외부 서비스 연동 오류
     */
    class ExternalServiceError(
        message: String? = UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR, message, cause)

    /**
     * 예상치 못한 시스템 오류 (Application 레벨)
     */
    class UnexpectedError(
        message: String? = UserApplicationErrorCode.UNEXPECTED_ERROR.message,
        cause: Throwable? = null,
    ) : UserApplicationException(UserApplicationErrorCode.UNEXPECTED_ERROR, message, cause)

    /**
     * Login specific exceptions
     */
    class UserNotFound(
        errorCode: ErrorCode,
        identifier: String,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, "User not found with identifier: $identifier", cause)

    class InvalidCredentials(
        errorCode: ErrorCode,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, cause = cause)

    class UserInactive(
        errorCode: ErrorCode,
        userId: String,
        cause: Throwable? = null
    ) : UserApplicationException(errorCode, "User is inactive: $userId", cause)
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/AddressDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/AddressDto.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.dto

import java.time.Instant

data class AddressDto(
    val id: String,
    val name: String,
    val streetAddress: String,
    val detailAddress: String?,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
    val version: Long,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetAddressByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetAddressByIdQuery.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.dto

data class GetAddressByIdQuery(
    val userId: String,
    val addressId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserAddressesQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserAddressesQuery.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.dto

data class GetUserAddressesQuery(
    val userId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserProfileByIdQuery.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/GetUserProfileByIdQuery.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.dto

data class GetUserProfileByIdQuery(
    val userId: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/LoginResult.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/LoginResult.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.dto

/**
 * 로그인 결과 DTO (Application Layer)
 */
data class LoginResult(
    val id: String,
    val username: String,
    val accessToken: String,
    val refreshToken: String,
)

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/UserProfileDto.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/dto/UserProfileDto.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.dto

import java.time.Instant

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val username: String,
    val phoneNumber: String?,
    val userType: String,
    val addresses: List<AddressDto>,
    val createdAt: Instant,
    val updatedAt: Instant,
    val status: String,
    val version: Long,
) {
    data class AddressDto(
        val id: String,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetAddressByIdQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetAddressByIdQueryHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.handler

import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetAddressByIdQuery
import com.restaurant.user.application.query.usecase.GetAddressByIdUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service

@Service
class GetAddressByIdQueryHandler(
    private val userRepository: UserRepository,
) : GetAddressByIdUseCase {
    override fun getAddressById(query: GetAddressByIdQuery): AddressDto {
        try {
            val userId = UserId.ofString(query.userId)
            val addressId = AddressId.ofString(query.addressId)
            val user =
                userRepository.findById(userId)
                    ?: throw UserDomainException.User.NotFound(userId.toString())

            val address =
                user.addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(addressId.toString())

            return AddressDto(
                id = address.addressId.value.toString(),
                name = address.name,
                streetAddress = address.streetAddress,
                detailAddress = address.detailAddress,
                city = address.city,
                state = address.state,
                country = address.country,
                zipCode = address.zipCode,
                isDefault = address.isDefault,
                createdAt = address.createdAt,
                updatedAt = address.updatedAt,
                version = address.version,
            )
        } catch (de: UserDomainException) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to fetch address due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserAddressesQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserAddressesQueryHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.handler

import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetUserAddressesQuery
import com.restaurant.user.application.query.usecase.GetUserAddressesUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service

@Service
class GetUserAddressesQueryHandler(
    private val userRepository: UserRepository,
) : GetUserAddressesUseCase {
    override fun getUserAddresses(query: GetUserAddressesQuery): List<AddressDto> {
        try {
            val userId = UserId.ofString(query.userId)
            val user =
                userRepository.findById(userId)
                    ?: throw UserDomainException.User.NotFound(userId.toString())

            return user.addresses.map { address ->
                AddressDto(
                    id = address.addressId.value.toString(),
                    name = address.name,
                    streetAddress = address.streetAddress,
                    detailAddress = address.detailAddress,
                    city = address.city,
                    state = address.state,
                    country = address.country,
                    zipCode = address.zipCode,
                    isDefault = address.isDefault,
                    createdAt = address.createdAt,
                    updatedAt = address.updatedAt,
                    version = address.version,
                )
            }
        } catch (de: UserDomainException.User.NotFound) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(
                message = "Failed to fetch addresses due to an unexpected error.",
                cause = e,
            )
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserProfileQueryHandler.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/handler/GetUserProfileQueryHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.handler

import com.restaurant.user.application.exception.UserApplicationException
import com.restaurant.user.application.query.dto.GetUserProfileByIdQuery
import com.restaurant.user.application.query.dto.UserProfileDto
import com.restaurant.user.application.query.usecase.GetUserProfileUseCase
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.UserId
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) : GetUserProfileUseCase {
    @Transactional(readOnly = true)
    override fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto {
        try {
            val userId = UserId.ofString(query.userId)
            val user = userRepository.findById(userId) ?: throw UserDomainException.User.NotFound(userId.toString())

            return UserProfileDto(
                id = user.id.value.toString(),
                username = user.username.value,
                email = user.email.value,
                name = user.name.value,
                phoneNumber = user.phoneNumber?.value,
                addresses =
                    user.addresses.map { address ->
                        UserProfileDto.AddressDto(
                            id = address.addressId.value.toString(),
                            name = address.name,
                            streetAddress = address.streetAddress,
                            detailAddress = address.detailAddress,
                            city = address.city,
                            state = address.state,
                            country = address.country,
                            zipCode = address.zipCode,
                            isDefault = address.isDefault,
                        )
                    },
                userType = user.userType.name,
                status = user.status.name,
                createdAt = user.createdAt,
                updatedAt = user.updatedAt,
                version = user.version,
            )
        } catch (de: UserDomainException.User.NotFound) {
            throw de
        } catch (iae: IllegalArgumentException) {
            throw UserApplicationException.BadRequest("Invalid user ID format.", iae)
        } catch (e: Exception) {
            throw UserApplicationException.UnexpectedError(message = "Failed to fetch profile due to an unexpected error.", cause = e)
        }
    }
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAddressByIdUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAddressByIdUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetAddressByIdQuery

/**
 * 주소 ID로 주소 조회 유스케이스 인터페이스
 */
interface GetAddressByIdUseCase {
    fun getAddressById(query: GetAddressByIdQuery): AddressDto
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAllAddressesUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetAllAddressesUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetUserAddressesQuery

/**
 * 모든 주소 조회 유스케이스 인터페이스
 */
interface GetAllAddressesUseCase {
    fun getAllAddresses(query: GetUserAddressesQuery): List<AddressDto>
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetProfileByIdUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetProfileByIdUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetUserProfileByIdQuery
import com.restaurant.user.application.query.dto.UserProfileDto

/**
 * 프로필 ID로 프로필 조회 유스케이스 인터페이스
 */
interface GetProfileByIdUseCase {
    fun getProfileById(query: GetUserProfileByIdQuery): UserProfileDto
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserAddressesUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserAddressesUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.application.query.dto.GetUserAddressesQuery

/**
 * 특정 사용자의 모든 주소 조회 유스케이스 인터페이스
 */
interface GetUserAddressesUseCase {
    fun getUserAddresses(query: GetUserAddressesQuery): List<AddressDto>
}

====================================================================


====================================================================
 File: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserProfileUseCase.kt
 Path: domains/user/application/src/main/kotlin/com/restaurant/user/application/query/usecase/GetUserProfileUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.application.query.usecase

import com.restaurant.user.application.query.dto.GetUserProfileByIdQuery
import com.restaurant.user.application.query.dto.UserProfileDto

/**
 * 사용자 프로필 조회 유스케이스 인터페이스
 */
interface GetUserProfileUseCase {
    fun getUserProfile(query: GetUserProfileByIdQuery): UserProfileDto
}

====================================================================


====================================================================
 File: domains/user/domain/build.gradle.kts
 Path: domains/user/domain/build.gradle.kts
 Timestamp: 2025-06-11 12:01:57
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    kotlin("plugin.serialization") version "2.1.0"
    id("io.spring.dependency-management")
}

dependencies {
    implementation(project(":domains:common:domain"))
    
    // kotlinx.serialization
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.1")
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-core:1.7.1")
    
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.1.0")
    implementation("com.github.avro-kotlin.avro4k:avro4k-core:2.3.0")
    implementation("jakarta.validation:jakarta.validation-api:3.1.0")
    implementation("com.fasterxml.uuid:java-uuid-generator:5.1.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

tasks {
    withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        compilerOptions {
            freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
        }
    }

    withType<Test> {
        useJUnitPlatform()
    }

}

sourceSets {
    main {
        kotlin.srcDirs("src/main/kotlin")
    }
    test {
        kotlin.srcDirs("src/test/kotlin")
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/aggregate/User.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.aggregate

import com.fasterxml.jackson.annotation.JsonIgnore
import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.UserStatus
import com.restaurant.user.domain.vo.UserType
import com.restaurant.user.domain.vo.Username
import java.time.Instant
import kotlin.ConsistentCopyVisibility

/**
 * User Aggregate Root (Rule 10)
 * 사용자와 관련된 모든 비즈니스 로직을 담당하는 Aggregate Root
 */
@ConsistentCopyVisibility
data class User private constructor(
    val id: UserId,
    val username: Username,
    val email: Email,
    val password: Password,
    val name: Name,
    val phoneNumber: PhoneNumber?,
    val userType: UserType,
    val status: UserStatus,
    val addresses: List<Address>,
    val createdAt: Instant,
    val updatedAt: Instant,
    @JsonIgnore
    val version: Long = 0L,
) : AggregateRoot() {
    companion object {
        private const val MAX_ADDRESSES = 10

        /**
         * 새로운 User를 생성합니다.
         */
        fun create(
            id: UserId,
            username: Username,
            email: Email,
            password: Password,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
        ): User {
            val now = Instant.now()
            val user =
                User(
                    id = id,
                    username = username,
                    email = email,
                    password = password,
                    name = name,
                    phoneNumber = phoneNumber,
                    userType = userType,
                    status = UserStatus.ACTIVE,
                    addresses = emptyList(),
                    createdAt = now,
                    updatedAt = now,
                    version = 0L,
                )

            // addDomainEvent는 protected 메서드
            user.addDomainEvent(
                UserEvent.Created(
                    username = username.value,
                    email = email.value,
                    name = name.value,
                    phoneNumber = phoneNumber?.value,
                    userType = userType.name,
                    id = id,
                    occurredAt = now,
                ),
            )

            return user
        }

        /**
         * 기존 데이터로부터 User를 재구성합니다.
         */
        fun reconstitute(
            id: UserId,
            username: Username,
            email: Email,
            password: Password,
            name: Name,
            phoneNumber: PhoneNumber?,
            userType: UserType,
            status: UserStatus,
            addresses: List<Address>,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): User {
            // 기본 주소 검증
            val defaultAddresses = addresses.filter { it.isDefault }
            if (defaultAddresses.size > 1) {
                throw UserDomainException.Address.MultipleDefaultsOnInit()
            }

            return User(
                id = id,
                username = username,
                email = email,
                password = password,
                name = name,
                phoneNumber = phoneNumber,
                userType = userType,
                status = status,
                addresses = addresses,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
        }
    }

    /**
     * 사용자 정보를 업데이트합니다.
     */
    fun updateProfile(
        name: Name,
        phoneNumber: PhoneNumber?,
    ): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        if (this.name == name && this.phoneNumber == phoneNumber) {
            return this
        }

        val updatedUser =
            copy(
                name = name,
                phoneNumber = phoneNumber,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.ProfileUpdated(
                name = name.value,
                phoneNumber = phoneNumber?.value,
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 비밀번호를 변경합니다.
     */
    fun changePassword(
        currentPassword: Password,
        newPassword: Password,
    ): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        if (this.password != currentPassword) {
            throw UserDomainException.User.PasswordMismatch()
        }

        if (this.password == newPassword) {
            return this
        }

        val updatedUser =
            copy(
                password = newPassword,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.PasswordChanged(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 주소를 추가합니다.
     */
    fun addAddress(address: Address): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        if (addresses.size >= MAX_ADDRESSES) {
            throw UserDomainException.Address.LimitExceeded(MAX_ADDRESSES)
        }

        if (addresses.any { it.addressId == address.addressId }) {
            throw UserDomainException.Address.DuplicateAddressId(address.addressId.value.toString())
        }

        val updatedAddresses =
            if (address.isDefault) {
                // 새 주소가 기본 주소라면, 기존 기본 주소들을 비기본으로 변경
                val newAddresses = addresses.map { it.copy(isDefault = false) }.toMutableList()
                newAddresses.add(address)
                newAddresses.toList()
            } else {
                addresses + address
            }

        val updatedUser =
            copy(
                addresses = updatedAddresses,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.AddressAdded(
                addressId = address.addressId,
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 주소를 업데이트합니다.
     */
    fun updateAddress(
        addressId: AddressId,
        name: Name,
        streetAddress: String,
        detailAddress: String?,
        city: String,
        state: String,
        country: String,
        zipCode: String,
        isDefault: Boolean,
    ): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        val existingAddress =
            addresses.find { it.addressId == addressId }
                ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        val updatedAddress =
            existingAddress.copy(
                name = name.value,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                updatedAt = Instant.now(),
            )

        val updatedAddresses = addresses.map { if (it.addressId == addressId) updatedAddress else it }

        if (isDefault && updatedAddresses.count { it.isDefault } > 1) {
            throw UserDomainException.Address.MultipleDefaults()
        }

        val updatedUser =
            copy(
                addresses = updatedAddresses,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.AddressUpdated(
                id = id,
                addressId = addressId,
                name = name.value,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 주소를 삭제합니다.
     */
    fun deleteAddress(addressId: AddressId): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }

        val existingAddress =
            addresses.find { it.addressId == addressId }
                ?: throw UserDomainException.Address.NotFound(addressId.value.toString())

        val updatedAddresses = addresses.filter { it.addressId != addressId }

        val updatedUser =
            copy(
                addresses = updatedAddresses,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.AddressDeleted(
                addressId = addressId,
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 사용자 계정을 비활성화합니다.
     */
    fun deactivate(): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }
        if (status == UserStatus.INACTIVE) {
            return this
        }

        val updatedUser =
            copy(
                status = UserStatus.INACTIVE,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.Deactivated(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 사용자 계정을 활성화합니다.
     */
    fun activate(): User {
        if (status == UserStatus.WITHDRAWN) {
            throw UserDomainException.User.AlreadyWithdrawn()
        }
        if (status == UserStatus.ACTIVE) {
            return this
        }

        val updatedUser =
            copy(
                status = UserStatus.ACTIVE,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.Activated(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 사용자 계정을 탈퇴 처리합니다.
     */
    fun withdraw(): User {
        if (status == UserStatus.WITHDRAWN) {
            return this
        }

        val updatedUser =
            copy(
                status = UserStatus.WITHDRAWN,
                updatedAt = Instant.now(),
                version = this.version + 1,
            )

        updatedUser.addDomainEvent(
            UserEvent.Withdrawn(
                id = id,
                occurredAt = Instant.now(),
            ),
        )

        return updatedUser
    }

    /**
     * 기본 주소를 가져옵니다.
     */
    fun getDefaultAddress(): Address? = addresses.find { it.isDefault }

    /**
     * 특정 주소를 가져옵니다.
     */
    fun getAddress(addressId: AddressId): Address? = addresses.find { it.addressId == addressId }

    /**
     * 사용자가 활성 상태인지 확인합니다.
     */
    fun isActive(): Boolean = status == UserStatus.ACTIVE

    /**
     * 사용자가 탈퇴 상태인지 확인합니다.
     */
    fun isWithdrawn(): Boolean = status == UserStatus.WITHDRAWN
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/entity/Address.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.entity

import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.exception.UserDomainException
import com.restaurant.user.domain.vo.AddressId
import java.time.Instant

/**
 * Address Domain Entity (Rule 11)
 * User Aggregate에 속하지만 자체 식별자를 가짐.
 */
data class Address constructor(
    val addressId: AddressId,
    val name: String,
    val streetAddress: String,
    val detailAddress: String?,
    val city: String,
    val state: String,
    val country: String,
    val zipCode: String,
    val isDefault: Boolean,
    val createdAt: Instant,
    val updatedAt: Instant,
    val version: Long = 0L,
) {
    init {
        if (streetAddress.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Street address cannot be blank.")
        }
        validateZipCode(zipCode)
        if (name.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Name cannot be blank.")
        }
        if (city.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("City cannot be blank.")
        }
        if (state.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("State cannot be blank.")
        }
        if (country.isBlank()) {
            throw UserDomainException.Validation.InvalidAddressFormat("Country cannot be blank.")
        }
    }

    fun updateDetails(
        name: String,
        streetAddress: String,
        detailAddress: String?,
        city: String,
        state: String,
        country: String,
        zipCode: String,
        isDefault: Boolean,
    ): Address {
        validateZipCode(zipCode)
        if (this.name == name &&
            this.streetAddress == streetAddress &&
            this.detailAddress == detailAddress &&
            this.city == city &&
            this.state == state &&
            this.country == country &&
            this.zipCode == zipCode &&
            this.isDefault == isDefault
        ) {
            return this
        }
        return this.copy(
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun toData(): UserEvent.AddressData =
        UserEvent.AddressData(
            id = addressId.value.toString(),
            name = name,
            streetAddress = streetAddress,
            detailAddress = detailAddress,
            city = city,
            state = state,
            country = country,
            zipCode = zipCode,
            isDefault = isDefault,
        )

    companion object {
        private fun validateZipCode(zipCode: String) {
            if (zipCode.isBlank() || zipCode.length != 5 || !zipCode.all { it.isDigit() }) {
                throw UserDomainException.Validation.InvalidAddressFormat("Zip code must be 5 digits.")
            }
        }

        fun create(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
        ): Address {
            validateZipCode(zipCode)
            val now = Instant.now()
            return Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = now,
                updatedAt = now,
                version = 0L,
            )
        }

        fun reconstitute(
            addressId: AddressId,
            name: String,
            streetAddress: String,
            detailAddress: String?,
            city: String,
            state: String,
            country: String,
            zipCode: String,
            isDefault: Boolean,
            createdAt: Instant,
            updatedAt: Instant,
            version: Long,
        ): Address =
            Address(
                addressId = addressId,
                name = name,
                streetAddress = streetAddress,
                detailAddress = detailAddress,
                city = city,
                state = state,
                country = country,
                zipCode = zipCode,
                isDefault = isDefault,
                createdAt = createdAt,
                updatedAt = updatedAt,
                version = version,
            )
    }

    fun markAsDefault(): Address {
        if (this.isDefault) return this
        return this.copy(
            isDefault = true,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }

    fun markAsNonDefault(): Address {
        if (!this.isDefault) return this
        return this.copy(
            isDefault = false,
            updatedAt = Instant.now(),
            version = this.version + 1,
        )
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/error/UserDomainErrorCodes.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.error

import com.restaurant.common.domain.error.ErrorCode

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum (Rule 67)
 */
enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다."),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다."),
    DUPLICATE_USERNAME("USER-DOMAIN-003", "이미 사용중인 사용자 이름입니다."),
    PASSWORD_MISMATCH("USER-DOMAIN-004", "비밀번호가 일치하지 않습니다."),
    USER_ALREADY_WITHDRAWN("USER-DOMAIN-005", "이미 탈퇴한 사용자입니다."),
    ADDRESS_NOT_FOUND("USER-DOMAIN-006", "주소를 찾을 수 없습니다."),
    DUPLICATE_ADDRESS_ID("USER-DOMAIN-007", "이미 존재하는 주소 ID 입니다."),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-008", "최대 주소 등록 개수를 초과했습니다."),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-009", "기본 주소는 삭제할 수 없습니다."),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-010", "마지막 주소는 삭제할 수 없습니다."),
    INVALID_EMAIL_FORMAT("USER-DOMAIN-101", "잘못된 이메일 형식입니다."),
    INVALID_USERNAME_FORMAT("USER-DOMAIN-102", "사용자 이름 형식이 올바르지 않습니다."),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-103", "비밀번호 형식이 올바르지 않습니다."),
    INVALID_NAME_FORMAT("USER-DOMAIN-104", "잘못된 이름 형식입니다."),
    INVALID_ADDRESS_FORMAT("USER-DOMAIN-105", "잘못된 주소 형식입니다."),
    INVALID_PHONE_NUMBER_FORMAT("USER-DOMAIN-106", "잘못된 전화번호 형식입니다."),
    INVALID_USER_ID_FORMAT("USER-DOMAIN-107", "잘못된 사용자 ID 형식입니다."),
    INVALID_ADDRESS_ID_FORMAT("USER-DOMAIN-108", "잘못된 주소 ID 형식입니다."),
    ADDRESS_ID_MISMATCH("USER-DOMAIN-201", "주소 ID가 일치하지 않습니다."),
    INVALID_CREDENTIALS("USER-DOMAIN-056", "Invalid credentials"),
    ADMIN_CANNOT_BE_WITHDRAWN("USER-DOMAIN-057", "Admin user cannot be withdrawn"),
    MULTIPLE_DEFAULT_ADDRESSES("USER-DOMAIN-109", "Cannot have multiple default addresses"),
    DEFAULT_ADDRESS_NOT_FOUND("USER-DOMAIN-108", "Default address not found"),
    PERSISTENCE_ERROR("USER-DOMAIN-901", "Persistence error occurred"),
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/event/UserEvent.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.time.Instant
import java.util.UUID

/**
 * Custom serializer for UUID
 */
object UUIDSerializer : KSerializer<UUID> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("UUID", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: UUID,
    ) {
        encoder.encodeString(value.toString())
    }

    override fun deserialize(decoder: Decoder): UUID = UUID.fromString(decoder.decodeString())
}

/**
 * Custom serializer for Instant
 */
object InstantSerializer : KSerializer<Instant> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("Instant", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: Instant,
    ) {
        encoder.encodeString(value.toString())
    }

    override fun deserialize(decoder: Decoder): Instant = Instant.parse(decoder.decodeString())
}

/**
 * Sealed class grouping all domain events related to the User aggregate. (Rule 34)
 */
@Serializable
sealed class UserEvent : DomainEvent {
    @Serializable(with = UUIDSerializer::class)
    abstract override val eventId: UUID

    @Serializable(with = InstantSerializer::class)
    abstract override val occurredAt: Instant
    abstract val id: UserId

    override val aggregateId: String
        get() = id.value.toString()
    override val aggregateType: String
        get() = "User"

    // version 필드 추가 - 기본값 1로 설정
    override val version: Int
        get() = 1

    /**
     * User Created Event
     */
    @Serializable
    @SerialName("Created")
    data class Created(
        val username: String,
        val email: String,
        val name: String,
        val phoneNumber: String?,
        val userType: String,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Deleted Event
     */
    @Serializable
    @SerialName("Deleted")
    data class Deleted(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Password Changed Event
     */
    @Serializable
    @SerialName("PasswordChanged")
    data class PasswordChanged(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Profile Updated Event
     */
    @Serializable
    @SerialName("ProfileUpdated")
    data class ProfileUpdated(
        val name: String,
        val phoneNumber: String?,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Address Added Event
     */
    @Serializable
    @SerialName("AddressAdded")
    data class AddressAdded(
        val addressId: AddressId,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Address Updated Event
     */
    @Serializable
    @SerialName("AddressUpdated")
    data class AddressUpdated(
        val addressId: AddressId,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Address Deleted Event
     */
    @Serializable
    @SerialName("AddressDeleted")
    data class AddressDeleted(
        val addressId: AddressId,
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Withdrawn Event
     */
    @Serializable
    @SerialName("Withdrawn")
    data class Withdrawn(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Deactivated Event
     */
    @Serializable
    @SerialName("Deactivated")
    data class Deactivated(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * User Activated Event
     */
    @Serializable
    @SerialName("Activated")
    data class Activated(
        override val id: UserId,
        @Serializable(with = UUIDSerializer::class)
        override val eventId: UUID = UUID.randomUUID(),
        @Serializable(with = InstantSerializer::class)
        override val occurredAt: Instant,
    ) : UserEvent()

    /**
     * Address Data for events (Rule 33, 34)
     */
    @Serializable
    data class AddressData(
        val id: String,
        val name: String,
        val streetAddress: String,
        val detailAddress: String?,
        val city: String,
        val state: String,
        val country: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/exception/UserDomainException.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.exception

import com.restaurant.common.domain.exception.DomainException
import com.restaurant.user.domain.error.UserDomainErrorCodes

/**
 * Sealed class representing all possible domain exceptions for the User aggregate. (Rule 68)
 */
sealed class UserDomainException(
    override val errorCode: UserDomainErrorCodes,
    message: String? = errorCode.message, // String? 타입으로 변경하고, null일 경우 errorCode.message 사용
    cause: Throwable? = null,
) : DomainException(message, cause) { // DomainException 생성자 변경에 따라 수정
    /**
     * Validation-related exceptions
     */
    sealed class Validation(
        override val errorCode: UserDomainErrorCodes,
        message: String = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class InvalidEmailFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_EMAIL_FORMAT,
                message,
            )

        class InvalidUsernameFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USERNAME_FORMAT,
                message,
            )

        class InvalidUserIdFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_USER_ID_FORMAT,
                message,
            )

        class InvalidPasswordFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
                message,
            )

        class InvalidNameFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_NAME_FORMAT,
                message,
            )

        class InvalidPhoneNumberFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_PHONE_NUMBER_FORMAT,
                message,
            )

        class InvalidAddressFormat(
            message: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                message,
            )

        class InvalidAddressIdFormat(
            value: String,
        ) : Validation(
                UserDomainErrorCodes.INVALID_ADDRESS_ID_FORMAT,
                "Invalid address ID format: $value",
            )
    }

    /**
     * User-related exceptions
     */
    sealed class User(
        override val errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            userId: String,
        ) : User(
                UserDomainErrorCodes.USER_NOT_FOUND,
                "User not found with ID: $userId",
            )

        class DuplicateUsername(
            username: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_USERNAME,
                "Username already exists: $username",
            )

        class DuplicateEmail(
            email: String,
        ) : User(
                UserDomainErrorCodes.DUPLICATE_EMAIL,
                "Email already exists: $email",
            )

        class PasswordMismatch : User(UserDomainErrorCodes.PASSWORD_MISMATCH)

        class AlreadyWithdrawn : User(UserDomainErrorCodes.USER_ALREADY_WITHDRAWN)

        class InvalidCredentials(
            username: String,
        ) : User(
                UserDomainErrorCodes.INVALID_CREDENTIALS,
                "Invalid credentials for username: $username",
            )

        class AdminCannotBeWithdrawn :
            User(
                UserDomainErrorCodes.ADMIN_CANNOT_BE_WITHDRAWN,
                "Admin user cannot be withdrawn.",
            )
    }

    /**
     * Address-related exceptions
     */
    sealed class Address(
        override val errorCode: UserDomainErrorCodes,
        message: String? = errorCode.message,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause) {
        class NotFound(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_NOT_FOUND,
                "Address not found with ID: $addressId",
            )

        class DefaultAddressNotFound(
            message: String = "Default address ID does not exist in the address list.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_NOT_FOUND,
                message,
            )

        class DuplicateAddressId(
            addressId: String,
        ) : Address(
                UserDomainErrorCodes.DUPLICATE_ADDRESS_ID,
                "Address ID already exists: $addressId",
            )

        class IdMismatch(
            existingId: String,
            newId: String,
        ) : Address(
                UserDomainErrorCodes.ADDRESS_ID_MISMATCH,
                "Address ID mismatch: expected $existingId, got $newId",
            )

        class LimitExceeded(
            limit: Int,
        ) : Address(
                UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
                "Cannot add more addresses, limit is $limit",
            )

        class CannotDeleteDefault(
            message: String = "Cannot remove the default address.",
        ) : Address(
                UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
                message,
            )

        class CannotDeleteLast(
            message: String = "Cannot remove the last address.",
        ) : Address(
                UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
                message,
            )

        class MultipleDefaults(
            message: String = "Multiple default addresses found.",
        ) : Address(
                UserDomainErrorCodes.MULTIPLE_DEFAULT_ADDRESSES,
                message,
            )

        class MultipleDefaultsOnInit(
            val reason: String = "Cannot initialize user with multiple default addresses.",
        ) : Address(
                UserDomainErrorCodes.INVALID_ADDRESS_FORMAT,
                reason,
            )
    }

    class PersistenceError(
        override val errorCode: UserDomainErrorCodes = UserDomainErrorCodes.PERSISTENCE_ERROR,
        message: String,
        cause: Throwable? = null,
    ) : UserDomainException(errorCode, message, cause)
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/repository/UserRepository.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.repository

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username

interface UserRepository {
    fun findById(id: UserId): User?

    fun findByUsername(username: Username): User?

    fun findByEmail(email: Email): User? // findByEmail 메서드 추가
    fun existsByUsername(username: Username): Boolean

    fun existsByEmail(email: Email): Boolean

    fun save(user: User): User

    fun delete(user: User)
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/AddressId.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.UUID
import java.io.Serializable as JavaSerializable

@Serializable(with = AddressIdSerializer::class)
@JvmInline
value class AddressId private constructor(
    val value: UUID,
) : JavaSerializable {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun ofString(value: String): AddressId =
            try {
                AddressId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidAddressIdFormat(value)
            }

        fun of(value: UUID): AddressId = AddressId(value)

        fun fromUUID(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

/**
 * Custom serializer for AddressId to handle UUID serialization
 */
object AddressIdSerializer : KSerializer<AddressId> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("AddressId", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: AddressId,
    ) {
        encoder.encodeString(value.value.toString())
    }

    override fun deserialize(decoder: Decoder): AddressId {
        val uuidString = decoder.decodeString()
        return AddressId.ofString(uuidString)
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Email.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * Value object representing an email address.
 * This class ensures that the email address is valid according to a basic pattern.
 */
@JvmInline
value class Email private constructor(
    val value: String,
) {
    companion object {
        private val EMAIL_PATTERN =
            Regex(
                "[a-zA-Z0-9+._%\\-]{1,256}" +
                    "@" +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
                    "(" +
                    "\\." +
                    "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
                    ")+",
            )

        /**
         * Creates a new Email from a string value.
         * @throws UserDomainException.Validation if the email format is invalid
         */
        fun of(value: String): Email {
            if (!EMAIL_PATTERN.matches(value)) {
                throw UserDomainException.Validation.InvalidEmailFormat("Invalid email format: $value")
            }
            return Email(value.lowercase())
        }
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Name.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Name private constructor(
    val value: String,
) : Serializable {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat("Invalid name format: $value")
        }
    }

    companion object {
        private const val MIN_LENGTH = 2
        private const val MAX_LENGTH = 50

        fun of(value: String): Name {
            if (value.isBlank() || value.length < MIN_LENGTH || value.length > MAX_LENGTH) {
                throw UserDomainException.Validation.InvalidNameFormat("이름은 $MIN_LENGTH 자 이상 $MAX_LENGTH 자 이하이어야 하며, 공백일 수 없습니다: '$value'")
            }
            return Name(value)
        }
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Password.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException

/**
 * 비밀번호 Value Object
 */
@JvmInline
value class Password private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Encoded password cannot be blank.")
        }
        if (value.length < 8) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must be at least 8 characters long.")
        }
        if (!value.contains(Regex("[A-Z]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one uppercase letter.")
        }
        if (!value.contains(Regex("[a-z]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one lowercase letter.")
        }
        if (!value.contains(Regex("[0-9]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one digit.")
        }
        if (!value.contains(Regex("[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?~`]"))) {
            throw UserDomainException.Validation.InvalidPasswordFormat("Password must contain at least one special character.")
        }
    }

    override fun toString(): String = "********"

    companion object {
        /**
         * Creates a Password VO from a pre-encoded password string.
         * All validation is performed during object creation.
         */
        fun of(encodedPassword: String): Password = Password(encodedPassword)
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/PhoneNumber.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class PhoneNumber private constructor(
    val value: String,
) : Serializable {
    init {
        if (!value.matches(PHONE_NUMBER_REGEX)) {
            throw UserDomainException.Validation.InvalidPhoneNumberFormat(value)
        }
    }

    companion object {
        private val PHONE_NUMBER_REGEX = Regex("^010-?\\d{4}-?\\d{4}$")

        fun of(value: String): PhoneNumber {
            val normalizedValue = value.replace("-", "")
            if (!PHONE_NUMBER_REGEX.matches(value)) {
                throw UserDomainException.Validation.InvalidPhoneNumberFormat("휴대폰 번호 형식이 올바르지 않습니다: $value")
            }

            return PhoneNumber(normalizedValue)
        }
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserId.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo
import com.restaurant.user.domain.exception.UserDomainException
import kotlinx.serialization.KSerializer
import kotlinx.serialization.Serializable
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.descriptors.SerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import java.util.UUID
import java.io.Serializable as JavaSerializable

/**
 * Value object representing a unique user identifier.
 * This class wraps a UUID and provides type safety and validation.
 */
@Serializable(with = UserIdSerializer::class)
@JvmInline
value class UserId private constructor(
    val value: UUID,
) : JavaSerializable {
    companion object {
        /**
         * Creates a new UserId from a UUID.
         */
        fun of(uuid: UUID): UserId = UserId(uuid)

        /**
         * Creates a new UserId from a string representation of a UUID.
         * @throws UserDomainException.Validation if the string is not a valid UUID
         */
        fun ofString(value: String): UserId =
            try {
                UserId(UUID.fromString(value))
            } catch (e: IllegalArgumentException) {
                throw UserDomainException.Validation.InvalidUserIdFormat(value)
            }

        /**
         * Generates a new random UserId.
         */
        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromUUID(value: UUID): UserId = UserId(value)
    }

    override fun toString(): String = value.toString()
}

/**
 * Custom serializer for UserId to handle UUID serialization
 */
object UserIdSerializer : KSerializer<UserId> {
    override val descriptor: SerialDescriptor = PrimitiveSerialDescriptor("UserId", PrimitiveKind.STRING)

    override fun serialize(
        encoder: Encoder,
        value: UserId,
    ) {
        encoder.encodeString(value.value.toString())
    }

    override fun deserialize(decoder: Decoder): UserId {
        val uuidString = decoder.decodeString()
        return UserId.ofString(uuidString)
    }
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/Username.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo

import com.restaurant.user.domain.exception.UserDomainException
import java.io.Serializable

@JvmInline
value class Username(
    val value: String,
) : Serializable {
    init {

        if (value.isBlank() || value.length < 3 || value.length > 20) {
            throw UserDomainException.Validation.InvalidUsernameFormat(value)
        }
    }

    companion object {
        fun of(value: String): Username = Username(value)
    }

    override fun toString(): String = value
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserStatus.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserStatus.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo

/**
 * Represents the status of a user account.
 */
enum class UserStatus {
    ACTIVE,
    INACTIVE,
    WITHDRAWN,
}

====================================================================


====================================================================
 File: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserType.kt
 Path: domains/user/domain/src/main/kotlin/com/restaurant/user/domain/vo/UserType.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.domain.vo

/**
 * Represents the type of user.
 */
enum class UserType {
    CUSTOMER,
    ADMIN,
}

====================================================================


====================================================================
 File: domains/user/infrastructure/build.gradle.kts
 Path: domains/user/infrastructure/build.gradle.kts
 Timestamp: 2025-06-11 12:01:57
====================================================================
import java.net.URLClassLoader

plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0" // For JPA Entities
    kotlin("plugin.allopen") version "2.1.0" // For JPA Entities
    kotlin("plugin.serialization") version "2.1.0" // For kotlinx.serialization
    id("com.github.imflog.kafka-schema-registry-gradle-plugin") version "2.3.2"
    id("io.spring.dependency-management") version "1.1.7"
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencyManagement {
    imports {
        mavenBom("org.springframework.boot:spring-boot-dependencies:3.5.0")
    }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    implementation(project(":domains:common:domain"))
    implementation(project(":domains:common:infrastructure")) // For BaseEntity if needed
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:user:application")) // For DTOs if any indirect use
    implementation(project(":independent:outbox")) // For OutboxMessageRepository interface

    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0")
    implementation("org.flywaydb:flyway-core:11.8.2")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.19.0")
    implementation("com.fasterxml.jackson.module:jackson-module-jsonSchema:2.19.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8:2.1.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7") // Logging

    // kotlinx.serialization 의존성 추가
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.8.0")

    // Kafka 관련
    implementation("org.springframework.kafka:spring-kafka:4.0.0-M2")
    implementation("org.apache.kafka:kafka-clients:3.9.0")
    implementation("io.confluent:kafka-schema-registry-client:7.8.0")
    implementation("io.confluent:kafka-json-schema-serializer:7.8.0")

    runtimeOnly("org.postgresql:postgresql:42.7.5")

    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.testcontainers:testcontainers:1.21.0")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:postgresql:1.21.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

// JSON Schema 생성 태스크 (Rule VII.1.3.2) - buildSrc의 GenerateJsonSchemaTask 사용
tasks.register<GenerateJsonSchemaTask>("generateJsonSchema") {
    group = "schema"
    description = "Generate JSON schemas from UserEvent data classes using Jackson JsonSchemaGenerator"
    dependsOn("compileKotlin")

    packageName.set("com.restaurant.user.domain.event")
    domainEventInterface.set("com.restaurant.common.domain.event.DomainEvent")
    outputDir.set(file("src/main/resources/schemas"))
}

// Schema Registry 설정 (Rule VII.1.3.3) - 새로운 토픽 네이밍 정책 적용
schemaRegistry {
    url.set("http://localhost:8081") // 개발 환경용, 실제 환경에서는 ENV 변수 등으로 설정

    // === 자동화된 스키마 등록 ===
    val env = System.getenv("ENV") ?: "dev"
    val team = "restaurant"
    val domain = "user"
    val dataType = "event"
    val version = "v1"

    fun File.toActionName(): String =
        this.nameWithoutExtension.removePrefix("user_event_")
            .replace('_', '-')

    // schemas 디렉터리 내 *.json 파일을 모두 탐색하여 register/compatibility 설정 자동 추가
    val schemaDir = file("src/main/resources/schemas")
    val schemaFiles = schemaDir.listFiles { f -> f.extension == "json" }?.toList() ?: emptyList()

    register {
        schemaFiles.forEach { schemaFile ->
            val action = schemaFile.toActionName()
            val subjectName = "$env.$team.$domain.$dataType.$action.$version-value"
            subject(subjectName, schemaFile.absolutePath, "JSON")
        }
    }

    compatibility {
        schemaFiles.forEach { schemaFile ->
            val action = schemaFile.toActionName()
            val subjectName = "$env.$team.$domain.$dataType.$action.$version-value"
            subject(subjectName, schemaFile.absolutePath, "JSON")
        }
    }
}

// Schema Registry 태스크들이 generateJsonSchema 후에 실행되도록 설정 (Rule VII.1.3.3)
tasks.named("registerSchemasTask") {
    dependsOn("generateJsonSchema")
}

tasks.named("testSchemasTask") {
    dependsOn("generateJsonSchema")
}

// build 태스크가 스키마 생성을 포함하도록 설정 (Rule VII.1.3.2)
tasks.named("build") {
    dependsOn("generateJsonSchema")
}

// processResources가 generateJsonSchema 후에 실행되도록 설정
tasks.named("processResources") {
    dependsOn("generateJsonSchema")
}
====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/AddressEntity.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/AddressEntity.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant
import java.util.UUID

import com.restaurant.common.infrastructure.entity.BaseEntity

@Entity
@Table(name = "addresses")
class AddressEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(nullable = false, unique = true) // domainId는 unique해야 할 가능성이 높습니다.
    val domainId: UUID,
    @Column(nullable = false)
    val name: String,
    @Column(nullable = false)
    val streetAddress: String,
    @Column(nullable = true)
    val detailAddress: String?,
    @Column(nullable = false)
    val city: String,
    @Column(nullable = false)
    val state: String,
    @Column(nullable = false)
    val country: String,
    @Column(nullable = false)
    val zipCode: String,
    @Column(nullable = false)
    val isDefault: Boolean,
    @Version
    @Column(nullable = false)
    val version: Long = 0L,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null // UserEntity와의 관계 추가
) : BaseEntity() 
====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/UserEntity.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/entity/UserEntity.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.entity

import com.restaurant.user.domain.vo.UserStatus
import com.restaurant.user.domain.vo.UserType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.CascadeType
import java.time.Instant
import java.util.Objects
import java.util.UUID

import com.restaurant.common.infrastructure.entity.BaseEntity

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false, length = 50)
    val username: String,
    @Column(nullable = false)
    val passwordHash: String,
    @Column(unique = true, nullable = false)
    val email: String,
    @Column(nullable = false, length = 50)
    val name: String,
    @Column(length = 20)
    val phoneNumber: String?,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val userType: UserType,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    val status: UserStatus = UserStatus.ACTIVE,
    @OneToMany(cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY, mappedBy = "user")
    var addresses: MutableList<AddressEntity> = mutableListOf(), // MutableList로 변경
    @Version
    @Column(nullable = false)
    val version: Long = 0L
) : BaseEntity() {
    // AddressEntity 추가를 위한 편의 메서드 (선택적, 양방향 관계 설정 시 유용)
    fun addAddress(address: AddressEntity) {
        addresses.add(address)
        address.user = this // AddressEntity에 user 필드가 있다고 가정
    }

    fun removeAddress(address: AddressEntity) {
        addresses.remove(address)
        address.user = null // AddressEntity에 user 필드가 있다고 가정
    }


    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || javaClass != other.javaClass) return false
        val that = other as UserEntity
        return Objects.equals(id, that.id) &&
            domainId == that.domainId
    }

    override fun hashCode(): Int {
        return Objects.hash(id ?: domainId)
    }

    override fun toString(): String {
        val defaultAddressDomainId = addresses.find { it.isDefault }?.domainId?.toString() ?: "N/A"
        return "UserEntity(id=$id, domainId=$domainId, username='$username', email='$email', userType=$userType, defaultAddressDomainId=${defaultAddressDomainId}, addresses=${addresses.size}, createdAt=${this.createdAt}, updatedAt=${this.updatedAt}, version=$version)"
    }
} 
====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/AddressEntityMapper.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/AddressEntityMapper.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.mapper

import com.restaurant.user.domain.entity.Address
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.infrastructure.entity.AddressEntity
import java.time.Instant

// Address.reconstitute에서 userId를 사용하지 않는다고 가정
fun AddressEntity.toDomain(): Address =
    Address.reconstitute(
        addressId = AddressId.of(this.domainId),
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )

// AddressEntity 생성 시 UserEntity를 받지 않음
// UserEntity의 addresses 컬렉션에 추가될 때 관계가 설정됨
fun Address.toEntity(): AddressEntity =
    AddressEntity(
        // id는 DB 자동 생성
        domainId = this.addressId.value,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        version = this.version, // Address 도메인 객체에 해당 필드가 있다고 가정
        // user 필드는 UserEntity에서 AddressEntity를 추가하면서 설정
    )

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/DomainEventToOutboxMessageConverter.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/DomainEventToOutboxMessageConverter.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.mapper

// import com.fasterxml.jackson.databind.ObjectMapper // ObjectMapper import 제거
import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.user.domain.event.UserEvent
import kotlinx.serialization.encodeToString // kotlinx.serialization import 추가
import kotlinx.serialization.json.Json // kotlinx.serialization import 추가
import org.springframework.stereotype.Component

@Component
class DomainEventToOutboxMessageConverter(
    private val kotlinJson: Json, // 주입받은 Json Bean 사용
) {
    fun convert(domainEvent: UserEvent): OutboxMessage {
        // UserEvent 객체를 JSON 문자열로 직렬화 (주입받은 kotlinJson 사용)
        val payloadAsJsonString = kotlinJson.encodeToString(domainEvent)
        val topic = determineTopic(domainEvent)

        val headers = mutableMapOf<String, String>()
        headers["aggregateId"] = domainEvent.aggregateId
        headers["aggregateType"] = domainEvent.aggregateType
        headers["eventType"] = determineEventType(domainEvent)
        headers["eventId"] = domainEvent.eventId.toString()
        headers["occurredAt"] = domainEvent.occurredAt.toString()
        headers["contentType"] = "application/json" // KafkaJsonSchemaSerializer가 처리하므로 유지
        headers["schemaVersion"] = "v${domainEvent.version}" // 이벤트에서 추출한 버전 사용
        headers["version"] = domainEvent.version.toString() // 버전 정보 추가

        return OutboxMessage(
            payload = payloadAsJsonString, // JSON 문자열로 직렬화된 payload 전달
            topic = topic,
            headers = headers,
            aggregateType = domainEvent.aggregateType,
            aggregateId = domainEvent.aggregateId,
            eventType = determineEventType(domainEvent),
        )
    }

    /**
     * 새로운 토픽 네이밍 정책: <환경>.<팀>.<도메인>.<데이터유형>.<액션>.<버전>
     * 각 이벤트 타입별로 개별 토픽 생성 (1:1 분리 정책)
     */
    private fun determineTopic(event: UserEvent): String {
        val environment = System.getenv("APP_ENV") ?: "dev"
        val team = System.getenv("TEAM_NAME") ?: "restaurant" // 팀 정보 환경변수에서 추출
        val domain = "user"
        val dataType = "event" // 데이터 유형
        val action = determineAction(event) // 이벤트별 액션 결정
        val version = "v${event.version}" // 이벤트에서 버전 추출

        return "$environment.$team.$domain.$dataType.$action.$version"
    }

    /**
     * 이벤트 타입별 액션 결정
     */
    private fun determineAction(event: UserEvent): String =
        when (event) {
            is UserEvent.Created -> "created"
            is UserEvent.Deleted -> "deleted"
            is UserEvent.PasswordChanged -> "password-changed"
            is UserEvent.ProfileUpdated -> "profile-updated"
            is UserEvent.AddressAdded -> "address-added"
            is UserEvent.AddressUpdated -> "address-updated"
            is UserEvent.AddressDeleted -> "address-deleted"
            is UserEvent.Withdrawn -> "withdrawn"
            is UserEvent.Deactivated -> "deactivated"
            is UserEvent.Activated -> "activated"
            else -> "unknown"
        }

    private fun determineEventType(event: UserEvent): String =
        when (event) {
            is UserEvent.Created -> "UserEvent.Created"
            is UserEvent.ProfileUpdated -> "UserEvent.ProfileUpdated"
            is UserEvent.PasswordChanged -> "UserEvent.PasswordChanged"
            is UserEvent.AddressAdded -> "UserEvent.AddressAdded"
            is UserEvent.AddressUpdated -> "UserEvent.AddressUpdated"
            is UserEvent.AddressDeleted -> "UserEvent.AddressDeleted"
            is UserEvent.Withdrawn -> "UserEvent.Withdrawn"
            is UserEvent.Deactivated -> "UserEvent.Deactivated"
            is UserEvent.Activated -> "UserEvent.Activated"
            is UserEvent.Deleted -> "UserEvent.Deleted"
            else -> event::class.simpleName ?: "UnknownEvent"
        }
}

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/UserEntityMapper.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/mapper/UserEntityMapper.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.mapper

import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.Name
import com.restaurant.user.domain.vo.Password
import com.restaurant.user.domain.vo.PhoneNumber
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.entity.UserEntity

fun UserEntity.toDomain(): User {
    val userDomainId = UserId.of(this.domainId)
    val domainAddresses =
        this.addresses
            .map { addressEntity ->
                addressEntity.toDomain() // userId 인자 제거됨
            }.toList()

    // User.reconstitute에서 defaultAddressId를 사용하지 않거나,
    // User 도메인 객체가 addresses 리스트 내 isDefault 플래그로 관리한다고 가정
    return User.reconstitute(
        id = userDomainId,
        username = Username.of(this.username),
        password = Password.of(this.passwordHash),
        email = Email.of(this.email),
        name = Name.of(this.name),
        phoneNumber = this.phoneNumber?.let { PhoneNumber.of(it) },
        userType = this.userType,
        status = this.status,
        addresses = domainAddresses,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )
}

fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            domainId = this.id.value,
            username = this.username.value,
            passwordHash = this.password.value,
            email = this.email.value,
            name = this.name.value,
            phoneNumber = this.phoneNumber?.value,
            userType = this.userType,
            status = this.status,
            version = this.version,
        )

    // addresses 변환 및 양방향 관계 설정
    val addressEntities =
        this.addresses
            .map { address ->
                val addressEntity = address.toEntity()
                addressEntity.user = entity // UserEntity에 대한 참조 설정
                addressEntity
            }.toMutableList()
    entity.addresses = addressEntities
    return entity
}

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/SpringDataJpaUserRepository.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/SpringDataJpaUserRepository.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.repository

import com.restaurant.user.infrastructure.entity.UserEntity
import org.springframework.data.jpa.repository.JpaRepository
import java.util.UUID

interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    fun findByDomainId(domainId: UUID): UserEntity?

    fun findByUsername(username: String): UserEntity?

    fun findByEmail(email: String): UserEntity?

    fun existsByUsername(username: String): Boolean

    fun existsByEmail(email: String): Boolean
}

====================================================================


====================================================================
 File: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/UserRepositoryImpl.kt
 Path: domains/user/infrastructure/src/main/kotlin/com/restaurant/user/infrastructure/repository/UserRepositoryImpl.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.user.domain.aggregate.User
import com.restaurant.user.domain.event.UserEvent
import com.restaurant.user.domain.repository.UserRepository
import com.restaurant.user.domain.vo.Email
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.domain.vo.Username
import com.restaurant.user.infrastructure.mapper.DomainEventToOutboxMessageConverter
import com.restaurant.user.infrastructure.mapper.toDomain
import com.restaurant.user.infrastructure.mapper.toEntity
import org.springframework.stereotype.Repository

@Repository
class UserRepositoryImpl(
    private val springDataJpaUserRepository: SpringDataJpaUserRepository,
    private val outboxMessageRepository: OutboxMessageRepository,
    private val domainEventToOutboxMessageConverter: DomainEventToOutboxMessageConverter,
) : UserRepository {
    override fun findById(id: UserId): User? = springDataJpaUserRepository.findByDomainId(id.value)?.toDomain()

    override fun findByUsername(username: Username): User? = springDataJpaUserRepository.findByUsername(username.value)?.toDomain()

    override fun findByEmail(email: Email): User? = springDataJpaUserRepository.findByEmail(email.value)?.toDomain()

    override fun existsByUsername(username: Username): Boolean = springDataJpaUserRepository.existsByUsername(username.value)

    override fun existsByEmail(email: Email): Boolean = springDataJpaUserRepository.existsByEmail(email.value)

    override fun save(user: User): User {
        val userEntity = user.toEntity()
        // 주의: userEntity의 addresses 내부 AddressEntity들이 userEntity를 참조하도록 설정 필요 (양방향 관계)
        // User.toEntity() 내부 또는 여기서 명시적으로 설정
        userEntity.addresses.forEach { it.user = userEntity }

        val savedEntity = springDataJpaUserRepository.save(userEntity)

        // 도메인 이벤트 처리
        val domainEvents = user.getDomainEvents()
        if (domainEvents.isNotEmpty()) {
            val outboxMessages = domainEvents.map { 
                domainEventToOutboxMessageConverter.convert(it as UserEvent)
            }

            if (outboxMessages.isNotEmpty()) {
                outboxMessageRepository.saveAll(outboxMessages)
            }

            user.clearDomainEvents()
        }

        return savedEntity.toDomain()
    }

    override fun delete(user: User) {
        springDataJpaUserRepository.delete(user.toEntity())
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/build.gradle.kts
 Path: domains/user/presentation/build.gradle.kts
 Timestamp: 2025-06-11 12:01:57
====================================================================
plugins {
    `java-library`
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.spring") version "2.1.0"
    id("io.spring.dependency-management")
}

java {
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common:presentation"))
    
    implementation("org.springframework.boot:spring-boot-starter-web:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-validation:3.5.0")

    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.6")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserAddressController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserAddressController.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.controller

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.command.dto.DeleteAddressCommand
import com.restaurant.user.application.command.usecase.DeleteAddressUseCase
import com.restaurant.user.application.command.usecase.RegisterAddressUseCase
import com.restaurant.user.application.command.usecase.UpdateAddressUseCase
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.command.extensions.dto.request.toCommand
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.servlet.support.ServletUriComponentsBuilder
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(name = "User Address Commands", description = "사용자 주소 관리 API (생성/수정/삭제)")
@RestController
@RequestMapping("/api/v1/users")
class UserAddressController(
    private val registerAddressCommandHandler: RegisterAddressUseCase,
    private val updateAddressCommandHandler: UpdateAddressUseCase,
    private val deleteAddressCommandHandler: DeleteAddressUseCase,
) {
    @PostMapping
    @Operation(
        summary = "사용자 주소 등록",
        description = "특정 사용자의 새로운 주소를 등록합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "주소 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden) - 다른 사용자의 주소 등록 시도 등",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun registerAddress(
        @Parameter(description = "주소를 등록할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "주소 등록 요청 정보", required = true, schema = Schema(implementation = RegisterAddressRequestV1::class))
        @Valid
        @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Received request to register address for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId))
        val addressId: AddressId = registerAddressCommandHandler.registerAddress(command)

        val location =
            ServletUriComponentsBuilder
                .fromCurrentRequest()
                .path("/{addressId}")
                .buildAndExpand(addressId.value)
                .toUri()

        return ResponseEntity.created(location).body(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address registered successfully. Address ID: ${addressId.value}",
            ),
        )
    }

    @PutMapping("/{addressId}")
    @Operation(
        summary = "사용자 주소 수정",
        description = "특정 사용자의 기존 주소 정보를 수정합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden) - 다른 사용자의 주소 수정 시도 등",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun updateAddress(
        @Parameter(description = "주소를 수정할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "수정할 주소의 ID", required = true, example = "b2c3d4e5-f6a7-8901-2345-67890abcdef1")
        @PathVariable addressId: UUID,
        @Parameter(description = "주소 수정 요청 정보", required = true, schema = Schema(implementation = UpdateAddressRequestV1::class))
        @Valid
        @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Received request to update address ID: $addressId for user ID: $userId" }
        val command = request.toCommand(UserId.of(userId), AddressId.of(addressId))
        updateAddressCommandHandler.updateAddress(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address updated successfully.",
            ),
        )
    }

    @DeleteMapping("/{addressId}")
    @Operation(
        summary = "사용자 주소 삭제",
        description = "특정 사용자의 주소를 삭제합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden) - 다른 사용자의 주소 삭제 시도 등",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun deleteAddress(
        @Parameter(description = "주소를 삭제할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "삭제할 주소의 ID", required = true, example = "b2c3d4e5-f6a7-8901-2345-67890abcdef1")
        @PathVariable addressId: UUID,
    ): ResponseEntity<CommandResultResponse> {
        log.info { "Received request to delete address ID: $addressId for user ID: $userId" }
        val command =
            DeleteAddressCommand(
                userId = UserId.of(userId).value.toString(),
                addressId = AddressId.of(addressId).value.toString(),
            )
        deleteAddressCommandHandler.deleteAddress(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "Address deleted successfully.",
            ),
        )
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/controller/UserController.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.controller

import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.user.application.command.usecase.ChangePasswordUseCase
import com.restaurant.user.application.command.usecase.DeleteUserUseCase
import com.restaurant.user.application.command.usecase.LoginUseCase
import com.restaurant.user.application.command.usecase.RegisterUserUseCase
import com.restaurant.user.application.command.usecase.UpdateProfileUseCase
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.user.presentation.v1.command.extensions.dto.request.toCommand
import com.restaurant.user.presentation.v1.query.dto.response.LoginResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PatchMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.servlet.support.ServletUriComponentsBuilder
import java.util.UUID

private val log = KotlinLogging.logger {}

@Tag(name = "User Commands", description = "사용자 계정 관리 API")
@RestController
@RequestMapping("/api/v1/users")
class UserController(
    private val registerUserCommandHandler: RegisterUserUseCase,
    private val loginCommandHandler: LoginUseCase,
    private val updateProfileCommandHandler: UpdateProfileUseCase,
    private val changePasswordCommandHandler: ChangePasswordUseCase,
    private val deleteUserCommandHandler: DeleteUserUseCase,
) {
    @PostMapping("/register")
    @Operation(
        summary = "사용자 회원가입",
        description = "새로운 사용자 계정을 생성합니다.",
        security = [], // 회원가입은 인증이 필요 없음
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "회원가입 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun registerUser(
        @Parameter(description = "회원가입 요청 정보", required = true, schema = Schema(implementation = RegisterUserRequestV1::class))
        @Valid
        @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand()
        val userId: UserId = registerUserCommandHandler.register(command)

        val location =
            ServletUriComponentsBuilder
                .fromCurrentContextPath()
                .path("/api/v1/users/{userId}/profile")
                .buildAndExpand(userId.value)
                .toUri()

        return ResponseEntity.created(location).body(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User registered successfully.",
            ),
        )
    }

    @PostMapping("/login")
    @Operation(
        summary = "사용자 로그인",
        description = "이메일과 비밀번호로 사용자 인증을 수행합니다.",
        security = [], // 로그인은 인증이 필요 없음
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그인 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = LoginResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증 실패 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun login(
        @Parameter(description = "로그인 요청 정보", required = true, schema = Schema(implementation = LoginRequestV1::class))
        @Valid
        @RequestBody request: LoginRequestV1,
    ): ResponseEntity<LoginResponseV1> {
        val command = request.toCommand()
        val loginResult = loginCommandHandler.login(command)
        return ResponseEntity.ok(
            LoginResponseV1(
                id = loginResult.id,
                username = loginResult.username,
                accessToken = loginResult.accessToken,
                refreshToken = loginResult.refreshToken,
            ),
        )
    }

    @PutMapping("/{userId}/profile")
    @Operation(
        summary = "사용자 프로필 수정",
        description = "기존 사용자의 프로필 정보를 수정합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun updateProfile(
        @Parameter(description = "수정할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "프로필 수정 요청 정보", required = true, schema = Schema(implementation = UpdateProfileRequestV1::class))
        @Valid
        @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        updateProfileCommandHandler.updateProfile(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User profile updated successfully.",
            ),
        )
    }

    @PatchMapping("/{userId}/password")
    @Operation(
        summary = "사용자 비밀번호 변경",
        description = "기존 비밀번호를 확인한 후 새로운 비밀번호로 변경합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "비밀번호 변경 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 또는 현재 비밀번호 불일치 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun changePassword(
        @Parameter(description = "비밀번호를 변경할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "비밀번호 변경 요청 정보", required = true, schema = Schema(implementation = ChangePasswordRequestV1::class))
        @Valid
        @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        changePasswordCommandHandler.changePassword(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User password changed successfully.",
            ),
        )
    }

    @DeleteMapping("/{userId}")
    @Operation(
        summary = "사용자 계정 삭제",
        description = "사용자 계정을 영구적으로 삭제합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "계정 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식입니다 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun deleteUser(
        @Parameter(description = "삭제할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(
            description = "계정 삭제 요청 정보 (필요시 현재 비밀번호 등)",
            required = true,
            schema = Schema(implementation = DeleteUserRequestV1::class),
        )
        @Valid
        @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val command = request.toCommand(UserId.of(userId))
        deleteUserCommandHandler.deleteUser(command)
        return ResponseEntity.ok(
            CommandResultResponse(
                status = "SUCCESS",
                message = "User deleted successfully.",
            ),
        )
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/ChangePasswordRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/ChangePasswordRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 비밀번호 변경 요청")
data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/DeleteUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/DeleteUserRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 계정 삭제 요청")
data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/LoginRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/LoginRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

@Schema(description = "사용자 로그인 요청")
data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterAddressRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 주소 등록 요청")
data class RegisterAddressRequestV1(
    @field:Schema(description = "주소 이름", example = "집")
    @field:NotBlank(message = "주소 이름은 필수 입력 항목입니다.")
    val name: String,
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "도시", example = "서울시")
    @field:NotBlank(message = "도시는 필수 입력 항목입니다.")
    val city: String,
    @field:Schema(description = "주/도", example = "서울특별시")
    @field:NotBlank(message = "주/도는 필수 입력 항목입니다.")
    val state: String,
    @field:Schema(description = "국가", example = "대한민국")
    @field:NotBlank(message = "국가는 필수 입력 항목입니다.")
    val country: String,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false", defaultValue = "false")
    val isDefault: Boolean? = false,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterUserRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/RegisterUserRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
/**
 * 사용자 등록 요청 DTO
 *
 * Contains validation and schema annotations for user registration API.
 *
 * @author junoko
 */
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

@Schema(description = "사용자 등록 요청")
data class RegisterUserRequestV1(
    @Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @Schema(description = "비밀번호", example = "password123!")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자 이상이어야 합니다.")
    val password: String,
    @Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @Schema(description = "사용자 아이디", example = "testuser")
    @field:NotBlank(message = "사용자 아이디는 필수 입력 항목입니다.")
    @field:Size(min = 3, max = 20, message = "사용자 아이디는 3자 이상 20자 이하이어야 합니다.")
    val username: String,
    @Schema(description = "전화번호 (선택)", example = "010-1234-5678")
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateAddressRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateAddressRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

@Schema(description = "사용자 주소 수정 요청")
data class UpdateAddressRequestV1(
    @field:Schema(description = "주소 이름", example = "회사")
    @field:NotBlank(message = "주소 이름은 필수 입력 항목입니다.")
    val name: String,
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "도시", example = "서울시")
    @field:NotBlank(message = "도시는 필수 입력 항목입니다.")
    val city: String,
    @field:Schema(description = "주/도", example = "서울특별시")
    @field:NotBlank(message = "주/도는 필수 입력 항목입니다.")
    val state: String,
    @field:Schema(description = "국가", example = "대한민국")
    @field:NotBlank(message = "국가는 필수 입력 항목입니다.")
    val country: String,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true", defaultValue = "false")
    val isDefault: Boolean? = false,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateProfileRequestV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/dto/request/UpdateProfileRequestV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern

@Schema(description = "사용자 프로필 수정 요청")
data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
    @field:Schema(description = "전화번호 (선택)", example = "010-1234-5678", nullable = true)
    @field:Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "유효한 전화번호 형식이 아닙니다 (예: 010-1234-5678)")
    val phoneNumber: String? = null,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/extensions/dto/request/UserCommandRequestExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/command/extensions/dto/request/UserCommandRequestExtensions.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.command.extensions.dto.request

import com.restaurant.user.application.command.dto.ChangePasswordCommand
import com.restaurant.user.application.command.dto.DeleteUserCommand
import com.restaurant.user.application.command.dto.LoginCommand
import com.restaurant.user.application.command.dto.RegisterAddressCommand
import com.restaurant.user.application.command.dto.RegisterUserCommand
import com.restaurant.user.application.command.dto.UpdateAddressCommand
import com.restaurant.user.application.command.dto.UpdateProfileCommand
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.LoginRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.user.presentation.v1.command.dto.request.UpdateProfileRequestV1

fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
        username = this.username,
        phoneNumber = this.phoneNumber,
    )

fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

fun UpdateProfileRequestV1.toCommand(userId: UserId): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId.value.toString(),
        name = this.name,
        phoneNumber = this.phoneNumber,
    )

fun ChangePasswordRequestV1.toCommand(userId: UserId): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId.value.toString(),
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

fun DeleteUserRequestV1.toCommand(userId: UserId): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId.value.toString(),
        password = this.currentPassword,
    )

fun RegisterAddressRequestV1.toCommand(userId: UserId): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId.value.toString(),
        name = this.name,
        street = this.street,
        detail = this.detail ?: "",
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

fun UpdateAddressRequestV1.toCommand(
    userId: UserId,
    addressId: AddressId,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId.value.toString(),
        addressId = addressId.value.toString(),
        name = this.name,
        street = this.street,
        detail = this.detail ?: "",
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserAddressQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserAddressQueryController.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.controller

import com.restaurant.user.application.query.dto.GetAddressByIdQuery
import com.restaurant.user.application.query.dto.GetUserAddressesQuery
import com.restaurant.user.application.query.usecase.GetAddressByIdUseCase
import com.restaurant.user.application.query.usecase.GetUserAddressesUseCase
import com.restaurant.user.domain.vo.AddressId
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.query.dto.response.AddressDetailResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toDetailResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.ArraySchema
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Address Queries", description = "사용자 주소 조회 API")
class UserAddressQueryController(
    private val getUserAddressesQueryHandler: GetUserAddressesUseCase,
    private val getAddressByIdQueryHandler: GetAddressByIdUseCase,
) {
    @GetMapping("/{userId}/addresses")
    @Operation(
        summary = "사용자 주소 목록 조회",
        description = "특정 사용자의 모든 주소를 조회합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 목록 조회 성공",
                content = [
                    Content(
                        mediaType = "application/json",
                        array = ArraySchema(schema = Schema(implementation = AddressResponseV1::class)),
                    ),
                ],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserAddresses(
        @Parameter(description = "주소를 조회할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
    ): ResponseEntity<List<AddressResponseV1>> {
        log.info { "Received request to get addresses for user ID: $userId" }
        val query = GetUserAddressesQuery(userId = UserId.of(userId).value.toString())
        val addresses = getUserAddressesQueryHandler.getUserAddresses(query)
        val responseList = addresses.map { it.toResponseV1() }

        log.info { "Returning ${responseList.size} addresses for user ID: $userId" }
        return ResponseEntity.ok(responseList)
    }

    @GetMapping("/{userId}/addresses/{addressId}")
    @Operation(
        summary = "특정 주소 상세 조회",
        description = "사용자의 특정 주소 상세 정보를 조회합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 상세 조회 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = AddressDetailResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 형식 (Bad Request)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getAddressById(
        @Parameter(description = "주소를 조회할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
        @Parameter(description = "조회할 주소의 ID", required = true, example = "b2c3d4e5-f6a7-8901-2345-67890abcdef1")
        @PathVariable addressId: UUID,
    ): ResponseEntity<AddressDetailResponseV1> {
        log.info { "Received request to get address ID: $addressId for user ID: $userId" }
        val query =
            GetAddressByIdQuery(
                userId = UserId.of(userId).value.toString(),
                addressId = AddressId.of(addressId).value.toString(),
            )
        val address = getAddressByIdQueryHandler.getAddressById(query)
        val response = address.toDetailResponseV1()

        log.info { "Returning address details for address ID: $addressId" }
        return ResponseEntity.ok(response)
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserQueryController.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/controller/UserQueryController.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.controller

import com.restaurant.user.application.query.dto.GetUserProfileByIdQuery
import com.restaurant.user.application.query.usecase.GetUserProfileUseCase
import com.restaurant.user.domain.vo.UserId
import com.restaurant.user.presentation.v1.query.dto.response.UserProfileResponseV1
import com.restaurant.user.presentation.v1.query.extensions.dto.response.toResponseV1
import io.github.oshai.kotlinlogging.KotlinLogging
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

private val log = KotlinLogging.logger {}

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User Queries", description = "사용자 정보 조회 API")
class UserQueryController(
    private val getUserProfileQueryHandler: GetUserProfileUseCase,
) {
    @GetMapping("/{userId}/profile")
    @Operation(
        summary = "사용자 프로필 조회",
        description = "사용자 ID로 프로필 정보를 조회합니다.",
        security = [SecurityRequirement(name = "bearerAuth")],
    )
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 조회 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = UserProfileResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 UUID 형식",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "401",
                description = "인증되지 않은 사용자 (Unauthorized)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "403",
                description = "접근 권한 없음 (Forbidden)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음 (Not Found)",
                content = [Content(mediaType = "application/problem+json", schema = Schema(implementation = ProblemDetail::class))],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "조회할 사용자의 ID", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef")
        @PathVariable userId: UUID,
    ): ResponseEntity<UserProfileResponseV1> {
        log.info { "Received request to get profile for user ID: $userId" }
        val query = GetUserProfileByIdQuery(userId = UserId.of(userId).value.toString())
        val userProfileDto = getUserProfileQueryHandler.getUserProfile(query)
        val responseDto = userProfileDto.toResponseV1()

        log.info { "Returning user profile for ID: $userId" }
        return ResponseEntity.ok(responseDto)
    }
}

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressDetailResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressDetailResponseV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import java.time.Instant

@Schema(description = "사용자 주소 상세 응답")
data class AddressDetailResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "주소 이름", example = "집")
    val name: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val streetAddress: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detailAddress: String?,
    @Schema(description = "도시", example = "서울시")
    val city: String,
    @Schema(description = "주/도", example = "서울특별시")
    val state: String,
    @Schema(description = "국가", example = "대한민국")
    val country: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "주소 생성 시간", example = "2023-01-01T12:00:00.000000000Z")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "주소 최종 수정 시간", example = "2023-01-01T12:00:00.000000000Z")
    val updatedAt: Instant,
    @Schema(description = "엔티티 버전 (낙관적 락)", example = "1")
    val version: Long,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/AddressResponseV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "사용자 주소 응답")
data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "주소 이름", example = "집")
    val name: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val streetAddress: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detailAddress: String?,
    @Schema(description = "도시", example = "서울시")
    val city: String,
    @Schema(description = "주/도", example = "서울특별시")
    val state: String,
    @Schema(description = "국가", example = "대한민국")
    val country: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/LoginResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/LoginResponseV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "로그인 응답 V1")
data class LoginResponseV1(
    @Schema(description = "사용자 ID (UUID)")
    val id: String,
    @Schema(description = "사용자 이름")
    val username: String,
    @Schema(description = "액세스 토큰")
    val accessToken: String,
    @Schema(description = "리프레시 토큰")
    val refreshToken: String
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/UserProfileResponseV1.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/dto/response/UserProfileResponseV1.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import java.time.Instant

/**
 * 사용자 프로필 정보 응답 DTO (Rule 1.4, 39)
 */
@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "사용자 아이디", example = "testuser") val username: String,
    @Schema(description = "전화번호", example = "010-1234-5678", nullable = true) val phoneNumber: String?,
    @Schema(description = "사용자 타입", example = "CUSTOMER") val userType: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 생성 시간", example = "2023-01-01T12:00:00.000000000Z")
    val createdAt: Instant,
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSSS'Z'", timezone = "UTC")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01T12:00:00.000000000Z")
    val updatedAt: Instant,
    @Schema(description = "계정 상태", example = "ACTIVE", allowableValues = ["ACTIVE", "INACTIVE", "SUSPENDED"])
    val status: String,
    @Schema(description = "엔티티 버전 (낙관적 락)", example = "1")
    val version: Long,
)

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserAddressQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserAddressQueryResponseExtensions.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.extensions.dto.response

import com.restaurant.user.application.query.dto.AddressDto
import com.restaurant.user.presentation.v1.query.dto.response.AddressDetailResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1

fun AddressDto.toDetailResponseV1(): AddressDetailResponseV1 =
    AddressDetailResponseV1(
        id = this.id,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        version = this.version,
    )

fun AddressDto.toResponseV1(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

====================================================================


====================================================================
 File: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserQueryResponseExtensions.kt
 Path: domains/user/presentation/src/main/kotlin/com/restaurant/user/presentation/v1/query/extensions/dto/response/UserQueryResponseExtensions.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.user.presentation.v1.query.extensions.dto.response

import com.restaurant.user.application.query.dto.UserProfileDto
import com.restaurant.user.presentation.v1.query.dto.response.AddressResponseV1
import com.restaurant.user.presentation.v1.query.dto.response.UserProfileResponseV1

fun UserProfileDto.toResponseV1(): UserProfileResponseV1 =
    UserProfileResponseV1(
        id = this.id,
        email = this.email,
        name = this.name,
        username = this.username,
        phoneNumber = this.phoneNumber,
        userType = this.userType,
        addresses = this.addresses.map { it.toResponseV1() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
        status = this.status,
        version = this.version,
    )

fun UserProfileDto.AddressDto.toResponseV1(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        name = this.name,
        streetAddress = this.streetAddress,
        detailAddress = this.detailAddress,
        city = this.city,
        state = this.state,
        country = this.country,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

====================================================================


====================================================================
 File: independent/outbox/build.gradle.kts
 Path: independent/outbox/build.gradle.kts
 Timestamp: 2025-06-11 12:01:57
====================================================================
plugins {
    id("java-library")
    kotlin("jvm") version "2.1.0"
    kotlin("plugin.jpa") version "2.1.0"
    kotlin("plugin.allopen") version "2.1.0"
    kotlin("plugin.serialization") version "2.1.0"
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.MappedSuperclass")
    annotation("jakarta.persistence.Embeddable")
}

dependencies {
    // Spring Boot & JPA
    implementation("org.springframework.boot:spring-boot-starter:3.5.0")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.5.0")
    
    // Spring Kafka (KafkaTemplate 사용)
    implementation("org.springframework.kafka:spring-kafka:4.0.0-M2")
    
    // Confluent Schema Registry for JSON Schema support
    implementation("io.confluent:kafka-json-schema-serializer:7.5.1")
    implementation("io.confluent:kafka-schema-registry-client:7.5.1")
    
    // kotlinx.serialization for UserEvent (de)serialization
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.0")

    // UserEvent 정의를 참조하기 위한 의존성 (제거)
    // implementation(project(":domains:user:domain"))
    
    // Database migration
    implementation("org.flywaydb:flyway-core:11.8.2")
    
    // Jackson for JSON processing
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.19.0")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.19.0")
    
    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect:2.1.0")
    implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.0")
    
    // Logging
    implementation("io.github.oshai:kotlin-logging-jvm:7.0.7")
    
    // Database drivers
    runtimeOnly("org.postgresql:postgresql:42.7.5")
    runtimeOnly("com.h2database:h2:2.3.232")
    
    // Test dependencies
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.5.0")
    testImplementation("org.springframework.kafka:spring-kafka-test:4.0.0-M2")
    testImplementation("io.mockk:mockk:1.14.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.13.0-M3")
    testImplementation("org.assertj:assertj-core:4.0.0-M1")
    testImplementation("org.testcontainers:testcontainers:1.21.0")
    testImplementation("org.testcontainers:junit-jupiter:1.21.0")
    testImplementation("org.testcontainers:postgresql:1.21.0")
    testImplementation("org.testcontainers:kafka:1.21.0")
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.addAll(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessage.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessage.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.dto

import java.time.Instant

/**
 * Outbox 메시지를 나타내는 도메인 모델
 */
data class OutboxMessage(
    val id: Long? = null,
    val payload: Any,
    val topic: String,
    val headers: Map<String, String>,
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String,
    val createdAt: Instant = Instant.now(),
    val status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    val retryCount: Int = 0,
    val lastAttemptAt: Instant? = null,
    val errorMessage: String? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (id != other.id) return false
        if (payload != other.payload) return false
        if (topic != other.topic) return false
        if (headers != other.headers) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (eventType != other.eventType) return false
        if (createdAt != other.createdAt) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false
        if (lastAttemptAt != other.lastAttemptAt) return false
        if (errorMessage != other.errorMessage) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + payload.hashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + eventType.hashCode()
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        result = 31 * result + (lastAttemptAt?.hashCode() ?: 0)
        result = 31 * result + (errorMessage?.hashCode() ?: 0)
        return result
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageRepository.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.dto

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.application.dto.OutboxMessageStatus

/**
 * Outbox 메시지 저장소에 대한 포트 인터페이스.
 */
interface OutboxMessageRepository {
    /**
     * 단일 Outbox 메시지를 저장합니다.
     * @param message 저장할 메시지
     * @return 저장된 메시지
     */
    fun save(message: OutboxMessage): OutboxMessage

    /**
     * 여러 Outbox 메시지를 저장합니다.
     * 이 메서드는 원자적으로 실행되어야 합니다 - 모든 메시지가 저장되거나 아무것도 저장되지 않아야 합니다.
     *
     * @param messages 저장할 메시지 목록
     */
    fun saveAll(messages: List<OutboxMessage>) // 반환 타입 Unit (없음)

    /**
     * ID로 Outbox 메시지를 조회합니다.
     *
     * @param id 메시지 ID
     * @return 조회된 메시지 또는 null
     */
    fun findById(id: Long): OutboxMessage?

    /**
     * 특정 상태의 Outbox 메시지들을 조회합니다.
     *
     * @param status 조회할 메시지 상태
     * @return 조회된 메시지 목록
     */
    fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage>

    /**
     * 메시지의 상태를 업데이트합니다. (OutboxMessageStatus enum 사용)
     * 이 메서드는 updatedAt과 lastAttemptTime도 함께 업데이트해야 합니다.
     *
     * @param id 메시지 ID (Long)
     * @param newStatus 새로운 상태 (OutboxMessageStatus)
     * @param incrementRetry 재시도 횟수 증가 여부
     * @return 업데이트된 메시지
     */
    fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean = false,
    ): OutboxMessage?

    /**
     * 특정 상태의 메시지를 조회하여 처리 중(PROCESSING) 상태로 변경합니다.
     * 동시성 제어를 위해 적절한 잠금 메커니즘을 사용해야 합니다.
     *
     * @param status 조회 및 처리할 메시지의 현재 상태 (일반적으로 PENDING)
     * @param limit 조회할 최대 메시지 수
     * @return 처리 대상으로 표시된 메시지 목록
     */
    fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage>

    /**
     * 특정 상태의 메시지 개수를 반환합니다.
     * @param status 조회할 메시지 상태
     * @return 해당 상태의 메시지 개수
     */
    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 메시지의 재시도 횟수를 1 증가시킵니다.
     * lastAttemptTime과 updatedAt도 현재 시간으로 업데이트합니다.
     * @param id 메시지 ID
     * @return 업데이트된 메시지 또는 null (메시지를 찾지 못한 경우)
     */
    fun incrementRetryCount(id: Long): OutboxMessage?

    /**
     * 처리되지 않은 메시지를 조회합니다. (FOR UPDATE SKIP LOCKED 사용 가능성 고려)
     * @param batchSize 조회할 최대 메시지 수
     * @return 처리되지 않은 OutboxMessage 목록
     */
    fun findUnprocessedMessages(batchSize: Int): List<OutboxMessage>

    /**
     * 메시지 상태를 업데이트합니다. (이 메서드는 updateStatus(id, newStatus, incrementRetry)로 대체될 수 있음)
     * @param messageId 업데이트할 메시지 ID
     * @param status 새로운 상태 (OutboxMessageStatus)
     * @param retryCount 재시도 횟수
     */
    fun updateMessageStatus( // status 타입을 OutboxMessageStatus로 변경
        messageId: Long,
        status: OutboxMessageStatus,
        retryCount: Int,
    )

    /**
     * 특정 상태이고 재시도 횟수가 지정된 값 미만인 메시지 목록을 조회합니다.
     * 주로 재시도할 실패(FAILED) 메시지를 찾는데 사용됩니다.
     *
     * @param status 조회할 메시지의 상태
     * @param maxRetries 이 횟수 미만으로 재시도된 메시지만 조회
     * @param limit 조회할 최대 메시지 수
     * @return 조건에 맞는 OutboxMessage 목록
     */
    fun findByStatusAndRetryCountLessThan(
        status: OutboxMessageStatus,
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage>
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageStatus.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/dto/OutboxMessageStatus.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.dto

/** Outbox 메시지 상태 enum */
enum class OutboxMessageStatus {
    /**
     * 처리 대기 중인 메시지
     */
    PENDING,

    /**
     * 처리 중인 메시지
     */
    PROCESSING,

    /**
     * 성공적으로 전송된 메시지
     */
    SENT,

    /**
     * 전송 실패한 메시지
     */
    FAILED,

    /**
     * 최대 재시도 횟수를 초과하여 더 이상 처리하지 않을 메시지
     */
    DEAD_LETTERED,

    /**
     * 더 이상 처리하지 않을 메시지
     */
    DISCARDED,
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxMetricsHandler.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxMetricsHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.handler

import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.outbox.application.dto.OutboxMessageStatus
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component

/**
 * Outbox 메트릭 및 모니터링 컴포넌트
 * Rule VII.2.23: 모니터링 설정 구축
 * Rule 80: 독립 모듈의 Application 레이어에 위치
 */
@Component
@ConditionalOnProperty(
    name = ["outbox.polling.enabled"],
    havingValue = "true",
    matchIfMissing = false,
)
class OutboxMetricsHandler(
    private val outboxMessageRepository: OutboxMessageRepository,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)

    /**
     * Outbox 메시지 상태별 통계를 주기적으로 로깅합니다.
     * Rule VII.2.23: 저장된 메시지 수, 전송 실패 수 등 메트릭 모니터링
     */
    @Scheduled(fixedRate = 60000) // 1분마다 실행
    fun logOutboxMetrics() {
        try {
            val pendingCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.PENDING)
            val processingCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.PROCESSING)
            val sentCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.SENT)
            val failedCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.FAILED)
            val deadLetteredCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.DEAD_LETTERED)

            logger.info(
                "Outbox Metrics - PENDING: {}, PROCESSING: {}, SENT: {}, FAILED: {}, DEAD_LETTERED: {}",
                pendingCount,
                processingCount,
                sentCount,
                failedCount,
                deadLetteredCount,
            )

            // 경고 조건 체크
            if (failedCount > 100) {
                logger.warn("High number of failed messages detected: {}", failedCount)
            }

            if (deadLetteredCount > 0) {
                logger.warn("Dead lettered messages detected: {}", deadLetteredCount)
            }

            if (pendingCount > 1000) {
                logger.warn("High number of pending messages detected: {}", pendingCount)
            }
        } catch (e: Exception) {
            logger.error("Failed to collect outbox metrics", e)
        }
    }

    /**
     * 오래된 성공 메시지 정리를 위한 통계 로깅
     * 운영 환경에서 정리 작업 계획 수립을 위한 정보 제공
     */
    @Scheduled(fixedRate = 3600000) // 1시간마다 실행
    fun logCleanupCandidates() {
        try {
            val sentCount = outboxMessageRepository.countByStatus(OutboxMessageStatus.SENT)
            logger.info("Cleanup candidates - SENT messages: {}", sentCount)

            if (sentCount > 10000) {
                logger.info("Consider implementing cleanup job for sent messages")
            }
        } catch (e: Exception) {
            logger.error("Failed to collect cleanup metrics", e)
        }
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxPoller.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/OutboxPoller.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.handler

import com.restaurant.outbox.application.usecase.ProcessOutboxEventsUseCase
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component

/**
 * Outbox 폴링/전송 컴포넌트
 * Rule 86: Outbox 모듈의 Application 레이어에 위치하는 폴링 컴포넌트
 * Rule 87: 동시성 제어를 위한 데이터베이스 수준 잠금 사용
 */
@Component
@ConditionalOnProperty(
    name = ["outbox.polling.enabled"],
    havingValue = "true",
    matchIfMissing = false,
)
class OutboxPoller(
    private val processOutboxEventsUseCase: ProcessOutboxEventsUseCase,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)
    private val batchSize = 100
    private val maxRetries = 3

    /**
     * 대기 중인 메시지를 주기적으로 폴링하여 처리합니다.
     * Rule 86: 주기적인 조회 및 메시지 브로커 전송 처리
     */
    @Scheduled(fixedRate = 1000) // 1초마다 실행
    fun pollAndProcessMessages() {
        try {
            val processedCount = processOutboxEventsUseCase.processPendingMessages(batchSize)
            if (processedCount > 0) {
                logger.debug("Processed {} pending messages", processedCount)
            }
        } catch (e: Exception) {
            logger.error("Error in outbox polling process", e)
        }
    }

    /**
     * 실패한 메시지를 주기적으로 재시도합니다.
     * Rule 90: 재시도 정책에 따른 실패 메시지 처리
     */
    @Scheduled(fixedRate = 300000) // 5분마다 실행
    fun retryFailedMessages() {
        try {
            val retryCount = processOutboxEventsUseCase.retryFailedMessages(maxRetries, batchSize)
            if (retryCount > 0) {
                logger.debug("Marked {} failed messages for retry", retryCount)
            }
        } catch (e: Exception) {
            logger.error("Error in failed message retry process", e)
        }
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/ProcessOutboxEventsUseCaseHandler.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/handler/ProcessOutboxEventsUseCaseHandler.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.handler

import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.application.usecase.ProcessOutboxEventsUseCase
import com.restaurant.outbox.infrastructure.exception.OutboxException
import com.restaurant.outbox.infrastructure.messaging.OutboxMessageSender
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * Outbox 이벤트 처리 Use Case 구현체
 * Rule 80: 독립 모듈의 Application Layer Use Case 구현체
 */
@Service
open class ProcessOutboxEventsUseCaseHandler(
    private val outboxMessageRepository: OutboxMessageRepository,
    private val outboxMessageSender: OutboxMessageSender,
) : ProcessOutboxEventsUseCase {
    private val logger = LoggerFactory.getLogger(this::class.java)

    @Transactional
    override fun process(outboxMessage: OutboxMessage) {
        try {
            outboxMessageSender.processAndSendMessage(outboxMessage)
            outboxMessage.id?.let { id ->
                outboxMessageRepository.updateStatus(id, OutboxMessageStatus.SENT)
                logger.debug("Successfully processed outbox message with ID: {}", id)
            }
        } catch (e: OutboxException.KafkaSendFailedException) {
            logger.error("Kafka send failed for message: {}, Error: {}", outboxMessage.id, e.message)
            outboxMessage.id?.let { id ->
                outboxMessageRepository.updateStatus(id, OutboxMessageStatus.FAILED, true)
            }
            throw e
        } catch (e: Exception) {
            logger.error("Unexpected error processing message: {}, Error: {}", outboxMessage.id, e.message, e)
            outboxMessage.id?.let { id ->
                outboxMessageRepository.updateStatus(id, OutboxMessageStatus.FAILED, true)
            }
            throw OutboxException.MessageProcessingFailedException(
                "Failed to process outbox message with ID ${outboxMessage.id}",
                e,
            )
        }
    }

    @Transactional
    override fun processPendingMessages(batchSize: Int): Int {
        try {
            val pendingMessages =
                outboxMessageRepository.findAndMarkForProcessing(
                    OutboxMessageStatus.PENDING,
                    batchSize,
                )

            if (pendingMessages.isEmpty()) {
                return 0
            }

            logger.debug("Found {} pending messages to process", pendingMessages.size)

            pendingMessages.forEach { message ->
                try {
                    process(message)
                } catch (e: Exception) {
                    logger.error("Failed to process message ID: {}", message.id, e)
                    // 개별 메시지 실패는 전체 배치를 중단시키지 않음
                }
            }

            return pendingMessages.size
        } catch (e: Exception) {
            logger.error("Error in processing pending messages", e)
            throw OutboxException.MessageProcessingFailedException(
                "Failed to process pending messages",
                e,
            )
        }
    }

    @Transactional
    override fun retryFailedMessages(
        maxRetries: Int,
        batchSize: Int,
    ): Int {
        try {
            val failedMessages =
                outboxMessageRepository.findByStatusAndRetryCountLessThan(
                    status = OutboxMessageStatus.FAILED,
                    maxRetries = maxRetries,
                    limit = batchSize,
                )

            if (failedMessages.isEmpty()) {
                return 0
            }

            logger.debug("Found {} failed messages for retry", failedMessages.size)

            var retryCount = 0
            failedMessages.forEach { message ->
                try {
                    message.id?.let { id ->
                        outboxMessageRepository.updateStatus(id, OutboxMessageStatus.PENDING, false)
                        retryCount++
                        logger.info("Message ID {} marked as PENDING for retry", id)
                    }
                } catch (e: Exception) {
                    logger.error("Error resetting failed message to PENDING: {}", message.id, e)
                }
            }

            return retryCount
        } catch (e: Exception) {
            logger.error("Error in failed message retry process", e)
            throw OutboxException.MessageProcessingFailedException(
                "Failed to retry failed messages",
                e,
            )
        }
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/usecase/ProcessOutboxEventsUseCase.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/application/usecase/ProcessOutboxEventsUseCase.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.application.usecase

import com.restaurant.outbox.application.dto.OutboxMessage

/**
 * Outbox 이벤트 처리를 위한 Use Case 인터페이스
 * Rule 80: 독립 모듈의 Application Layer Use Case 인터페이스
 */
interface ProcessOutboxEventsUseCase {
    /**
     * 단일 Outbox 메시지를 처리합니다.
     * @param outboxMessage 처리할 Outbox 메시지
     */
    fun process(outboxMessage: OutboxMessage)

    /**
     * 대기 중인 Outbox 메시지들을 배치로 처리합니다.
     * @param batchSize 처리할 최대 메시지 수
     * @return 처리된 메시지 수
     */
    fun processPendingMessages(batchSize: Int = 100): Int

    /**
     * 실패한 Outbox 메시지들을 재시도합니다.
     * @param maxRetries 최대 재시도 횟수
     * @param batchSize 처리할 최대 메시지 수
     * @return 재시도 대상으로 표시된 메시지 수
     */
    fun retryFailedMessages(
        maxRetries: Int = 3,
        batchSize: Int = 100,
    ): Int
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/config/OutboxKafkaConfig.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/config/OutboxKafkaConfig.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.apache.kafka.common.serialization.StringSerializer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

/**
 * Outbox 모듈의 Kafka 설정
 * Rule 88: KafkaTemplate Bean 정의
 * Schema Registry 엄격한 호환성 검사 활성화
 */
@Configuration
open class OutboxKafkaConfig {
    /**
     * KafkaTemplate for Outbox message sending
     * Rule 88: OutboxMessageSender에서 사용할 KafkaTemplate Bean
     * StringSerializer를 사용하여 JSON 문자열 전송
     */
    @Bean
    open fun outboxKafkaTemplate(outboxProducerFactory: ProducerFactory<String, String>): KafkaTemplate<String, String> =
        KafkaTemplate(outboxProducerFactory)

    /**
     * Producer Factory for Outbox
     * StringSerializer 사용 (JSON 문자열 전송)
     */
    @Bean
    open fun outboxProducerFactory(): ProducerFactory<String, String> {
        val props = mutableMapOf<String, Any>()

        // 기본 설정 - application.yml에서 오버라이드 가능
        props[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = "localhost:9092"
        props[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java

        // String Serializer 사용 (JSON 문자열 전송)
        props[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java

        // Producer 최적화 설정
        props[ProducerConfig.ACKS_CONFIG] = "all"
        props[ProducerConfig.RETRIES_CONFIG] = 3
        props[ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG] = true
        props[ProducerConfig.BATCH_SIZE_CONFIG] = 16384
        props[ProducerConfig.BUFFER_MEMORY_CONFIG] = 33554432
        props[ProducerConfig.COMPRESSION_TYPE_CONFIG] = "lz4"
        props[ProducerConfig.DELIVERY_TIMEOUT_MS_CONFIG] = 120000
        props[ProducerConfig.REQUEST_TIMEOUT_MS_CONFIG] = 30000
        props[ProducerConfig.MAX_BLOCK_MS_CONFIG] = 60000
        props[ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION] = 1

        return DefaultKafkaProducerFactory(props)
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/converter/StringMapConverter.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/converter/StringMapConverter.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.converter

import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.ObjectMapper
import jakarta.persistence.AttributeConverter
import jakarta.persistence.Converter

/**
 * Map<String, String>을 JSON 문자열로 변환하는 JPA Converter
 * Rule 83: Outbox 모듈의 Infrastructure 레이어 내 converter 패키지에 위치
 */
@Converter
class StringMapConverter : AttributeConverter<Map<String, String>, String> {
    private val objectMapper = ObjectMapper()

    override fun convertToDatabaseColumn(attribute: Map<String, String>?): String =
        if (attribute == null) {
            "{}"
        } else {
            try {
                objectMapper.writeValueAsString(attribute)
            } catch (e: Exception) {
                throw IllegalArgumentException("Error converting map to JSON", e)
            }
        }

    override fun convertToEntityAttribute(dbData: String?): Map<String, String> =
        if (dbData.isNullOrBlank()) {
            emptyMap()
        } else {
            try {
                objectMapper.readValue(dbData, object : TypeReference<Map<String, String>>() {})
            } catch (e: Exception) {
                throw IllegalArgumentException("Error converting JSON to map", e)
            }
        }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/entity/OutboxEventEntity.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.entity

import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.converter.StringMapConverter
import jakarta.persistence.Column
import jakarta.persistence.Convert
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Lob
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.Instant

/** Outbox 메시지 JPA Entity */
@Entity
@Table(name = "outbox_events")
class OutboxEventEntity(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column(name = "aggregate_type", nullable = false)
    val aggregateType: String,
    @Column(name = "aggregate_id", nullable = false)
    val aggregateId: String,
    @Column(nullable = false)
    val topic: String,
    @Lob
    @Column(nullable = false, columnDefinition = "text")
    val payload: String,
    @Convert(converter = StringMapConverter::class)
    @Column(nullable = false, columnDefinition = "text")
    val headers: Map<String, String>,
    @Column(name = "event_type", nullable = false)
    val eventType: String,
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: OutboxMessageStatus = OutboxMessageStatus.PENDING,
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: Instant = Instant.now(),
    @Column(name = "updated_at")
    var updatedAt: Instant? = Instant.now(), // 추가된 필드, 생성 시 현재 시간으로 초기화
    @Column(name = "last_attempt_time")
    var lastAttemptTime: Instant? = null,
    @Column(name = "retry_count", nullable = false)
    var retryCount: Int = 0,
    @Version
    var version: Long = 0,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventEntity

        if (id != other.id) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (topic != other.topic) return false
        if (payload != other.payload) return false
        if (headers != other.headers) return false
        if (status != other.status) return false
        if (createdAt != other.createdAt) return false
        if (updatedAt != other.updatedAt) return false // 추가된 필드 비교
        if (lastAttemptTime != other.lastAttemptTime) return false
        if (retryCount != other.retryCount) return false
        if (eventType != other.eventType) return false
        if (version != other.version) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + topic.hashCode()
        result = 31 * result + payload.hashCode()
        result = 31 * result + headers.hashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + createdAt.hashCode()
        result = 31 * result + (updatedAt?.hashCode() ?: 0) // 추가된 필드 해시코드
        result = 31 * result + (lastAttemptTime?.hashCode() ?: 0)
        result = 31 * result + retryCount
        result = 31 * result + eventType.hashCode()
        result = 31 * result + version.hashCode()
        return result
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/error/OutboxErrorCodes.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.error

enum class OutboxErrorCodes(
    val code: String,
    val message: String,
) {
    MESSAGE_NOT_FOUND("OUTBOX-001", "Outbox message not found"),
    MESSAGE_PROCESSING_FAILED("OUTBOX-002", "Failed to process outbox message"),
    KAFKA_SEND_FAILED("OUTBOX-003", "Failed to send message to Kafka"),
    MAX_RETRIES_EXCEEDED("OUTBOX-004", "Maximum retry attempts exceeded"),
    INVALID_MESSAGE_STATUS("OUTBOX-005", "Invalid message status transition"),
    DATABASE_ERROR("OUTBOX-006", "Database operation failed"), 
    SERIALIZATION_ERROR("OUTBOX-007", "Message serialization failed"),
    DATABASE_OPERATION_FAILED("OUTBOX-008", "Database operation failed"), 
    UNEXPECTED_INFRA_ERROR("OUTBOX-009", "An unexpected infrastructure error occurred")
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/exception/OutboxException.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.exception

import com.restaurant.outbox.infrastructure.error.OutboxErrorCodes

/** Outbox 예외 베이스 클래스 */
sealed class OutboxException(
    val errorCode: OutboxErrorCodes,
    message: String? = null,
    cause: Throwable? = null,
) : RuntimeException(message ?: errorCode.message, cause) {
    class MessageNotFoundException(
        messageId: Long,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MESSAGE_NOT_FOUND,
        "Message not found with id: $messageId",
        cause,
    )

    class MessageProcessingFailedException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MESSAGE_PROCESSING_FAILED,
        message,
        cause,
    )

    class KafkaSendFailedException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.KAFKA_SEND_FAILED,
        message,
        cause,
    )

    class MaxRetriesExceededException(
        messageId: Long,
        maxRetries: Int,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.MAX_RETRIES_EXCEEDED,
        "Maximum retry attempts ($maxRetries) exceeded for message: $messageId",
        cause,
    )

    class InvalidMessageStatusException(
        currentStatus: String,
        newStatus: String,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.INVALID_MESSAGE_STATUS,
        "Invalid status transition from $currentStatus to $newStatus",
        cause,
    )

    class DatabaseException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.DATABASE_ERROR,
        message,
        cause,
    )

    class SerializationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(
        OutboxErrorCodes.SERIALIZATION_ERROR,
        message,
        cause,
    )

    class DatabaseOperationException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.DATABASE_OPERATION_FAILED, message, cause)


    class UnexpectedInfrastructureException(
        message: String? = null,
        cause: Throwable? = null,
    ) : OutboxException(OutboxErrorCodes.UNEXPECTED_INFRA_ERROR, message, cause)
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/extensions/OutboxEventEntityExtensions.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/extensions/OutboxEventEntityExtensions.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.extensions

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity

fun OutboxEventEntity.toDomain(): OutboxMessage {
    // DB에서 읽은 JSON 문자열 payload를 OutboxMessage.payload (String 또는 ByteArray)로 전달합니다.
    // OutboxEventEntity.payload는 String이므로, 여기서는 String으로 전달됩니다.
    return OutboxMessage(
        id = this.id,
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.eventType,
        payload = this.payload, // DB의 String payload를 그대로 전달
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        lastAttemptAt = this.lastAttemptTime,
        createdAt = this.createdAt,
        errorMessage = null,
    )
}

fun OutboxMessage.toEntity(): OutboxEventEntity {
    // OutboxMessage.payload (String 또는 ByteArray)를 OutboxEventEntity.payload (String)로 변환합니다.
    val payloadAsString: String =
        when (this.payload) {
            is String -> this.payload
            is ByteArray -> this.payload.toString(Charsets.UTF_8)
            else -> {
                // Rule 81에 따라 OutboxMessage.payload는 String 또는 ByteArray이어야 합니다.
                // 이 외의 타입이 들어오면 로직 또는 설정 오류입니다.
                throw IllegalArgumentException(
                    "OutboxMessage.payload must be a JSON String or ByteArray. Found: ${this.payload::class.simpleName}",
                )
            }
        }

    return OutboxEventEntity(
        aggregateId = this.aggregateId,
        aggregateType = this.aggregateType,
        eventType = this.eventType,
        payload = payloadAsString, // 변환된 String payload
        topic = this.topic,
        headers = this.headers,
        status = this.status,
        retryCount = this.retryCount,
        lastAttemptTime = this.lastAttemptAt,
        createdAt = this.createdAt,
        updatedAt = java.time.Instant.now(),
    )
}

fun OutboxMessage.toExistingEntity(existingEntity: OutboxEventEntity): OutboxEventEntity {
    existingEntity.status = this.status
    existingEntity.retryCount = this.retryCount
    existingEntity.lastAttemptTime = this.lastAttemptAt
    existingEntity.updatedAt = java.time.Instant.now()
    // payload는 일반적으로 변경되지 않음
    return existingEntity
}

fun OutboxMessage.updateFromDomain(existingEntity: OutboxEventEntity): OutboxEventEntity = this.toExistingEntity(existingEntity)

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/messaging/OutboxMessageSender.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/messaging/OutboxMessageSender.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.messaging

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.infrastructure.exception.OutboxException
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.common.header.internals.RecordHeader
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.support.SendResult
import org.springframework.stereotype.Component
import java.util.concurrent.CompletableFuture
import org.springframework.beans.factory.annotation.Qualifier

/**
 * Outbox 메시지 전송 컴포넌트
 * Rule 88: KafkaTemplate을 사용하여 OutboxMessage를 Kafka로 전송
 * Rule VII.1.3.4: spring-kafka KafkaTemplate 기반 메시지 발행
 * Rule 80: 독립 모듈의 Infrastructure 레이어 내 messaging 패키지에 위치
 */
@Component
class OutboxMessageSender(
    @Qualifier("outboxKafkaTemplate") private val kafkaTemplate: KafkaTemplate<String, String>,
) {
    private val logger = LoggerFactory.getLogger(this::class.java)

    /**
     * Outbox 메시지를 처리하고 Kafka로 전송합니다.
     * Rule 88: 객체를 KafkaTemplate을 통해 메시지 브로커로 전송
     * Rule VII.1.3.4: KafkaJsonSchemaSerializer를 통한 JSON 직렬화 및 Schema Registry 활용 (이제 StringSerializer 사용)
     * 
     * @param messageDto 전송할 Outbox 메시지
     * @throws OutboxException.KafkaSendFailedException Kafka 전송 실패 시
     */
    fun processAndSendMessage(messageDto: OutboxMessage) {
        try {
            val producerRecord = createProducerRecord(messageDto)

            // KafkaTemplate을 사용하여 비동기 전송
            val future: CompletableFuture<SendResult<String, String>> = kafkaTemplate.send(producerRecord)
            
            // 비동기 콜백 설정
            future.whenComplete { result, exception ->
                if (exception != null) {
                    logger.error(
                        "Failed to send message to Kafka. MessageId: {}, Topic: {}, AggregateId: {}, Error: {}",
                        messageDto.id,
                        messageDto.topic,
                        messageDto.aggregateId,
                        exception.message,
                        exception
                    )
                    throw OutboxException.KafkaSendFailedException(
                        message = "Failed to send message to Kafka for OutboxMessage ID ${messageDto.id} (Topic: ${messageDto.topic}, AggregateId: ${messageDto.aggregateId}): ${exception.message}",
                        cause = exception
                    )
                } else {
                    logger.info(
                        "Successfully sent message to Kafka. Topic: {}, Partition: {}, Offset: {}, MessageId: {}, AggregateId: {}",
                        result.recordMetadata.topic(),
                        result.recordMetadata.partition(),
                        result.recordMetadata.offset(),
                        messageDto.id,
                        messageDto.aggregateId
                    )
                }
            }

        } catch (e: Exception) {
            logger.error(
                "Failed to send message to Kafka. MessageId: {}, Topic: {}, AggregateId: {}, Error: {}",
                messageDto.id,
                messageDto.topic,
                messageDto.aggregateId,
                e.message,
                e
            )
            throw OutboxException.KafkaSendFailedException(
                message = "Failed to send message to Kafka for OutboxMessage ID ${messageDto.id} (Topic: ${messageDto.topic}, AggregateId: ${messageDto.aggregateId}): ${e.message}",
                cause = e
            )
        }
    }

    /**
     * OutboxMessage를 Kafka ProducerRecord로 변환합니다.
     * Rule 88: Outbox Event Entity에 저장된 정보를 메시지 헤더에 포함
     * Rule VII.2.6: 토픽명 및 헤더 정보 설정
     * Rule VII.1.3.4: 객체 페이로드 및 Schema Registry 헤더 처리
     * 
     * @param messageDto 변환할 Outbox 메시지
     * @return Kafka 전송용 ProducerRecord
     */
    private fun createProducerRecord(messageDto: OutboxMessage): ProducerRecord<String, String> {
        // OutboxMessage.payload는 이미 kotlinx.serialization으로 직렬화된 JSON 문자열.
        // 이를 그대로 Kafka에 전송 (StringSerializer 사용).
        val payloadAsString: String = when (val p = messageDto.payload) {
            is String -> p
            is ByteArray -> {
                // ByteArray의 경우, UTF-8 문자열로 변환. (CI/CD에서 스키마 검증 시 이 변환을 고려해야 함)
                logger.warn(
                    "ByteArray payload received. Converting to UTF-8 string. OutboxMessage ID: {}",
                    messageDto.id
                )
                p.toString(Charsets.UTF_8)
            }
            else -> {
                logger.error(
                    "Unsupported payload type: {}. Expected String or ByteArray. OutboxMessage ID: {}",
                    p::class.simpleName, messageDto.id
                )
                throw OutboxException.KafkaSendFailedException(
                    message = "Unsupported payload type for OutboxMessage ID ${messageDto.id}: ${p::class.simpleName}"
                )
            }
        }

        val record = ProducerRecord<String, String>(
            messageDto.topic,
            messageDto.aggregateId, // Rule 88: Aggregate ID를 메시지 키로 사용
            payloadAsString // JSON 문자열 직접 전송
        )

        // Rule 88: Outbox Event Entity에 저장된 헤더 정보 포함
        messageDto.headers.forEach { (key, value) ->
            record.headers().add(RecordHeader(key, value.toByteArray()))
        }

        // 추가 메타데이터 헤더
        record.headers().add(RecordHeader("outbox-message-id", (messageDto.id?.toString() ?: "unknown").toByteArray()))
        record.headers().add(RecordHeader("aggregate-type", messageDto.aggregateType.toByteArray()))
        record.headers().add(RecordHeader("event-type", messageDto.eventType.toByteArray()))
        record.headers().add(RecordHeader("created-at", messageDto.createdAt.toString().toByteArray()))

        return record
    }
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxEventRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxEventRepository.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

@Repository
interface JpaOutboxEventRepository : JpaRepository<OutboxEventEntity, Long> {
    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    fun findTopByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    fun findByStatusAndRetryCountGreaterThanEqual(
        status: OutboxMessageStatus,
        retryCount: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    fun countByStatus(status: OutboxMessageStatus): Long

    /**
     * 특정 상태의 메시지들을 조회하되, 재시도 횟수가 특정 값 미만인 메시지들만 조회합니다.
     * 이 메서드는 주로 실패한 메시지 중 아직 재시도 한도에 도달하지 않은 메시지를 찾는데 사용될 수 있습니다.
     */
    @Query(
        "SELECT oe FROM OutboxEventEntity oe WHERE oe.status = :status AND oe.retryCount < :maxRetries ORDER BY oe.createdAt ASC",
    )
    fun findByStatusAndRetryCountLessThan(
        @Param("status") status: OutboxMessageStatus, // OutboxMessageStatus로 수정
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    /**
     * 처리되지 않은 이벤트를 조회하며 비관적 잠금을 사용합니다. (SKIP LOCKED 사용)
     * 데이터베이스에 따라 @QueryHint 사용이 필요할 수 있습니다.
     * 예시: PostgreSQL의 경우 FOR UPDATE SKIP LOCKED
     * Spring Data JPA 3.x 이상에서는 @Lock(LockModeType.PESSIMISTIC_WRITE)와 함께
     * spring.jpa.properties.jakarta.persistence.lock.timeout=0 (또는 DB 특화 힌트) 설정 고려.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        "SELECT e FROM OutboxEventEntity e WHERE e.status = com.restaurant.outbox.application.dto.OutboxMessageStatus.PENDING ORDER BY e.createdAt ASC",
    )
    fun findUnprocessedEventsWithLock(pageable: Pageable): List<OutboxEventEntity>
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxMessageRepository.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/JpaOutboxMessageRepository.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import java.time.Instant

interface JpaOutboxMessageRepository : JpaRepository<OutboxEventEntity, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND (e.lastAttemptTime IS NULL OR e.lastAttemptTime < :cutoffTime)
        AND e.retryCount < :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findMessagesToProcess(
        @Param("status") status: OutboxMessageStatus,
        @Param("cutoffTime") cutoffTime: Instant,
        @Param("maxRetries") maxRetries: Int = 3,
    ): List<OutboxEventEntity>

    fun findByStatus(status: OutboxMessageStatus): List<OutboxEventEntity>

    fun findTopByStatusOrderByCreatedAtAsc(
        status: OutboxMessageStatus,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    @Query("SELECT COUNT(e) FROM OutboxEventEntity e WHERE e.status = :status")
    fun countByStatus(
        @Param("status") status: OutboxMessageStatus,
    ): Long

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        """
        SELECT e FROM OutboxEventEntity e 
        WHERE e.status = :status 
        AND e.retryCount >= :maxRetries
        ORDER BY e.createdAt ASC
        """,
        nativeQuery = false,
    )
    fun findByStatusAndRetryCountGreaterThanEqual(
        @Param("status") status: OutboxMessageStatus,
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    @Query(
        "SELECT oe FROM OutboxEventEntity oe WHERE oe.status = :status AND oe.retryCount < :maxRetries ORDER BY oe.createdAt ASC",
    )
    fun findByStatusAndRetryCountLessThan(
        @Param("status") status: OutboxMessageStatus,
        @Param("maxRetries") maxRetries: Int,
        pageable: Pageable,
    ): List<OutboxEventEntity>

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query(
        "SELECT e FROM OutboxEventEntity e WHERE e.status = com.restaurant.outbox.application.dto.OutboxMessageStatus.PENDING ORDER BY e.createdAt ASC",
    )
    fun findUnprocessedEventsWithLock(pageable: Pageable): List<OutboxEventEntity>
}

====================================================================


====================================================================
 File: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/OutboxMessageRepositoryImpl.kt
 Path: independent/outbox/src/main/kotlin/com/restaurant/outbox/infrastructure/repository/OutboxMessageRepositoryImpl.kt
 Timestamp: 2025-06-11 12:01:57
====================================================================
package com.restaurant.outbox.infrastructure.repository

import com.restaurant.outbox.application.dto.OutboxMessage
import com.restaurant.outbox.application.dto.OutboxMessageRepository
import com.restaurant.outbox.application.dto.OutboxMessageStatus
import com.restaurant.outbox.infrastructure.entity.OutboxEventEntity
import com.restaurant.outbox.infrastructure.exception.OutboxException
import com.restaurant.outbox.infrastructure.extensions.toDomain
import com.restaurant.outbox.infrastructure.extensions.toEntity
import org.slf4j.LoggerFactory
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional
import java.time.Instant

/**
 * Outbox 메시지 저장 Repository 구현체
 * Rule 82: Outbox 모듈의 Infrastructure 레이어 내 repository 패키지에 위치
 * Rule 87: 동시성 제어를 위한 데이터베이스 수준 잠금 사용
 */
@Repository
open class OutboxMessageRepositoryImpl(
    private val jpaOutboxEventRepository: JpaOutboxEventRepository,
) : OutboxMessageRepository {
    private val logger = LoggerFactory.getLogger(this::class.java)

    @Transactional
    override fun save(message: OutboxMessage): OutboxMessage {
        try {
            val entity = message.toEntity()
            val savedEntity = jpaOutboxEventRepository.save(entity)
            return savedEntity.toDomain()
        } catch (e: Exception) {
            logger.error("Failed to save outbox message", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to save outbox message",
                e,
            )
        }
    }

    @Transactional
    override fun saveAll(messages: List<OutboxMessage>) {
        try {
            val entities = messages.map { it.toEntity() }
            jpaOutboxEventRepository.saveAll(entities)
            logger.debug("Successfully saved {} outbox messages", messages.size)
        } catch (e: Exception) {
            logger.error("Failed to save {} outbox messages", messages.size, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to save outbox messages",
                e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findById(id: Long): OutboxMessage? =
        try {
            jpaOutboxEventRepository.findById(id).map { it.toDomain() }.orElse(null)
        } catch (e: Exception) {
            logger.error("Failed to find outbox message by id: {}", id, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find outbox message by id: $id",
                e,
            )
        }

    @Transactional(readOnly = true)
    override fun findByStatus(status: OutboxMessageStatus): List<OutboxMessage> =
        try {
            jpaOutboxEventRepository.findByStatus(status).map { it.toDomain() }
        } catch (e: Exception) {
            logger.error("Failed to find outbox messages by status: {}", status, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find outbox messages by status: $status",
                e,
            )
        }

    @Transactional
    override fun updateStatus(
        id: Long,
        newStatus: OutboxMessageStatus,
        incrementRetry: Boolean,
    ): OutboxMessage? {
        return try {
            val entity = jpaOutboxEventRepository.findById(id).orElse(null) ?: return null
            entity.status = newStatus
            if (incrementRetry) {
                entity.retryCount += 1
            }
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()
            val savedEntity = jpaOutboxEventRepository.save(entity)
            savedEntity.toDomain()
        } catch (e: Exception) {
            logger.error("Failed to update status for message id: {}", id, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to update status for message id: $id",
                e,
            )
        }
    }

    /**
     * Rule 87: 동시성 제어를 위한 데이터베이스 수준 잠금 사용
     * PESSIMISTIC_WRITE 잠금과 함께 SKIP LOCKED 기능 활용
     */
    @Transactional
    override fun findAndMarkForProcessing(
        status: OutboxMessageStatus,
        limit: Int,
    ): List<OutboxMessage> =
        try {
            val pageable: Pageable = PageRequest.of(0, limit)
            val entitiesToProcess =
                when (status) {
                    OutboxMessageStatus.PENDING -> {
                        // Rule 87: SKIP LOCKED를 사용한 동시성 제어
                        jpaOutboxEventRepository.findUnprocessedEventsWithLock(pageable)
                    }
                    else -> {
                        jpaOutboxEventRepository.findTopByStatusOrderByCreatedAtAsc(status, pageable)
                    }
                }

            val processedMessages =
                entitiesToProcess.mapNotNull { entity: OutboxEventEntity ->
                    try {
                        entity.status = OutboxMessageStatus.PROCESSING
                        entity.lastAttemptTime = Instant.now()
                        entity.updatedAt = Instant.now()
                        val savedEntity = jpaOutboxEventRepository.save(entity)
                        savedEntity.toDomain()
                    } catch (e: Exception) {
                        logger.warn("Failed to mark message {} for processing", entity.id, e)
                        null
                    }
                }

            logger.debug("Marked {} messages for processing", processedMessages.size)
            processedMessages
        } catch (e: Exception) {
            logger.error("Failed to find and mark messages for processing", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find and mark messages for processing",
                e,
            )
        }

    @Transactional(readOnly = true)
    override fun countByStatus(status: OutboxMessageStatus): Long =
        try {
            jpaOutboxEventRepository.countByStatus(status)
        } catch (e: Exception) {
            logger.error("Failed to count messages by status: {}", status, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to count messages by status: $status",
                e,
            )
        }

    @Transactional
    override fun incrementRetryCount(id: Long): OutboxMessage? {
        return try {
            val entity = jpaOutboxEventRepository.findById(id).orElse(null) ?: return null
            entity.retryCount += 1
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()
            val savedEntity = jpaOutboxEventRepository.save(entity)
            savedEntity.toDomain()
        } catch (e: Exception) {
            logger.error("Failed to increment retry count for message id: {}", id, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to increment retry count for message id: $id",
                e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findUnprocessedMessages(batchSize: Int): List<OutboxMessage> =
        try {
            jpaOutboxEventRepository
                .findTopByStatusOrderByCreatedAtAsc(OutboxMessageStatus.PENDING, PageRequest.of(0, batchSize))
                .map { it.toDomain() }
        } catch (e: Exception) {
            logger.error("Failed to find unprocessed messages", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find unprocessed messages",
                e,
            )
        }

    @Transactional
    override fun updateMessageStatus(
        messageId: Long,
        status: OutboxMessageStatus,
        retryCount: Int,
    ) {
        try {
            val entity =
                jpaOutboxEventRepository.findById(messageId).orElseThrow {
                    OutboxException.MessageNotFoundException(messageId)
                }

            entity.status = status
            entity.retryCount = retryCount
            entity.lastAttemptTime = Instant.now()
            entity.updatedAt = Instant.now()

            jpaOutboxEventRepository.save(entity)
        } catch (e: OutboxException) {
            throw e
        } catch (e: Exception) {
            logger.error("Failed to update message status for id: {}", messageId, e)
            throw OutboxException.DatabaseOperationException(
                "Failed to update message status for id: $messageId",
                e,
            )
        }
    }

    @Transactional(readOnly = true)
    override fun findByStatusAndRetryCountLessThan(
        status: OutboxMessageStatus,
        maxRetries: Int,
        limit: Int,
    ): List<OutboxMessage> =
        try {
            val pageable: Pageable = PageRequest.of(0, limit)
            jpaOutboxEventRepository
                .findByStatusAndRetryCountLessThan(status, maxRetries, pageable)
                .map { it.toDomain() }
        } catch (e: Exception) {
            logger.error("Failed to find messages by status and retry count", e)
            throw OutboxException.DatabaseOperationException(
                "Failed to find messages by status and retry count",
                e,
            )
        }
}

====================================================================


====================================================================
 File: settings.gradle.kts
 Path: settings.gradle.kts
 Timestamp: 2025-06-11 12:01:57
====================================================================
import org.gradle.api.initialization.resolve.RepositoriesMode

/**
 * settings.gradle.kts for the project.
 *
 * Configures plugin repositories and project structure for Gradle.
 *
 * @author junoko
 */

rootProject.name = "restaurant"

pluginManagement {
    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}

@Suppress("UnstableApiUsage")
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.PREFER_SETTINGS)
    repositories { 
        mavenCentral()
        maven { url = uri("https://maven.pkg.jetbrains.space/public/p/kotlinx-html/maven") }  // Add JetBrains repo for Kotlin
        maven { url = uri("https://packages.confluent.io/maven/") }
        // Spring Milestones and Snapshots for Spring Cloud compatibility if needed in the future
        // maven { url = uri("https://repo.spring.io/milestone") }
    }
}

// Common modules
include(":domains:common:domain")
include(":domains:common:application")
include(":domains:common:infrastructure")
include(":domains:common:presentation")

// User modules
include(":domains:user:domain")
include(":domains:user:application")
include(":domains:user:infrastructure")
include(":domains:user:presentation")

// Independent modules
include(":independent:outbox")

// Application modules
include(":apps:user-app")

====================================================================

==============================================================
 File Collection Completed: 2025-06-11 21:01:57 
==============================================================
