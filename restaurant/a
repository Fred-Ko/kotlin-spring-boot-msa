> Task :domains:common:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:common:processResources NO-SOURCE
> Task :domains:user:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:domain:processResources NO-SOURCE
> Task :domains:user:application:processResources NO-SOURCE
> Task :domains:user:apps:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:infrastructure:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :shared:outbox:application:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:application:loadKtlintReporters
> Task :shared:outbox:application:processResources NO-SOURCE
> Task :domains:user:infrastructure:processResources NO-SOURCE
> Task :domains:user:presentation:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :domains:user:presentation:processResources
> Task :domains:user:apps:processResources
> Task :domains:user:apps:loadKtlintReporters
> Task :domains:user:domain:loadKtlintReporters
> Task :domains:user:infrastructure:loadKtlintReporters
> Task :domains:user:presentation:loadKtlintReporters
> Task :domains:user:apps:runKtlintCheckOverTestSourceSet NO-SOURCE
> Task :domains:user:apps:ktlintTestSourceSetCheck SKIPPED
> Task :shared:outbox:application:kaptGenerateStubsKotlin
> Task :domains:user:presentation:runKtlintCheckOverTestSourceSet NO-SOURCE
> Task :shared:outbox:application:kaptKotlin SKIPPED
> Task :domains:user:presentation:ktlintTestSourceSetCheck SKIPPED
> Task :shared:outbox:checkKotlinGradlePluginConfigurationErrors SKIPPED
> Task :shared:outbox:kaptGenerateStubsKotlin
> Task :shared:outbox:kaptKotlin SKIPPED
> Task :shared:outbox:compileKotlin NO-SOURCE
> Task :shared:outbox:compileJava NO-SOURCE
> Task :shared:outbox:processResources NO-SOURCE
> Task :shared:outbox:classes UP-TO-DATE
> Task :shared:outbox:resolveMainClassName
> Task :shared:outbox:bootJar SKIPPED
> Task :shared:outbox:jar
> Task :shared:outbox:assemble
> Task :shared:outbox:loadKtlintReporters
> Task :shared:outbox:runKtlintCheckOverMainSourceSet NO-SOURCE
> Task :shared:outbox:ktlintMainSourceSetCheck SKIPPED
> Task :shared:outbox:runKtlintCheckOverTestSourceSet NO-SOURCE
> Task :shared:outbox:ktlintTestSourceSetCheck SKIPPED
> Task :domains:common:compileKotlin
> Task :domains:common:compileJava NO-SOURCE
> Task :domains:common:classes UP-TO-DATE
> Task :domains:common:jar
> Task :shared:outbox:application:compileKotlin
> Task :shared:outbox:application:compileJava NO-SOURCE
> Task :shared:outbox:application:classes UP-TO-DATE
> Task :shared:outbox:application:jar
> Task :domains:user:apps:runKtlintCheckOverKotlinScripts
> Task :domains:user:application:runKtlintCheckOverKotlinScripts
> Task :domains:user:apps:ktlintKotlinScriptCheck
> Task :domains:user:application:ktlintKotlinScriptCheck
> Task :domains:user:presentation:runKtlintCheckOverKotlinScripts
> Task :domains:user:domain:runKtlintCheckOverKotlinScripts
> Task :domains:user:presentation:ktlintKotlinScriptCheck
> Task :domains:user:domain:ktlintKotlinScriptCheck
> Task :shared:outbox:runKtlintCheckOverKotlinScripts
> Task :shared:outbox:ktlintKotlinScriptCheck
> Task :shared:outbox:check
> Task :shared:outbox:build
> Task :domains:user:infrastructure:runKtlintCheckOverKotlinScripts
> Task :domains:user:domain:compileKotlin
> Task :domains:user:domain:compileJava NO-SOURCE
> Task :domains:user:domain:classes UP-TO-DATE
> Task :domains:user:infrastructure:ktlintKotlinScriptCheck
> Task :domains:user:domain:jar
> Task :domains:user:infrastructure:generateAvroProtocol NO-SOURCE
> Task :domains:user:infrastructure:generateAvroJava NO-SOURCE
> Task :domains:user:infrastructure:generateTestAvroProtocol NO-SOURCE
> Task :domains:user:infrastructure:generateTestAvroJava NO-SOURCE
> Task :domains:user:infrastructure:kaptGenerateStubsKotlin FAILED
> Task :domains:user:domain:runKtlintCheckOverTestSourceSet
> Task :domains:user:apps:runKtlintCheckOverMainSourceSet
> Task :domains:user:application:runKtlintCheckOverTestSourceSet
> Task :domains:user:domain:runKtlintCheckOverMainSourceSet
> Task :domains:user:application:runKtlintCheckOverMainSourceSet
> Task :domains:user:presentation:runKtlintCheckOverMainSourceSet
> Task :domains:user:application:kaptGenerateStubsKotlin

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':domains:user:infrastructure:kaptGenerateStubsKotlin'.
> Could not resolve all files for configuration ':domains:user:infrastructure:compileClasspath'.
   > Could not find io.confluent:kafka-avro-serializer:7.5.3.
     Required by:
         project :domains:user:infrastructure
   > Could not find io.confluent:kafka-schema-registry-client:7.5.3.
     Required by:
         project :domains:user:infrastructure

* Try:
> Run with --stacktrace option to get the stack trace.
> Run with --info or --debug option to get more log output.
> Run with --scan to get full insights.
> Get more help at https://help.gradle.org.

BUILD FAILED in 5s
38 actionable tasks: 38 executed

--------------------------------


// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/event/UserEvent.kt =====
package com.restaurant.domain.user.event

import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime

sealed class UserEvent(
    open val userId: UserId,
    override val eventId: String,
    override val occurredAt: LocalDateTime,
) : DomainEvent {
    override val aggregateId: String
        get() = userId.value.toString()
    override val aggregateType: String
        get() = User::class.java.simpleName

    data class Created(
        override val userId: UserId,
        val email: String,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class ProfileUpdated(
        override val userId: UserId,
        val name: String,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class PasswordChanged(
        override val userId: UserId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressAdded(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressUpdated(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)

    data class AddressRemoved(
        override val userId: UserId,
        val addressId: AddressId,
        override val eventId: String,
        override val occurredAt: LocalDateTime,
    ) : UserEvent(userId, eventId, occurredAt)
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/repository/UserRepository.kt =====
package com.restaurant.domain.user.repository

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId

interface UserRepository {
    fun save(user: User): User

    fun findById(id: UserId): User?

    fun findByEmail(email: Email): User?

    fun existsByEmail(email: Email): Boolean

    fun delete(user: User)
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/aggregate/User.kt =====
package com.restaurant.domain.user.aggregate

import com.restaurant.common.domain.aggregate.AggregateRoot
import com.restaurant.domain.user.event.UserEvent
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import java.time.LocalDateTime
import java.util.UUID

data class User
    private constructor(
        val id: UserId,
        val email: Email,
        val password: Password,
        val name: Name,
        val addresses: List<Address> = emptyList(),
        val createdAt: LocalDateTime = LocalDateTime.now(),
        val updatedAt: LocalDateTime = LocalDateTime.now(),
    ) : AggregateRoot() {
        companion object {
            fun create(
                email: Email,
                password: Password,
                name: Name,
            ): User {
                val userId = UserId.generate()
                val user = User(id = userId, email = email, password = password, name = name)
                val event =
                    UserEvent.Created(
                        userId = userId,
                        email = email.value,
                        name = name.value,
                        eventId = UUID.randomUUID().toString(),
                        occurredAt = user.createdAt,
                    )
                user.addDomainEvent(event)
                return user
            }

            fun reconstitute(
                id: UserId,
                email: Email,
                password: Password,
                name: Name,
                addresses: List<Address> = emptyList(),
                createdAt: LocalDateTime,
                updatedAt: LocalDateTime,
            ): User =
                User(
                    id = id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
        }

        fun updateProfile(name: Name): User {
            val updated = this.copy(name = name, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.ProfileUpdated(
                    userId = this.id,
                    name = name.value,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun changePassword(encodedPassword: Password): User {
            val updated = this.copy(password = encodedPassword, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.PasswordChanged(
                    userId = this.id,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun addAddress(address: Address): User {
            val newAddresses =
                if (address.isDefault) {
                    addresses.map { it.update(isDefault = false) } + address
                } else {
                    if (addresses.isEmpty()) {
                        listOf(address.update(isDefault = true))
                    } else {
                        addresses + address
                    }
                }
            val updated = this.copy(addresses = newAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressAdded(
                    userId = this.id,
                    addressId = address.addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun updateAddress(
            addressId: AddressId,
            updatedAddress: Address,
        ): User {
            if (addressId != updatedAddress.addressId) {
                throw UserDomainException.Validation.InvalidAddressFormat(
                    "수정하려는 주소의 ID(${addressId.value})와 전달된 주소 데이터의 ID(${updatedAddress.addressId.value})가 일치하지 않습니다.",
                )
            }

            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            val newAddresses =
                if (updatedAddress.isDefault) {
                    addresses.map {
                        when {
                            it.addressId == addressId -> updatedAddress
                            else -> it.update(isDefault = false)
                        }
                    }
                } else {
                    val currentDefault = addresses.find { it.isDefault }
                    if (currentDefault?.addressId == addressId) {
                        val addressesWithoutOriginal = addresses.filter { it.addressId != addressId }
                        val updatedList = addressesWithoutOriginal + updatedAddress
                        if (updatedList.size > 1) {
                            val firstOther = updatedList.first { it.addressId != addressId }
                            updatedList.map { adr ->
                                if (adr.addressId == firstOther.addressId) adr.update(isDefault = true) else adr
                            }
                        } else {
                            listOf(updatedAddress.update(isDefault = true))
                        }
                    } else {
                        addresses.map { if (it.addressId == addressId) updatedAddress else it }
                    }
                }

            val ensuredAddresses =
                if (newAddresses.none { it.isDefault } && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressUpdated(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        fun removeAddress(addressId: AddressId): User {
            val existingAddress =
                addresses.find { it.addressId == addressId }
                    ?: throw UserDomainException.Address.NotFound(
                        userId = this.id.value.toString(),
                        addressId = addressId.value.toString(),
                    )

            if (addresses.size == 1) {
                throw UserDomainException.Address.CannotRemoveLastAddress(
                    addressId = addressId.value.toString(),
                )
            }

            val newAddresses = addresses.filter { it.addressId != addressId }
            val ensuredAddresses =
                if (existingAddress.isDefault && newAddresses.isNotEmpty()) {
                    newAddresses.mapIndexed { index, adr -> if (index == 0) adr.update(isDefault = true) else adr }
                } else {
                    newAddresses
                }

            val updated = this.copy(addresses = ensuredAddresses, updatedAt = LocalDateTime.now())
            val event =
                UserEvent.AddressRemoved(
                    userId = this.id,
                    addressId = addressId,
                    eventId = UUID.randomUUID().toString(),
                    occurredAt = updated.updatedAt,
                )
            updated.addDomainEvent(event)
            return updated
        }

        private fun copy(
            email: Email = this.email,
            password: Password = this.password,
            name: Name = this.name,
            addresses: List<Address> = this.addresses,
            createdAt: LocalDateTime = this.createdAt,
            updatedAt: LocalDateTime = this.updatedAt,
        ): User {
            val copiedUser =
                User(
                    id = this.id,
                    email = email,
                    password = password,
                    name = name,
                    addresses = addresses,
                    createdAt = createdAt,
                    updatedAt = updatedAt,
                )
            return copiedUser
        }
    }

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Email.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Email private constructor(
    val value: String,
) {
    init {
        if (!value.matches(EMAIL_REGEX)) {
            throw UserDomainException.Validation.InvalidEmailFormat(value)
        }
    }

    companion object {
        private val EMAIL_REGEX = Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+$")

        fun of(value: String): Email = Email(value)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/UserId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class UserId private constructor(
    val value: UUID,
) {
    companion object {
        fun of(value: UUID): UserId = UserId(value)

        fun generate(): UserId = UserId(UUID.randomUUID())

        fun fromString(value: String): UserId = UserId(UUID.fromString(value))
    }

    override fun toString(): String = value.toString()
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Password.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Password private constructor(
    val encodedValue: String,
) {
    init {
        if (encodedValue.isBlank()) {
            throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호 값(인코딩 또는 raw)은 비어있을 수 없습니다.")
        }
    }

    companion object {
        private const val MIN_RAW_LENGTH = 8

        fun validateRaw(rawPassword: String) {
            if (rawPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 비어있을 수 없습니다.")
            }
            if (rawPassword.length < MIN_RAW_LENGTH) {
                throw UserDomainException.Validation.InvalidPasswordFormat("비밀번호는 최소 ${MIN_RAW_LENGTH}글자 이상이어야 합니다.")
            }
        }

        fun fromEncoded(encodedPassword: String): Password {
            if (encodedPassword.isBlank()) {
                throw UserDomainException.Validation.InvalidPasswordFormat("인코딩된 비밀번호 값은 비어있을 수 없습니다.")
            }
            return Password(encodedPassword)
        }
    }

    override fun toString(): String = "********"
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/AddressId.kt =====
package com.restaurant.domain.user.vo

import java.util.UUID

data class AddressId private constructor(
    val value: UUID,
) {
    companion object {
        fun generate(): AddressId = AddressId(UUID.randomUUID())

        fun fromString(value: String): AddressId = AddressId(UUID.fromString(value))

        fun of(value: UUID): AddressId = AddressId(value)
    }

    override fun toString(): String = value.toString()
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/vo/Name.kt =====
package com.restaurant.domain.user.vo

import com.restaurant.domain.user.exception.UserDomainException

data class Name private constructor(
    val value: String,
) {
    init {
        if (value.isBlank()) {
            throw UserDomainException.Validation.InvalidNameFormat(value)
        }
    }

    companion object {
        fun of(name: String): Name = Name(name)
    }

    override fun toString(): String = value
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/model/Address.kt =====
package com.restaurant.domain.user.model

import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.vo.AddressId

data class Address
    private constructor(
        val addressId: AddressId,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    ) {
        init {
            if (street.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("도로명 주소는 비어있을 수 없습니다.")
            }
            if (zipCode.isBlank()) {
                throw UserDomainException.Validation.InvalidAddressFormat("우편번호는 비어있을 수 없습니다.")
            }
        }

        companion object {
            fun create(
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean = false,
            ): Address =
                Address(
                    addressId = AddressId.generate(),
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )

            fun reconstitute(
                addressId: AddressId,
                street: String,
                detail: String,
                zipCode: String,
                isDefault: Boolean,
            ): Address =
                Address(
                    addressId = addressId,
                    street = street,
                    detail = detail,
                    zipCode = zipCode,
                    isDefault = isDefault,
                )
        }

        fun update(
            street: String = this.street,
            detail: String = this.detail,
            zipCode: String = this.zipCode,
            isDefault: Boolean = this.isDefault,
        ): Address =
            Address(
                addressId = this.addressId,
                street = street,
                detail = detail,
                zipCode = zipCode,
                isDefault = isDefault,
            )
    }

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/exception/UserDomainException.kt =====
package com.restaurant.domain.user.exception

import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.DomainException
import com.restaurant.domain.user.error.UserDomainErrorCodes

// sealed class UserDomainException(...): DomainException(...) 제거

// 최상위 sealed class 는 marker 역할만 하거나, 공통 필드(message)만 가질 수 있음
sealed class UserDomainException(
    message: String,
) : DomainException(message) {
    // Rule 68, 73: 상위 클래스 DomainException의 abstract val errorCode를 override로 명시
    abstract override val errorCode: ErrorCode

    sealed class Validation(
        message: String,
        override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
    ) : UserDomainException(message) {
        data class InvalidEmailFormat(
            val email: String,
        ) : Validation("이메일 형식이 올바르지 않습니다: $email")

        data class InvalidPasswordFormat(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_PASSWORD_FORMAT,
        ) : Validation("비밀번호 형식이 올바르지 않습니다: $reason")

        data class InvalidNameFormat(
            val name: String,
        ) : Validation("이름 형식이 올바르지 않습니다: $name")

        data class InvalidAddressFormat(
            val reason: String,
        ) : Validation("주소 형식이 올바르지 않습니다: $reason")
    }

    // 각 하위 sealed class 또는 data class 에서 errorCode 를 override
    sealed class User(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String,
            // Rule 68: errorCode 를 override 로 명시적 지정
            override val errorCode: ErrorCode = UserDomainErrorCodes.USER_NOT_FOUND,
        ) : User("사용자를 찾을 수 없습니다: $userId") // 생성자에서 message 전달

        data class DuplicateEmail(
            val email: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.DUPLICATE_EMAIL,
        ) : User("이미 등록된 이메일입니다: $email")

        data class InvalidCredentials(
            override val errorCode: ErrorCode = UserDomainErrorCodes.PASSWORD_MISMATCH,
        ) : User(errorCode.message) // ErrorCode의 기본 메시지 사용

        data class InvalidInput(
            val reason: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.INVALID_INPUT,
        ) : User("잘못된 사용자 입력: $reason")
    }

    sealed class Address(
        message: String,
    ) : UserDomainException(message) {
        data class NotFound(
            val userId: String, // 사용자 ID도 String으로 변경
            val addressId: String, // Long -> String (AddressId.value.toString())
            override val errorCode: ErrorCode = UserDomainErrorCodes.ADDRESS_NOT_FOUND,
        ) : Address("사용자($userId)의 주소($addressId)를 찾을 수 없습니다.")

        data class MaxLimitExceeded(
            val userId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.MAX_ADDRESS_LIMIT_EXCEEDED,
        ) : Address("사용자($userId)의 최대 주소 등록 개수를 초과했습니다.")

        data class DefaultAddressRemovalAttempt(
            val addressId: String, // Long -> String
            override val errorCode: ErrorCode = UserDomainErrorCodes.DEFAULT_ADDRESS_CANNOT_BE_REMOVED,
        ) : Address("기본 주소($addressId)는 삭제할 수 없습니다.")

        data class CannotRemoveLastAddress(
            val addressId: String,
            override val errorCode: ErrorCode = UserDomainErrorCodes.CANNOT_REMOVE_LAST_ADDRESS,
        ) : Address("마지막 주소($addressId)는 삭제할 수 없습니다.")
    }
}

// ===== domains/user/domain/src/main/kotlin/com/restaurant/domain/user/error/UserDomainErrorCodes.kt =====
package com.restaurant.domain.user.error

// Removed: import com.restaurant.common.core.error.ErrorCode
// Removed: import org.springframework.http.HttpStatus

/**
 * User 도메인 비즈니스 규칙 위반 관련 에러 코드 Enum
 */
import com.restaurant.common.core.error.ErrorCode

enum class UserDomainErrorCodes(
    override val code: String,
    override val message: String,
    override val status: Int
) : ErrorCode {
    USER_NOT_FOUND("USER-DOMAIN-001", "사용자를 찾을 수 없습니다.", 404),
    DUPLICATE_EMAIL("USER-DOMAIN-002", "이미 사용중인 이메일입니다.", 409),
    PASSWORD_MISMATCH("USER-DOMAIN-003", "비밀번호가 일치하지 않습니다.", 401),
    ADDRESS_NOT_FOUND("USER-DOMAIN-004", "주소를 찾을 수 없습니다.", 404),
    MAX_ADDRESS_LIMIT_EXCEEDED("USER-DOMAIN-005", "최대 주소 등록 개수를 초과했습니다.", 400),
    DEFAULT_ADDRESS_CANNOT_BE_REMOVED("USER-DOMAIN-006", "기본 주소는 삭제할 수 없습니다.", 400),
    CANNOT_REMOVE_LAST_ADDRESS("USER-DOMAIN-007", "마지막 주소는 삭제할 수 없습니다.", 400),
    INVALID_PASSWORD_FORMAT("USER-DOMAIN-008", "비밀번호 형식이 올바르지 않습니다.", 400),
    INVALID_INPUT("USER-DOMAIN-009", "입력값이 유효하지 않습니다.", 400),
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/AddressResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import io.swagger.v3.oas.annotations.media.Schema

data class AddressResponseV1(
    @Schema(description = "주소 ID", example = "550e8400-e29b-41d4-a716-446655440000")
    val id: String,
    @Schema(description = "도로명 주소", example = "서울시 강남구 테헤란로 123")
    val street: String,
    @Schema(description = "상세 주소", example = "456동 789호")
    val detail: String,
    @Schema(description = "우편번호", example = "12345")
    val zipCode: String,
    @Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/dto/response/UserProfileResponseV1.kt =====
package com.restaurant.presentation.user.v1.query.dto.response

import com.fasterxml.jackson.annotation.JsonFormat
import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel
import java.time.LocalDateTime

@Schema(description = "사용자 프로필 응답")
data class UserProfileResponseV1(
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val id: String,
    @Schema(description = "사용자 이메일", example = "test@example.com") val email: String,
    @Schema(description = "사용자 이름", example = "홍길동") val name: String,
    @Schema(description = "주소 목록") val addresses: List<AddressResponseV1> = emptyList(),
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 생성 시간", example = "2023-01-01 12:00:00")
    val createdAt: LocalDateTime,
    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @Schema(description = "계정 최종 수정 시간", example = "2023-01-01 12:00:00")
    val updatedAt: LocalDateTime,
) : RepresentationModel<UserProfileResponseV1>()

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/query/UserQueryControllerV1.kt =====
package com.restaurant.presentation.user.v1.query

import com.restaurant.application.user.handler.GetUserProfileQueryHandler
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.presentation.user.extensions.v1.response.toResponse
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 조회", description = "사용자 프로필 조회 API")
class UserQueryControllerV1(
    private val getUserProfileQueryHandler: GetUserProfileQueryHandler,
) {
    private val log = LoggerFactory.getLogger(UserQueryControllerV1::class.java)

    @GetMapping("/{userId}")
    @Operation(summary = "사용자 프로필 조회", description = "사용자 ID를 통해 프로필 정보를 조회합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 조회 성공",
                content = [Content(mediaType = "application/json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [
                    Content(
                        mediaType = "application/problem+json",
                        schema =
                            io.swagger.v3.oas.annotations.media
                                .Schema(implementation = org.springframework.http.ProblemDetail::class),
                    ),
                ],
            ),
        ],
    )
    fun getUserProfile(
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationId: String? = null,
    ): ResponseEntity<UserProfileResponseV1> {
        val finalCorrelationId =
            correlationId ?: java.util.UUID
                .randomUUID()
                .toString()
        log.debug("사용자 프로필 조회 요청, correlationId={}, userId={}", finalCorrelationId, userId)
        val query = GetUserProfileQuery(userId)
        val result = getUserProfileQueryHandler.handle(query, finalCorrelationId)
        val response = result.toResponse()
        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, finalCorrelationId)).withSelfRel(),
        )
        log.info("사용자 프로필 조회 성공, correlationId={}, userId={}", finalCorrelationId, userId)
        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserAddressControllerV1.kt =====
package com.restaurant.presentation.user.v1.command

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.command.handler.DeleteAddressCommandHandler
import com.restaurant.application.user.command.handler.RegisterAddressCommandHandler
import com.restaurant.application.user.command.handler.UpdateAddressCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users/{userId}/addresses")
@Tag(name = "주소 관리", description = "사용자의 배달 주소 등록, 수정, 삭제 API")
class UserAddressControllerV1(
    private val registerAddressCommandHandler: RegisterAddressCommandHandler,
    private val updateAddressCommandHandler: UpdateAddressCommandHandler,
    private val deleteAddressCommandHandler: DeleteAddressCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserAddressControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping
    @Operation(summary = "주소 등록", description = "사용자의 새로운 배달 주소를 등록합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "주소 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: RegisterAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId)

        registerAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PutMapping("/{addressId}")
    @Operation(summary = "주소 수정", description = "등록된 배달 주소를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
        @Valid @RequestBody request: UpdateAddressRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = request.toCommand(userId, addressId)

        updateAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{addressId}")
    @Operation(summary = "주소 삭제", description = "등록된 배달 주소를 삭제합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "주소 삭제 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자 또는 주소를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteAddress(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Parameter(description = "주소 ID", required = true) @PathVariable addressId: String,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        val command = DeleteAddressCommand(userId, addressId)

        deleteAddressCommandHandler.handle(command, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "주소가 삭제되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/UserCommandControllerV1.kt =====
package com.restaurant.presentation.user.v1.command
import com.restaurant.application.user.command.handler.UpdateProfileCommandHandler
import com.restaurant.application.user.handler.ChangePasswordCommandHandler
import com.restaurant.application.user.handler.DeleteUserCommandHandler
import com.restaurant.application.user.handler.LoginCommandHandler
import com.restaurant.application.user.handler.RegisterUserCommandHandler
import com.restaurant.common.presentation.dto.response.CommandResultResponse
import com.restaurant.presentation.user.extensions.v1.request.toCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1
import com.restaurant.presentation.user.v1.command.dto.response.LoginResponseV1
import com.restaurant.presentation.user.v1.query.UserQueryControllerV1
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo
import org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import java.util.UUID

@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "사용자 관리", description = "사용자 등록, 로그인, 프로필 관리 API")
class UserCommandControllerV1(
    private val registerUserCommandHandler: RegisterUserCommandHandler,
    private val loginCommandHandler: LoginCommandHandler,
    private val updateProfileCommandHandler: UpdateProfileCommandHandler,
    private val changePasswordCommandHandler: ChangePasswordCommandHandler,
    private val deleteUserCommandHandler: DeleteUserCommandHandler,
) {
    private val log = LoggerFactory.getLogger(UserCommandControllerV1::class.java)

    private fun getOrGenerateCorrelationId(headerValue: String?): String =
        if (!headerValue.isNullOrBlank()) headerValue else UUID.randomUUID().toString()

    @PostMapping("/register")
    @Operation(summary = "사용자 등록", description = "신규 사용자를 시스템에 등록합니다. 이메일, 이름, 비밀번호가 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "201",
                description = "사용자 등록 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "409",
                description = "이미 존재하는 이메일",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun registerUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: RegisterUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 등록 요청: email={}, correlationId={}", request.email, correlationId)

        // extension 함수 사용
        val userId = registerUserCommandHandler.handle(request.toCommand(), correlationId)

        log.info("사용자 등록 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자가 성공적으로 등록되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity
            .created(
                linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).toUri(),
            ).body(response)
    }

    @PostMapping("/login")
    @Operation(summary = "로그인", description = "이메일과 비밀번호로 로그인합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그인 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = LoginResponseV1::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "로그인 실패 (이메일 또는 비밀번호 불일치)",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun login(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Valid @RequestBody request: LoginRequestV1,
    ): ResponseEntity<LoginResponseV1> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그인 요청: email={}, correlationId={}", request.email, correlationId)

        val loginResult = loginCommandHandler.handle(request.toCommand(), correlationId)

        log.info("로그인 성공: userId={}, correlationId={}", loginResult, correlationId)

        val response =
            LoginResponseV1(
                status = "SUCCESS",
                message = "로그인 성공",
                userId = loginResult,
                accessToken = "",
                refreshToken = "",
                correlationId = correlationId,
            )

        response.add(
            linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(loginResult, correlationId)).withRel("user-profile"),
        )

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/profile")
    @Operation(summary = "프로필 수정", description = "사용자 프로필 정보를 수정합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "프로필 수정 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun updateProfile(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: UpdateProfileRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("프로필 수정 요청: userId={}, correlationId={}", userId, correlationId)

        updateProfileCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("프로필 수정 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "프로필이 성공적으로 수정되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @PutMapping("/{userId}/password")
    @Operation(summary = "비밀번호 변경", description = "사용자 비밀번호를 변경합니다. 현재 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "비밀번호 변경 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "현재 비밀번호가 일치하지 않음",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun changePassword(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: ChangePasswordRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("비밀번호 변경 요청: userId={}, correlationId={}", userId, correlationId)

        changePasswordCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("비밀번호 변경 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "비밀번호가 성공적으로 변경되었습니다.",
                correlationId = correlationId,
            )
        response.add(linkTo(methodOn(UserQueryControllerV1::class.java).getUserProfile(userId, correlationId)).withRel("user-profile"))

        return ResponseEntity.ok(response)
    }

    @DeleteMapping("/{userId}")
    @Operation(summary = "사용자 탈퇴", description = "사용자 계정을 삭제합니다. 비밀번호 확인이 필요합니다.")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "사용자 탈퇴 성공",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
            ApiResponse(
                responseCode = "400",
                description = "잘못된 요청 데이터",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "401",
                description = "비밀번호가 일치하지 않음",
                content = [Content(mediaType = "application/problem+json")],
            ),
            ApiResponse(
                responseCode = "404",
                description = "사용자를 찾을 수 없음",
                content = [Content(mediaType = "application/problem+json")],
            ),
        ],
    )
    fun deleteUser(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
        @Parameter(description = "사용자 ID", required = true) @PathVariable userId: String,
        @Valid @RequestBody request: DeleteUserRequestV1,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("사용자 탈퇴 요청: userId={}, correlationId={}", userId, correlationId)

        deleteUserCommandHandler.handle(request.toCommand(userId), correlationId)

        log.info("사용자 탈퇴 성공: userId={}, correlationId={}", userId, correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "사용자 계정이 성공적으로 삭제되었습니다.",
                correlationId = correlationId,
            )

        return ResponseEntity.ok(response)
    }

    @PostMapping("/logout")
    @Operation(summary = "로그아웃", description = "현재 사용자 세션을 종료합니다. (토큰 기반 인증에서는 클라이언트 측 토큰 삭제로 처리)")
    @ApiResponses(
        value = [
            ApiResponse(
                responseCode = "200",
                description = "로그아웃 요청 처리됨",
                content = [Content(mediaType = "application/json", schema = Schema(implementation = CommandResultResponse::class))],
            ),
        ],
    )
    fun logout(
        @Parameter(hidden = true) @RequestHeader("X-Correlation-Id", required = false) correlationIdHeader: String?,
    ): ResponseEntity<CommandResultResponse> {
        val correlationId = getOrGenerateCorrelationId(correlationIdHeader)
        log.info("로그아웃 요청: correlationId={}", correlationId)

        val response =
            CommandResultResponse(
                status = "SUCCESS",
                message = "로그아웃 요청이 처리되었습니다.",
                correlationId = correlationId,
            )
        response.add(
            linkTo(methodOn(UserCommandControllerV1::class.java).login(correlationId, LoginRequestV1("", ""))).withRel("login"),
        )

        return ResponseEntity.ok(response)
    }
}

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class DeleteUserRequestV1(
    @field:Schema(description = "현재 비밀번호 확인", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/LoginRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class LoginRequestV1(
    @field:Schema(description = "사용자 이메일", example = "user@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    val password: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/ChangePasswordRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordRequestV1(
    @field:Schema(description = "현재 비밀번호", example = "currentPassword123")
    @field:NotBlank(message = "현재 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val currentPassword: String,
    @field:Schema(description = "새 비밀번호", example = "newPassword456")
    @field:NotBlank(message = "새 비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val newPassword: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class UpdateAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "테헤란로 123")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "456호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "12345")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "true")
    val isDefault: Boolean? = false,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/DeleteAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

// 주소 삭제 시 별도 요청 본문이 필요 없을 수 있으나, ktlint 규칙상 파일 생성
data class DeleteAddressRequestV1(
    // 필요한 필드가 있다면 추가
    val dummy: String? = null, // ktlint 회피용 임시 필드
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/UpdateProfileRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

data class UpdateProfileRequestV1(
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterUserRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterUserRequestV1(
    @field:Schema(description = "사용자 이메일", example = "test@example.com")
    @field:NotBlank(message = "이메일은 필수 입력 항목입니다.")
    @field:Email(message = "유효한 이메일 형식이 아닙니다.")
    val email: String,
    @field:Schema(description = "사용자 비밀번호", example = "password123")
    @field:NotBlank(message = "비밀번호는 필수 입력 항목입니다.")
    @field:Size(min = 8, message = "비밀번호는 최소 8자리 이상이어야 합니다.")
    val password: String,
    @field:Schema(description = "사용자 이름", example = "홍길동")
    @field:NotBlank(message = "이름은 필수 입력 항목입니다.")
    val name: String,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/request/RegisterAddressRequestV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.request

import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class RegisterAddressRequestV1(
    @field:Schema(description = "도로명 주소", example = "선릉로 433")
    @field:NotBlank(message = "도로명 주소는 필수 입력 항목입니다.")
    val street: String,
    @field:Schema(description = "상세 주소", example = "101호")
    val detail: String?,
    @field:Schema(description = "우편번호", example = "06211")
    @field:NotBlank(message = "우편번호는 필수 입력 항목입니다.")
    @field:Size(min = 5, max = 5, message = "우편번호는 5자리여야 합니다.")
    val zipCode: String,
    @field:Schema(description = "기본 주소 여부", example = "false")
    val isDefault: Boolean? = false,
)

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/v1/command/dto/response/LoginResponseV1.kt =====
package com.restaurant.presentation.user.v1.command.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "로그인 응답")
data class LoginResponseV1(
    @Schema(description = "상태", example = "SUCCESS") val status: String,
    @Schema(description = "메시지", example = "로그인 성공") val message: String,
    @Schema(description = "사용자 ID", example = "550e8400-e29b-41d4-a716-446655440000") val userId: String,
    @Schema(description = "액세스 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val accessToken: String,
    @Schema(description = "리프레시 토큰", example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...") val refreshToken: String,
    @Schema(description = "상관 관계 ID", example = "correlationId-123") val correlationId: String,
) : RepresentationModel<LoginResponseV1>()

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserAddressCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.presentation.user.v1.command.dto.request.RegisterAddressRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateAddressRequestV1

// RegisterAddressRequestV1 -> RegisterAddressCommand 변환
fun RegisterAddressRequestV1.toCommand(userId: String): RegisterAddressCommand =
    RegisterAddressCommand(
        userId = userId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// UpdateAddressRequestV1 -> UpdateAddressCommand 변환
fun UpdateAddressRequestV1.toCommand(
    userId: String,
    addressId: String,
): UpdateAddressCommand =
    UpdateAddressCommand(
        userId = userId,
        addressId = addressId,
        street = this.street,
        detail = this.detail ?: "",
        zipCode = this.zipCode,
        isDefault = this.isDefault ?: false,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserCommandRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.presentation.user.v1.command.dto.request.ChangePasswordRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.DeleteUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.LoginRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.RegisterUserRequestV1
import com.restaurant.presentation.user.v1.command.dto.request.UpdateProfileRequestV1

// RegisterUserRequestV1 -> RegisterUserCommand 변환
fun RegisterUserRequestV1.toCommand(): RegisterUserCommand =
    RegisterUserCommand(
        email = this.email,
        password = this.password,
        name = this.name,
    )

// LoginRequestV1 -> LoginCommand 변환
fun LoginRequestV1.toCommand(): LoginCommand =
    LoginCommand(
        email = this.email,
        password = this.password,
    )

// UpdateProfileRequestV1 -> UpdateProfileCommand 변환
fun UpdateProfileRequestV1.toCommand(userId: String): UpdateProfileCommand =
    UpdateProfileCommand(
        userId = userId,
        name = this.name,
    )

// ChangePasswordRequestV1 -> ChangePasswordCommand 변환
fun ChangePasswordRequestV1.toCommand(userId: String): ChangePasswordCommand =
    ChangePasswordCommand(
        userId = userId,
        currentPassword = this.currentPassword,
        newPassword = this.newPassword,
    )

// DeleteUserRequestV1 -> DeleteUserCommand 변환
fun DeleteUserRequestV1.toCommand(userId: String): DeleteUserCommand =
    DeleteUserCommand(
        userId = userId,
        password = this.currentPassword,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/request/UserQueryRequestExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.request

import com.restaurant.application.user.query.GetUserProfileQuery

// String (UUID) -> GetUserProfileQuery 변환
fun String.toGetUserProfileQuery(): GetUserProfileQuery =
    GetUserProfileQuery(
        userId = this,
    )

// ===== domains/user/presentation/src/main/kotlin/com/restaurant/presentation/user/extensions/v1/response/UserQueryResponseExtensions.kt =====
package com.restaurant.presentation.user.extensions.v1.response

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.presentation.user.v1.query.dto.response.AddressResponseV1
import com.restaurant.presentation.user.v1.query.dto.response.UserProfileResponseV1

// UserProfileDto -> UserProfileResponseV1 변환
fun UserProfileDto.toResponse(): UserProfileResponseV1 =
    UserProfileResponseV1(
        id = this.id,
        email = this.email,
        name = this.name,
        addresses = this.addresses.map { it.toResponse() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

// UserProfileDto.AddressDto -> AddressResponseV1 변환
fun UserProfileDto.AddressDto.toResponse(): AddressResponseV1 =
    AddressResponseV1(
        id = this.id,
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// List<UserProfileDto.AddressDto> -> List<AddressResponseV1> 변환
fun List<UserProfileDto.AddressDto>.toResponse(): List<AddressResponseV1> = map { it.toResponse() }

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/UserEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.LocalDateTime
import java.util.ArrayList
import java.util.UUID

@Entity
@Table(name = "users")
class UserEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "domain_id", unique = true, nullable = false, updatable = false)
    val domainId: UUID,
    @Column(unique = true, nullable = false) val email: String,
    @Column(nullable = false) val password: String,
    @Column(nullable = false) val name: String,
    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime = LocalDateTime.now(),
    @Column(name = "updated_at", nullable = false)
    val updatedAt: LocalDateTime = LocalDateTime.now(),
    @Version
    @Column(nullable = false)
    val version: Long = 0,
) {
    // JPA 필드는 private으로 설정
    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    private var addressEntities: MutableList<AddressEntity> = ArrayList()

    // 주소 목록에 대한 불변 뷰 제공 (프로퍼티로 제공)
    val addresses: List<AddressEntity>
        get() = addressEntities.toList()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as UserEntity

        if (id != other.id) return false
        if (email != other.email) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + email.hashCode()
        return result
    }

    override fun toString(): String =
        "UserEntity(id=$id, domainId=$domainId, email='$email', name='$name', createdAt=$createdAt, updatedAt=$updatedAt, addresses=${addressEntities.size}, version=$version)"
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/entity/AddressEntity.kt =====
package com.restaurant.infrastructure.user.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.util.UUID

@Entity
@Table(name = "user_addresses")
class AddressEntity(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long? = null,
    @Column(name = "address_id", nullable = false, unique = true) val addressId: UUID,
    @Column(nullable = false) val street: String,
    @Column val detail: String,
    @Column(name = "zip_code", nullable = false) val zipCode: String,
    @Column(name = "is_default", nullable = false) val isDefault: Boolean,
    @Version
    @Column(nullable = false)
    val version: Long = 0,
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    var user: UserEntity? = null,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as AddressEntity

        // 도메인 ID로 비교
        return addressId == other.addressId
    }

    override fun hashCode(): Int {
        // 도메인 ID 기반 해시코드
        return addressId.hashCode()
    }

    override fun toString(): String =
        "AddressEntity(id=$id, addressId=$addressId, street='$street', detail='$detail', zipCode='$zipCode', isDefault=$isDefault, version=$version)"
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/UserRepositoryImpl.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.UserId
import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.infrastructure.user.extensions.toDomain
import com.restaurant.infrastructure.user.extensions.toEntity
import com.restaurant.shared.outbox.application.port.OutboxMessageRepository
import com.restaurant.shared.outbox.application.port.model.OutboxMessage
import org.springframework.stereotype.Repository

@Repository
class UserRepositoryImpl(
    private val jpaRepository: SpringDataJpaUserRepository,
    private val outboxMessageRepository: OutboxMessageRepository, // Corrected type and variable name
    // private val avroEventSerializer: AvroEventSerializer // Inject hypothetical serializer
) : UserRepository {
    override fun save(user: User): User {
        val domainEvents = user.getDomainEvents()

        val entity = user.toEntity()
        val savedEntity = jpaRepository.save(entity)

        if (domainEvents.isNotEmpty()) {
            val aggregateIdStr = user.id?.value?.toString() ?: throw IllegalStateException("User domain ID must not be null for outbox saving")
            val aggregateType = "User" // Or derive more dynamically if needed

            val outboxMessages = domainEvents.map { event ->
                createOutboxMessage(event, aggregateType, aggregateIdStr)
            }
            outboxMessageRepository.save(outboxMessages) // Call new repository method
        }

        user.clearDomainEvents()

        return savedEntity.toDomain()
    }

    // Helper function to create OutboxMessage from DomainEvent (moved out of save method)
    private fun createOutboxMessage(
        event: DomainEvent,
        aggregateType: String,
        aggregateId: String
    ): OutboxMessage {
        val eventTypeSimple = event::class.java.simpleName.replace("Event", "").lowercase()
        // TODO: Externalize environment/topic naming logic (Rule 98)
        val environment = "dev"
        val targetTopic = "$environment.$aggregateType.$eventTypeSimple.v1" // Rule 98 convention

        // --- Placeholder for Avro Serialization (Rule 92, 120) ---
        // TODO: 1. Obtain Avro schema for the DomainEvent (e.g., UserRegisteredEvent)
        // TODO: 2. Create Avro-specific class instance and map DomainEvent data
        // TODO: 3. Use Avro serializer to convert Avro object to ByteArray
        val payloadBytes: ByteArray = serializeEventToAvroBytes(event, targetTopic) // Placeholder serialization

        val headers = mapOf(
            "correlationId" to event.eventId, // Use eventId as correlationId
            "aggregateId" to aggregateId,
            "aggregateType" to aggregateType
            // Add other headers if needed
        )

        return OutboxMessage(
            eventId = java.util.UUID.fromString(event.eventId),
            aggregateType = aggregateType,
            aggregateId = aggregateId,
            targetTopic = targetTopic,
            payload = payloadBytes,
            headers = headers
        )
    }

    // --- Placeholder for Avro Serialization Logic (moved out of save method) ---
    private fun serializeEventToAvroBytes(event: DomainEvent, topic: String): ByteArray {
        // TODO: Implement actual Avro serialization here using Avro schema and serializer
        // This is where Avro-generated classes and serializer will be used (Rule 111.5)
        // Example (pseudocode):
        // val avroEvent = mapDomainEventToAvro(event) // Map DomainEvent to Avro class
        // return avroSerializer.serialize(topic, avroEvent) // Serialize to ByteArray
        return "仮のペイロード".toByteArray() // TEMPORARY: Placeholder payload (non-Avro, Rule 92, 120 violated)
    }

    // Placeholder for mapping logic (could be in a separate mapper class)
    // private fun mapToAvro(event: DomainEvent): SpecificRecordBase { ... }

    override fun findById(id: UserId): User? = jpaRepository.findByDomainId(id.value)?.toDomain()

    override fun findByEmail(email: Email): User? =
        jpaRepository.findByEmail(email.value)?.let {
            it.toDomain()
        }

    override fun existsByEmail(email: Email): Boolean = jpaRepository.existsByEmail(email.value)

    override fun delete(user: User) {
        val entity = user.toEntity()
        jpaRepository.delete(entity)
    }
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/repository/SpringDataJpaUserRepository.kt =====
package com.restaurant.infrastructure.user.repository

import com.restaurant.infrastructure.user.entity.UserEntity
import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository
import java.util.Optional
import java.util.UUID

@Repository
interface SpringDataJpaUserRepository : JpaRepository<UserEntity, Long> {
    @EntityGraph(attributePaths = ["addresses"])
    override fun findById(id: Long): Optional<UserEntity>

    @EntityGraph(attributePaths = ["addresses"])
    fun findByDomainId(domainId: UUID): UserEntity?

    @EntityGraph(attributePaths = ["addresses"])
    fun findByEmail(email: String): UserEntity?

    fun existsByEmail(email: String): Boolean
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/UserEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import com.restaurant.infrastructure.user.entity.UserEntity

// UserEntity -> User 변환
fun UserEntity.toDomain(): User {
    // addresses는 Lazy Loading이므로 트랜잭션 경계 내에서만 접근해야 함
    val domainAddresses = this.addresses.map { it.toDomain() } // addresses getter is already List

    return User.reconstitute(
        id = UserId.of(this.domainId), // Use domainId for UserId
        email = Email.of(email),
        password = Password.fromEncoded(password),
        name = Name.of(name),
        addresses = domainAddresses,
        createdAt = createdAt,
        updatedAt = updatedAt,
    )
}

// User -> UserEntity 변환
fun User.toEntity(): UserEntity {
    val entity =
        UserEntity(
            id = null, // Let JPA handle the Long ID generation
            domainId =
                this.id?.value
                    ?: throw IllegalArgumentException(
                        "User Domain ID cannot be null for entity conversion",
                    ), // Use UUID from Domain
            email = email.value,
            password = password.encodedValue,
            name = name.value,
            createdAt = createdAt,
            updatedAt = updatedAt,
        )
    // Set addresses manually, establishing the bidirectional link
    this.addresses.map { address ->
        // 람다 파라미터를 새 줄로 이동
        address.toEntity().apply { user = entity } // Set back-reference
    }
    // JPA Cascade 설정에 의존하여 저장하므로 별도 설정 불필요
    return entity
}

// ===== domains/user/infrastructure/src/main/kotlin/com/restaurant/infrastructure/user/extensions/AddressEntityExtensions.kt =====
package com.restaurant.infrastructure.user.extensions

import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.infrastructure.user.entity.AddressEntity

// AddressEntity -> Address 변환
fun AddressEntity.toDomain(): Address {
    // val id = this.id ?: throw IllegalStateException("영속화된 AddressEntity의 ID는 null일 수 없습니다") // Long id 제거

    return Address.reconstitute(
        // id = id, // Long id 제거
        addressId = AddressId.of(this.addressId), // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
    )
}

// Address -> AddressEntity 변환 (UserEntity 참조 없이)
fun Address.toEntity(): AddressEntity =
    AddressEntity(
        id = null, // JPA가 Long ID를 관리하도록 null 전달 (기존 id 필드 사용 제거)
        addressId = this.addressId.value, // addressId 매핑 추가
        street = street,
        detail = detail,
        zipCode = zipCode,
        isDefault = isDefault,
        user = null, // Will be set when added to UserEntity
        // version은 JPA가 관리하거나, 필요시 Domain 객체에서 전달받아 설정
    )

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/query/GetUserProfileQuery.kt =====
package com.restaurant.application.user.query

data class GetUserProfileQuery(
    val userId: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class DeleteUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(DeleteUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteUserCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        log.debug("Attempting user deletion, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for deletion, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Password mismatch during user deletion, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("비밀번호가 일치하지 않습니다.")
            }

            // 사용자 삭제
            userRepository.delete(user)

            log.info("User deleted successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user deletion, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 시스템 오류
            log.error(
                "System error during user deletion, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.RegisterAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class RegisterAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(RegisterAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 및 Domain Entity 생성
        val userId = UserId.fromString(command.userId)
        val address =
            Address.create(
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )

        log.debug("Attempting to register address, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address registration, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 추가 (Aggregate 호출)
            val updatedUser = user.addAddress(address)
            // 저장 (Repository)
            userRepository.save(updatedUser)

            log.info("Address registered successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address registration, correlationId={}, userId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address registration, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class DeleteAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug("Attempting to delete address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for address deletion, correlationId={}, userId={}", correlationId, userId)
                        // Rule 69: Domain 예외 사용
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 주소 삭제 (Aggregate 호출 - 내부에서 AddressNotFound 예외 발생 가능)
            val updatedUser = user.removeAddress(addressId)
            // 저장
            userRepository.save(updatedUser)

            log.info("Address deleted successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error: {}",
                correlationId,
                command.userId,
                command.addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // Rule 70: 예상치 못한 오류는 ApplicationException.SystemError
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                command.userId,
                command.addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/RegisterUserCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.RegisterUserCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.Password
import org.slf4j.LoggerFactory
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class RegisterUserCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(RegisterUserCommandHandler::class.java)

    @Transactional
    fun handle(
        command: RegisterUserCommand,
        correlationId: String? = null,
    ): String {
        // Validate raw inputs and create VOs
        val email = Email.of(command.email)
        Password.validateRaw(command.password) // Validate raw password
        val name = Name.of(command.name)
        // Encode password and create Password VO
        val encodedPassword = passwordEncoder.encode(command.password)
        val password = Password.fromEncoded(encodedPassword)

        // 이메일 중복 검증 (Domain 예외 사용)
        if (userRepository.existsByEmail(email)) {
            // DuplicateEmail 예외는 ErrorCode를 내부적으로 가지므로 별도 로깅 불필요
            throw UserDomainException.User.DuplicateEmail(email = command.email)
        }

        try {
            // 사용자 생성 (이제 User 인스턴스만 반환)
            val newUser = User.create(email, password, name)

            // 사용자 저장 (Repository에서 이벤트 처리)
            val savedUser = userRepository.save(newUser)

            log.info("사용자 등록 성공, correlationId={}, email={}", correlationId, email)
            // Return UUID instead of Long
            return savedUser.id.value.toString()
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during user registration, correlationId={}, errorCode={}, error: {}",
                correlationId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (dive: DataIntegrityViolationException) {
            // Catch potential unique constraint violations not caught by existsByEmail (race condition)
            log.error(
                "Data integrity violation during user registration, possibly duplicate email race condition, correlationId={}, error: {}",
                correlationId,
                dive.message,
                dive,
            )
            // Re-throw as duplicate email domain exception
            throw UserDomainException.User.DuplicateEmail(email.value)
        } catch (e: Exception) {
            // 기타 예상치 못한 오류
            log.error("사용자 등록 중 시스템 오류 발생, correlationId={}, error={}", correlationId, e.message, e)
            // Wrap as ApplicationException.SystemError before propagating
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/DeleteUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.DeleteAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 삭제 커맨드 핸들러
 */
@Service
class DeleteUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(DeleteUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: DeleteAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to delete address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address deletion, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 주소 삭제 (Domain 로직 호출)
            val updatedUser = user.removeAddress(addressId)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address deleted successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address deletion, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address deletion, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateProfileCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        try {
            // 사용자 조회 - DomainException (NotFound)는 상위로 전파
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("사용자를 찾을 수 없음, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 프로필 업데이트
            val updatedUser = user.updateProfile(name = name)
            userRepository.save(updatedUser)

            log.info("사용자 프로필 업데이트 성공, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            log.error(
                "사용자 프로필 업데이트 중 도메인 오류 발생, correlationId={}, errorCode={}, error={}",
                correlationId,
                de.errorCode.code,
                de.message,
                de,
            )
            throw de
        } catch (e: Exception) {
            log.error(
                "사용자 프로필 업데이트 중 시스템 오류 발생, correlationId={}, error={}",
                correlationId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/ChangePasswordCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.ChangePasswordCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Password
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class ChangePasswordCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(ChangePasswordCommandHandler::class.java)

    @Transactional
    fun handle(
        command: ChangePasswordCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: Create VOs outside try-catch
        val userId = UserId.fromString(command.userId)
        Password.validateRaw(command.newPassword)
        val encodedNewPassword = passwordEncoder.encode(command.newPassword)
        val newPasswordVo = Password.fromEncoded(encodedNewPassword)

        log.debug("Attempting password change, correlationId={}, userId={}", correlationId, userId)

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId)
                    ?: run {
                        log.warn("User not found for password change, correlationId={}, userId={}", correlationId, userId)
                        throw UserDomainException.User.NotFound(userId = command.userId)
                    }

            // 현재 비밀번호 검증 (Application Layer)
            if (!passwordEncoder.matches(command.currentPassword, user.password.encodedValue)) {
                log.warn("Password change failed: Current password mismatch, correlationId={}, userId={}", correlationId, userId)
                throw UserApplicationException.AuthenticationFailed("현재 비밀번호가 일치하지 않습니다.")
            }

            // 비밀번호 변경 (Aggregate 호출)
            val updatedUser = user.changePassword(newPasswordVo)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info("Password changed successfully, correlationId={}, userId={}", correlationId, userId)
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during password change, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                command.userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during password change, correlationId={}, userId={}, error={}",
                correlationId,
                command.userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserAddressCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 주소 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)

        log.debug(
            "Attempting to update address, correlationId={}, userId={}, addressId={}",
            correlationId,
            userId,
            addressId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for address update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 업데이트할 주소 객체 생성
            val updatedAddress =
                Address.reconstitute(
                    addressId = addressId,
                    street = command.street,
                    detail = command.detail,
                    zipCode = command.zipCode,
                    isDefault = command.isDefault,
                )

            // 현재 주소를 찾고 업데이트
            val updatedUser = user.updateAddress(addressId, updatedAddress)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "Address updated successfully, correlationId={}, userId={}, addressId={}",
                correlationId,
                userId,
                addressId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during address update, correlationId={}, userId={}, addressId={}, errorCode={}, error={}",
                correlationId,
                userId,
                addressId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during address update, correlationId={}, userId={}, addressId={}, error={}",
                correlationId,
                userId,
                addressId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateUserProfileCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.UpdateProfileCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Name
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

/**
 * 사용자 프로필 업데이트 커맨드 핸들러
 */
@Service
class UpdateUserProfileCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateUserProfileCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateProfileCommand,
        correlationId: String? = null,
    ) {
        // Rule 14, 61: VO 생성
        val userId = UserId.fromString(command.userId)
        val name = Name.of(command.name)

        log.debug(
            "Attempting to update user profile, correlationId={}, userId={}",
            correlationId,
            userId,
        )

        try {
            // 사용자 조회
            val user =
                userRepository.findById(userId) ?: run {
                    log.warn(
                        "User not found for profile update, correlationId={}, userId={}",
                        correlationId,
                        userId,
                    )
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }

            // 프로필 업데이트 (Domain 로직 호출)
            val updatedUser = user.updateProfile(name)

            // 사용자 저장
            userRepository.save(updatedUser)

            log.info(
                "User profile updated successfully, correlationId={}, userId={}",
                correlationId,
                userId,
            )
        } catch (de: UserDomainException) {
            // Rule 71: 로깅 시 errorCode 추가
            log.warn(
                "Domain error during profile update, correlationId={}, userId={}, errorCode={}, error={}",
                correlationId,
                userId,
                de.errorCode.code,
                de.message,
            )
            throw de
        } catch (e: Exception) {
            // 예상치 못한 시스템 오류
            log.error(
                "System error during profile update, correlationId={}, userId={}, error={}",
                correlationId,
                userId,
                e.message,
                e,
            )
            throw UserApplicationException.SystemError(e)
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): String {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (UserId 반환)
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, user.id.value)
            return user.id.value.toString()
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/UpdateAddressCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.UpdateAddressCommand
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.model.Address
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.AddressId
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
public class UpdateAddressCommandHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(UpdateAddressCommandHandler::class.java)

    @Transactional
    fun handle(
        command: UpdateAddressCommand,
        correlationId: String? = null,
    ) {
        val userId = UserId.fromString(command.userId)
        val addressId = AddressId.fromString(command.addressId)
        val updatedAddressData =
            Address.reconstitute(
                addressId = addressId,
                street = command.street,
                detail = command.detail,
                zipCode = command.zipCode,
                isDefault = command.isDefault,
            )
        log.debug("Attempting to update address, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for address update, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = command.userId)
                }
        val updatedUser = user.updateAddress(addressId, updatedAddressData)
        userRepository.save(updatedUser)
        log.info("Address updated successfully, correlationId={}, userId={}, addressId={}", correlationId, userId, addressId)
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/handler/GetUserProfileQueryHandler.kt =====
package com.restaurant.application.user.handler

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.application.user.extensions.toUserProfileDto
import com.restaurant.application.user.query.GetUserProfileQuery
import com.restaurant.domain.user.exception.UserDomainException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.UserId
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class GetUserProfileQueryHandler(
    private val userRepository: UserRepository,
) {
    private val log = LoggerFactory.getLogger(GetUserProfileQueryHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        query: GetUserProfileQuery,
        correlationId: String? = null,
    ): UserProfileDto {
        val userId = UserId.fromString(query.userId)
        log.debug("Attempting to get user profile, correlationId={}, userId={}", correlationId, userId)
        val user =
            userRepository.findById(userId)
                ?: run {
                    log.warn("User not found for profile query, correlationId={}, userId={}", correlationId, userId)
                    throw UserDomainException.User.NotFound(userId = query.userId)
                }
        val result = user.toUserProfileDto()
        log.debug("User profile retrieved successfully, correlationId={}, userId={}", correlationId, userId)
        return result
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/extensions/UserDtoExtensions.kt =====
package com.restaurant.application.user.extensions

import com.restaurant.application.user.dto.UserProfileDto
import com.restaurant.domain.user.aggregate.User
import com.restaurant.domain.user.model.Address

/**
 * Domain 객체를 Application DTO로 변환하는 확장 함수들
 */

fun User.toUserProfileDto(): UserProfileDto =
    UserProfileDto(
        id = this.id.value.toString(),
        email = this.email.value,
        name = this.name.value,
        addresses = this.addresses.map { it.toAddressDto() },
        createdAt = this.createdAt,
        updatedAt = this.updatedAt,
    )

fun Address.toAddressDto(): UserProfileDto.AddressDto =
    UserProfileDto.AddressDto(
        id = this.addressId.value.toString(),
        street = this.street,
        detail = this.detail,
        zipCode = this.zipCode,
        isDefault = this.isDefault,
    )

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/UserProfileDto.kt =====
package com.restaurant.application.user.dto

import java.time.LocalDateTime

data class UserProfileDto(
    val id: String,
    val email: String,
    val name: String,
    val addresses: List<AddressDto> = emptyList(),
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime,
) {
    data class AddressDto(
        val id: String,
        val street: String,
        val detail: String,
        val zipCode: String,
        val isDefault: Boolean,
    )
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/dto/LoginResult.kt =====
package com.restaurant.application.user.dto

import java.util.UUID

// 로그인 결과를 담는 데이터 클래스
data class LoginResult(
    val userId: String,
    val accessToken: String = UUID.randomUUID().toString(), // 임시 구현
    val refreshToken: String = UUID.randomUUID().toString(), // 임시 구현
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/ChangePasswordCommand.kt =====
package com.restaurant.application.user.command

data class ChangePasswordCommand(
    val userId: String,
    val currentPassword: String,
    val newPassword: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/LoginCommand.kt =====
package com.restaurant.application.user.command

data class LoginCommand(
    val email: String,
    val password: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateAddressCommand.kt =====
package com.restaurant.application.user.command

data class UpdateAddressCommand(
    val userId: String,
    val addressId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteUserCommand.kt =====
package com.restaurant.application.user.command

data class DeleteUserCommand(
    val userId: String,
    val password: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/handler/LoginCommandHandler.kt =====
package com.restaurant.application.user.command.handler

import com.restaurant.application.user.command.LoginCommand
import com.restaurant.application.user.dto.LoginResult
import com.restaurant.application.user.exception.UserApplicationException
import com.restaurant.domain.user.repository.UserRepository
import com.restaurant.domain.user.vo.Email
import org.slf4j.LoggerFactory
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class LoginCommandHandler(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
) {
    private val log = LoggerFactory.getLogger(LoginCommandHandler::class.java)

    @Transactional(readOnly = true)
    fun handle(
        command: LoginCommand,
        correlationId: String? = null,
    ): LoginResult {
        // VO 생성
        val email = Email.of(command.email)
        log.debug("Attempting to login user, correlationId={}, email={}", correlationId, email)

        try {
            // 사용자 조회
            val user =
                userRepository.findByEmail(email)
                    ?: run {
                        log.warn("User not found for login, correlationId={}, email={}", correlationId, email)
                        // 사용자가 없는 경우에도 동일한 인증 실패 메시지를 반환하여 정보 노출 방지
                        throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
                    }

            // 비밀번호 검증
            if (!passwordEncoder.matches(command.password, user.password.encodedValue)) {
                log.warn("Invalid password for login, correlationId={}, email={}", correlationId, email)
                throw UserApplicationException.AuthenticationFailed("이메일 또는 비밀번호가 일치하지 않습니다.")
            }

            // 로그인 성공 처리 (LoginResult 반환)
            val userId = user.id.value.toString()
            log.info("User logged in successfully, correlationId={}, userId={}", correlationId, userId)

            // 실제 구현에서는 JWT 토큰 생성 로직이 들어갈 것임
            return LoginResult(
                userId = userId,
                accessToken = "jwt.access.token.$userId", // 임시 구현
                refreshToken = "jwt.refresh.token.$userId", // 임시 구현
            )
        } catch (e: Exception) {
            when (e) {
                is UserApplicationException -> {
                    // Rule 71: 로깅 시 errorCode 추가
                    log.warn(
                        "Application error during login, correlationId={}, email={}, errorCode={}, error: {}",
                        correlationId,
                        command.email,
                        e.errorCode.code,
                        e.message,
                    )
                    throw e
                }
                else -> {
                    // 예상치 못한 오류 처리
                    log.error("System error during login, correlationId={}, email={}, error={}", correlationId, command.email, e.message, e)
                    throw UserApplicationException.SystemError(e)
                }
            }
        }
    }
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterUserCommand.kt =====
package com.restaurant.application.user.command

data class RegisterUserCommand(
    val email: String,
    val password: String,
    val name: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/DeleteAddressCommand.kt =====
package com.restaurant.application.user.command

data class DeleteAddressCommand(
    val userId: String,
    val addressId: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/RegisterAddressCommand.kt =====
package com.restaurant.application.user.command

data class RegisterAddressCommand(
    val userId: String,
    val street: String,
    val detail: String,
    val zipCode: String,
    val isDefault: Boolean = false,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/command/UpdateProfileCommand.kt =====
package com.restaurant.application.user.command

data class UpdateProfileCommand(
    val userId: String,
    val name: String,
)

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/exception/UserApplicationException.kt =====
package com.restaurant.application.user.exception

import com.restaurant.application.user.error.UserApplicationErrorCode
import com.restaurant.common.core.error.ErrorCode
import com.restaurant.common.core.exception.ApplicationException

sealed class UserApplicationException(
    override val errorCode: ErrorCode,
    final override val message: String = errorCode.message,
) : ApplicationException(message) {
    data class InvalidInput(
        val details: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.INVALID_INPUT,
            if (details != null) "유효하지 않은 입력: $details" else UserApplicationErrorCode.INVALID_INPUT.message,
        )

    data class AuthenticationFailed(
        val reason: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.AUTHENTICATION_FAILED,
            if (reason != null) "인증 실패: $reason" else UserApplicationErrorCode.AUTHENTICATION_FAILED.message,
        )

    data class ExternalServiceError(
        val serviceName: String,
        val causeError: String? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.EXTERNAL_SERVICE_ERROR,
            "외부 서비스($serviceName) 호출 오류${causeError?.let { ": $it" } ?: ""}",
        )

    data class SystemError(
        val causeException: Throwable? = null,
    ) : UserApplicationException(
            UserApplicationErrorCode.SYSTEM_ERROR,
            "시스템 오류 발생${causeException?.message?.let { ": $it" } ?: ""}",
        )
}

// ===== domains/user/application/src/main/kotlin/com/restaurant/application/user/error/UserApplicationErrorCode.kt =====
package com.restaurant.application.user.error

import com.restaurant.common.core.error.ErrorCode
import org.springframework.http.HttpStatus

/**
 * User Application 레이어 관련 에러 코드 Enum
 */
enum class UserApplicationErrorCode(
    override val code: String,
    override val status: HttpStatus,
    override val message: String,
) : ErrorCode {
    INVALID_INPUT("USER-APPLICATION-001", HttpStatus.BAD_REQUEST, "입력값이 유효하지 않습니다."),
    AUTHENTICATION_FAILED("USER-APPLICATION-002", HttpStatus.UNAUTHORIZED, "인증에 실패했습니다."), // 예시: JWT 토큰 검증 실패 등
    EXTERNAL_SERVICE_ERROR("USER-APPLICATION-003", HttpStatus.INTERNAL_SERVER_ERROR, "외부 서비스 호출에 실패했습니다."),
    SYSTEM_ERROR("USER-APPLICATION-999", HttpStatus.INTERNAL_SERVER_ERROR, "처리 중 오류가 발생했습니다."),
    // 필요한 다른 Application 에러 코드 추가
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/GlobalExceptionHandler.kt =====
package com.restaurant.apps

import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.common.core.exception.DomainException
import com.restaurant.common.core.exception.InfrastructureException
import com.restaurant.common.core.exception.PresentationException
import com.restaurant.shared.outbox.OutboxException
import jakarta.validation.ConstraintViolationException
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ProblemDetail
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.context.request.WebRequest
import java.net.URI
import java.time.Instant
import java.util.UUID

@ControllerAdvice
class GlobalExceptionHandler(
    @Value("\${app.problem.base-url:https://api.restaurant.com/problems}") private val problemBaseUrl: String,
) {
    private val log = LoggerFactory.getLogger(GlobalExceptionHandler::class.java)

    private fun createProblemDetail(
        status: HttpStatus,
        code: String,
        title: String,
        detail: String?,
        request: WebRequest,
    ): ProblemDetail {
        val correlationId = request.getHeader("X-Correlation-Id") ?: UUID.randomUUID().toString()
        return ProblemDetail.forStatus(status).apply {
            type = URI.create("$problemBaseUrl/${code.lowercase()}")
            this.title = title
            this.detail = detail ?: "오류가 발생했습니다."
            setProperty("errorCode", code)
            setProperty("timestamp", Instant.now().toString())
            setProperty("correlationId", correlationId)
        }
    }

    private fun getCorrelationId(request: WebRequest): String = request.getHeader("X-Correlation-Id") ?: "N/A"

    @ExceptionHandler(DomainException::class)
    fun handleDomainException(
        ex: DomainException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val status = ex.errorCode.status
        val code = ex.errorCode.code
        val title = ex.errorCode.code

        log.warn(
            "Domain Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ApplicationException::class)
    fun handleApplicationException(
        ex: ApplicationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val status = ex.errorCode.status
        val code = ex.errorCode.code
        val title = ex.errorCode.code

        log.error(
            "Application Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, ex.message, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(InfrastructureException::class)
    fun handleInfrastructureException(
        ex: InfrastructureException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "INFRASTRUCTURE_ERROR"
        val title = "Infrastructure Error"
        val detail = ex.message ?: "인프라스트럭처 처리 중 오류가 발생했습니다."

        log.error(
            "Infrastructure Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(PresentationException::class)
    fun handlePresentationException(
        ex: PresentationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "PRESENTATION_ERROR"
        val title = "Presentation Error"
        val detail = ex.message ?: "프레젠테이션 처리 중 오류가 발생했습니다."

        log.warn(
            "Presentation Exception Handled: correlationId={}, code={}, status={}, message={}",
            correlationId,
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(
        ex: MethodArgumentNotValidException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.bindingResult.fieldErrors.map {
                mapOf("field" to it.field, "reason" to (it.defaultMessage ?: "유효하지 않은 값입니다."))
            }
        log.warn(
            "Validation Exception Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams.toString(),
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(ConstraintViolationException::class)
    fun handleConstraintViolationException(
        ex: ConstraintViolationException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "VALIDATION_ERROR"
        val title = "Validation Error"
        val detail = "입력 데이터가 유효하지 않습니다."

        val invalidParams =
            ex.constraintViolations.map {
                mapOf("field" to it.propertyPath.toString(), "reason" to it.message)
            }
        log.warn(
            "Constraint Violation Handled: correlationId={}, invalidParams={}\n{}",
            correlationId,
            invalidParams,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        problem.setProperty("invalid-params", invalidParams)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(HttpMessageNotReadableException::class)
    fun handleMessageNotReadableException(
        ex: HttpMessageNotReadableException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.BAD_REQUEST
        val code = "MESSAGE_NOT_READABLE"
        val title = "Invalid Request Body"
        val detail = "요청 본문의 형식이 잘못되었거나 읽을 수 없습니다."
        log.warn(
            "Message Not Readable Exception Handled: correlationId={}, error={}",
            correlationId,
            ex.message,
        )

        val problem = createProblemDetail(status, code, title, detail, request)

        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(Exception::class)
    fun handleGenericException(
        ex: Exception,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val correlationId = getCorrelationId(request)
        val status = HttpStatus.INTERNAL_SERVER_ERROR
        val code = "SYSTEM_ERROR"
        val title = "Internal Server Error"
        val detail = "서버에서 예상치 못한 오류가 발생했습니다."
        log.error(
            "Unhandled Exception: correlationId={}, error={}",
            correlationId,
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }

    @ExceptionHandler(OutboxException::class)
    fun handleOutboxException(
        ex: OutboxException,
        request: WebRequest,
    ): ResponseEntity<ProblemDetail> {
        val status = HttpStatus.valueOf(ex.errorCode.status)
        val code = ex.errorCode.code
        val title = ex.errorCode.message
        val detail = ex.message

        log.error(
            "Outbox Exception Handled: correlationId={}, code={}, status={}, message={}",
            getCorrelationId(request),
            code,
            status.value(),
            ex.message,
            ex,
        )

        val problem = createProblemDetail(status, code, title, detail, request)
        return ResponseEntity.status(status).body(problem)
    }
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/UserApplication.kt =====
package com.restaurant.apps.user

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.autoconfigure.domain.EntityScan
import org.springframework.boot.runApplication
import org.springframework.context.annotation.ComponentScan
import org.springframework.data.jpa.repository.config.EnableJpaRepositories

@SpringBootApplication
@ComponentScan(
    basePackages = [
        "com.restaurant.apps.user",
        "com.restaurant.presentation.user",
        "com.restaurant.application.user",
        "com.restaurant.infrastructure.user",
        "com.restaurant.common",
        "com.restaurant.shared.outbox",
    ],
)
@EntityScan(
    basePackages = [
        "com.restaurant.infrastructure.user.entity",
        "com.restaurant.shared.outbox.infrastructure.entity",
    ],
)
@EnableJpaRepositories(
    basePackages = [
        "com.restaurant.infrastructure.user.repository",
        "com.restaurant.shared.outbox.infrastructure.persistence",
    ],
)
class UserApplication

fun main(args: Array<String>) {
    runApplication<UserApplication>(*args)
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SwaggerConfig.kt =====
package com.restaurant.apps.user.config

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import org.springdoc.core.models.GroupedOpenApi
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfig {
    @Bean
    fun publicApi(): GroupedOpenApi =
        GroupedOpenApi
            .builder()
            .group("user-api-v1")
            .pathsToMatch("/api/v1/users/**")
            .build()

    @Bean
    fun springOpenAPI(): OpenAPI =
        OpenAPI()
            .info(
                Info()
                    .title("User Service API")
                    .description("User Service API Documentation")
                    .version("v1"),
            )
}

// ===== domains/user/apps/src/main/kotlin/com/restaurant/apps/user/config/SecurityConfig.kt =====
package com.restaurant.apps.user.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
class SecurityConfig {
    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()

    @Bean
    fun filterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() } // 개발 편의상 CSRF 비활성화 (실제 환경에서는 필요에 따라 설정)
            .authorizeHttpRequests { authz ->
                authz.anyRequest().permitAll() // 개발 편의상 모든 요청 허용 (실제 환경에서는 인증/인가 필요)
            }
        return http.build()
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/domain/event/DomainEvent.kt =====
package com.restaurant.common.domain.event

import java.time.LocalDateTime

/**
 * 모든 도메인 이벤트가 구현해야 하는 공통 인터페이스.
 */
interface DomainEvent {
    /**
     * 이벤트가 발생한 Aggregate의 루트 엔티티 ID (UUID의 문자열 표현).
     */
    val aggregateId: String

    /**
     * 이벤트가 발생한 Aggregate의 타입 이름.
     */
    val aggregateType: String // 예: "User", "Order"

    /**
     * 이벤트 발생 시각.
     */
    val occurredAt: LocalDateTime

    /**
     * 이벤트 고유 ID.
     */
    val eventId: String
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/domain/aggregate/AggregateRoot.kt =====
package com.restaurant.common.domain.aggregate

import com.restaurant.common.domain.event.DomainEvent

abstract class AggregateRoot {
    private val domainEvents: MutableList<DomainEvent> = mutableListOf()

    protected fun addDomainEvent(event: DomainEvent) {
        domainEvents.add(event)
    }

    fun getDomainEvents(): List<DomainEvent> = domainEvents.toList()

    fun clearDomainEvents() {
        domainEvents.clear()
    }
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/NotFoundErrorResponse.kt =====
package com.restaurant.common.presentation.dto.response

data class NotFoundErrorResponse(
    val code: String = "NOT_FOUND",
    val message: String = "요청하신 리소스를 찾을 수 없습니다.",
    val detail: String? = null,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/ValidationErrorResponse.kt =====
package com.restaurant.common.presentation.dto.response

import org.springframework.hateoas.RepresentationModel

data class ValidationErrorResponse(
    val type: String,
    val title: String,
    val detail: String,
    val errorCode: String,
    val timestamp: String,
    val correlationId: String?,
    val invalidParams: List<InvalidParam>,
) : RepresentationModel<ValidationErrorResponse>() {
    data class InvalidParam(
        val field: String,
        val reason: String,
    )
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/BusinessErrorResponse.kt =====
package com.restaurant.common.presentation.dto.response

data class BusinessErrorResponse(
    val code: String,
    val message: String,
    val detail: String? = null,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/CommandResultResponse.kt =====
package com.restaurant.common.presentation.dto.response

import io.swagger.v3.oas.annotations.media.Schema
import org.springframework.hateoas.RepresentationModel

@Schema(description = "커맨드 실행 결과 응답")
data class CommandResultResponse(
    @field:Schema(description = "처리 상태", example = "SUCCESS", required = true)
    val status: String,
    @field:Schema(description = "결과 메시지", example = "처리가 성공적으로 완료되었습니다.", required = true)
    val message: String,
    @field:Schema(description = "상관 관계 ID", example = "123e4567-e89b-12d3-a456-426614174000", required = true)
    val correlationId: String,
) : RepresentationModel<CommandResultResponse>()

// ===== domains/common/src/main/kotlin/com/restaurant/common/presentation/dto/response/InternalServerErrorResponse.kt =====
package com.restaurant.common.presentation.dto.response

data class InternalServerErrorResponse(
    val code: String = "INTERNAL_SERVER_ERROR",
    val message: String = "서버 내부 오류가 발생했습니다.",
    val detail: String? = null,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/infrastructure/mapper/EntityMapper.kt =====
package com.restaurant.common.infrastructure.mapper

interface EntityMapper<D, E> {
    fun toEntity(domain: D): E

    fun toDomain(entity: E): D
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/query/QueryResult.kt =====
package com.restaurant.common.core.query

data class QueryResult<T>(
    val success: Boolean,
    val data: T? = null,
    val errorCode: String? = null,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/query/dto/CursorPageDto.kt =====
package com.restaurant.common.core.query.dto

/**
 * 커서 기반 페이징 결과 DTO
 *
 * @property items 조회된 아이템 목록
 * @property nextCursor 다음 페이지 요청 시 사용할 커서 (null이면 마지막 페이지)
 * @property hasNext 다음 페이지 존재 여부
 */
data class CursorPageDto<T>(
    val items: List<T>,
    val nextCursor: String?,
    val hasNext: Boolean,
)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/DomainException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 도메인 비즈니스 규칙 위반 시 발생하는 기본 예외 클래스.
 */
abstract class DomainException(
    message: String,
) : RuntimeException(message) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/InfrastructureException.kt =====
package com.restaurant.common.core.exception

open class InfrastructureException(
    message: String,
) : RuntimeException(message)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/ApplicationException.kt =====
package com.restaurant.common.core.exception

import com.restaurant.common.core.error.ErrorCode

/**
 * 애플리케이션 레이어에서 발생하는 기술적 또는 외부 요인 관련 예외의 기본 클래스.
 */
abstract class ApplicationException(
    message: String,
    cause: Throwable? = null, // 원인 예외를 포함할 수 있도록 cause 추가
) : RuntimeException(message, cause) {
    /**
     * 이 예외에 해당하는 구체적인 에러 코드.
     * 각 하위 예외 클래스에서 구현해야 함 (Rule 68).
     */
    abstract val errorCode: ErrorCode
}

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/exception/PresentationException.kt =====
package com.restaurant.common.core.exception

open class PresentationException(
    message: String,
) : RuntimeException(message)

// ===== domains/common/src/main/kotlin/com/restaurant/common/core/error/ErrorCode.kt =====
package com.restaurant.common.core.error

interface ErrorCode {
    val code: String
    val message: String
    val status: Int
}

abstract class BaseErrorCode(
    override val code: String,
    override val message: String,
    override val status: Int,
) : ErrorCode {
    companion object {
        fun fromCode(
            errorCodes: List<ErrorCode>,
            code: String?,
        ): ErrorCode? = errorCodes.find { it.code == code }
    }
}

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/kafka/SpringKafkaEventPublisherAdapter.kt =====
package com.restaurant.shared.outbox.infrastructure.kafka

// Removed ObjectMapper import
// Removed KafkaEventMessageDto import
import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto
import com.restaurant.shared.outbox.application.exception.OutboxKafkaSendException
import com.restaurant.shared.outbox.application.port.KafkaEventPublisherPort
import org.apache.kafka.clients.producer.ProducerRecord
import org.apache.kafka.common.header.internals.RecordHeader
import org.slf4j.LoggerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Component

@Component
class SpringKafkaEventPublisherAdapter(
    private val kafkaTemplate: KafkaTemplate<String, ByteArray>, // Changed value type to ByteArray
    // Removed objectMapper
) : KafkaEventPublisherPort {
    private val logger = LoggerFactory.getLogger(SpringKafkaEventPublisherAdapter::class.java)

    override fun publish(event: OutboxEventPollingDto) {
        try {
            // Directly use OutboxEventPollingDto fields (Rule 88)
            val topic = event.targetTopic // Use targetTopic from DTO
            val key = event.aggregateId ?: event.eventId.toString() // Use aggregateId or eventId as key
            val payload = event.payload // Use ByteArray payload directly
            val headers = mapOf( // Construct headers (Rule 81, 83)
                "correlationId" to event.eventId.toString(),
                "aggregateId" to (event.aggregateId ?: ""),
                "aggregateType" to (event.aggregateType ?: "")
            ).map { RecordHeader(it.key, it.value.toByteArray()) }

            val record = ProducerRecord<String, ByteArray>( // Changed value type to ByteArray
                topic,
                null, // Partition (optional)
                key,
                payload,
                headers
            )

            // Consider async send with callback for better performance and error handling
            kafkaTemplate.send(record).get() // .get() makes it synchronous, potentially blocking

            logger.info("Kafka 메시지 발행 성공: topic={}, key={}", topic, key)
        } catch (ex: Exception) {
            // Log the original exception
            logger.error("Kafka 메시지 발행 실패 for eventId {}: {}", event.eventId, ex.message, ex)
            // Throw specific application exception
            throw OutboxKafkaSendException("Kafka 메시지 발행 실패 for eventId ${event.eventId}", ex)
        }
    }

    // Removed toKafkaEventMessageDto and determineTopic methods
}

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/entity/OutboxEventEntity.kt =====
package com.restaurant.shared.outbox.infrastructure.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Lob
import jakarta.persistence.Table
import jakarta.persistence.Version
import java.time.LocalDateTime
import java.util.UUID

@Entity
@Table(name = "outbox_events") // Rule 22 variant for outbox
class OutboxEventEntity(
    // JPA PK
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    // Outbox event unique ID
    @Column(nullable = false, updatable = false)
    val eventId: UUID,
    // Aggregate type
    @Column(nullable = false, updatable = false)
    val aggregateType: String,
    // Aggregate ID
    @Column(nullable = false, updatable = false)
    val aggregateId: String,
    // Event type
    @Column(nullable = false, updatable = false)
    val eventType: String,
    // Payload (large) - Changed to ByteArray (Rule 81)
    @Lob
    @Column(nullable = false, updatable = false) // Rely on JPA default for byte array or use columnDefinition = "BLOB" if needed
    val payload: ByteArray,
    // Target Topic (Rule 81)
    @Column(nullable = false, updatable = false)
    val targetTopic: String,
    // Status (변경됨)
    @Column(nullable = false)
    var status: String,
    // 발생 시각
    @Column(nullable = false, updatable = false)
    val occurredAt: LocalDateTime,
    // 처리 시각 (변경됨)
    @Column(nullable = true)
    var processedAt: LocalDateTime? = null,
    // 재시도 횟수 (변경됨)
    @Column(nullable = false)
    var retryCount: Int = 0,
    // 마지막 시도 시각 (변경됨)
    @Column(nullable = true)
    var lastAttemptTime: LocalDateTime? = null,
    // 에러 메시지 (변경됨)
    @Lob
    @Column(nullable = true, columnDefinition = "TEXT")
    var errorMessage: String? = null,
    // 버전
    @Version
    @Column(nullable = false)
    val version: Long = 0,
) { // Added equals/hashCode for ByteArray comparison
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventEntity

        if (id != other.id) return false
        if (eventId != other.eventId) return false
        // Compare other fields...
        if (!payload.contentEquals(other.payload)) return false // ByteArray comparison

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + eventId.hashCode()
        // Include other fields...
        result = 31 * result + payload.contentHashCode() // ByteArray hash code
        return result
    }
    // Companion object for constants if needed (e.g., status strings)
    companion object {
        const val STATUS_PENDING = "PENDING"
        const val STATUS_PROCESSING = "PROCESSING"
        const val STATUS_SENT = "SENT"
        const val STATUS_FAILED = "FAILED"
    }
}

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/persistence/SpringDataJpaOutboxEventRepository.kt =====
package com.restaurant.shared.outbox.infrastructure.persistence

import com.restaurant.shared.outbox.infrastructure.entity.OutboxEventEntity
import jakarta.persistence.LockModeType
import jakarta.persistence.QueryHint
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Lock
import org.springframework.data.jpa.repository.Query
import org.springframework.data.jpa.repository.QueryHints
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

/**
 * Spring Data JPA repository for OutboxEventEntity.
 * This is internal to the outbox infrastructure layer.
 */
@Repository
interface SpringDataJpaOutboxEventRepository : JpaRepository<OutboxEventEntity, Long> {
    /**
     * Finds pending or failed outbox events with pessimistic locking to prevent concurrent processing.
     * Uses SKIP LOCKED hint suitable for databases like PostgreSQL and MySQL 8+.
     *
     * @param statuses List of statuses to fetch (e.g., PENDING, FAILED).
     * @param pageable Pageable object to limit the number of fetched events per poll.
     * @return List of locked OutboxEventEntity objects.
     */
    @Lock(LockModeType.PESSIMISTIC_WRITE) // Request a pessimistic write lock
    @QueryHints(
        value = [
            // Specific hint for SKIP LOCKED depends on the database.
            // For PostgreSQL/Oracle:
            QueryHint(name = "jakarta.persistence.lock.timeout", value = "0"), // Equivalent to NOWAIT or SKIP LOCKED behavior
            // For MySQL 8+:
            // QueryHint(name = "jakarta.persistence.lock.scope", value = "EXTENDED"), // May be needed for SKIP LOCKED
            // QueryHint(name = "org.hibernate.lockMode.alias", value = "SKIP_LOCKED") // Check Hibernate documentation for exact syntax
        ],
    )
    @Query("SELECT o FROM OutboxEventEntity o WHERE o.status IN :statuses ORDER BY o.occurredAt ASC")
    fun findByStatusInWithLock(
        @Param("statuses") statuses: List<String>,
        pageable: Pageable,
    ): List<OutboxEventEntity>
}

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/persistence/JpaOutboxEventPollingAdapter.kt =====
package com.restaurant.shared.outbox.infrastructure.persistence

import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto
import com.restaurant.shared.outbox.application.port.OutboxEventPollingPort
import com.restaurant.shared.outbox.infrastructure.persistence.extensions.toPollingDto
import org.springframework.data.domain.Pageable
import org.springframework.stereotype.Component
import java.time.LocalDateTime

@Component
class JpaOutboxEventPollingAdapter(
    private val jpaRepository: SpringDataJpaOutboxEventRepository,
) : OutboxEventPollingPort {
    override fun findEventsForProcessing(
        statuses: List<String>,
        pageable: Pageable,
    ): List<OutboxEventPollingDto> = jpaRepository.findByStatusInWithLock(statuses, pageable).map { it.toPollingDto() }

    override fun updateEventStatus(
        eventId: Long,
        status: String,
        processedAt: LocalDateTime?,
        errorMessage: String?,
        retryCount: Int?,
        lastAttemptTime: LocalDateTime?,
    ): OutboxEventPollingDto? {
        val entity = jpaRepository.findById(eventId).orElse(null) ?: return null
        entity.status = status
        processedAt?.let { entity.processedAt = it }
        errorMessage?.let { entity.errorMessage = it }
        retryCount?.let { entity.retryCount = it }
        lastAttemptTime?.let { entity.lastAttemptTime = it }
        return jpaRepository.save(entity).toPollingDto()
    }
}

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/persistence/extensions/OutboxEventEntityExtensions.kt =====
package com.restaurant.shared.outbox.infrastructure.persistence.extensions

import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto
import com.restaurant.shared.outbox.application.dto.OutboxMessageHeaders
import com.restaurant.shared.outbox.application.port.model.OutboxMessage
import com.restaurant.shared.outbox.infrastructure.entity.OutboxEventEntity
import java.time.LocalDateTime
import java.util.UUID

fun OutboxEventEntity.toPollingDto(): OutboxEventPollingDto =
    OutboxEventPollingDto(
        id = this.id,
        eventId = this.eventId,
        aggregateType = this.aggregateType,
        aggregateId = this.aggregateId,
        eventType = this.eventType,
        payload = this.payload,
        status = this.status,
        retryCount = this.retryCount,
        targetTopic = this.targetTopic,
        headers = OutboxMessageHeaders(
            aggregateId = this.aggregateId,
            aggregateType = this.aggregateType,
            correlationId = this.eventId.toString(),
            traceId = null, // or get from context if available
            eventType = this.eventType
        ),
    )

fun OutboxMessage.toEntity(): OutboxEventEntity = OutboxEventEntity(
    eventId = UUID.fromString(this.eventId),
    aggregateType = this.aggregateType,
    aggregateId = this.aggregateId,
    eventType = this.eventType,
    payload = this.payload,
    targetTopic = this.targetTopic,
    status = OutboxEventEntity.STATUS_PENDING,
    occurredAt = LocalDateTime.now(),
)

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/persistence/JpaOutboxMessageRepository.kt =====
package com.restaurant.shared.outbox.infrastructure.persistence

// Removed ObjectMapper and related imports
// Removed DomainEvent import
// Removed OutboxEventRepository import
// Removed serialization/deserialization exception imports
import com.restaurant.shared.outbox.application.port.OutboxMessageRepository // New import
import com.restaurant.shared.outbox.application.port.model.OutboxMessage // New import
import com.restaurant.shared.outbox.infrastructure.entity.OutboxEventEntity
// Removed LoggerFactory import (no longer used)
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional

/**
 * JPA implementation of the OutboxMessageRepository port. (Rule 82)
 * Responsible for saving OutboxMessage objects as OutboxEventEntity into the database.
 */
@Component
class JpaOutboxMessageRepository( // Renamed class
    private val jpaRepository: SpringDataJpaOutboxEventRepository,
    // Removed ObjectMapper dependency
) : OutboxMessageRepository { // Changed interface

    @Transactional
    override fun save(messages: List<OutboxMessage>) { // Changed signature
        if (messages.isEmpty()) return

        val outboxEntities = messages.map { message ->
            OutboxEventEntity(
                eventId = message.eventId,
                aggregateType = message.aggregateType,
                aggregateId = message.aggregateId,
                eventType = message.targetTopic, // Using targetTopic as eventType for now, adjust if needed
                payload = message.payload, // Directly use ByteArray
                targetTopic = message.targetTopic, // Added targetTopic
                status = OutboxEventEntity.STATUS_PENDING,
                occurredAt = java.time.LocalDateTime.now(), // Set occurredAt on save
                // Other fields (processedAt, retryCount etc.) are null/default initially
            )
        }
        jpaRepository.saveAll(outboxEntities)
    }

    // Removed createOutboxEntity, serializePayload, deserializePayload, resolveEventClass methods
    // Removed companion object and logger
}

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/exception/OutboxInfrastructureExceptions.kt =====
package com.restaurant.shared.outbox.infrastructure.exception

// Removed: import com.restaurant.common.core.exception.InfrastructureException
import com.restaurant.shared.outbox.OutboxErrorCode // New import
import com.restaurant.shared.outbox.OutboxException // New import
import com.restaurant.shared.outbox.infrastructure.error.OutboxInfrastructureErrorCode // New import

/**
 * Base exception for Outbox infrastructure layer errors.
 */
open class OutboxInfrastructureException(
    override val errorCode: OutboxErrorCode, // Added errorCode
    message: String,
    cause: Throwable? = null
) : OutboxException(message, errorCode, cause) // Changed inheritance

class OutboxDatabaseException(
    message: String,
    cause: Throwable? = null
) : OutboxInfrastructureException(
    OutboxInfrastructureErrorCode.DATABASE_OPERATION_FAILED,
    message,
    cause
)

class OutboxSerializationException(
    message: String,
    cause: Throwable? = null,
) : OutboxInfrastructureException(
    OutboxInfrastructureErrorCode.SERIALIZATION_FAILED,
    message,
    cause
)

class OutboxDeserializationException(
    message: String,
    cause: Throwable? = null,
) : OutboxInfrastructureException(
    OutboxInfrastructureErrorCode.DESERIALIZATION_FAILED,
    message,
    cause
)

// ===== shared/outbox/infrastructure/src/main/kotlin/com/restaurant/shared/outbox/infrastructure/error/OutboxInfrastructureErrorCode.kt =====
package com.restaurant.shared.outbox.infrastructure.error

// Removed: import com.restaurant.common.core.error.ErrorCode
// Removed: import org.springframework.http.HttpStatus
import com.restaurant.shared.outbox.OutboxErrorCode // New import

/**
 * Error codes specific to the Outbox module's infrastructure layer.
 */
enum class OutboxInfrastructureErrorCode( // Rule 67
    override val code: String,
    override val message: String,
    override val status: Int, // Added status implementation
) : OutboxErrorCode {
    DATABASE_OPERATION_FAILED(
        "OUTBOX-INFRA-001",
        "Failed to perform database operation on outbox event.",
        500 // Default to Internal Server Error
    ),
    SERIALIZATION_FAILED(
        "OUTBOX-INFRA-002",
        "Failed to serialize outbox event payload.",
        500 // Default to Internal Server Error
    ),
    DESERIALIZATION_FAILED(
        "OUTBOX-INFRA-003",
        "Failed to deserialize outbox event payload.",
        500 // Default to Internal Server Error
    ),
    // Add more specific infrastructure errors if needed
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/OutboxErrorCode.kt =====
package com.restaurant.shared.outbox

/**
 * Base interface for error codes specific to the Outbox module.
 */
interface OutboxErrorCode {
    val code: String
    val message: String
    val status: Int // Added HTTP status code (Rule 73 adaptation)
}
// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/OutboxException.kt =====
package com.restaurant.shared.outbox

import com.restaurant.shared.outbox.OutboxErrorCode

/**
 * Base exception for all exceptions originating from the Outbox module.
 */
abstract class OutboxException(
    override val message: String,
    open val errorCode: OutboxErrorCode,
    cause: Throwable? = null // Removed 'override'
) : RuntimeException(message, cause)
// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/port/OutboxEventPollingPort.kt =====
package com.restaurant.shared.outbox.application.port

import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto
import org.springframework.data.domain.Pageable
import java.time.LocalDateTime

interface OutboxEventPollingPort {
    fun findEventsForProcessing(
        statuses: List<String>,
        pageable: Pageable,
    ): List<OutboxEventPollingDto>

    fun updateEventStatus(
        eventId: Long,
        status: String,
        processedAt: LocalDateTime? = null,
        errorMessage: String? = null,
        retryCount: Int? = null,
        lastAttemptTime: LocalDateTime? = null,
    ): OutboxEventPollingDto?
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/port/KafkaEventPublisherPort.kt =====
package com.restaurant.shared.outbox.application.port

import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto

/**
 * Kafka 메시지 발행을 위한 Application 레이어 Port.
 * Infrastructure Adapter에서 구현.
 */
interface KafkaEventPublisherPort {
    /**
     * Outbox 이벤트를 Kafka로 발행한다.
     * @param event Outbox에서 폴링된 이벤트 DTO
     * @throws com.restaurant.shared.outbox.application.exception.OutboxKafkaSendException 발행 실패 시
     */
    fun publish(event: OutboxEventPollingDto)
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/port/model/OutboxMessage.kt =====
package com.restaurant.shared.outbox.application.port.model

import java.util.UUID

/**
 * Represents a message to be stored in the outbox before being published.
 * This structure is defined by Rule 81.
 *
 * @property eventId Unique identifier for the event (correlation ID).
 * @property aggregateType The type of the aggregate root that originated the event (e.g., "User", "Order").
 * @property aggregateId The unique identifier of the aggregate root instance (as String).
 * @property targetTopic The target Kafka topic name for this message.
 * @property payload The serialized event payload as raw bytes.
 * @property headers Optional headers to be included in the Kafka message.
 */
data class OutboxMessage(
    val eventId: UUID = UUID.randomUUID(),
    val aggregateType: String,
    val aggregateId: String,
    val targetTopic: String,
    val payload: ByteArray, // Rule 81: Payload as ByteArray
    val headers: Map<String, String> = emptyMap()
) {
    // equals and hashCode need to be overridden for ByteArray comparison
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxMessage

        if (eventId != other.eventId) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (targetTopic != other.targetTopic) return false
        if (!payload.contentEquals(other.payload)) return false
        if (headers != other.headers) return false

        return true
    }

    override fun hashCode(): Int {
        var result = eventId.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + targetTopic.hashCode()
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + headers.hashCode()
        return result
    }
}
// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/port/OutboxMessageRepository.kt =====
package com.restaurant.shared.outbox.application.port

// Removed: import com.restaurant.common.domain.event.DomainEvent
import com.restaurant.shared.outbox.application.port.model.OutboxMessage // New import

/**
 * Port interface for saving OutboxMessages. (Rule 81)
 * This interface is technology-agnostic and resides in the application layer.
 * Domain infrastructure layers will depend on this port to save messages transactionally.
 */
interface OutboxMessageRepository { // Renamed interface
    /**
     * Saves a list of OutboxMessage objects.
     * Implementations should ensure this operation is atomic, typically
     * within the same transaction as the domain aggregate changes.
     *
     * @param messages The list of OutboxMessage objects to save.
     */
    fun save(messages: List<OutboxMessage>) // Changed signature

    // Removed overloaded save method for single DomainEvent
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/dto/OutboxEventPollingDto.kt =====
package com.restaurant.shared.outbox.application.dto

import java.util.UUID

/**
 * Outbox polling용 DTO (infra entity 직접 참조 금지)
 */
data class OutboxEventPollingDto(
    val id: Long?,
    val eventId: UUID,
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String, // Note: This might represent the target topic now
    val targetTopic: String, // Added targetTopic
    val payload: ByteArray, // Changed to ByteArray
    val status: String,
    val retryCount: Int,
) {
    // equals and hashCode need to be overridden for ByteArray comparison
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as OutboxEventPollingDto

        if (id != other.id) return false
        if (eventId != other.eventId) return false
        if (aggregateType != other.aggregateType) return false
        if (aggregateId != other.aggregateId) return false
        if (eventType != other.eventType) return false
        if (targetTopic != other.targetTopic) return false // Added check
        if (!payload.contentEquals(other.payload)) return false
        if (status != other.status) return false
        if (retryCount != other.retryCount) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id?.hashCode() ?: 0
        result = 31 * result + eventId.hashCode()
        result = 31 * result + aggregateType.hashCode()
        result = 31 * result + aggregateId.hashCode()
        result = 31 * result + eventType.hashCode()
        result = 31 * result + targetTopic.hashCode() // Added field
        result = 31 * result + payload.contentHashCode()
        result = 31 * result + status.hashCode()
        result = 31 * result + retryCount
        return result
    }
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/dto/KafkaEventMessageDto.kt =====
package com.restaurant.shared.outbox.application.dto

/**
 * Kafka 메시지 전송에 필요한 정보를 담는 DTO.
 */
data class KafkaEventMessageDto(
    val topic: String,
    val key: String,
    val payloadJson: String,
    val headers: Map<String, String> = emptyMap(),
)

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/exception/OutboxApplicationExceptions.kt =====
package com.restaurant.shared.outbox.application.exception

// Removed: import com.restaurant.common.core.error.ErrorCode
// Removed: import com.restaurant.common.core.exception.ApplicationException
import com.restaurant.shared.outbox.OutboxErrorCode // New import
import com.restaurant.shared.outbox.OutboxException // New import
import com.restaurant.shared.outbox.application.error.OutboxApplicationErrorCode

open class OutboxApplicationException(
    override val errorCode: OutboxErrorCode, // Changed type
    message: String,
    cause: Throwable? = null
) : OutboxException(message, errorCode, cause) // Changed inheritance and added cause

class OutboxKafkaSendException(
    message: String,
    cause: Throwable? = null
) : OutboxApplicationException(OutboxApplicationErrorCode.KAFKA_SEND_FAILED, message, cause)

class OutboxEventProcessingException(
    message: String,
    cause: Throwable? = null
) : OutboxApplicationException(OutboxApplicationErrorCode.EVENT_PROCESSING_FAILED, message, cause)

class OutboxMaxRetriesReached(
    message: String,
    cause: Throwable? = null
) : OutboxApplicationException(OutboxApplicationErrorCode.MAX_RETRIES_REACHED, message, cause)

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/OutboxPoller.kt =====
package com.restaurant.shared.outbox.application

import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto
import com.restaurant.shared.outbox.application.port.OutboxEventPollingPort
import com.restaurant.shared.outbox.application.OutboxMessageSender
import org.slf4j.LoggerFactory
import org.springframework.data.domain.PageRequest
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component

@Component
class OutboxPoller(
    private val outboxPollingPort: OutboxEventPollingPort,
    private val eventSender: OutboxMessageSender,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    @Scheduled(fixedDelay = 60000)
    fun pollAndSendEvents() {
        try {
            val statuses = listOf("PENDING", "FAILED")
            val events: List<OutboxEventPollingDto> = outboxPollingPort.findEventsForProcessing(statuses, PageRequest.of(0, 100))
            if (events.isNotEmpty()) {
                log.info("폴링된 Outbox 이벤트 ${events.size}건 처리 시작")
                eventSender.processEvents(events)
            }
        } catch (e: Exception) {
            log.error("Outbox 이벤트 폴링 중 오류 발생: ${e.message}", e)
        }
    }
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/OutboxMessageSender.kt =====
package com.restaurant.shared.outbox.application

import com.restaurant.shared.outbox.application.dto.OutboxEventPollingDto
import com.restaurant.shared.outbox.application.exception.OutboxEventProcessingException
import com.restaurant.shared.outbox.application.exception.OutboxKafkaSendException
import com.restaurant.shared.outbox.application.port.OutboxEventPollingPort
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Propagation
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDateTime

/**
 * Processes outbox events by sending them to Kafka.
 * Handles deserialization, transformation to Avro, Kafka publishing, and status updates.
 */
@Service
class OutboxMessageSender( // Renamed class
    private val outboxPollingPort: OutboxEventPollingPort,
    private val kafkaEventPublisherPort: com.restaurant.shared.outbox.application.port.KafkaEventPublisherPort,
    @Value("\${spring.kafka.properties.app.environment:dev}") private val environment: String, // This might be removable if not used
) {
    private val log = LoggerFactory.getLogger(OutboxMessageSender::class.java) // Updated logger class

    fun processEvents(events: List<OutboxEventPollingDto>) {
        events.forEach { event: OutboxEventPollingDto ->
            try {
                processSingleEvent(event)
            } catch (e: Exception) {
                log.error("Failed to process outbox event ID: \\${event.id}. Error: \\${e.message}", e)
                handleProcessingFailure(event, e)
            }
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    fun processSingleEvent(event: OutboxEventPollingDto) {
        log.info("Processing outbox event ID: ${event.id}, Type: ${event.eventType}")
        try {
            kafkaEventPublisherPort.publish(event)
            markEventAsSent(event)
            log.info("Successfully sent outbox event ID: ${event.id} to Kafka")
        } catch (e: OutboxKafkaSendException) {
            log.error("Kafka send failed for event ID: ${event.id}. Error: ${e.message}", e)
            handleProcessingFailure(event, e)
            throw e
        } catch (e: OutboxEventProcessingException) {
            log.error("Processing failed for event ID: ${event.id}. Error: ${e.message}", e)
            handleProcessingFailure(event, e)
            throw e
        } catch (e: Exception) {
            log.error("Unexpected error processing event ID: ${event.id}. Error: ${e.message}", e)
            handleProcessingFailure(event, e)
            throw e
        }
    }

    // determineTopic은 Adapter로 이동

    private fun markEventAsSent(event: OutboxEventPollingDto) {
        outboxPollingPort.updateEventStatus(
            eventId = event.id ?: return,
            status = "SENT",
            processedAt = LocalDateTime.now(),
            errorMessage = null,
        )
    }

    private fun handleProcessingFailure(
        event: OutboxEventPollingDto,
        exception: Exception,
    ) {
        outboxPollingPort.updateEventStatus(
            eventId = event.id ?: return,
            status = "FAILED",
            errorMessage = exception.message?.take(1024),
            retryCount = event.retryCount + 1,
            lastAttemptTime = LocalDateTime.now(),
        )
    }
}

// ===== shared/outbox/application/src/main/kotlin/com/restaurant/shared/outbox/application/error/OutboxApplicationErrorCode.kt =====
package com.restaurant.shared.outbox.application.error

// Removed: import com.restaurant.common.core.error.ErrorCode
// Removed: import org.springframework.http.HttpStatus
import com.restaurant.shared.outbox.OutboxErrorCode // New import

enum class OutboxApplicationErrorCode(
    override val code: String,
    override val message: String,
    override val status: Int, // Added status implementation
) : OutboxErrorCode {
    KAFKA_SEND_FAILED(
        "OUTBOX-APP-001",
        "Failed to send event to Kafka.",
        500 // Default to Internal Server Error
    ),
    EVENT_PROCESSING_FAILED(
        "OUTBOX-APP-002",
        "Generic error during outbox event processing.",
        500 // Default to Internal Server Error
    ),
    MAX_RETRIES_REACHED(
        "OUTBOX-APP-003",
        "Event processing failed after maximum retries.",
        500 // Default to Internal Server Error
    ),
}

// ===== shared/outbox/application/port/OutboxEventRepository.kt =====
package com.restaurant.shared.outbox.application.port

import com.restaurant.common.domain.event.DomainEvent

interface OutboxEventRepository {
    fun save(
        events: List<DomainEvent>,
        aggregateType: String,
        aggregateId: String,
    )
}

// ===== shared/outbox/application/port/model/OutboxMessage.kt =====
package com.restaurant.shared.outbox.application.port.model

data class OutboxMessage(
    val eventId: String, // UUID to String
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String,
    val payload: ByteArray, // Raw bytes
    val targetTopic: String,
    val headers: Map<String, String> = emptyMap(), // Kafka headers
)

// ===== shared/outbox/application/dto/OutboxEventPollingDto.kt =====
package com.restaurant.shared.outbox.application.dto

import java.util.UUID

data class OutboxEventPollingDto(
    val id: Long?,
    val eventId: UUID,
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String,
    val payload: ByteArray,
    val status: String,
    val retryCount: Int,
    val targetTopic: String,
    val headers: OutboxMessageHeaders? = null, // headers를 nullable로 변경
)

// ===== shared/outbox/application/dto/OutboxMessageHeaders.kt =====
package com.restaurant.shared.outbox.application.dto

data class OutboxMessageHeaders (
    val aggregateType: String,
    val aggregateId: String,
    val eventType: String? = null,
    val correlationId: String? = null,
    val causationId: String? = null,
    val traceId: String? = null,
    val userId: String? = null,
    val clientId: String? = null,
    val transactionId: String? = null,
    val spanId: String? = null,
)

// ===== shared/outbox/application/dto/OutboxMessagePayload.kt =====
package com.restaurant.shared.outbox.application.dto

data class OutboxMessagePayload (
    val payload: ByteArray
)

// ===== domains/user/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.
    // Removed: implementation("org.springframework:spring-web") // Removed per Rule 10

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== domains/user/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== domains/user/infrastructure/build.gradle.kts =====
import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask // Added for Avro task config
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile // Added for Avro task config

plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Added Avro plugin (Rule 109)
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common")) // Keep common for now, might need review later
    // implementation(project(":shared:outbox")) // Removed root outbox dependency
    implementation(project(":shared:outbox:application")) // Keep application dependency for OutboxMessageRepository port

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.mapstruct:mapstruct:1.6.3") // Assuming MapStruct is used for entity mapping

    // Avro / Kafka Dependencies (Rule 111)
    implementation("org.apache.avro:avro:1.11.3") // Use consistent versions
    implementation("io.confluent:kafka-avro-serializer:7.5.3")
    implementation("io.confluent:kafka-schema-registry-client:7.5.3")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// Avro Task Configuration (Rule 111)
tasks.withType<KotlinCompile> {
    dependsOn(tasks.withType<GenerateAvroJavaTask>())
    source(tasks.withType<GenerateAvroJavaTask>().map { it.outputs })
}

tasks.withType<GenerateAvroJavaTask> {
    source("src/main/resources/avro") // Point to local Avro schema location
    setOutputDir(file("$buildDir/generated-sources/avro/kotlin")) // Use setOutputDir for Avro plugin compatibility
    isCreateSetters = false
    fieldVisibility = "PRIVATE"
    isCreateOptionalGetters = false
    isGettersReturnOptional = false
    // Add other configurations as needed, e.g., custom converters
}

// Ensure generated sources are added to the Kotlin source set
kotlin.sourceSets.main {
    kotlin.srcDir(layout.buildDirectory.dir("generated-sources/avro/kotlin"))
}

// ===== domains/user/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common"))
    implementation(project(":domains:user:domain"))
    // implementation(project(":domains:user:infrastructure")) // Removed per Rule 9

    // Spring Boot BOM 적용: 버전 제거
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-security")

    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== domains/user/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== domains/common/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    // Spring Boot Starter Web (이미 spring-web을 포함)
    implementation("org.springframework.boot:spring-boot-starter-web")

    // Validation
    implementation("org.springframework.boot:spring-boot-starter-validation")

    // Swagger
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0")

    // Hateoas
    implementation("org.springframework.hateoas:spring-hateoas")
}

// ===== shared/outbox/build.gradle.kts =====
// Removed: import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    kotlin("jvm")
    id("org.springframework.boot")
    id("io.spring.dependency-management") // Version managed by parent
    kotlin("plugin.jpa")
    kotlin("plugin.spring")
    kotlin("kapt")
    // id("org.jlleitschuh.gradle.ktlint")
    // Removed: id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Avro plugin removed (Rule 111)
}

group = "com.restaurant.shared"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
    // Confluent repository for Kafka Avro Serializer etc.
    maven { url = uri("https://packages.confluent.io/maven/") }
}

// Define versions in one place
val avroVersion = "1.11.3"
val kafkaAvroSerializerVersion = "7.5.3" // Check for the latest compatible version
val mapstructVersion = "1.5.5.Final"

dependencies {
    implementation(kotlin("stdlib"))
    implementation(kotlin("reflect"))

    // Project Dependencies
    // implementation(project(":domains:common")) // Removed for Outbox independence (Rule 4)

    // Spring Boot Starters
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.springframework.boot:spring-boot-starter-validation") // Optional, as per instructions

    // Kafka (Avro dependencies removed - Rule 111)
    // Removed: implementation("org.apache.avro:avro:$avroVersion")
    // Removed: implementation("io.confluent:kafka-avro-serializer:$kafkaAvroSerializerVersion")
    // Removed: implementation("io.confluent:kafka-schema-registry-client:$kafkaAvroSerializerVersion")

    // MapStruct (Optional - for DTO mapping, e.g., DomainEvent <-> Avro)
    // implementation("org.mapstruct:mapstruct:$mapstructVersion")
    // kapt("org.mapstruct:mapstruct-processor:$mapstructVersion")

    // Database (Test scope)
    testRuntimeOnly("com.h2database:h2")

    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
    }
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("io.mockk:mockk:1.13.10")
    testImplementation("org.springframework.kafka:spring-kafka-test")
    // Add Kotest dependencies if needed
    // testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    // testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
}

tasks.withType<KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
    // Removed Avro task dependency: dependsOn(tasks.withType<GenerateAvroJavaTask>())
    // Removed Avro generated sources: source(tasks.withType<GenerateAvroJavaTask>().map { it.outputs })
}

// Removed Avro task configuration block (Rule 111)
// tasks.withType<GenerateAvroJavaTask> {
//     isCreateSetters = false
//     fieldVisibility = "PRIVATE"
//     isCreateOptionalGetters = false
//     isGettersReturnOptional = false
// }

tasks.withType<Test> {
    useJUnitPlatform()
}

// Configure Kotlin JPA plugin
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.Embeddable")
    annotation("jakarta.persistence.MappedSuperclass")
}

noArg {
    annotation("jakarta.persistence.Entity")
}

// If using MapStruct, configure kapt
// kapt {
//    correctErrorTypes = true
// }

// ===== shared/outbox/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("kapt")
}

dependencies {
    // implementation(project(":domains:common")) // Removed for Outbox independence (Rule 4)
    implementation(project(":shared:outbox:application"))
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.slf4j:slf4j-api")
    implementation("org.slf4j:slf4j-simple")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("com.fasterxml.jackson.core:jackson-databind")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// ===== shared/outbox/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("kapt")
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

dependencies {
    // implementation(project(":domains:common")) // Removed for Outbox independence (Rule 4)
    // implementation(project(":shared:outbox:infrastructure")) // 순환 의존성 방지 위해 주석 처리

    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310")
    implementation("org.slf4j:slf4j-api")
    implementation("org.slf4j:slf4j-simple")
    implementation("org.springframework.boot:spring-boot-starter-web")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// ===== ./shared/outbox/build.gradle.kts =====
// Removed: import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    kotlin("jvm")
    id("org.springframework.boot")
    id("io.spring.dependency-management") // Version managed by parent
    kotlin("plugin.jpa")
    kotlin("plugin.spring")
    kotlin("kapt")
    // id("org.jlleitschuh.gradle.ktlint")
    // Removed: id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Avro plugin removed (Rule 111)
}

group = "com.restaurant.shared"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
    // Confluent repository for Kafka Avro Serializer etc.
    maven { url = uri("https://packages.confluent.io/maven/") }
}

// Define versions in one place
val avroVersion = "1.11.3"
val kafkaAvroSerializerVersion = "7.5.3" // Check for the latest compatible version
val mapstructVersion = "1.5.5.Final"

dependencies {
    implementation(kotlin("stdlib"))
    implementation(kotlin("reflect"))

    // Project Dependencies
    // implementation(project(":domains:common")) // Removed for Outbox independence (Rule 4)

    // Spring Boot Starters
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.springframework.boot:spring-boot-starter-validation") // Optional, as per instructions

    // Kafka (Avro dependencies removed - Rule 111)
    // Removed: implementation("org.apache.avro:avro:$avroVersion")
    // Removed: implementation("io.confluent:kafka-avro-serializer:$kafkaAvroSerializerVersion")
    // Removed: implementation("io.confluent:kafka-schema-registry-client:$kafkaAvroSerializerVersion")

    // MapStruct (Optional - for DTO mapping, e.g., DomainEvent <-> Avro)
    // implementation("org.mapstruct:mapstruct:$mapstructVersion")
    // kapt("org.mapstruct:mapstruct-processor:$mapstructVersion")

    // Database (Test scope)
    testRuntimeOnly("com.h2database:h2")

    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(group = "org.junit.vintage", module = "junit-vintage-engine")
    }
    testImplementation("org.jetbrains.kotlin:kotlin-test-junit5")
    testImplementation("io.mockk:mockk:1.13.10")
    testImplementation("org.springframework.kafka:spring-kafka-test")
    // Add Kotest dependencies if needed
    // testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    // testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
}

tasks.withType<KotlinCompile> {
    compilerOptions {
        freeCompilerArgs.set(listOf("-Xjsr305=strict"))
        jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
    }
    // Removed Avro task dependency: dependsOn(tasks.withType<GenerateAvroJavaTask>())
    // Removed Avro generated sources: source(tasks.withType<GenerateAvroJavaTask>().map { it.outputs })
}

// Removed Avro task configuration block (Rule 111)
// tasks.withType<GenerateAvroJavaTask> {
//     isCreateSetters = false
//     fieldVisibility = "PRIVATE"
//     isCreateOptionalGetters = false
//     isGettersReturnOptional = false
// }

tasks.withType<Test> {
    useJUnitPlatform()
}

// Configure Kotlin JPA plugin
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.Embeddable")
    annotation("jakarta.persistence.MappedSuperclass")
}

noArg {
    annotation("jakarta.persistence.Entity")
}

// If using MapStruct, configure kapt
// kapt {
//    correctErrorTypes = true
// }

// ===== ./shared/outbox/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("kapt")
}

dependencies {
    // implementation(project(":domains:common")) // Removed for Outbox independence (Rule 4)
    implementation(project(":shared:outbox:application"))
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("org.slf4j:slf4j-api")
    implementation("org.slf4j:slf4j-simple")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("com.fasterxml.jackson.core:jackson-databind")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// ===== ./shared/outbox/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    kotlin("kapt")
    id("org.springframework.boot")
    id("io.spring.dependency-management")
}

dependencies {
    // implementation(project(":domains:common")) // Removed for Outbox independence (Rule 4)
    // implementation(project(":shared:outbox:infrastructure")) // 순환 의존성 방지 위해 주석 처리

    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.kafka:spring-kafka")
    implementation("com.fasterxml.jackson.core:jackson-databind")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310")
    implementation("org.slf4j:slf4j-api")
    implementation("org.slf4j:slf4j-simple")
    implementation("org.springframework.boot:spring-boot-starter-web")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// ===== ./build.gradle.kts =====
plugins {
    kotlin("jvm") version "2.1.20" apply false
    kotlin("plugin.spring") version "2.1.20" apply false
    kotlin("plugin.jpa") version "2.1.20" apply false
    kotlin("plugin.allopen") version "2.1.20" apply false
    kotlin("plugin.noarg") version "2.1.20" apply false
    kotlin("kapt") version "2.1.20" apply false
    id("org.springframework.boot") version "3.3.2" apply false
    id("io.spring.dependency-management") version "1.1.7" apply false
    id("org.jlleitschuh.gradle.ktlint") version "12.2.0" apply false
    java
}

val springBootVersion = "3.3.2"


repositories {
    mavenCentral()
    gradlePluginPortal()
}

allprojects {
    group = "com.restaurant"
    version = "1.0.0"

    repositories {
        mavenCentral()
        gradlePluginPortal()
    }
}



subprojects {
    apply(plugin = "org.jetbrains.kotlin.jvm")
    apply(plugin = "org.jetbrains.kotlin.plugin.spring")
    apply(plugin = "org.jetbrains.kotlin.plugin.jpa")
    apply(plugin = "org.springframework.boot")
    apply(plugin = "io.spring.dependency-management")
    apply(plugin = "java")
    apply(plugin = "org.jlleitschuh.gradle.ktlint")

    configure<org.jlleitschuh.gradle.ktlint.KtlintExtension> {
        version.set("1.5.0")
        debug.set(true)
        verbose.set(true)
        outputToConsole.set(true)
        outputColorName.set("RED")
        ignoreFailures.set(false)
        enableExperimentalRules.set(true)
        filter {
            exclude { it.file.path.contains("generated/") }
        }
        disabledRules.set(setOf("HEADER_KEYWORD", "no-wildcard-imports", "no-blank-line-before-rbrace", "no-empty-file"))
    }

    configure<JavaPluginExtension> {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }

    configure<org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension> {
        jvmToolchain(21)
    }

    tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
        compilerOptions {
            freeCompilerArgs.set(listOf("-Xjsr305=strict", "-Xconsistent-data-class-copy-visibility"))
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
        }
    }

    tasks.withType<Test> {
        useJUnitPlatform()
    }

    dependencies {
        // Kotlin
        implementation("org.jetbrains.kotlin:kotlin-reflect")
        implementation("org.jetbrains.kotlin:kotlin-stdlib-jdk8")
        implementation("org.jetbrains.kotlin:kotlin-stdlib:2.1.20")
    }

    configurations {
        compileOnly {
            extendsFrom(configurations.annotationProcessor.get())
        }
    }

    tasks.getByName<org.springframework.boot.gradle.tasks.bundling.BootJar>("bootJar") {
        enabled = false
    }

    tasks.getByName<Jar>("jar") {
        enabled = true
    }
}

// ===== ./domains/account/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== ./domains/account/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:account:application"))
    implementation(project(":domains:account:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/account/infrastructure/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
}

dependencies {
    implementation(project(":domains:account:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// ===== ./domains/account/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common"))
    implementation(project(":domains:account:domain"))
    implementation(project(":domains:account:infrastructure"))

    // Spring Boot 버전을 통일
    implementation("org.springframework.boot:spring-boot-starter:3.2.5")
    implementation("org.springframework.boot:spring-boot-starter-web:3.2.5")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa:3.2.5")

    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.5")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== ./domains/account/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:account:presentation"))
    implementation(project(":domains:account:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/user/domain/build.gradle.kts =====
plugins {
    kotlin("jvm")
}

dependencies {
    implementation(project(":domains:common"))

    // 순수 도메인 레이어는 외부 의존성이 없습니다.
    // Removed: implementation("org.springframework:spring-web") // Removed per Rule 10

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 기존 테스트 의존성도 유지
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")
}

// ===== ./domains/user/presentation/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:user:application"))
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/user/infrastructure/build.gradle.kts =====
import com.github.davidmc24.gradle.plugin.avro.GenerateAvroJavaTask // Added for Avro task config
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile // Added for Avro task config

plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
    kotlin("plugin.jpa")
    id("com.github.davidmc24.gradle.plugin.avro") version "1.9.1" // Added Avro plugin (Rule 109)
}

dependencies {
    implementation(project(":domains:user:domain"))
    implementation(project(":domains:common")) // Keep common for now, might need review later
    // implementation(project(":shared:outbox")) // Removed root outbox dependency
    implementation(project(":shared:outbox:application")) // Keep application dependency for OutboxMessageRepository port

    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.mapstruct:mapstruct:1.6.3") // Assuming MapStruct is used for entity mapping

    // Avro / Kafka Dependencies (Rule 111)
    implementation("org.apache.avro:avro:1.11.3") // Use consistent versions
    implementation("io.confluent:kafka-avro-serializer:7.5.3")
    implementation("io.confluent:kafka-schema-registry-client:7.5.3")

    // MapStruct 어노테이션 프로세서 - Kotlin에서는 kapt 사용
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // H2 데이터베이스
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

// Avro Task Configuration (Rule 111)
tasks.withType<KotlinCompile> {
    dependsOn(tasks.withType<GenerateAvroJavaTask>())
    source(tasks.withType<GenerateAvroJavaTask>().map { it.outputs })
}

tasks.withType<GenerateAvroJavaTask> {
    source("src/main/resources/avro") // Point to local Avro schema location
    setOutputDir(file("$buildDir/generated-sources/avro/kotlin")) // Use setOutputDir for Avro plugin compatibility
    isCreateSetters = false
    fieldVisibility = "PRIVATE"
    isCreateOptionalGetters = false
    isGettersReturnOptional = false
    // Add other configurations as needed, e.g., custom converters
}

// Ensure generated sources are added to the Kotlin source set
kotlin.sourceSets.main {
    kotlin.srcDir(layout.buildDirectory.dir("generated-sources/avro/kotlin"))
}

// ===== ./domains/user/application/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("kapt")
    kotlin("plugin.spring")
}

dependencies {
    implementation(project(":domains:common"))
    implementation(project(":domains:user:domain"))
    // implementation(project(":domains:user:infrastructure")) // Removed per Rule 9

    // Spring Boot BOM 적용: 버전 제거
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-security")

    implementation("org.mapstruct:mapstruct:1.6.3")

    // MapStruct 어노테이션 프로세서
    kapt("org.mapstruct:mapstruct-processor:1.6.3")

    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    // Kotest Spring 확장
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")

    // MockK
    testImplementation("io.mockk:mockk:1.13.8")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.junit.jupiter:junit-jupiter-api:5.11.4")
    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.11.4")
    testImplementation("org.assertj:assertj-core:3.27.3")

    // H2 데이터베이스
    testRuntimeOnly("com.h2database:h2:2.3.232")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// ===== ./domains/user/apps/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
    id("org.springframework.boot")
}

dependencies {
    implementation(project(":domains:user:presentation"))
    implementation(project(":domains:user:infrastructure"))
    implementation(project(":domains:common"))

    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")

    // HATEOAS 지원
    implementation("org.springframework.boot:spring-boot-starter-hateoas")
    implementation("org.springframework.boot:spring-boot-starter-security")

    // OpenAPI 3.0 & Swagger UI
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.4")
    implementation("org.webjars:webjars-locator-core:0.59")

    // Database
    runtimeOnly("com.h2database:h2:2.3.232")

    // 테스트
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("io.mockk:mockk:1.13.17")
}

// ===== ./domains/common/build.gradle.kts =====
plugins {
    kotlin("jvm")
    kotlin("plugin.spring")
}

dependencies {
    // Spring Boot Starter Web (이미 spring-web을 포함)
    implementation("org.springframework.boot:spring-boot-starter-web")

    // Validation
    implementation("org.springframework.boot:spring-boot-starter-validation")

    // Swagger
    implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.1.0")

    // Hateoas
    implementation("org.springframework.hateoas:spring-hateoas")
}

// ===== ./temp/delivery/domain/build.gradle.kts =====

// ===== ./temp/delivery/presentation/build.gradle.kts =====

// ===== ./temp/delivery/infrastructure/build.gradle.kts =====

// ===== ./temp/delivery/application/build.gradle.kts =====

// ===== ./temp/delivery/apps/build.gradle.kts =====

// ===== ./temp/restaurant/domain/build.gradle.kts =====

// ===== ./temp/restaurant/presentation/build.gradle.kts =====

// ===== ./temp/restaurant/infrastructure/build.gradle.kts =====

// ===== ./temp/restaurant/application/build.gradle.kts =====

// ===== ./temp/restaurant/apps/build.gradle.kts =====

// ===== ./temp/payment/domain/build.gradle.kts =====

// ===== ./temp/payment/presentation/build.gradle.kts =====

// ===== ./temp/payment/infrastructure/build.gradle.kts =====

// ===== ./temp/payment/application/build.gradle.kts =====

// ===== ./temp/payment/apps/build.gradle.kts =====

// ===== ./temp/order/domain/build.gradle.kts =====

// ===== ./temp/order/presentation/build.gradle.kts =====

// ===== ./temp/order/infrastructure/build.gradle.kts =====

// ===== ./temp/order/application/build.gradle.kts =====

// ===== ./temp/order/apps/build.gradle.kts =====

// ===== ./settings.gradle.kts =====
rootProject.name = "restaurant"

include("domains:common")

include(":domains:user:application")
include(":domains:user:apps")
include(":domains:user:domain")
include(":domains:user:infrastructure")
include(":domains:user:presentation")

include(":domains:account:application")
include(":domains:account:apps")
include(":domains:account:domain")
include(":domains:account:infrastructure")
include(":domains:account:presentation")

// include(":domains:restaurant:application")
// // include(":domains:restaurant:apps")
// include(":domains:restaurant:domain")
// include(":domains:restaurant:infrastructure")
// include(":domains:restaurant:presentation")

include(":shared:outbox")
include(":shared:outbox:application")
include(":shared:outbox:infrastructure")
// include("libs:outbox")
// include("support:common")
