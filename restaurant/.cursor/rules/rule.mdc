---
description: 
globs: 
alwaysApply: true
---
# 프로젝트 기술 문서

## 1. 시작하기 전에

이 문서는 프로젝트를 시작하기 앞서 **반드시 준수해야 할 규칙 및 가이드**를 담은 문서입니다.
본 문서에 기술된 모든 규칙과 패턴은 선택 사항이 아닌 **필수 사항**으로, 프로젝트의 모든 구성원이 예외 없이 따라야 합니다.
여러가지 선택지 중에 하나를 선택하여 최대한 일관된 프로젝트 구조를 가져가기 위함입니다.

### 1.1 프로젝트 개요

#### 1.1.1 기술 스택

- **프레임워크**: Spring Boot
- **빌드 도구**: Gradle
- **프로그래밍 언어**: Kotlin
- **매핑 라이브러리**: Kotlin 확장 함수 기반 객체 변환

#### 1.1.2 아키텍처 원칙

- **도메인 주도 설계(DDD)**: 핵심 도메인 로직에 집중합니다.
- **클린 아키텍처**: 시스템을 Presentation, Application, Domain, Infrastructure의 4개 레이어로 명확히 구분합니다. 이외에 특별한 상위 레이어로 Messaging 레이어를 도입하며 @KafkaListener나 이와 비슷한 책임을 가지는 코드만 존재한다.
- **이벤트 소싱**: 사용하지 않습니다. 비동기 상태 추적은 별도의 상태 저장소를 통해 구현됩니다.

### 1.2 프로젝트 구조

#### 1.2.1 모듈화 전략

##### 1.2.1.1 멀티모듈 프로젝트

- **레이어별 모듈 분리**: Presentation, Application, Domain, Infrastructure 레이어별로 모듈을 분리하여 관리합니다.
- **목적**: 한 영역의 변경이 다른 영역에 미치는 영향을 최소화합니다.

##### 1.2.1.2 도메인별 모듈화

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.

##### 1.2.1.3 공통 모듈

- **내용**: 전역에서 사용하는 순수 유틸리티, 공유 추상 클래스, 인터페이스 등이 포함됩니다.
- **주의**: 과도한 의존을 피하여 "공통 모듈 지옥"을 방지합니다.

#### 1.2.2 프로젝트 구조 참고용

아래는 참고용이고 그대로 하라는건 아니다.

```
domains/
├── common/
│   ├── src/
│   │   └── main/
│   │       └── kotlin/
│   │           └── com/
│   │               └── example/
│   │                   └── common/
│   │                       ├── dto/
│   │                       │   ├── AsyncCommandResult.kt
│   │                       │   └── CommandResult.kt
│   │                       ├── exception/
│   │                       │   ├── ApplicationException.kt
│   │                       │   ├── DomainException.kt
│   │                       │   ├── InfrastructureException.kt
│   │                       │   └── PresentationException.kt
│   │                       └── config/
│   │                           ├── Extensions.kt
│   │                           └── GlobalExceptionHandler.kt
│   ├── user/
│   │   ├── apps/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── apps/
│   │   │   │                       └── user/
│   │   │   │                           └── UserApplication.kt
│   │   ├── domain/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── domain/
│   │   │   │                       └── user/
│   │   │   │                           ├── aggregate/
│   │   │   │                           │   └── User.kt
│   │   │   │                           ├── exception/
│   │   │   │                           │   └── UserDomainException.kt
│   │   │   │                           ├── repository/
│   │   │   │                           │   └── UserRepository.kt
│   │   │   │                           └── vo/
│   │   │   │                               ├── Email.kt
│   │   │   │                               └── UserId.kt
│   │   ├── application/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── application/
│   │   │   │                       └── user/
│   │   │   │                           ├── command/
│   │   │   │                           │   ├── handler/
│   │   │   │                           │   │   ├── CreateUserCommandHandler.kt
│   │   │   │                           │   │   └── UpdateUserCommandHandler.kt
│   │   │   │                           │   ├── CreateUserCommand.kt
│   │   │   │                           │   └── UpdateUserCommand.kt
│   │   │   │                           ├── common/
│   │   │   │                           │   └── UserApplicationException.kt
│   │   │   │                           ├── extensions/
│   │   │   │                           │   └── UserApplicationExtensions.kt
│   │   │   │                           └── query/
│   │   │   │                               ├── handler/
│   │   │   │                               │   ├── FindUsersQueryHandler.kt
│   │   │   │                               │   └── GetUserQueryHandler.kt
│   │   │   │                               ├── FindUsersQuery.kt
│   │   │   │                               └── GetUserQuery.kt
│   │   ├── infrastructure/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── infrastructure/
│   │   │   │                       └── user/
│   │   │   │                           ├── entity/
│   │   │   │                           │   └── UserEntity.kt
│   │   │   │                           ├── exception/
│   │   │   │                           │   └── UserInfrastructureException.kt
│   │   │   │                           ├── extensions/
│   │   │   │                           │   └── UserEntityExtensions.kt
│   │   │   │                           └── repository/
│   │   │   │                               ├── SpringDataJpaUserRepository.kt
│   │   │   │                               └── UserRepositoryImpl.kt
│   │   ├── presentation/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── presentation/
│   │   │   │                       └── user/
│   │   │   │                           ├── exception/
│   │   │   │                           │   └── UserPresentationException.kt
│   │   │   │                           ├── v1/
│   │   │   │                           │   ├── command/
│   │   │   │                           │   │   ├── UserCommandControllerV1.kt
│   │   │   │                           │   │   └── dto/
│   │   │   │                           │   │       └── request/
│   │   │   │                           │   │           ├── UserCreateRequestV1.kt
│   │   │   │                           │   │           └── UserUpdateRequestV1.kt
│   │   │   │                           │   ├── extensions/
│   │   │   │                           │   │   └── UserRequestExtensions.kt
│   │   │   │                           │   └── query/
│   │   │   │                           │       ├── UserQueryControllerV1.kt
│   │   │   │                           │       └── dto/
│   │   │   │                           │           └── response/
│   │   │   │                           │               ├── UserResponseV1.kt
│   │   │   │                           │               └── UserSearchResponseV1.kt
│   │   │   └── build.gradle.kts
│   └── build.gradle.kts
├── order/
│   ├── apps/
│   │   ├── src/
│   │   │   └── main/
│   │   │       └── kotlin/
│   │   │           └── com/
│   │   │               └── example/
│   │   │                   └── apps/
│   │   │                       └── order/
│   │   │                           └── OrderApplication.kt
│   │   ├── domain/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── domain/
│   │   │   │                       └── order/
│   │   │   │                           ├── aggregate/
│   │   │   │                           │   └── Order.kt
│   │   │   │                           ├── entity/
│   │   │   │                           │   └── OrderItem.kt
│   │   │   │                           ├── exception/
│   │   │   │                           │   └── OrderDomainException.kt
│   │   │   │                           ├── repository/
│   │   │   │                           │   └── OrderRepository.kt
│   │   │   │                           └── vo/
│   │   │   │                               ├── OrderId.kt
│   │   │   │                               └── OrderStatus.kt
│   │   ├── application/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── application/
│   │   │   │                       └── order/
│   │   │   │                           ├── command/
│   │   │   │                           │   ├── handler/
│   │   │   │                           │   │   ├── CancelOrderCommandHandler.kt
│   │   │   │                           │   │   ├── CreateOrderCommandHandler.kt
│   │   │   │                           │   │   └── UpdateOrderCommandHandler.kt
│   │   │   │                           │   ├── CancelOrderCommand.kt
│   │   │   │                           │   ├── CreateOrderCommand.kt
│   │   │   │                           │   └── UpdateOrderCommand.kt
│   │   │   │                           ├── common/
│   │   │   │                           │   └── OrderApplicationException.kt
│   │   │   │                           ├── extensions/
│   │   │   │                           │   └── OrderApplicationExtensions.kt
│   │   │   │                           └── query/
│   │   │   │                               ├── handler/
│   │   │   │                               │   ├── FindOrdersByCustomerQueryHandler.kt
│   │   │   │                               │   ├── FindOrdersQueryHandler.kt
│   │   │   │                               │   └── GetOrderQueryHandler.kt
│   │   │   │                               ├── FindOrdersByCustomerQuery.kt
│   │   │   │                               ├── FindOrdersQuery.kt
│   │   │   │                               └── GetOrderQuery.kt
│   │   ├── infrastructure/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── infrastructure/
│   │   │   │                       └── order/
│   │   │   │                           ├── entity/
│   │   │   │                           │   ├── OrderEntity.kt
│   │   │   │                           │   └── OrderItemEntity.kt
│   │   │   │                           ├── exception/
│   │   │   │                           │   └── OrderInfrastructureException.kt
│   │   │   │                           ├── extensions/
│   │   │   │                           │   └── OrderEntityExtensions.kt
│   │   │   │                           └── repository/
│   │   │   │                               ├── OrderRepositoryImpl.kt
│   │   │   │                               └── SpringDataJpaOrderRepository.kt
│   │   ├── presentation/
│   │   │   ├── src/
│   │   │   │   └── main/
│   │   │   │       └── kotlin/
│   │   │   │           └── com/
│   │   │   │               └── example/
│   │   │   │                   └── presentation/
│   │   │   │                       └── order/
│   │   │   │                           ├── exception/
│   │   │   │                           │   └── OrderPresentationException.kt
│   │   │   │                           ├── v1/
│   │   │   │                           │   ├── command/
│   │   │   │                           │   │   ├── OrderCommandControllerV1.kt
│   │   │   │                           │   │   └── dto/
│   │   │   │                           │   │       └── request/
│   │   │   │                           │   │           ├── OrderCancelRequestV1.kt
│   │   │   │                           │   │           └── OrderCreateRequestV1.kt
│   │   │   │                           │   ├── extensions/
│   │   │   │                           │   │   └── OrderRequestExtensions.kt
│   │   │   │                           │   └── query/
│   │   │   │                           │       ├── OrderQueryControllerV1.kt
│   │   │   │                           │       └── dto/
│   │   │   │                           │           └── response/
│   │   │   │                           │               ├── OrderHistoryResponseV1.kt
│   │   │   │                           │               └── OrderResponseV1.kt
│   │   │   └── build.gradle.kts
│   └── build.gradle.kts
└── build.gradle.kts
```

## 2. 핵심 개발 원칙

### 2.1 클린 아키텍처 및 레이어 규칙

#### 2.1.1 레이어 구조 및 의존성

##### 2.1.1.1 레이어 간 의존성 및 도메인 규칙

- **도메인 레이어의 독립성**
  - **규칙**: Domain 레이어는 Presentation, Application, Infrastructure 레이어를 절대 참조하지 않습니다.
  - **목적**: 도메인의 순수성을 유지합니다.

- **Aggregate의 VO 사용 범위**
  - **규칙**: 도메인 내 Aggregate(집합체)의 Value Object(VO)는 Domain 레이어 외부에서 사용하지 않습니다.
  - **목적**: 도메인 경계 내에서만 활용합니다.

##### 2.1.1.2 레이어별 엔티티 정의 규칙

- **2.1.2.1 JPA 엔티티의 위치**
  - **규칙**: JPA 엔티티는 `Infrastructure` 레이어에 정의합니다.
  - **목적**: 데이터베이스와의 매핑을 담당하는 JPA 엔티티를 인프라스트럭처 레이어로 분리하여, 도메인 레이어의 순수성을 유지하고 기술적 의존성을 격리합니다.
  - **구현**:
    - JPA 엔티티는 `@Entity` 어노테이션을 사용하며, 데이터베이스 테이블과 매핑됩니다.
    - 도메인 로직은 JPA 엔티티에 포함시키지 않고, 필요 시 도메인 레이어의 Aggregate나 VO로 변환하여 사용합니다.
  - **예시**:

```kotlin
@Entity
@Table(name = "users")
data class UserEntity(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,
  val name: String,
  val email: String
)

```

- **2.1.2.2 Aggregate와 VO의 위치**
  - **규칙**: Aggregate, Value Object(VO), 그리고 기타 DDD 엔티티는 `Domain` 레이어에 정의하며, 외부 기술 프레임워크(JPA, Spring 등)에 의존하지 않도록 최대한 순수하게 유지합니다. ddd에서 하위 엔티티는 도메인 레이어에 entity 폴더에 위치합니다. 이는 jpa entity와 다름을 문서에 명시합니다.
  - **목적**: 도메인 로직의 독립성과 재사용성을 보장하며, 비즈니스 규칙을 기술적 세부사항과 분리합니다.
  - **구현**:
    - Aggregate는 도메인 내의 루트 엔티티로, 비즈니스 규칙과 불변성을 관리합니다.
    - VO는 불변 객체로, 도메인 내에서 값의 의미를 캡슐화합니다.
    - JPA 엔티티와의 매핑은 `Infrastructure` 레이어에서 별도로 처리하며, 코틀린 확장 함수를 활용해 변환합니다.
  - **예시**:

```kotlin
data class User(
  val id: UserId,
  val name: String,
  val email: Email
) {
  fun updateName(newName: String): User {
	  return copy(name = newName)
  }
}

@JvmInline
value class UserId(val value: Long)

data class Email(val value: String) {
  init {
	  require(value.contains("@")) { "유효한 이메일 형식이 아닙니다." }
  }
}

```

- **2.1.2.3 JPA 엔티티와 DDD 엔티티 간 매핑**
  - **규칙**: JPA 엔티티와 도메인 레이어의 Aggregate/VO 간 변환은 `Infrastructure` 또는 `Application` 레이어에서 수행하며, 코틀린 확장 함수를 사용하여 직접 매핑 로직을 정의합니다.
  - **목적**: 도메인 레이어의 순수성을 유지하면서, 데이터 영속성과 도메인 로직을 분리합니다.
  - **구현**:
    - `Infrastructure` 레이어에서 Repository가 JPA 엔티티를 조회/저장하고, 코틀린 확장 함수를 통해 이를 도메인 객체로 변환합니다.
  - **예시**:

```kotlin
// Infrastructure Layer - extensions/UserEntityExtensions.kt
package com.example.infrastructure.user.entity.extensions

import com.example.infrastructure.user.entity.UserEntity
import com.example.domain.user.User
import com.example.domain.user.vo.UserId
import com.example.domain.user.vo.Email

fun UserEntity.toDomain(): User {
  return User(
	  id = this.id?.let { UserId.of(it) },
	  name = this.name,
	  email = Email.of(this.email)
  )
}
```

```kotlin
// Infrastructure Layer - extensions/UserDomainExtensions.kt
package com.example.infrastructure.user.entity.extensions

import com.example.infrastructure.user.entity.UserEntity
import com.example.domain.user.User

fun User.toEntity(): UserEntity {
  return UserEntity(
	  id = this.id?.value,
	  name = this.name,
	  email = this.email.value
  )
}
```

```kotlin
@Repository
class UserRepositoryImpl(
  private val jpaRepository: SpringDataJpaUserRepository
) : UserRepository {
  override fun findById(id: UserId): User? {
	  return jpaRepository.findById(id.value)
		  .map { it.toDomain() } // 확장 함수를 통한 변환
		  .orElse(null)
  }

  override fun save(user: User): User {
	  val entity = user.toEntity() // 확장 함수를 통한 변환
	  val savedEntity = jpaRepository.save(entity)
	  return savedEntity.toDomain() // 확장 함수를 통한 변환
  }
}
```

- **2.1.2.4 주의사항**
  - **도메인 레이어의 순수성**: 도메인 객체는 JPA 어노테이션(`@Entity`, `@Id` 등)이나 Spring 관련 의존성을 포함시키지 않습니다.
  - **성능 고려**: 빈번한 객체 변환으로 인한 오버헤드를 줄이기 위해, 필요한 경우 매핑 로직을 최적화하거나 캐싱을 고려합니다.
  - **테스트 용이성**: 도메인 레이어는 가능하다면 순수 Kotlin으로 작성되므로, 단위 테스트 시 mocking 없이 독립적으로 테스트 가능합니다.

#### 2.1.2 CQRS 패턴

##### 2.1.2.1 Command

- **역할**: 상태 변경, 데이터 생성, 수정, 삭제와 같은 시스템의 상태를 변경하는 모든 작업을 캡슐화하여 애플리케이션 레이어로 전달합니다. Command는 사용자 인터페이스의 액션 또는 외부 시스템의 이벤트에 대한 응답으로 생성될 수 있습니다. Command의 핵심 역할은 "무엇을 하라"를 명확하게 정의하고 전달하는 것입니다.
- **특징**:
  - **상태 변경 지시**: Command는 시스템의 상태를 변경하려는 명확한 의도를 담고 있습니다.
  - **단방향 흐름**: 애플리케이션 레이어에서 Command는 상태 변경 작업만을 수행하고, 별도의 데이터를 반환하지 않습니다. 이는 Command의 목적이 상태 변경 자체에 집중되어 있기 때문입니다.
  - **비즈니스 로직**: Command는 애플리케이션 레이어에서 Command Handler에 의해 처리되며, Command Handler는 도메인 레이어의 Aggregate를 사용하여 실제 비즈니스 로직을 수행하고 상태를 변경합니다.
  - **명확한 의도**: Command는 사용자 액션 또는 시스템 요구사항을 명확하게 표현하므로, 코드의 가독성과 유지보수성을 높입니다.
  - **예시**:
    - 사용자 생성 Command: `CreateUserCommand` (이름, 이메일, 비밀번호 포함)
    - 주문 생성 Command: `CreateOrderCommand` (고객 ID, 주문 상품 목록 포함)
    - 상품 수정 Command: `UpdateProductCommand` (상품 ID, 수정할 속성들 포함)

- **Command Handler와의 관계**: Command는 애플리케이션 레이어의 Command Handler에 의해 처리됩니다. Command Handler는 특정 Command를 처리하는 책임을 가지며, 도메인 레이어의 Aggregate를 사용하여 비즈니스 로직을 실행하고, 필요하다면 Infrastructure 레이어를 통해 데이터 영속성을 처리합니다. Command Handler는 Command를 받아 처리하고, 성공 또는 실패 결과를 `CommandResult` 또는 `AsyncCommandResult` 객체로 반환합니다 (자세한 내용은 "2.2.2 Command 리턴 규칙 (Application Layer)" 섹션 참조).

##### 2.1.2.2 Query

- **역할**: 시스템의 현재 상태에 대한 정보를 조회하거나 검색하는 요청을 캡슐화하여 애플리케이션 레이어로 전달합니다. Query는 사용자 인터페이스에 데이터를 표시하거나, 다른 시스템에 데이터를 제공하기 위해 사용됩니다. Query의 핵심 역할은 "무엇을 알고 싶다"를 명확하게 정의하고 전달하는 것입니다.
- **특징**:
  - **데이터 조회**: Query는 시스템의 상태를 변경하지 않고, 저장된 데이터를 조회하는 목적으로 사용됩니다.
  - **데이터 반환**: Query는 요청한 데이터를 Response DTO 형태로 애플리케이션 레이어에서 Presentation 레이어로 반환합니다.
  - **읽기 전용**: Query는 데이터베이스나 저장소에 대한 읽기 전용 작업을 수행하며, 쓰기 작업은 수행하지 않습니다. 이는 Query의 목적이 데이터 조회에만 집중되어 있기 때문입니다.
  - **최적화된 조회**: Query는 특정 조회 요구사항에 맞춰 최적화될 수 있습니다. 예를 들어, 특정 필드만 조회하거나, 특정 조건에 맞는 데이터만 필터링하는 등 다양한 조회 전략을 적용할 수 있습니다.
  - **예시**:
    - 사용자 정보 조회 Query: `GetUserQuery` (사용자 ID 포함)
    - 상품 목록 조회 Query: `FindProductsQuery` (검색 조건, 페이지 정보 포함)
    - 주문 상세 정보 조회 Query: `GetOrderDetailQuery` (주문 ID 포함)

- **Query Handler와의 관계**: Query는 애플리케이션 레이어의 Query Handler에 의해 처리됩니다. Query Handler는 특정 Query를 처리하는 책임을 가지며, Infrastructure 레이어의 Repository를 사용하여 데이터를 조회하고, 조회 결과를 Response DTO로 변환하여 반환합니다. Query Handler는 도메인 로직을 직접 수행하지 않고, 주로 데이터 조회 및 변환 작업을 담당합니다 (자세한 내용은 "2.2.3 Query 전략" 섹션 참조).

### 2.2 데이터 처리 규칙

#### 2.2.1 DTO 규칙

##### 2.2.1.1 DTO 네이밍 규칙

- **2.2.1.1.1 Presentation 레이어**
  - **Request DTO**: 사용자로부터 입력받은 데이터를 담으며, 이름 뒤에 "Request"를 붙입니다.
    - 예: `UserCreateRequest`, `ProductUpdateRequest`, `LoginRequest`
  - **Response DTO**: API가 응답으로 반환하는 데이터를 담으며, 이름 뒤에 "Response"를 붙입니다.
    - 예: `UserInfoResponse`, `ProductDetailResponse`, `AuthTokenResponse`

- **2.2.1.1.2 Application 레이어**
  - **Command DTO**: 특정 기능 실행(명령)에 필요한 데이터를 캡슐화하며, 이름 뒤에 "Command"를 붙입니다.
    - 예: `CreateUserCommand`, `UpdateProductCommand`
  - **Query DTO**: 데이터 조회 및 검색 요청에 필요한 정보를 전달하며, 이름 뒤에 "Query"를 붙입니다.
    - 예: `GetUserQuery`, `FindProductsQuery`

##### 2.2.1.2 DTO 변환 규칙

- **원칙**: Presentation 레이어의 `Request DTO`는 애플리케이션 레이어의 `Command DTO` 또는 `Query DTO`로 변환되어 사용됩니다.
- **구현**: 코틀린 확장 함수를 사용하여 객체 간 변환을 구현합니다.
  - **설명**: 각 DTO 클래스에 대한 확장 함수를 정의하여 변환 로직을 구현합니다. Extensions 폴더 및 파일에 확장 함수를 위치시켜 코드를 관리합니다.
  - **장점**:
    - **직관성**: 코틀린 언어 기능 자체를 활용하여 별도의 라이브러리 의존성 없이 간결하게 구현합니다.
    - **유연성**: 복잡한 객체 구조나 커스터마이징 요구사항에 대해 확장 함수를 통해 유연하게 대응할 수 있습니다.
    - **유지보수**: 변환 로직이 각 DTO 클래스 근처에 위치하여 응집도를 높이고 유지보수를 용이하게 합니다.
  - **단점**:
    - **수동 구현**: MapStruct와 같은 자동화 도구의 도움 없이 개발자가 직접 변환 코드를 작성해야 합니다.
    - **코드 중복 가능성**: 유사한 변환 로직이 여러 곳에서 반복될 수 있으므로, 필요에 따라 공통 함수나 유틸리티 클래스를 활용해야 합니다.
    - **컴파일 타임 검증**: MapStruct의 컴파일 타임 매핑 검증과 같은 강력한 타입 안정성 검증은 제공되지 않습니다.

##### 2.2.1.2.1 Extensions 폴더 구조 (필수)

- **규칙**: 모든 레이어는 다음과 같은 Extensions 폴더 구조를 반드시 준수해야 합니다:

1. **Presentation 레이어**:

```
domains:
  user:
    presentation:
      src:
        main:
          kotlin:
            com:
              example:
                presentation:
                  user:
                    v1:
                      extensions:
                        request:      # Request DTO 변환 (필수)
                          - UserRequestExtensions.kt
                        response:     # Response DTO 변환 (필수)
                          - UserResponseExtensions.kt
                        controller:   # 컨트롤러 확장 (필요시)
                          - UserControllerExtensions.kt
```

2. **Application 레이어**:

```
domains:
  user:
    application:
      src:
        main:
          kotlin:
            com:
              example:
                application:
                  user:
                    extensions:
                      command:      # Command 관련 확장 (필수)
                        - UserCommandExtensions.kt
                      query:        # Query 관련 확장 (필수)
                        - UserQueryExtensions.kt
                      common:       # 공통 확장 (필요시)
                        - UserCommonExtensions.kt
```

3. **Infrastructure 레이어**:

```
domains:
  user:
    infrastructure:
      src:
        main:
          kotlin:
            com:
              example:
                infrastructure:
                  user:
                    extensions:
                      entity:       # Entity 변환 확장 (필수)
                        - UserEntityExtensions.kt
                      repository:   # Repository 확장 (필요시)
                        - UserRepositoryExtensions.kt
                      api:          # 외부 API 확장 (필요시)
                        - UserApiExtensions.kt
                      common:       # 공통 확장 (필요시)
                        - UserCommonExtensions.kt
```

- **폴더명 규칙**:
  - 모든 하위 폴더명은 반드시 소문자로 작성합니다.
  - 각 기능별 폴더는 해당 기능의 확장 함수만 포함해야 합니다.
  - 파일명은 도메인명+기능명+Extensions.kt 형식을 따라야 합니다 (예: UserRequestExtensions.kt).

- **준수 사항**:
  - 모든 프로젝트는 위 구조를 반드시 준수해야 합니다.
  - 각 확장 함수는 해당 기능에 맞는 폴더에만 위치해야 합니다.
  - 하위 폴더 추가가 필요한 경우, 팀 내 합의 후 문서화하여 일관성을 유지해야 합니다.

##### 2.2.1.2.2 구현 (Kotlin 확장 함수 사용)

- **확장 함수 구현 예시 (UserRequestExtensions.kt)**:

```kotlin
package com.example.presentation.user.v1.extensions.request // 패키지 경로 변경

import com.example.presentation.user.v1.dto.request.UserCreateRequestV1
import com.example.application.user.command.CreateUserCommand

fun UserCreateRequestV1.toCommand(): CreateUserCommand {
    return CreateUserCommand(
        name = this.name,
        email = this.email,
        password = this.password
    )
}
```

- **확장 함수 사용 예시 (Controller)**:

```kotlin
@RestController
@RequestMapping("/api/v1/users")
class UserCommandController(
    private val createUserCommandHandler: CreateUserCommandHandler
) {
    @PostMapping
    fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
        val command = request.toCommand() // 확장 함수 호출
        val result = createUserCommandHandler.handle(command)
        return ResponseEntity.ok(mapOf(
            "status" to "success",
            "message" to "요청이 처리되었습니다.",
            "correlationId" to result.correlationId
        ))
    }
}
```

- **Entity -> Domain 변환 확장 함수 구현 예시 (UserEntityExtensions.kt - Infrastructure Layer)**:

```kotlin
package com.example.infrastructure.user.extensions.entity

import com.example.infrastructure.user.entity.UserEntity
import com.example.domain.user.User
import com.example.domain.user.vo.UserId
import com.example.domain.user.vo.Email

fun UserEntity.toDomain(): User {
    return User(
        id = this.id?.let { UserId.of(it) },
        name = this.name,
        email = Email.of(this.email)
    )
}
```

- **Domain -> Entity 변환 확장 함수 구현 예시 (UserDomainExtensions.kt - Infrastructure Layer)**:

```kotlin
package com.example.infrastructure.user.extensions.entity

import com.example.infrastructure.user.entity.UserEntity
import com.example.domain.user.User

fun User.toEntity(): UserEntity {
    return UserEntity(
        id = this.id?.value,
        name = this.name,
        email = this.email.value
    )
}
```

- **Entity -> Domain 변환 확장 함수 사용 예시 (Repository - Infrastructure Layer)**:

```kotlin
@Repository
class UserRepositoryImpl(
    private val jpaRepository: SpringDataJpaUserRepository
) : UserRepository {
    override fun findById(id: UserId): User? {
        return jpaRepository.findById(id.value)
            .map { it.toDomain() } // 확장 함수 호출
            .orElse(null)
    }

    override fun save(user: User): User {
        val entity = user.toEntity() // 확장 함수 호출
        val savedEntity = jpaRepository.save(entity)
        return savedEntity.toDomain() // 확장 함수 호출
    }
}
```

#### 2.2.2 Value Object (VO) 작성 규칙

##### 2.5.1.1 목적

Value Object(VO)는 도메인 레이어에서 불변 값을 캡슐화하며, 도메인 규칙을 강제합니다(5.3.2). 이 가이드는 VO의 복잡도와 관계없이 통일된 작성 규칙을 제공하여 코드의 일관성, 가독성, 유지보수성을 보장하는 것을 목표로 합니다.

##### 2.5.1.2 기본 규칙

- **불변성**: VO는 생성 후 상태가 변경되지 않는 불변 객체로 설계됩니다.
- **Private Constructor**: 직접 객체 생성을 차단하기 위해 생성자를 `private`으로 설정합니다.
- **Companion Object**: VO 생성은 `companion object`에 정의된 `of` 메서드를 통해 제어됩니다.
- **유효성 검사**: `of` 메서드에서 `require`를 사용해 입력값의 유효성을 검사합니다.
- **toString 오버라이드**: 디버깅과 로깅의 편의를 위해 `toString()`을 값 자체로 반환하도록 재정의합니다.

##### 2.5.1.3 VO 작성 패턴

모든 VO는 다음 구조를 따릅니다:

- **`data class`로 작성**: 단순 VO와 복잡 VO 모두 `data class`를 사용합니다.
- **`private constructor`로 생성 차단**: 외부에서 직접 생성하지 못하도록 제한합니다.
- **`companion object`에서 `of` 메서드로 생성**: 생성 로직을 통제합니다.
- **유효성 검사**: `of` 메서드 내에서 수행합니다.
- **`toString()` 오버라이드**: 값을 문자열로 반환합니다.

###### 2.5.1.3.1 예시: 단순 VO (UserId)

```kotlin
package com.example.domain.user.vo

data class UserId private constructor(
    val value: Long
) {
    companion object {
        fun of(value: Long): UserId {
            require(value > 0) { "UserId는 0보다 커야 합니다." }
            return UserId(value)
        }
    }

    override fun toString(): String = value.toString()
}
```

###### 2.5.1.3.2 예시: 복잡 VO (Password)

```kotlin
package com.example.domain.user.vo

import java.security.MessageDigest

data class Password private constructor(
val encodedValue: String
) {
companion object {
	private const val SALT = "ddd-user-salt"
	private const val MIN_LENGTH = 8
	private val PASSWORD_REGEX = Regex("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d@$!%*#?&]+$")

	fun of(rawPassword: String): Password {
		require(rawPassword.length >= MIN_LENGTH) { "비밀번호는 최소 ${MIN_LENGTH}글자 이상이어야 합니다." }
		require(rawPassword.matches(PASSWORD_REGEX)) { "비밀번호는 영문자와 숫자를 포함해야 합니다." }
		return Password(encode(rawPassword))
	}

	fun fromEncoded(encodedPassword: String): Password {
		return Password(encodedPassword)
	}

	private fun encode(rawPassword: String): String {
		val saltedPassword = rawPassword + SALT
		val messageDigest = MessageDigest.getInstance("SHA-256")
		val digest = messageDigest.digest(saltedPassword.toByteArray())
		return digest.fold("") { str, byte -> str + "%02x".format(byte) }
	}
}

fun matches(rawPassword: String): Boolean = encodedValue == encode(rawPassword)

override fun toString(): String = encodedValue
}
```

##### 2.5.1.4 세부 규칙

###### 2.5.1.4.1 생성 제어

- 모든 VO는 `companion object`의 `of` 메서드로만 생성됩니다.
- 필요 시 추가 생성 메서드(예: `fromEncoded`)를 `companion object`에 정의합니다.

###### 2.5.1.4.2 유효성 검사

- `of` 메서드에서 `require`를 사용해 유효성을 검사하며, 실패 시 도메인 의미를 담은 메시지를 반환합니다.
- 예시:

```kotlin
  require(value.isNotBlank()) { "이름은 공백일 수 없습니다." }
```

###### 2.5.1.4.3 네이밍 규칙

- **클래스명**: VO가 표현하는 값의 의미를 명확히 (예: `Email`, `UserId`).
- **프로퍼티명**: 기본적으로 `value` 사용, 특수한 경우 의미 있는 이름 (예: `encodedValue`).
- **생성 메서드**: 기본은 `of`, 특수 생성은 의미 반영 (예: `fromEncoded`).

###### 2.5.1.4.4 추가 메서드

- VO에 도메인 로직이 필요할 경우 (예: `matches`), 의미 있는 메서드만 추가합니다.
- 복잡한 로직 (예: 암호화)은 `companion object`의 `private` 메서드로 분리합니다.

###### 2.5.1.4.5 상수 및 정규식

- 상수와 정규식은 `companion object`에 `private`으로 정의하며, 대문자 스네이크 케이스 사용 (예: `MIN_LENGTH`, `PASSWORD_REGEX`).

##### 2.5.1.5 적용 예시

###### 2.5.1.5.1 `Email`

```kotlin
package com.example.domain.user.vo

data class Email private constructor(
    val value: String
) {
    companion object {
        private val EMAIL_REGEX = Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+$")

        fun of(value: String): Email {
            require(value.matches(EMAIL_REGEX)) { "유효한 이메일 형식이 아닙니다." }
            return Email(value)
        }
    }

    override fun toString(): String = value
}
```

###### 2.5.1.5.2 `Name`

```kotlin
package com.example.domain.user.vo

data class Name private constructor(
    val value: String
) {
    companion object {
        fun of(value: String): Name {
            require(value.isNotBlank()) { "이름은 공백일 수 없습니다." }
            require(value.length in 2..50) { "이름은 2~50자 사이여야 합니다." }
            return Name(value)
        }
    }

    override fun toString(): String = value
}
```

##### 2.5.1.6 주의사항

- **의존성 배제**: VO는 순수 Kotlin으로 작성되며, JPA나 Spring 어노테이션을 포함시키지 않습니다(5.3.4).
- **성능**: 복잡한 유효성 검사(예: 정규식)가 빈번히 호출될 경우, 캐싱이나 최적화를 고려합니다.
- **테스트**: 모든 VO는 Kotest로 유닛 테스트를 작성하며, 생성 성공/실패와 추가 메서드 동작을 검증합니다(18.3.1).

##### 2.5.1.7 장점

- **일관성**: 모든 VO가 동일한 구조로 작성되어 코드 이해와 유지보수가 용이합니다.
- **유연성**: 단순 VO와 복잡 VO 모두 동일 패턴으로 커버 가능합니다.
- **안정성**: 생성 시 유효성 검사가 강제되어 런타임 오류가 줄어듭니다.

#### 2.2.3 JPA 엔티티 작성 규칙

##### 2.6.1.1 목적

JPA 엔티티는 데이터베이스와 객체 간 매핑을 담당하며, `Infrastructure` 레이어에서 정의되어 도메인 로직과 기술적 의존성을 분리합니다(섹션 5.3.1 참조). 이 섹션은 Kotlin과 Spring Data JPA 환경에서 일관성 있고 유지보수 가능한 엔티티 작성 규칙을 제공하며, 도메인 모델과의 명확한 분리 및 매핑 전략을 정의합니다.

##### 2.6.1.2 기본 규칙

###### 2.6.1.2.1 위치

- **규칙**: JPA 엔티티는 `Infrastructure` 레이어에 정의합니다.
- **경로**: `domains/{domain}/infrastructure/src/main/kotlin/com/example/infrastructure/{domain}/entity/`
- **목적**: 도메인 레이어의 순수성을 보장하고, 데이터베이스 접근 로직을 기술적 계층으로 격리합니다(섹션 5.1).
- **예시**:

```
domains/user/infrastructure/src/main/kotlin/com/example/infrastructure/user/entity/UserEntity.kt
```

###### 2.6.1.2.2 네이밍 규칙

- **클래스명**: 도메인 이름에 `Entity` 접미사를 붙입니다 (예: `UserEntity`, `OrderEntity`).
- **테이블명**: `@Table`로 명시하며, 소문자 복수형 사용 (예: `users`, `orders`).
- **필드명**: 도메인 모델과 의미를 일치시키며 카멜 케이스 사용 (예: `userId`, `email`).

###### 2.6.1.2.3 불변성 유지

- **규칙**: 모든 필드는 `val`로 정의하여 불변성을 유지합니다.
- **이유**: 도메인 모델에서 상태 변경을 처리하고, JPA 엔티티는 최종 상태만 반영하므로 가변성(`var`)이 필요 없습니다(섹션 5.3.3).
- **구현 방식**:
  - **생성 시점 초기화**: 생성자에서 모든 필드를 `val`로 초기화하며, 기본값(예: `null`, `emptyList()`)을 사용.
  - **업데이트 처리**: JPA의 변경 감지(dirty checking)를 사용하지 않고, 도메인 모델에서 변경된 상태를 새 엔티티로 매핑하여 저장합니다.
  - **JPA 동작 보장**: 불변 필드는 JPA의 리플렉션으로 설정되며, 엔티티는 항상 새 객체로 생성되어 영속성 컨텍스트에 반영됩니다.
- **예외**: 실시간 외부 시스템 동기화 등 특수 요구사항이 있을 경우, `var` 사용을 허용하며 문서화합니다.

###### 2.6.1.2.4 도메인 로직 배제

- **규칙**: JPA 엔티티에는 비즈니스 로직을 포함시키지 않습니다.
- **목적**: 로직은 `Domain` 레이어의 Aggregate와 Value Object에서 처리하며, JPA 엔티티는 데이터 홀더 역할만 수행합니다(섹션 5.3.1).

###### 2.6.1.2.5 Kotlin 플러그인 사용

- **규칙**: `kotlin-jpa`와 `kotlin-allopen` 플러그인을 적용하여 JPA 요구사항(no-arg 생성자, open 클래스)을 충족합니다.
- **Gradle 설정**:

```kotlin
plugins {
  id("org.jetbrains.kotlin.plugin.jpa") version "1.9.22"
  id("org.jetbrains.kotlin.plugin.allopen") version "1.9.22"
}
allOpen {
  annotation("jakarta.persistence.Entity")
}
```

###### 2.6.1.2.6 ID 필드 처리

- **규칙**:
  - ID는 `val id: Long? = null`로 선언하여 신규 엔티티와 기존 엔티티를 구분합니다.
  - 도메인 모델의 ID는 Value Object(예: `UserId`)로 캡슐화하며, 매핑 시 값을 추출/주입합니다(섹션 19 참조).
- **ID 생성**: `@GeneratedValue`로 자동 생성되며, `GenerationType.IDENTITY`를 기본 사용.
- **예시**:

```kotlin
// 도메인 모델
data class User(val id: UserId?, val name: String, val email: Email)

// Value Object
@JvmInline
value class UserId private constructor(val value: Long) {
  companion object {
	  fun of(value: Long): UserId = UserId(value)
  }
}

// JPA 엔티티
@Entity
@Table(name = "users")
class UserEntity(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,
  val name: String,
  val email: String
)
```

##### 2.6.1.3 작성 패턴

###### 2.6.1.3.1 기본 구조

- **필수 어노테이션**: `@Entity`, `@Table`, `@Id`, `@GeneratedValue`.
- **예시**:

```kotlin
package com.example.infrastructure.user.entity

import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "users")
class UserEntity(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,
  val name: String,
  val email: String
)
```

###### 2.6.1.3.2 관계 설정

- **기본 규칙**: 단방향 관계를 우선 사용하며, 양방향 관계는 명확한 기준에 따라 필요한 경우에만 적용합니다.

- **2.6.1.3.2.1 단방향/양방향 선택 기준**
  - **단방향 관계 사용 시나리오**:
    - 데이터 조회 성능이 중요한 경우 (양방향보다 캐시 효율성이 높음)
    - 관계가 단순하고 역방향 탐색이 필요 없는 경우
    - 부모 엔티티에서 자식 엔티티 접근만 필요한 경우 (예: `Order → OrderItem`)
    - 일반적인 기본 선택지로 사용

  - **양방향 관계 사용 시나리오**:
    - 도메인 로직상 반드시 역방향 참조가 필요한 경우 (예: `OrderItem`에서 `Order` 정보 필요)
    - 양쪽에서 조회 성능이 중요한 경우 (JOIN 없이 탐색)
    - 복잡한 집계 쿼리나 보고서가 필요한 경우
    - 관계의 소유권이 명확히 양쪽에 필요한 경우

  - **양방향 관계 관리 규칙**:
    - 관계의 소유자를 명확히 정의 (`@ManyToOne` 쪽이 소유자)
    - 양방향 관계는 도메인 모델에서도 명시적으로 처리하며, 매핑 시 일관성 보장
    - 양방향 관계의 동기화는 도메인 모델에서 처리한 후 매핑으로 반영

  - **컬렉션 처리**: `@OneToMany` 등 컬렉션은 불변 리스트(`List<T>`)로 정의하며, 관계 변경은 도메인 모델에서 처리 후 매핑으로 반영.
  - **예시**:

```kotlin
package com.example.infrastructure.order.entity

import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.persistence.ManyToOne
import jakarta.persistence.JoinColumn
import jakarta.persistence.FetchType

// 단방향 관계 예시
@Entity
@Table(name = "orders")
class OrderEntity(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,
  val customerId: Long,
  // Order → OrderItem 단방향 관계
  @OneToMany(mappedBy = "order")
  val items: List<OrderItemEntity> = emptyList()
)

// 양방향 관계 예시
@Entity
@Table(name = "order_items")
class OrderItemEntity(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,
  val productId: Long,
  val quantity: Int,
  // OrderItem → Order 역방향 관계 (양방향 완성)
  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "order_id")
  val order: OrderEntity? = null
)
```

###### 2.6.1.3.3 컬럼 속성 정의

- **규칙**: `@Column`으로 제약 조건을 명시하며, 데이터베이스 스키마와 일치시킵니다.
- **예시**:

```kotlin
@Entity
@Table(name = "users")
class UserEntity(
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  val id: Long? = null,
  @Column(nullable = false, length = 100)
  val name: String,
  @Column(nullable = false, unique = true)
  val email: String
)
```

###### 2.6.1.3.4 Fetch 전략 가이드

- **기본 규칙**: 모든 관계는 기본적으로 Lazy 로딩을 사용합니다.

- **2.6.1.3.4.1 Lazy vs Eager 선택 기준**
  - **Lazy 로딩 (기본 권장)**:
    - 대부분의 관계에 적용
    - 대용량 데이터나 복잡한 객체 그래프에 필수
    - 필요할 때만 데이터를 로드하여 메모리 효율성 확보
    - 적용 방법: `@ManyToOne(fetch = FetchType.LAZY)`

  - **Eager 로딩 (제한적 사용)**:
    - 다음 조건을 모두 만족할 때만 사용:
      - 컬렉션 크기가 10 미만으로 확정적인 경우
      - 부모 엔티티 조회 시 항상 자식 엔티티가 필요한 경우
      - 참조 엔티티가 불변이거나 거의 변경되지 않는 경우
    - 예시: 국가-도시 관계 (`Country → City`)에서 국가 수가 제한적이고 변경이 드문 경우

- **2.6.1.3.4.2 N+1 문제 해결 전략**
  - **@EntityGraph 사용**:
    - **적합한 상황**: 여러 관계를 동시에 로드해야 하는 복잡한 조회
    - **장점**: 명확한 관계 정의, 일관된 조회 패턴 제공
    - **단점**: 너무 많은 조인 시 성능 저하 가능성
    - **구현 예시**:

```kotlin
@EntityGraph(attributePaths = ["items", "customer"])
fun findWithItemsAndCustomerById(id: Long): Optional<OrderEntity>
```

- **JOIN FETCH 사용**:
  - **적합한 상황**: 단일 관계 조회 또는 간단한 JPQL 쿼리
  - **장점**: 더 세밀한 제어 가능, 복잡한 WHERE 조건 적용 가능
  - **단점**: 쿼리 작성 및 관리 부담
  - **구현 예시**:

```kotlin
@Query("SELECT o FROM OrderEntity o JOIN FETCH o.items WHERE o.id = :id")
fun findWithItemsById(id: Long): Optional<OrderEntity>
```

- **Batch Size 설정**:
  - **적합한 상황**: 다수의 엔티티에서 동일한 관계를 로드하는 경우
  - **장점**: N+1 문제를 최소화하면서 Lazy 로딩의 유연성 유지
  - **구현 예시**:

```kotlin
@BatchSize(size = 20)
@OneToMany(mappedBy = "order")
val items: List<OrderItemEntity> = emptyList()
```

- **2.6.1.3.4.3 성능 테스트 규칙**
  - Fetch 전략 변경 시 반드시 Kotest로 N+1 발생 여부를 검증합니다.
  - SQL 로그를 캡처하여 실제 발생하는 쿼리 수를 검증해야 합니다.
  - 테스트 예시:

```kotlin
// 로그 캡처 및 쿼리 수 검증 테스트
test("주문과 아이템을 조회할 때 N+1 문제가 발생하지 않는다") {
	val orders = orderRepository.findAllWithItems()

	// 로그 캡처 또는 카운터로 쿼리 수 확인
	queryCounter.count shouldBe 1 // 단일 쿼리로 모든 데이터 조회
}
```

- **세부사항**:
  - `@ManyToOne`, `@OneToOne`: 기본값이 EAGER이므로 명시적으로 `FetchType.LAZY`로 설정.
  - `@OneToMany`, `@ManyToMany`: 기본값이 LAZY이므로 추가 설정 불필요.
- **예시**:

```kotlin
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "order_id")
val order: OrderEntity? = null
```

##### 2.6.1.4 도메인 모델과의 매핑

###### 2.6.1.4.1 기본 규칙

- **위치**: 매핑 로직은 `Infrastructure` 레이어에서 정의하며, 필요 시 `Application` 레이어로 이동 가능(섹션 5.3.3).
- **방식**: MapStruct를 사용하지 않고, 코틀린 확장 함수를 사용하여 직접 매핑 로직을 작성합니다.
- **목적**: 도메인 레이어의 순수성을 유지하며, 매핑 과정의 명시성과 제어를 강화합니다.

###### 2.6.1.4.2 매핑 클래스 정의

- **규칙**: 각 도메인별로 전용 확장 함수 파일을 `extensions` 폴더에 작성합니다.
- **네이밍**: `{Domain}EntityExtensions.kt` 형식 (예: `UserEntityExtensions.kt`).
- **예시**:

```kotlin
package com.example.infrastructure.user.extensions.entity

import com.example.infrastructure.user.entity.UserEntity
import com.example.domain.user.User
import com.example.domain.user.vo.UserId
import com.example.domain.user.vo.Email

fun UserEntity.toDomain(): User {
  return User(
	  id = this.id?.let { UserId.of(it) },
	  name = this.name,
	  email = Email.of(this.email)
  )
}

fun User.toEntity(): UserEntity {
  return UserEntity(
	  id = this.id?.value,
	  name = this.name,
	  email = this.email.value
  )
}
```

###### 2.6.1.4.3 매핑 방향

- **To Entity**: 도메인 모델의 최종 상태를 JPA 엔티티로 변환하는 확장 함수 구현 (`User.toEntity()`).
- **To Domain**: JPA 엔티티를 도메인 모델로 변환하는 확장 함수 구현 (`UserEntity.toDomain()`), Value Object 생성 규칙을 준수(섹션 19).
- **예외 처리**: 변환 중 유효성 검사 실패 시 `IllegalArgumentException`을 발생시킵니다. (VO 생성자 내에서 처리)

###### 2.6.1.4.4 관계 매핑

- **규칙**: `@OneToMany` 등 관계는 도메인 모델의 컬렉션으로 변환하며, 불변성을 유지합니다.
- **하위 엔티티 매핑**:
  - 상위 엔티티 참조는 매핑 시 설정하며, 생성자에서 주입하지 않습니다.
  - 컬렉션은 도메인 모델에서 변경 후 전체를 새로 매핑합니다.
- **예시**:

```kotlin
package com.example.infrastructure.order.extensions.entity

import com.example.infrastructure.order.entity.OrderEntity
import com.example.infrastructure.order.entity.OrderItemEntity
import com.example.domain.order.Order
import com.example.domain.order.OrderItem
import com.example.domain.order.vo.OrderId

fun OrderEntity.toDomain(): Order {
  return Order(
	  id = this.id?.let { OrderId.of(it) },
	  customerId = this.customerId,
	  items = this.items.map { it.toDomain() } // OrderItemEntity -> OrderItem 변환 확장 함수 호출
  )
}

fun Order.toEntity(): OrderEntity {
  val orderEntity = OrderEntity(
	  id = this.id?.value,
	  customerId = this.customerId
  )
  val items = this.items.map { it.toEntity(orderEntity) } // OrderItem -> OrderItemEntity 변환 확장 함수 호출, OrderEntity 참조 전달
  orderEntity.items = items // OrderEntity 에 items 설정
  return orderEntity
}

fun OrderItemEntity.toDomain(): OrderItem {
  return OrderItem(
	  productId = this.productId,
	  quantity = this.quantity
  )
}

fun OrderItem.toEntity(orderEntity: OrderEntity): OrderItemEntity {
  return OrderItemEntity(
	  productId = this.productId,
	  quantity = this.quantity,
	  order = orderEntity // OrderEntity 참조 설정
  )
}
```

###### 2.6.1.4.5 영속성 컨텍스트 관리

- **규칙**: Repository는 도메인 객체(`Order`)를 반환하며, JPA 엔티티(`OrderEntity`)는 `Infrastructure` 레이어 내부에서만 사용됩니다.

- **업데이트 패턴**:

1. 도메인 ID로 기존 도메인 객체 조회.

2. 도메인 로직으로 상태 변경.

3. 변경된 도메인 모델을 새 엔티티로 매핑 후 저장.

4. 저장된 결과를 도메인 객체로 변환하여 반환.

```kotlin
@Service
class OrderService(
    private val orderRepository: OrderRepository
) {
    @Transactional
    fun addItem(orderId: OrderId, newItem: OrderItem): Order {
        val order = orderRepository.findById(orderId)
            .orElseThrow { IllegalArgumentException("Order not found: $orderId") }
        val updatedOrder = order.addItem(newItem)
        return orderRepository.save(updatedOrder)
    }
}

@Repository
class OrderRepositoryImpl(
    private val jpaOrderRepository: SpringDataJpaOrderRepository
) : OrderRepository {
    override fun findById(id: OrderId): Optional<Order> {
        return jpaOrderRepository.findById(id.value)
            .map { it.toDomain() } // 확장 함수를 통한 변환
    }

    override fun save(order: Order): Order {
        val entity = order.toEntity() // 확장 함수를 통한 변환
        val savedEntity = jpaOrderRepository.save(entity)
        return savedEntity.toDomain() // 확장 함수를 통한 변환
    }
}
```

###### 2.6.1.4.6 주의사항

- **성능**: 빈번한 객체 생성으로 인한 오버헤드를 줄이기 위해, 매핑 로직을 최적화하거나 캐싱을 고려합니다.
- **테스트**: 매핑 로직은 Kotest로 양방향 변환을 검증합니다(섹션 18.4.3).

##### 2.6.1.5 주의사항

- **도메인 순수성**: JPA 어노테이션은 `Infrastructure` 레이어에만 포함되며, 도메인 레이어에 침투하지 않습니다(섹션 5.1).
- **관계 관리**: 양방향 관계는 최소화하며, 불변 리스트로 관리합니다.
- **성능**: 복잡한 관계 매핑 시 N+1 문제를 방지하기 위해 `@EntityGraph` 또는 쿼리 최적화를 적용합니다.
- **테스트**: JPA 엔티티는 Testcontainers로 실제 DB 환경에서 테스트하며, H2와의 차이를 검증합니다(섹션 18.4.3).

##### 2.6.1.6 장점

- **분리**: 도메인과 데이터베이스 로직의 명확한 분리로 유지보수성이 향상됩니다.
- **불변성**: 상태 변경을 도메인에서 관리하여 예측 가능성이 높아집니다.
- **안정성**: 기술적 의존성이 도메인에 영향을 주지 않습니다.

## 3. API 개발 규칙

### 3.1 API 설계 규칙

#### 3.1.1 REST API 응답 규칙

##### 3.1.1.1 Command 요청에 대한 REST 응답 규칙

- **3.1.1.1.1 동기 응답**
  - **특징**: 프레젠테이션 레이어에서 제공되며, 애플리케이션 레이어의 Command 실행 결과를 기반으로 최소한의 메타데이터를 반환합니다.
  - **필수 필드**: `status`, `message`, `correlationId` (결과 확인용 식별자)
  - **예시**:

```json
      {
        "status": "success",
        "message": "요청이 처리되었습니다.",
        "correlationId": "correlation123"
      }
```

- **3.1.1.1.2 비동기 응답**
  - **특징**: 프레젠테이션 레이어에서 제공되며, URL 처리는 프레젠테이션 레이어에서만 수행합니다. 애플리케이션 레이어는 `jobId`만 제공합니다.
  - **필수 필드**: `status`, `message`, `jobId`, 상태 조회 및 관리용 링크
  - **예시**:

```json
      {
        "status": "accepted",
        "message": "요청이 접수되었습니다.",
        "jobId": "job12345",
        "links": [
          {
            "rel": "job-status-ws",
            "href": "wss://example.com/ws/job-status/job12345",
            "type": "ws",
            "action": "subscribe"
          },
          {
            "rel": "job-none-ws",
            "href": "/api/v1/jobs/status/job12345",
            "type": "http",
            "method": "GET",
            "action": "get-status"
          }
        ]
      }
```

##### 3.1.1.2 Command 리턴 규칙 (Application Layer)

- **3.1.1.2.1 기본 원칙**
  - **규칙**: Command 핸들러는 상태 변경만 수행하며, 비즈니스 데이터(예: 생성된 엔티티의 상세 정보)를 반환하지 않습니다.
  - **참고**: 결과 확인용 `correlationId` 또는 `jobId`는 반환 가능하며, 이는 프레젠테이션 레이어에서 처리됩니다.

- **3.1.1.2.2 동기 Command 처리**
  - **리턴 값**: `CommandResult` 객체
  - **필수 필드**:
    - `success`: boolean
    - `correlationId`: string
  - **예시**:

```json
      {
        "success": true,
        "correlationId": "corr-456"
      }
```

- **3.1.1.2.3 비동기 Command 처리**
  - **리턴 값**: `AsyncCommandResult` 객체
  - **필수 필드**:
    - `success`: boolean
    - `jobId`: string
  - **예시**:

```json
      {
        "success": true,
        "jobId": "job-789"
      }
```

- **참고**: 상태 추적은 데이터베이스 테이블 또는 메시지 큐를 통해 관리되며, 이벤트 소싱은 사용하지 않습니다.

- **3.1.1.2.4 실패 처리**
  - **리턴 값**: `CommandResult` 또는 `AsyncCommandResult` 객체에 오류 정보 포함
  - **필수 필드**:
    - `success`: false
    - `errorCode`: string
  - **예시**:

```json
      {
        "success": false,
        "errorCode": "VALIDATION_ERROR"
      }
```

- **참고**: 실패 시 프레젠테이션 레이어에서 `ProblemDetail`을 사용해 RFC 7807 형식으로 변환되며, 자세한 내용은 섹션 12. 에러 처리를 참조하세요.

- **3.1.1.2.5 구현 참고**
  - **동기 Command 핸들러 예시**:

```kotlin
      class CreateUserCommandHandler(
          private val userRepository: UserRepository
      ) {
          fun handle(command: CreateUserCommand): CommandResult {
              userRepository.save(User(command.name, command.email))
              return CommandResult(true, UUID.randomUUID().toString())
          }
      }
```

- **프레젠테이션 계층에서의 변환 (Kotlin 확장 함수 사용)**:

```kotlin
      @RestController
      @RequestMapping("/api/v1/users")
      class UserController(
          private val createUserCommandHandler: CreateUserCommandHandler
      ) {
          @PostMapping
          fun createUser(@RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
              val command = request.toCommand() // 확장 함수 호출
              val result = createUserCommandHandler.handle(command)
              return ResponseEntity.ok(mapOf(
                  "status" to "success",
                  "message" to "요청이 처리되었습니다.",
                  "correlationId" to result.correlationId
              ))
          }
      }
```

#### 3.1.2 Query 전략

##### 3.1.2.1 페이지네이션

- **규칙**: 다건 조회는 페이지네이션을 적용.
- **방식**: 결정 시 커서 페이지네이션을 기본.

#### 3.1.3 HATEOAS 및 URI 템플릿 사용 규칙

##### 3.1.3.1 목적

- RESTful API에서 클라이언트가 하드코딩된 URL에 의존하지 않고, 동적으로 제공되는 링크를 통해 리소스를 탐색할 수 있도록 HATEOAS(Hypermedia as the Engine of Application State)를 적용합니다.
- URI 템플릿을 활용하여 경로 변경에 유연하게 대응합니다.

##### 3.1.3.2 기본 규칙

- **의존성**: Spring HATEOAS(`spring-boot-starter-hateoas`)를 사용합니다.
- **링크 포함**: 성공적인 Command 요청(동기/비동기) 응답에는 관련 리소스 상태 확인 또는 다음 작업을 위한 링크를 포함합니다.
- **실패 응답**: 링크는 선택 사항이며, 오류 해결을 위한 추가 링크(예: 재시도)가 있다면 포함 권장. 실패 응답은 `ProblemDetail`을 사용하여 처리되며, 섹션 12. 에러 처리를 참조하세요.

##### 3.1.3.3 링크 구조

- **필수 필드**: 모든 링크는 `rel`(관계), `href`(URL), `method`(HTTP 메서드)를 포함합니다.
- **형식**:

```kotlin
  mapOf(
      "rel" to "관계_이름",
      "href" to "리소스_URL",
      "method" to "HTTP_메서드"
  )
```

- **예시**:

```kotlin
  mapOf(
      "rel" to "job-status",
      "href" to "/api/v1/jobs/status/job123",
      "method" to "GET"
  )
```

##### 3.1.3.4 URI 템플릿 사용

- **하드코딩 금지**: 링크 경로는 하드코딩하지 않고, Spring HATEOAS의 `linkTo`와 `methodOn`을 사용해 동적으로 생성합니다.
- **형식**:

```kotlin
  linkTo<컨트롤러_클래스> { 메서드(파라미터) }.withRel("관계_이름")
```

- **예시**:

```kotlin
  val statusLink = linkTo<JobStatusController> { getJobStatus(jobId) }.withRel("job-status")
```

##### 3.1.3.5 비동기 Command 규칙

- **필수 링크**: 비동기 응답에는 작업 상태 확인을 위한 `job-status` 링크를 포함하며, `jobId`를 기반으로 생성합니다.
- **예시**:

```kotlin
  val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
  "links" to listOf(mapOf("rel" to statusLink.rel.value(), "href" to statusLink.href, "method" to "GET"))
```

##### 3.1.3.6 응답 형식

- **규칙**: 링크는 응답의 `links` 필드에 `List<Map<String, String>>`로 포함됩니다.
- **예시**:

```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job123",
    "links": [
      {
        "rel": "job-status",
        "href": "/api/v1/jobs/status/job123",
        "method": "GET"
      }
    ]
  }
```

##### 3.1.3.7 구현 참고

- **비동기 Command 예시 (Kotlin 확장 함수 사용)**:

```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserAsyncCommandController(
      private val handler: CreateUserAsyncCommandHandler
  ) {
      @PostMapping("/async")
      fun createUserAsync(@RequestBody request: UserCreateRequest): ResponseEntity<Map<String, Any>> {
          val command = request.toCommand() // 확장 함수 호출
          val result = handler.handle(command)
          val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
          return if (result.success) {
              ResponseEntity.accepted().body(mapOf(
                  "status" to "accepted",
                  "message" to "요청이 접수되었습니다.",
                  "jobId" to result.jobId,
                  "links" to listOf(mapOf(
                      "rel" to statusLink.rel.value(),
                      "href" to statusLink.href,
                      "method" to "GET"
                  ))
              ))
          } else {
              // ProblemDetail을 사용한 에러 응답은 섹션 12.8 참조
              throw ApplicationException("비동기 작업 실패")
          }
      }
  }
```

##### 3.1.3.8 준수 사항

- **컨트롤러 메서드 명명**: `linkTo`가 참조하므로 메서드 이름은 명확해야 합니다(예: `getJobStatus`).
- **테스트**: `MockMvc`를 사용해 링크 생성을 검증합니다.
- **문서화**: Swagger와 통합 시 `links` 필드를 명시적으로 정의합니다.

#### 3.1.4 Presentation 레이어 Validation

##### 2.1.4.1 목적

- **목적**: 클라이언트로부터 입력받은 데이터의 유효성을 검증하여 잘못된 요청을 조기에 차단하고, 시스템의 안정성과 데이터 무결성을 보장합니다.

##### 2.1.4.2 규칙

- **규칙**: Presentation 레이어에서 요청 데이터(`Request DTO`)의 유효성 검사는 `jakarta.validation.constraints` 패키지의 어노테이션을 적극 활용하여 수행합니다.

##### 2.1.4.3 의존성

- **의존성**: Spring Boot Starter Validation(`spring-boot-starter-validation`)을 사용하며, Gradle에 추가합니다.
  - **설정 예시**:

```groovy
dependencies {
	implementation "org.springframework.boot:spring-boot-starter-validation"
}
```

##### 2.1.4.4 적용 방식

- **적용 방식**:
  - 모든 `Request DTO` 필드에 대해 적절한 검증 어노테이션을 적용합니다.
  - 컨트롤러 메서드에서 `@Valid` 어노테이션을 사용하여 유효성 검사를 트리거합니다.
  - 검증 실패 시, Spring의 `MethodArgumentNotValidException`을 통해 `ProblemDetail` 형식으로 에러 응답을 반환합니다(12.7 글로벌 예외 처리 참조).

##### 2.1.4.5 주요 검증 어노테이션

- **주요 검증 어노테이션**:
  - `@NotNull`: 필수 입력값 검증
  - `@NotBlank`: 공백 문자열 방지 (문자열에 적용)
  - `@Size`: 문자열 길이 또는 컬렉션 크기 제한
  - `@Min` / `@Max`: 숫자 값의 범위 제한
  - `@Email`: 이메일 형식 검증
  - `@Pattern`: 정규 표현식을 통한 형식 검증
  - 기타: 프로젝트 요구사항에 따라 커스텀 어노테이션 정의 가능

##### 2.1.4.6 예시

- **예시**:
  - **Request DTO 정의**:

```kotlin
data class UserCreateRequestV1(
  @field:NotBlank(message = "이름은 필수입니다.")
  @field:Size(min = 2, max = 50, message = "이름은 2~50자 사이여야 합니다.")
  val name: String,

  @field:NotBlank(message = "이메일은 필수입니다.")
  @field:Email(message = "유효한 이메일 형식이어야 합니다.")
  val email: String,

  @field:NotBlank(message = "비밀번호는 필수입니다.")
  @field:Size(min = 8, max = 20, message = "비밀번호는 8~20자 사이여야 합니다.")
  @field:Pattern(
	  regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d@$!%*#?&]+$",
	  message = "비밀번호는 영문자와 숫자를 포함해야 합니다."
  )
  val password: String
)
```

- **컨트롤러에서 사용**:

```kotlin
@RestController
@RequestMapping("/api/v1/users")
class UserCommandController(
  private val createUserCommandHandler: CreateUserCommandHandler
) {
  @PostMapping
  fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
	  val command = request.toCommand() // 확장 함수 호출
	  val result = createUserCommandHandler.handle(command)
	  return ResponseEntity.ok(mapOf(
		  "status" to "success",
		  "message" to "요청이 처리되었습니다.",
		  "correlationId" to result.correlationId
	  ))
  }
}
```

##### 2.1.4.7 에러 응답

- **에러 응답**: 검증 실패 시, `ProblemDetail`을 사용하여 RFC 7807 형식을 따르며, 필드별 에러 메시지를 확장 필드 `invalid-params`로 포함합니다.
  - **예시 응답**:

```json
{
  "type": "https://example.com/probs/invalid-params",
  "title": "Invalid Input",
  "status": 400,
  "detail": "입력 데이터가 유효하지 않습니다.",
  "instance": "/api/v1/users",
  "errorCode": "VALIDATION_ERROR",
  "timestamp": "2025-03-24T10:00:00Z",
  "invalid-params": [
	  {
		  "field": "name",
		  "message": "이름은 필수입니다."
	  },
	  {
		  "field": "email",
		  "message": "유효한 이메일 형식이어야 합니다."
	  }
  ]
}
```

#### 3.1.5 에러 처리 규칙

##### 3.1.5.1 에러 처리 목적

- **목적**: 시스템의 안정성을 유지하고, 클라이언트에게 RFC 7807("Problem Details for HTTP APIs")에 준수하는 명확한 에러 메시지를 제공하기 위해 일관된 에러 처리 전략을 정의합니다.
- **필수 준수사항**: 이 문서에서 정의하는 모든 에러 처리 규칙은 프로젝트의 모든 구성원이 반드시 따라야 하는 강제적인 규칙입니다. 일관된 에러 처리는 디버깅과 유지보수를 크게 향상시킵니다.

##### 3.1.5.2 레이어별 에러 처리

- **Presentation 레이어**:
  - **역할**: 클라이언트의 요청을 검증하고, 애플리케이션 레이어로 전달하기 전에 유효성 검사를 수행합니다.
  - **에러 유형**: 요청 데이터의 유효성 검사 실패, 인증/인가 실패 등.
  - **처리 방식**: `@Valid` 어노테이션을 사용한 유효성 검사, Spring Security를 통한 인증/인가 처리.
  - **응답**: `ProblemDetail`을 사용하여 RFC 7807 형식으로 클라이언트에게 반환.

- **Application 레이어**:
  - **역할**: 비즈니스 로직을 실행하며, 도메인 레이어와 상호작용합니다.
  - **에러 유형**: 비즈니스 규칙 위반, 도메인 로직 에러 등.
  - **처리 방식**: 도메인에서 발생한 예외를 catching하고, `CommandResult` 또는 `AsyncCommandResult`에 에러 정보를 포함하여 반환. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환.
  - **응답**: CommandResult 또는 AsyncCommandResult에 에러 정보를 포함하여 반환.

- **Domain 레이어**:
  - **역할**: 핵심 비즈니스 로직을 포함하며, 도메인 규칙을 준수합니다.
  - **에러 유형**: 도메인 규칙 위반 (예: 무효한 상태 전환).
  - **처리 방식**: 도메인 예외를 throw하여 상위 레이어로 전달.
  - **예외 클래스**: `DomainException`과 같은 커스텀 예외 클래스를 사용.

- **Infrastructure 레이어**:
  - **역할**: 데이터베이스, 외부 API 등과의 통신을 담당합니다.
  - **에러 유형**: 데이터베이스 연결 실패, 외부 API 응답 지연 등.
  - **처리 방식**: 인프라 관련 예외를 catching하고, 애플리케이션 레이어에서 처리할 수 있는 형태로 변환.
  - **예외 클래스**: `InfrastructureException`과 같은 커스텀 예외 클래스를 사용.

##### 3.1.5.3 에러 응답 형식

- **형식**: 모든 에러 응답은 RFC 7807에 따라 JSON 형식으로 반환되며, Spring Boot 3.0 이상에서 제공하는 `ProblemDetail` 클래스를 기본으로 사용합니다. `ProblemDetail`은 다음과 같은 필드를 포함합니다:
  - `type`: 문제 유형을 식별하는 URI (기본값: "about:blank")
  - `title`: 문제 유형에 대한 간단한 설명 (문제 유형별 고정 문자열)
  - `status`: HTTP 상태 코드 (`UserErrorCode` enum에 정의된 `HttpStatus` 값과 연계)
  - `detail`: 문제에 대한 인스턴스별 설명
  - `instance`: 문제를 발생시킨 특정 요청을 식별하는 URI (선택적)
  - 확장 필드: `errorCode` (에러 식별용 고유 코드), `timestamp` (에러 발생 시각) 등은 `setProperty` 메서드를 통해 추가됩니다.
- **예시**:

```json
{
"type": "https://example.com/probs/user-not-found",
"title": "User Not Found",
"status": 404,
"detail": "사용자를 찾을 수 없습니다.",
"instance": "/api/v1/users/123",
"errorCode": "USER_NOT_FOUND",
"timestamp": "2025-03-24T12:00:00Z"
}
```

##### 3.1.5.4 ProblemDetail 활용 패턴 (Presentation Layer)

- **필수 구현 규칙**: Presentation Layer (Controller)에서는 다음과 같은 패턴으로 ProblemDetail을 생성하고 반환해야 합니다:

1. **ProblemDetail 객체 생성 및 HttpStatus 설정 (필수)**:
   - `ProblemDetail.forStatus(HttpStatus)` 메서드를 사용하여 객체 생성과 상태 코드 설정을 동시에 수행합니다.
   - 이 때 HttpStatus는 UserErrorCode enum의 status 필드를 사용해야 합니다.

2. **필수 속성 설정**:
   - 모든 ProblemDetail 객체는 다음 속성을 반드시 설정해야 합니다:
     - `type`: 문제 유형 URI (`type = URI.create("https://example.com/probs/${error.code.lowercase()}")`)
     - `title`: 에러 유형 이름 (`title = error.code`)
     - `detail`: 상세 에러 메시지 (`detail = error.message` 또는 예외 메시지)
     - `errorCode`: 에러 코드 (`setProperty("errorCode", error.code)`)
     - `timestamp`: 발생 시간 (`setProperty("timestamp", Instant.now().toString())`)

3. **apply 람다 블록 사용 (필수)**:
   - 속성 설정에는 반드시 `.apply { ... }` 람다 블록을 사용하여 가독성을 높이고 일관된 코드 스타일을 유지해야 합니다.

4. **ResponseEntity 반환 (필수)**:
   - ProblemDetail 객체는 `ResponseEntity.status(error.status).body(problemDetail)` 형태로 반환해야 합니다.
   - 절대 ProblemDetail 객체를 직접 반환하지 않습니다.

5. **필수 코드 패턴 예시**:

```kotlin
@RestController
@RequestMapping("/api/v1/users")
class UserCommandController(
    private val createUserCommandHandler: CreateUserCommandHandler
) {
    @PostMapping
    fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
        val command = request.toCommand()
        val result = createUserCommandHandler.handle(command)
        
        return if (result.success) {
            ResponseEntity.ok(mapOf(
                "status" to "success",
                "message" to "요청이 처리되었습니다.",
                "correlationId" to result.correlationId
            ))
        } else {
            // 필수 - UserErrorCode enum 활용
            val error = UserErrorCode.fromCode(result.errorCode)
            
            // 필수 - ProblemDetail 생성 및 apply 람다 블록 활용
            val problem = ProblemDetail.forStatus(error.status).apply {
                type = URI.create("https://example.com/probs/${error.code.lowercase()}")
                title = error.code
                detail = error.message
                instance = URI.create("/api/v1/users")
                setProperty("errorCode", error.code)
                setProperty("timestamp", Instant.now().toString())
            }
            
            // 필수 - ResponseEntity 반환
            ResponseEntity.status(error.status).body(problem)
        }
    }
}
```

6. **Validation 에러 처리**:
   - 검증 실패 시 `invalid-params` 필드를 추가하여 모든 필드 에러 정보를 포함해야 합니다:

```kotlin
val problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
    type = URI.create("https://example.com/probs/validation-error")
    title = "VALIDATION_ERROR"
    detail = "입력 값이 유효하지 않습니다"
    instance = URI.create(request.requestURI)
    setProperty("errorCode", "VALIDATION_ERROR")
    setProperty("timestamp", Instant.now().toString())
    setProperty("invalid-params", errors.map { error ->
        mapOf(
            "field" to error.field,
            "message" to error.defaultMessage
        )
    })
}
```

7. **주의사항**:
   - 모든 컨트롤러에서 에러 응답은 반드시 위 패턴을 준수해야 합니다.
   - ProblemDetail 속성 설정 순서는 위 예제의 순서를 따라야 합니다.
   - 커스텀 속성은 반드시 `setProperty()` 메서드로 추가합니다.

##### 3.1.5.5 UserErrorCode enum 활용 패턴 (전반적인 레이어)

- **필수 구현 규칙**: 모든 에러 코드는 `UserErrorCode`(또는 도메인별 에러 코드 Enum)로 관리해야 하며, 프로젝트 전반에 다음과 같은 패턴으로 사용해야 합니다:

1. **UserErrorCode enum 기본 구조 (필수)**:

```kotlin
enum class UserErrorCode(
    val code: String,
    val message: String,
    val status: HttpStatus
) {
    // 도메인 에러
    NOT_FOUND("USER_NOT_FOUND", "사용자를 찾을 수 없습니다.", HttpStatus.NOT_FOUND),
    DUPLICATE_EMAIL("DUPLICATE_EMAIL", "이미 등록된 이메일입니다.", HttpStatus.CONFLICT),
    
    // 인증 관련 에러
    UNAUTHORIZED("UNAUTHORIZED", "인증에 실패했습니다.", HttpStatus.UNAUTHORIZED),
    FORBIDDEN("FORBIDDEN", "접근 권한이 없습니다.", HttpStatus.FORBIDDEN),
    
    // 입력값 검증 에러
    INVALID_INPUT("INVALID_INPUT", "입력값이 유효하지 않습니다.", HttpStatus.BAD_REQUEST),
    
    // 기본 에러
    UNKNOWN("UNKNOWN_ERROR", "알 수 없는 오류가 발생했습니다.", HttpStatus.INTERNAL_SERVER_ERROR);

    companion object {
        // 필수 - 코드로 찾는 메서드
        fun fromCode(code: String?): UserErrorCode =
            entries.find { it.code == code } ?: UNKNOWN
    }
}
```

2. **Presentation Layer에서의 활용 (필수)**:
   - Controller에서 CommandResult의 에러 코드를 UserErrorCode로 변환하여 ProblemDetail 생성에 사용:

```kotlin
// controller 내 메서드에서
val error = UserErrorCode.fromCode(result.errorCode)
val problem = ProblemDetail.forStatus(error.status).apply {
    type = URI.create("https://example.com/probs/${error.code.lowercase()}")
    title = error.code
    detail = error.message
    // 나머지 속성 설정
}
```

3. **Application Layer에서의 활용 (필수)**:
   - Command Handler에서 에러 발생 시 UserErrorCode의 code 값을 CommandResult에 포함해야 함:

```kotlin
class CreateUserCommandHandler(
    private val userRepository: UserRepository
) {
    fun handle(command: CreateUserCommand): CommandResult {
        return try {
            // 이메일 중복 체크
            if (userRepository.existsByEmail(command.email)) {
                // 필수 - UserErrorCode enum의 code 값을 errorCode로 사용
                return CommandResult(false, errorCode = UserErrorCode.DUPLICATE_EMAIL.code)
            }
            
            userRepository.save(User(command.name, command.email))
            CommandResult(true, UUID.randomUUID().toString())
        } catch (e: Exception) {
            // 필수 - 예상치 못한 예외는 UserErrorCode.UNKNOWN.code로 반환
            CommandResult(false, errorCode = UserErrorCode.UNKNOWN.code)
        }
    }
}
```

4. **GlobalExceptionHandler에서의 활용 (필수)**:
   - 모든 예외 처리에서 UserErrorCode를 활용하여 일관된 에러 응답 생성:

```kotlin
@ControllerAdvice
class GlobalExceptionHandler {
    
    @ExceptionHandler(UserCommandException::class)
    fun handleUserCommandException(ex: UserCommandException): ResponseEntity<ProblemDetail> {
        // 필수 - fromCode 메서드로 에러코드 변환
        val error = UserErrorCode.fromCode(ex.errorCode)
        val problem = ProblemDetail.forStatus(error.status).apply {
            type = URI.create("https://example.com/probs/${error.code.lowercase()}")
            title = error.code
            detail = ex.message ?: error.message
            instance = URI.create("/api/v1/users")
            setProperty("errorCode", error.code)
            setProperty("timestamp", Instant.now().toString())
        }
        return ResponseEntity.status(error.status).body(problem)
    }
    
    // DomainException, ValidationException 등 처리 메서드도 유사한 패턴으로 구현
}
```

5. **커스텀 예외 클래스 구조 (필수)**:
   - 모든 커스텀 예외는 errorCode를 포함해야 합니다:

```kotlin
// UserCommandException.kt
class UserCommandException(
    val errorCode: String,
    message: String? = null
) : RuntimeException(message ?: UserErrorCode.fromCode(errorCode).message)

// 사용 예시
throw UserCommandException(UserErrorCode.NOT_FOUND.code)
```

6. **주의사항 (필수)**:
   - 모든 에러 코드는 반드시 열거형(Enum)으로 관리해야 합니다.
   - 문자열 리터럴로 에러 코드를 직접 지정하는 것은 금지됩니다.
   - 새로운 에러 유형이 필요할 때는 반드시 해당 도메인의 ErrorCode enum에 추가해야 합니다.
   - 각 도메인별로 별도의 ErrorCode enum을 정의할 수 있으나, 구조와 활용 패턴은 반드시 동일해야 합니다.

##### 3.1.5.6 컨트롤러 레벨 vs 글로벌 예외 처리: 역할 및 선택 기준

컨트롤러 레벨 예외 처리와 글로벌 예외 처리는 서로 보완적인 관계로, 둘 다 프로젝트에 **필수적으로 구현**해야 합니다. 다음은 각각의 역할과 적용 기준을 정의합니다:

| 특성 | 컨트롤러 레벨 예외 처리 | 글로벌 예외 처리 |
|------|---------------------|-----------------|
| **정의** | 특정 컨트롤러 내에서 `@ExceptionHandler` 어노테이션을 사용하여 예외 처리 | `@ControllerAdvice` 또는 `@RestControllerAdvice`를 사용한 전역 예외 처리 |
| **적용 범위** | 해당 컨트롤러 내에서만 발생하는 예외 | 애플리케이션 전체에서 발생하는 모든 예외 |
| **우선순위** | 글로벌 예외 처리보다 높은 우선순위 | 컨트롤러 레벨 예외 처리가 없을 때 적용 |
| **필수 적용 사례** | 1. 컨트롤러 및 API 고유의 비즈니스 예외<br>2. 특정 엔드포인트에만 적용되는 커스텀 예외 처리<br>3. CommandResult 처리 로직 | 1. 시스템 전체 공통 예외(ValidationException 등)<br>2. 예상치 못한 런타임 예외<br>3. 인프라 관련 예외<br>4. 기본 폴백 에러 처리 |
| **장점** | 1. 특정 API에 맞춤형 에러 응답 제공<br>2. 컨트롤러 로직과 직접 연관된 예외 처리 가능<br>3. 특정 API의 비즈니스 로직에 최적화된 처리 | 1. 중복 코드 제거<br>2. 일관된 에러 응답 형식 보장<br>3. 전체 애플리케이션의 예외 처리 통합 관리<br>4. 누락된 예외 처리의 안전망 역할 |
| **단점** | 1. 코드 중복 가능성<br>2. 컨트롤러 간 일관성 유지 어려움 | 1. 컨트롤러별 세부 맞춤형 응답 어려움<br>2. 모든 상황에 일반화된 처리 방식 적용 |

**필수 구현 규칙**:

1. **컨트롤러 레벨 (필수)**:
   - 모든 컨트롤러는 CommandResult의 success 필드에 따른 에러 처리 로직을 포함해야 합니다.
   - 해당 컨트롤러에 특화된 비즈니스 예외는 컨트롤러 레벨에서 처리해야 합니다.

```kotlin
@RestController
class UserController {
    // 컨트롤러 내 메서드들
    
    @ExceptionHandler(UserSpecificException::class)
    fun handleUserSpecificException(ex: UserSpecificException): ResponseEntity<ProblemDetail> {
        val error = UserErrorCode.fromCode(ex.errorCode)
        val problem = ProblemDetail.forStatus(error.status).apply {
            // 필수 속성 설정
        }
        return ResponseEntity.status(error.status).body(problem)
    }
}
```

2. **글로벌 레벨 (필수)**:
   - 모든 프로젝트는 GlobalExceptionHandler 클래스를 구현해야 합니다.
   - 다음 예외 유형에 대한 핸들러 메서드를 반드시 포함해야 합니다:
     - `MethodArgumentNotValidException` (유효성 검증 실패)
     - `HttpMessageNotReadableException` (요청 본문 파싱 실패)
     - `DomainException` (도메인 예외)
     - `ApplicationException` (애플리케이션 예외)
     - `Exception` (일반 예외 - 마지막 폴백)

```kotlin
@RestControllerAdvice
class GlobalExceptionHandler {
    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationException(ex: MethodArgumentNotValidException): ResponseEntity<ProblemDetail> {
        // 유효성 검사 실패 처리 - invalid-params 포함
    }
    
    @ExceptionHandler(DomainException::class)
    fun handleDomainException(ex: DomainException): ResponseEntity<ProblemDetail> {
        // 도메인 예외 처리
    }
    
    // 다른 예외 처리 메서드들
    
    @ExceptionHandler(Exception::class)
    fun handleGenericException(ex: Exception): ResponseEntity<ProblemDetail> {
        // 모든 예외에 대한 기본 폴백 처리
    }
}
```

3. **적용 원칙 (필수)**:
   - **컨트롤러 레벨과 글로벌 레벨 모두 반드시 구현**해야 합니다.
   - 두 계층은 서로 보완 관계이며, 어느 한쪽만 선택해서는 안 됩니다.
   - 모든 예외 처리에서 ProblemDetail 활용 패턴과 UserErrorCode enum 활용 패턴을 준수해야 합니다.
   - 컨트롤러 레벨에서 처리되지 않은 예외는 글로벌 레벨에서 반드시 처리해야 합니다.

4. **중요 원칙**:
   - 모든 예외 처리는 ProblemDetail을 사용해야 합니다.
   - 모든 에러 코드는 UserErrorCode enum(또는 도메인별 ErrorCode enum)에서 관리해야 합니다.
   - 에러 응답의 형식과 구조는 API 전체에서 일관성을 유지해야 합니다.

##### 3.1.5.7 로깅

- **규칙**: 모든 에러는 로깅되며, 로깅 레벨은 에러의 심각도에 따라 다릅니다.
  - **INFO**: 클라이언트의 잘못된 요청 (예: 유효성 검사 실패)
  - **WARN**: 시스템의 일부 기능에 영향을 미치는 에러
  - **ERROR**: 시스템의 주요 기능에 영향을 미치는 심각한 에러
- **로깅 형식**: 에러 코드, 메시지, 스택 트레이스(필요 시) 포함.

##### 3.1.5.8 비동기 에러 처리

- **특징**: 비동기 Command의 경우, 에러가 발생하면 `AsyncCommandResult`에 에러 정보를 포함하여 반환합니다. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환하여 응답합니다.
- **응답 형식** (RFC 7807 준수):

```json
  {
	"type": "https://example.com/probs/async-processing-error",
	"title": "Async Processing Error",
	"status": 400,
	"detail": "비동기 작업 처리에 실패했습니다.",
	"instance": "/api/v1/users/async",
	"errorCode": "ASYNC_PROCESSING_ERROR",
	"timestamp": "2025-03-24T10:00:00Z",
	"jobId": "job123"
  }
```

- **상태 조회**: 클라이언트는 `jobId`를 사용하여 작업의 최종 상태를 조회할 수 있으며, 에러 발생 시 상세 에러 정보를 확인할 수 있습니다.
- **구현 예시**:

```kotlin
@RestController
@RequestMapping("/api/v1/users")
class UserAsyncCommandController(
  private val handler: CreateUserAsyncCommandHandler
) {
  @PostMapping("/async")
  fun createUserAsync(@RequestBody request: UserCreateRequest): ResponseEntity<Any> {
	  val command = request.toCommand() // 확장 함수 호출
	  val result = handler.handle(command)
	  return if (result.success) {
		  ResponseEntity.accepted().body(mapOf(
			  "status" to "accepted",
			  "message" to "요청이 접수되었습니다.",
			  "jobId" to result.jobId
		  ))
	  } else {
		  val error = UserErrorCode.fromCode(result.errorCode)
		  val problem = ProblemDetail.forStatus(error.status).apply {
			  type = URI.create("https://example.com/probs/${error.code.lowercase()}")
			  title = error.code
			  detail = error.message
			  instance = URI.create("/api/v1/users/async")
			  setProperty("errorCode", error.code)
			  setProperty("timestamp", Instant.now().toString())
			  setProperty("jobId", result.jobId)
		  }
		  ResponseEntity.status(error.status).body(problem)
	  }
  }
}
```

#### 3.1.6 API 문서화

##### 3.1.6.1 Presentation 레이어에서 Swagger 적용

- **목적**:
  - API의 명세를 문서화하고, 클라이언트 및 개발자가 쉽게 이해하고 테스트할 수 있도록 Swagger를 Presentation 레이어에 적용합니다. 이를 통해 API의 엔드포인트, 요청/응답 형식, 에러 응답 등을 명확히 정의하고 유지보수성을 높입니다.

- **의존성 설정**:
  - **의존성**: Spring Boot 프로젝트에서 Swagger를 사용하기 위해 `springdoc-openapi` 라이브러리를 사용합니다.
    - **Gradle 설정 예시**:

```groovy
dependencies {
	implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2"
}
```

- **설명**: `springdoc-openapi-starter-webmvc-ui`는 Spring Boot와 통합된 OpenAPI 3 명세를 생성하며, Swagger UI를 기본 제공합니다.

- **기본 설정**:
  - **구성**: Spring Boot의 `@Configuration` 클래스를 통해 Swagger 설정을 커스터마이징합니다.
  - **예시**:

```kotlin
import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfig {
  @Bean
  fun customOpenAPI(): OpenAPI {
	  return OpenAPI()
		  .info(
			  Info()
				  .title("Project API")
				  .version("v1")
				  .description("Spring Boot 기반 프로젝트 API 문서")
			  )
  }
}
```

- **접근 경로**: 기본적으로 `/v3/api-docs`에서 OpenAPI JSON을 확인할 수 있으며, `/swagger-ui.html`에서 Swagger UI에 접근 가능합니다.

- **API 문서화**:
  - **어노테이션 사용**: Presentation 레이어의 컨트롤러에 OpenAPI 어노테이션(`@Operation`, `@ApiResponse`, `@Parameter` 등)을 적용하여 API를 문서화합니다.
  - **규칙**:
    - 모든 엔드포인트는 `@Operation`으로 설명을 추가합니다.
    - 요청/응답 DTO는 스키마로 자동 생성되며, 추가 설명은 `@Schema`로 제공합니다.
    - 에러 응답은 RFC 7807(`ProblemDetail`) 형식을 반영하여 정의합니다(섹션 12 참조).

  - **예시**:

```kotlin
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import jakarta.validation.Valid

@RestController
@RequestMapping("/api/v1/users")
class UserCommandController(
  private val createUserCommandHandler: CreateUserCommandHandler
) {
  @PostMapping
  @Operation(summary = "새로운 사용자 생성", description = "사용자 정보를 입력받아 새로운 사용자를 생성합니다.")
  @ApiResponses(
	  ApiResponse(responseCode = "200", description = "사용자 생성 성공",
		  content = [Content(schema = Schema(implementation = Map::class))]),
	  ApiResponse(responseCode = "400", description = "잘못된 요청 데이터",
		  content = [Content(schema = Schema(implementation = ProblemDetail::class))])
  )
  fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
	  val command = request.toCommand() // 확장 함수 호출
	  val result = createUserCommandHandler.handle(command)
	  return ResponseEntity.ok(mapOf(
		  "status" to "success",
		  "message" to "요청이 처리되었습니다.",
		  "correlationId" to result.correlationId
	  ))
  }
}
```

- **Request DTO 문서화**:
  - **Request DTO 문서화**:

```kotlin
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "사용자 생성 요청 데이터")
data class UserCreateRequestV1(
  @field:Schema(description = "사용자 이름", example = "John Doe", required = true)
  @field:NotBlank(message = "이름은 필수입니다.")
  val name: String,

  @field:Schema(description = "사용자 이메일", example = "john.doe@example.com", required = true)
  @field:NotBlank(message = "이메일은 필수입니다.")
  @field:Email(message = "유효한 이메일 형식이어야 합니다.")
  val email: String
)
```

- **HATEOAS 통합**:
  - **규칙**: 섹션 13에서 정의된 HATEOAS 링크(`links` 필드)를 Swagger 문서에 반영합니다.
  - **구현**: 응답 객체에 `links` 필드를 명시하며, `@Schema`로 설명을 추가합니다.
  - **예시**:

```kotlin
@Operation(summary = "비동기 사용자 생성", description = "비동기로 사용자 생성 요청을 접수합니다.")
@ApiResponses(
  ApiResponse(responseCode = "202", description = "요청 접수 완료",
	  content = [Content(schema = Schema(implementation = Map::class))])
)
@PostMapping("/async")
fun createUserAsync(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
  val command = request.toCommand() // 확장 함수 호출
  val result = handler.handle(command)
  val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
  return ResponseEntity.accepted().body(mapOf(
	  "status" to "accepted",
	  "message" to "요청이 접수되었습니다.",
	  "jobId" to result.jobId,
	  "links" to listOf(mapOf(
		  "rel" to statusLink.rel.value(),
		  "href" to statusLink.href,
		  "method" to "GET"
	  ))
  ))
}
```

- **에러 응답 문서화**:
  - **규칙**: 섹션 12.3에 정의된 `ProblemDetail` 형식을 Swagger에 반영하며, `UserErrorCode` enum을 기반으로 주요 에러를 문서화합니다.
  - **예시**:

```kotlin
@ApiResponses(
  ApiResponse(responseCode = "400", description = "유효성 검사 실패",
	  content = [Content(schema = Schema(implementation = ProblemDetail::class))])
)
```

- **Swagger UI 커스터마이징**:
  - **설정**: `application.yml` 또는 `application.properties`를 통해 Swagger UI 경로와 옵션을 조정 가능합니다.
  - **예시**:

```yaml
springdoc:
  swagger-ui:
	  path: /custom-swagger-ui.html
	  display-request-duration: true
```

- **주의사항**:
  - **버전 관리**: API 버전(`v1`, `v2` 등)에 따라 별도의 Swagger 그룹을 설정하여 문서를 분리할 수 있습니다.
    - 예: `springdoc.group-configs` 설정 사용.
  - **성능**: 대규모 프로젝트에서는 Swagger 생성 시 성능 영향을 최소화하기 위해 필요한 엔드포인트만 노출하도록 필터링 고려.
  - **보안**: 운영 환경에서는 Swagger UI 접근을 제한하거나 비활성화합니다(예: `springdoc.swagger-ui.enabled=false`).

## 4. 비동기 메시징 규칙 (Kafka)

### 4.1 Kafka 기본 규칙

#### 4.1.1 Kafka 및 Avro 사용 규칙

##### 4.1.1.1 목적

Kafka를 활용한 이벤트 기반 아키텍처에서 Avro를 데이터 직렬화 포맷으로 사용하며, 스키마 레지스트리를 통해 스키마를 중앙 집중식으로 관리합니다. 이를 통해 대규모 조직에서의 이벤트 처리(Saga, Request & Response), 외부 도메인 이벤트 발행, 스키마 버전 관리, 공통 데이터 구조의 재사용성을 보장합니다.

##### 4.1.1.2 기본 규칙

- **4.1.1.2.1 기술 스택**
  - **메시징 시스템**: Apache Kafka
  - **직렬화 포맷**: Avro
  - **스키마 관리**: Confluent Schema Registry
  - **Kafka 클라이언트**: Spring Kafka (`spring-kafka`)

- **4.1.1.2.2 아키텍처 원칙**
  - **내부 이벤트**: Kafka를 사용하지 않으며, 애플리케이션 내부에서는 메모리 내 이벤트 버스(예: Spring `ApplicationEvent`)를 활용합니다.
  - **외부 이벤트**: Kafka를 통해 발행하며, 외부 도메인 이벤트와 내부 이벤트를 명확히 구분합니다.
  - **Saga**: 분산 트랜잭션 처리를 위해 Saga 패턴을 적용하며, 이벤트는 상태 변경 명령과 보상 트랜잭션으로 구성됩니다.
  - **Request & Response**: 동기 요청-응답 패턴은 Kafka Streams 또는 별도 HTTP API로 처리하며, 비동기 이벤트는 Kafka 토픽으로 발행합니다。

##### 4.1.1.3 토픽 네이밍 컨벤션

- **4.1.1.3.1 규칙**
  - **형식**: `{environment}.{domain}.{event-type}.{entity}.{version}`
    - `environment`: 운영 환경 (예: `prod`, `staging`, `dev`)
    - `domain`: 도메인 이름 (예: `user`, `order`, `payment`)
    - `event-type`: 이벤트 유형 (예: `domain-event`, `saga`, `request`, `response`)
    - `entity`: 엔티티 이름 (예: `user`, `order`, `transaction`)
    - `version`: 스키마 버전 (예: `v1`, `v2`)
  - **외부용 구분**: 외부 도메인 이벤트는 `domain-event` 유형으로 한정하며, 내부용은 Kafka 토픽을 생성하지 않습니다.
  - **예시**:
    - `prod.user.domain-event.user.v1`: 사용자 도메인의 외부 이벤트 (버전 1)
    - `prod.order.saga.order.v2`: 주문 도메인의 Saga 이벤트 (버전 2)
    - `staging.payment.request.transaction.v1`: 결제 도메인의 요청 토픽 (버전 1)
    - `staging.payment.response.transaction.v1`: 결제 도메인의 응답 토픽 (버전 1)

- **4.1.1.3.2 주의사항**
  - 토픽 이름은 소문자와 하이픈(`-`)만 사용하며, 최대 249자로 제한합니다.
  - 버전은 스키마 레지스트리의 `schemaVersion`과 일치해야 합니다.

##### 4.1.1.4 Avro 스키마 관리

- **4.1.1.4.1 저장 경로**
  - **위치**: 각 도메인 모듈의 `infrastructure` 레이어 내 `avro` 디렉터리에 저장합니다.
  - **구체적 경로**:

```
  domains/
  ├── user/
  │   └── infrastructure/
  │       └── src/main/resources/avro/
  │           ├── user-domain-event-v1.avsc
  │           └── user-saga-v1.avsc
  ├── order/
  │   └── infrastructure/
  │       └── src/main/resources/avro/
  │           ├── order-domain-event-v1.avsc
  │           └── order-saga-v2.avsc
```

- **파일명 형식**: `{entity}-{event-type}-{version}.avsc`

- **4.1.1.4.2 관리 방식**
  - **스키마 정의**: `.avsc` 파일로 작성하며, Confluent Schema Registry에 등록합니다.
  - **버전 관리**: 스키마 변경 시 새로운 `.avsc` 파일을 생성하고, 기존 스키마와의 호환성(Backward, Forward, Full)을 보장합니다.
  - **빌드 프로세스**: Gradle 플러그인(`com.github.davidmc24.gradle.plugin.avro`)을 사용해 `.avsc` 파일로부터 Kotlin 클래스를 자동 생성합니다.
    - **Gradle 설정**:

```groovy
plugins {
	id "com.github.davidmc24.gradle.plugin.avro" version "1.9.1"
}
dependencies {
	implementation "org.apache.avro:avro:1.11.3"
	implementation "io.confluent:kafka-avro-serializer:7.5.0"
}
avro {
	createSetters = false // 불변 객체 생성
	fieldVisibility = "PRIVATE"
}
```

- **생성된 클래스 위치**: `infrastructure/src/main/kotlin/com/example/infrastructure/{domain}/avro/`

- **4.1.1.4.3 예시: `UserDomainEvent` 스키마**

```json
  {
    "namespace": "com.example.infrastructure.user.avro",
    "type": "record",
    "name": "UserDomainEvent",
    "fields": [
      {"name": "envelope", "type": "com.example.common.avro.Envelope"},
      {"name": "payload", "type": {
        "type": "record",
        "name": "UserPayload",
        "fields": [
          {"name": "userId", "type": "long"},
          {"name": "name", "type": "string"},
          {"name": "email", "type": "string"},
          {"name": "eventType", "type": "string"}
        ]
      }}
    ]
  }
```

##### 4.1.1.5 Envelope 구조

- **4.1.1.5.1 정의**
  - **위치**: 공통 모듈(`common`)의 `avro` 디렉터리에 저장.

```
domains/
└── common/
  └── src/main/resources/avro/
	  └── envelope.avsc
```

- **스키마**:

```json
  {
	"namespace": "com.example.common.avro",
	"type": "record",
	"name": "Envelope",
	"fields": [
	  {"name": "schemaVersion", "type": "string"},
	  {"name": "eventId", "type": "string"},
	  {"name": "timestamp", "type": "long", "doc": "Event timestamp in nanoseconds"},
	  {"name": "source", "type": "string"}
	]
  }
```

- **4.1.1.5.2 규칙**
  - **`schemaVersion`**: 토픽 이름의 `version`과 일치 (예: `v1`, `v2`).
  - **`eventId`**: UUID로 고유 식별자 생성.
  - **`timestamp`**: 이벤트 발생 시각을 나노초 단위로 기록 (Unix epoch nanoseconds, `System.nanoTime()` 사용).
  - **`source`**: 이벤트 발행 도메인 (예: `user`, `order`).

- **4.1.1.5.3 사용 예시**

```kotlin
  val envelope = Envelope(
      schemaVersion = "v1",
      eventId = UUID.randomUUID().toString(),
      timestamp = System.nanoTime(), // 나노초 단위 타임스탬프
      source = "user"
  )
  val event = UserDomainEvent(envelope, UserPayload(1L, "John Doe", "john@example.com", "CREATED"))
```

##### 4.1.1.6 공통 파트 관리

- **4.1.1.6.1 위치**
  - **공통 모듈**: `domains/common/`에 위치.
  - **구체적 경로**:

```
domains/
└── common/
  ├── src/main/resources/avro/
  │   └── envelope.avsc
  └── src/main/kotlin/com/example/common/avro/
	  └── Envelope.kt (자동 생성)
```

- **4.1.1.6.2 관리 방식**
  - **재사용**: `Envelope`는 모든 도메인 이벤트에서 공통으로 포함되며, 각 도메인의 `.avsc` 파일에서 참조합니다.
  - **업데이트**: 공통 스키마 변경 시, 모든 도메인에서 호환성 테스트를 수행한 후 배포합니다.
  - **의존성 설정**:

```groovy
dependencies {
  implementation project(":domains:common")
}
```

##### 4.1.1.7 Kafka 사용 패턴

- **4.1.1.7.1 Saga**
  - **토픽**: `{environment}.{domain}.saga.{entity}.{version}`
  - **메시지**: 상태 변경 명령과 보상 트랜잭션 이벤트를 발행.
  - **예시**:

```kotlin
@KafkaListener(topics = ["prod.order.saga.order.v1"])
fun handleSaga(event: OrderSagaEvent) {
  when (event.payload.eventType) {
	  "CREATE" -> processOrderCreation(event)
	  "COMPENSATE" -> compensateOrderCreation(event)
  }
}
```

- **4.1.1.7.2 Request & Response**
  - **토픽**:
    - 요청: `{environment}.{domain}.request.{entity}.{version}`
    - 응답: `{environment}.{domain}.response.{entity}.{version}`
  - **구현**: `correlationId`를 `Envelope.eventId`로 사용해 요청-응답 매핑.
  - **예시**:

```kotlin
@KafkaListener(topics = ["prod.payment.request.transaction.v1"])
fun handleRequest(event: PaymentRequestEvent): PaymentResponseEvent {
  val response = processPayment(event.payload)
  return PaymentResponseEvent(envelope.copy(eventId = event.envelope.eventId), response)
}
```

- **4.1.1.7.3 외부 도메인 이벤트**
  - **토픽**: `{environment}.{domain}.domain-event.{entity}.{version}`
  - **규칙**: 내부 이벤트는 Kafka로 발행하지 않으며, 외부 시스템과의 통신에만 사용.
  - **예시**:

```kotlin
kafkaTemplate.send("prod.user.domain-event.user.v1", UserDomainEvent(envelope, payload))
```

- **4.1.1.8 설정 예시**
  - **4.1.1.8.1 Spring Kafka 설정**

```kotlin
@Configuration
class KafkaConfig {
  @Bean
  fun kafkaTemplate(): KafkaTemplate<String, Any> {
	  return KafkaTemplate(producerConfig())
  }

  private fun producerConfig(): ProducerFactory<String, Any> {
	  val config = mapOf(
		  ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to "localhost:9092",
		  ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
		  ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to KafkaAvroSerializer::class.java,
		  "schema.registry.url" to "http://localhost:8081"
	  )
	  return DefaultKafkaProducerFactory(config)
  }
}
```

- **4.1.1.8.2 스키마 레지스트리 설정**
  - **URL**: `application.yml`에 정의.

```yaml
spring:
  kafka:
	properties:
	  schema.registry.url: http://localhost:8081
```

- **4.1.1.9 주의사항**
  - **스키마 호환성**: 스키마 변경 시 Confluent Schema Registry의 호환성 규칙(기본: Backward)을 준수합니다.
  - **토픽 분리**: 대규모 트래픽을 고려해 도메인별, 이벤트 유형별로 토픽을 세분화합니다.
  - **테스트**: Testcontainers를 사용해 Kafka와 Schema Registry를 포함한 통합 테스트를 작성합니다(섹션 18.3.3 참조).
  - **타임스탬프 정밀도**: `timestamp`는 나노초 단위로 기록되며, 시스템 간 시간 동기화(NTP 등)를 통해 정확성을 보장해야 합니다.
  - **버전 관리**: `schemaVersion`과 토픽 버전이 일치하지 않을 경우 즉시 감지할 수 있도록 모니터링 설정을 추가합니다.

#### 4.1.2 Kafka Producer와 Consumer 작성 가이드

##### 2.3.2.1 목적

이 가이드는 Apache Kafka의 Producer와 Consumer를 작성하고 운영하기 위한 실무 지침을 제공합니다. 기존 문서의 규칙(특히 Avro 사용)을 준수하며, Spring Boot 기반 구현, 성능 최적화, 오류 처리 등을 다룹니다.

##### 2.3.2.2 소개

- **Kafka Producer**: 애플리케이션에서 Kafka 브로커로 Avro 포맷 데이터를 전송합니다.
- **Kafka Consumer**: Kafka 토픽에서 Avro 데이터를 소비하여 처리합니다.
- **적용 사례**: 실시간 이벤트 스트리밍, 대규모 메시지 처리 등.
- **전제 조건**: 본 문서는 섹션 20(Kafka 및 Avro 사용 규칙)을 준수하며, Avro 스키마를 기본 직렬화 방식으로 사용합니다.

##### 2.3.2.3 Producer 기본 작성 가이드

- **2.3.2.3.1 필수 설정**
  - Producer는 Avro 직렬화를 위해 다음 설정을 포함해야 합니다:
    - `bootstrap.servers`: Kafka 브로커 주소 (예: `kafka-broker:9092`)
    - `key.serializer`: `StringSerializer` (키는 문자열로 가정)
    - `value.serializer`: `KafkaAvroSerializer` (Avro 직렬화)
    - `schema.registry.url`: Schema Registry 주소 (예: `http://schema-registry:8081`)

- **2.3.2.3.2 기본 예제 (Spring Boot + Avro)**

```kotlin
@Configuration
class KafkaProducerConfig {
  @Bean
  fun producerFactory(): ProducerFactory<String, GenericRecord> {
	  val config = mapOf(
		  ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to "kafka-broker:9092",
		  ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
		  ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to KafkaAvroSerializer::class.java,
		  "schema.registry.url" to "http://schema-registry:8081"
	  )
	  return DefaultKafkaProducerFactory(config)
  }

  @Bean
  fun kafkaTemplate(): KafkaTemplate<String, GenericRecord> {
	  return KafkaTemplate(producerFactory())
  }
}

@Service
class UserEventProducer(
  private val kafkaTemplate: KafkaTemplate<String, GenericRecord>
) {
  fun sendUserEvent(userId: String, name: String, action: String) {
	  val avroRecord = AvroSchema.userSchema.newRecordBuilder()
		  .setUserId(userId)
		  .setName(name)
		  .setAction(action)
		  .build()
	  kafkaTemplate.send("prod.user.domain-event.user.v1", userId, avroRecord)
		  .whenComplete { result, ex ->
			  if (ex == null) {
				  println("Sent event for $userId with offset=${result.recordMetadata.offset()}")
			  } else {
				  println("Failed to send event for $userId: ${ex.message}")
			  }
		  }
  }
}

// Avro 스키마 예시 (별도 파일 또는 섹션 20 참조)
object AvroSchema {
  val userSchema = SchemaBuilder.record("UserEvent")
	  .fields()
	  .requiredString("userId")
	  .requiredString("name")
	  .requiredString("action")
	  .endRecord()
}
```

- **설명**: Avro 직렬화를 사용하며, 토픽 네임은 `prod.<서비스>.<도메인>-event.<엔티티>.v1` 형식으로 가정(기존 문서 규칙 추정).

##### 2.3.2.4 Consumer 기본 작성 가이드

- **2.3.2.4.1 필수 설정**
  - Consumer는 Avro 역직렬화를 위해 다음 설정을 포함해야 합니다:
    - `bootstrap.servers`: Kafka 브로커 주소
    - `group.id`: Consumer Group 식별자
    - `key.deserializer`: `StringDeserializer`
    - `value.deserializer`: `KafkaAvroDeserializer`
    - `schema.registry.url`: Schema Registry 주소

- **2.3.2.4.2 기본 예제 (Spring Boot + Avro)**

```kotlin
@Configuration
class KafkaConsumerConfig {
  @Bean
  fun consumerFactory(): ConsumerFactory<String, GenericRecord> {
	  val config = mapOf(
		  ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG to "kafka-broker:9092",
		  ConsumerConfig.GROUP_ID_CONFIG to "user-group",
		  ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG to StringDeserializer::class.java,
		  ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG to KafkaAvroSerializer::class.java,
		  "schema.registry.url" to "http://schema-registry:8081",
		  ConsumerConfig.AUTO_OFFSET_RESET_CONFIG to "earliest"
	  )
	  return DefaultKafkaConsumerFactory(config)
  }

  @Bean
  fun kafkaListenerContainerFactory(): ConcurrentKafkaListenerContainerFactory<String, GenericRecord> {
	  val factory = ConcurrentKafkaListenerContainerFactory<String, GenericRecord>()
	  factory.consumerFactory = consumerFactory()
	  return factory
  }
}

@Service
class UserEventConsumer {
  @KafkaListener(topics = ["prod.user.domain-event.user.v1"], groupId = "user-group")
  fun consume(record: GenericRecord) {
	  val userId = record.get("userId").toString()
	  val name = record.get("name").toString()
	  val action = record.get("action").toString()
	  println("Consumed event: userId=$userId, name=$name, action=$action")
  }
}
```

- **설명**: Avro 데이터를 역직렬화하여 처리하며, Consumer Group 기반으로 구현.

##### 2.3.2.5 Producer 설정 모범 사례

- **2.3.2.5.1 메시지 신뢰성 보장**
  - **`acks` 설정**:
    - `acks=all`을 기본으로 사용해 데이터 손실 방지 (기존 문서 규칙 가정).
    - `retries=3`와 `max.in.flight.requests.per.connection=1`으로 순서 보장.
  - **예제**:

```kotlin
val config = mapOf(
  ProducerConfig.ACKS_CONFIG to "all",
  ProducerConfig.RETRIES_CONFIG to 3,
  ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION to 1
)
```

- **2.3.2.5.2 성능 튜닝**
  - **`batch.size`와 `linger.ms`**:
    - Avro 데이터 크기에 따라 `batch.size=32768` (32KB) 권장.
    - `linger.ms=5`로 지연 최소화.
  - **압축**: `compression.type=gzip`으로 Avro 데이터 크기 감소.

- **2.3.2.5.3 오류 처리**
  - **콜백 활용**:

```kotlin
kafkaTemplate.send("topic", avroRecord).whenComplete { _, ex ->
  if (ex != null) retryOrSendToDeadLetter(avroRecord, ex)
}
```

##### 2.3.2.6 Consumer 설정 모범 사례

- **2.3.2.6.1 Consumer Group 운영**
  - **`group.id`와 파티션 할당**:
    - 파티션 수와 Consumer 인스턴스 수를 일치시켜 부하 분산.
    - `max.poll.interval.ms=300000` (5분)으로 재균형 최소화.
  - **예제**:

```kotlin
val config = mapOf(
  ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG to 300000,
  ConsumerConfig.MAX_POLL_RECORDS_CONFIG to 500
)
```

- **2.3.2.6.2 성능 최적화**
  - **Consumer Lag 방지**:
    - `concurrency=3`으로 병렬 처리 설정.
  - **예제**:

```kotlin
@KafkaListener(topics = ["prod.user.domain-event.user.v1"], concurrency = "3")
fun consume(record: GenericRecord) {
  processAvroRecord(record)
}
```

- **2.3.2.6.3 오류 처리**
  - **재시도 및 데드 레터 큐**:

```kotlin
@KafkaListener(topics = ["prod.user.domain-event.user.v1"])
fun consume(record: GenericRecord) {
  try {
	  processAvroRecord(record)
  } catch (e: Exception) {
	  kafkaTemplate.send("dead-letter-topic", record)
  }
}
```

##### 2.3.2.7 실무 예제

- **2.3.2.7.1 실시간 사용자 이벤트 처리**

```kotlin
@Service
class UserEventProducer(
  private val kafkaTemplate: KafkaTemplate<String, GenericRecord>
) {
  fun sendUserEvent(userId: String, name: String, action: String) {
	  val avroRecord = AvroSchema.userSchema.newRecordBuilder()
		  .setUserId(userId)
		  .setName(name)
		  .setAction(action)
		  .build()
	  kafkaTemplate.send("prod.user.domain-event.user.v1", userId, avroRecord)
  }
}

@Service
class UserEventConsumer {
  @KafkaListener(topics = ["prod.user.domain-event.user.v1"], groupId = "user-group")
  fun consume(record: GenericRecord) {
	  val userId = record.get("userId").toString()
	  val name = record.get("name").toString()
	  val action = record.get("action").toString()
	  println("Processed: userId=$userId, name=$name, action=$action")
  }
}
```

##### 2.3.2.8 모니터링 및 운영 팁

- **Consumer Lag 모니터링**: Prometheus와 Grafana로 실시간 추적.
- **스키마 관리**: Schema Registry를 통해 Avro 스키마 버전 관리.
- **로그**: Avro 데이터 처리 로그를 통해 디버깅 용이성 확보.

##### 2.3.2.9 주의사항

- **Avro 스키마 호환성**: 스키마 변경 시 기존 Consumer와의 호환성 확인 (섹션 20 참조).
- **메시지 크기**: Avro 데이터가 1MB를 초과하지 않도록 설계.
- **테스트**: Testcontainers로 Avro 기반 통합 테스트 권장 (섹션 18.4.3 참조).

##### 2.3.2.10 장점

- **일관성**: Avro로 데이터 구조화 및 스키마 관리 용이.
- **확장성**: Consumer Group으로 대규모 처리 가능.
- **호환성**: 기존 문서 규칙 준수로 통합성 유지.

##### 2.3.2.11 멱등성 보장을 위한 EventLog 테이블 설계

- **2.3.2.11.1 `event_log` 테이블 구조 예시**

```sql
  CREATE TABLE event_log (
      event_id        VARCHAR(100) PRIMARY KEY,            -- 메시지 고유 식별자 (예: UUID)
      event_type      VARCHAR(50),                         -- 이벤트 유형 (선택 사항)
      received_at     TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- 메시지 수신 시간
      processed_at    TIMESTAMP,                           -- 처리 완료 시간
      status          VARCHAR(20),                         -- 처리 상태 (예: SUCCESS, FAILED, RETRYING)
      payload_hash    VARCHAR(255),                        -- 메시지 내용 해시값 (선택 사항)
      metadata        JSONB                                -- Kafka 오프셋, 파티션 등 메타 정보 (선택 사항)
  );
```

- `event_id`는 반드시 고유해야 하며, 중복 삽입을 방지하기 위해 **PRIMARY KEY** 또는 **UNIQUE 제약**을 설정합니다.

- 메시지를 처리할 때 이 테이블에 `INSERT`를 시도하고, 중복된 경우 예외를 잡아 무시하거나 상태를 로깅합니다.

- 비즈니스 로직(CUD)과 이 기록은 **동일 트랜잭션** 내에서 수행되어야 정확한 처리 상태를 반영할 수 있습니다.

- `status` 필드를 통해 처리 성공(`SUCCESS`), 실패(`FAILED`), 재시도 중(`RETRYING`) 여부를 기록하여 리트라이 대상 추적에 활용할 수 있습니다.

- **2.3.2.11.2 스프링부트 예제 코드 (Kotlin)**

```kotlin
@Service
class UserEventConsumer(
  private val eventLogRepository: EventLogRepository,
  private val orderRepository: OrderRepository
) {
  @RetryableTopic(
	  attempts = "3",
	  backoff = @Backoff(delay = 2000L, multiplier = 2.0),
	  dltTopicSuffix = "-dlt",
	  autoCreateTopics = "true"
  )
  @KafkaListener(
	  topics = ["prod.user.domain-event.user.v1"],
	  groupId = "user-group",
	  containerFactory = "kafkaListenerContainerFactory"
  )
  @Transactional
  fun consume(record: GenericRecord) {
	  val eventId = record.get("eventId").toString()
	  val userId = record.get("userId").toString()
	  val name = record.get("name").toString()
	  val action = record.get("action").toString()

	  try {
		  eventLogRepository.insert(EventLog(eventId, "UserEvent", status = "SUCCESS"))
		  orderRepository.save(Order(userId, name, action))
	  } catch (e: DataIntegrityViolationException) {
		  // event_id 중복 발생 시: 이미 처리된 메시지로 간주하고 무시
		  logger.info("Duplicate event ignored: $eventId")
	  } catch (e: Exception) {
		  // 예기치 못한 오류 발생 시, 상태를 FAILED로 기록하거나 DLQ 처리
		  eventLogRepository.insert(EventLog(eventId, "UserEvent", status = "FAILED"))
		  throw e
	  }
  }
}
```

  > 위 예제에서는 `@RetryableTopic` 어노테이션을 통해 메시지 처리 실패 시 최대 3회까지 백오프 전략으로 재시도하며, 최종 실패 시에는 `-dlt` 접미사의 Dead Letter Topic으로 전송됩니다. 이 기능은 Spring Kafka 2.7 이상에서 제공되며, 자동 토픽 생성 기능도 함께 설정 가능합니다.

  또한 Kafka에서 Exactly Once Semantics(EOS)를 활용하려면 아래 설정이 Producer와 Consumer 측 모두 필요합니다:

- **Producer 측**:

```yaml
spring.kafka.producer.transaction-id-prefix: tx-
spring.kafka.properties.enable.idempotence: true
```

- **Consumer 측**:

```yaml
spring.kafka.consumer.isolation-level: read_committed
```

- **KafkaTemplate 사용 시**:

```kotlin
kafkaTemplate.executeInTransaction { template ->
	template.send(...)
}
```

  이 설정을 적용하면 Kafka 내에서 메시지 전송, 저장, 소비 과정에서 정확히 한 번 처리(Exactly Once)가 보장되며, 위의 멱등성 로직과 함께 구성할 경우 시스템 전반의 데이터 정합성과 신뢰성이 극대화됩니다.

  > 참고: 해당 테이블은 필요에 따라 Outbox 패턴과 통합하여 Kafka 발행과 일관된 이벤트 흐름을 구성할 수도 있습니다.

## 5. 품질 보증

### 5.1 테스트 작성 가이드

#### 2.4.1.1 Kotest 개요 및 테스트 원칙

- **표준화**: 모든 테스트는 Kotest를 사용하며, JUnit 등 다른 프레임워크는 배제합니다.
- **목표**:
  - **가독성**: 테스트 코드는 명세서처럼 읽히며, 비개발자도 이해할 수 있어야 합니다.
  - **독립성**: 각 테스트는 격리된 상태로 실행되며, 테스트 간 데이터 공유는 금지됩니다.
  - **단일 책임**: 하나의 테스트는 하나의 기능만 검증합니다.
  - **반복 가능성**: 동일한 입력에 대해 항상 동일한 결과를 반환해야 합니다.
  - **빠른 실행**: 테스트는 신속히 실행되어 개발 생산성을 높입니다.
- **규칙**:
  - 테스트 이름은 한국어로 작성하여 의도를 명확히 합니다(예: "유효한 사용자 생성").
  - 외부 의존성(DB, API 등)은 모킹하거나 테스트 전용 환경(H2, Testcontainers)을 사용합니다.

#### 2.4.1.2 기술 스택과 Gradle 설정

- **도구**:
  - **Kotest**: 테스트 프레임워크.
  - **MockK**: 모킹 라이브러리.
  - **Testcontainers**: 실제 DB 테스트 환경 제공.
  - **Spring Boot Test**: 통합 테스트 지원.
- **Gradle 의존성**:

```kotlin
  dependencies {
      testImplementation("io.kotest:kotest-runner-junit5:5.9.1") // Kotest 실행기
      testImplementation("io.kotest:kotest-assertions-core:5.9.1") // Kotest Assertions
      testImplementation("io.mockk:mockk:1.13.11") // MockK
      testImplementation("org.testcontainers:testcontainers:1.20.0") // Testcontainers
      testImplementation("org.testcontainers:postgresql:1.20.0") // PostgreSQL 지원
      testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.4") // Spring Boot Test
      testImplementation("com.h2database:h2:2.2.224") // H2 인메모리 DB
  }
```

- **테스트 환경 설정**:
  - `src/test/resources/application-test.yml`에 H2 설정 추가:

```yaml
  spring:
	datasource:
	  url: jdbc:h2:mem:testdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1
	  driver-class-name: org.h2.Driver
	  username: sa
	  password:
	jpa:
	  hibernate:
		  ddl-auto: create-drop
```

#### 2.4.1.3 Kotest 공통 설정

- **기본 클래스**: 모든 테스트는 `SpringKotestSpec`을 상속받아 작성합니다.

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.context.ApplicationContext
import org.springframework.transaction.annotation.Transactional

@SpringBootTest
@Transactional
abstract class SpringKotestSpec(body: BehaviorSpec.() -> Unit = {}) : BehaviorSpec(body) {
  companion object {
	  private lateinit var context: ApplicationContext
	  fun setContext(ctx: ApplicationContext) { context = ctx }
	  inline fun <reified T> getBean(): T = context.getBean(T::class.java)
  }

  override fun beforeSpec(spec: io.kotest.core.spec.Spec) {
	  setContext(applicationContext)
  }
}
```

- **사용법**: 각 테스트 클래스에서 `getBean()`으로 의존성을 주입받습니다.
- **규칙**:
  - `@Transactional`로 테스트 후 롤백 보장.
  - 비동기 테스트는 별도 스레드 사용 시 롤백 주의(18.7 참조).

#### 2.4.1.4 레이어별 Kotest 전략

- **2.4.1.4.1 Domain 레이어**
  - **스타일**: `FunSpec` (간단한 단위 테스트에 적합).
  - **특징**: 순수 Kotlin으로 작성되며, 외부 의존성 없음(5.3.2).
  - **테스트 대상**: Aggregate, Value Object(VO), 비즈니스 로직.
  - **시나리오**:
    - 성공: 객체 생성 및 로직 실행.
    - 실패: 유효성 검사 실패 시 예외.
    - 불변성: 상태 변경 후 불변성 확인.
  - **예시**:

```kotlin
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.throwables.shouldThrow

class UserTest : FunSpec({
  test("유효한 사용자 생성") {
	  val user = User(UserId.of(1L), "John", Email.of("john@example.com"))
	  user.name shouldBe "John"
	  user.email.value shouldBe "john@example.com"
  }

  test("유효하지 않은 이메일로 생성 시 예외 발생") {
	  val exception = shouldThrow<IllegalArgumentException> {
		  Email.of("invalid")
	  }
	  exception.message shouldBe "유효한 이메일 형식이 아닙니다."
  }

  test("이름 업데이트 후 불변성 유지") {
	  val user = User(UserId.of(1L), "John", Email.of("john@example.com"))
	  val updated = user.updateName("Jane")
	  updated.name shouldBe "Jane"
	  updated.id shouldBe user.id // 불변성 확인
  }
})
```

- **2.4.1.4.2 Application 레이어**
  - **스타일**: `BehaviorSpec` (Given-When-Then 구조로 로직 흐름 명확화).
  - **환경**: `@SpringBootTest` + `@Transactional` + H2 인메모리 DB.
  - **테스트 대상**: CommandHandler, QueryHandler.
  - **시나리오**:
    - 성공: 상태 변경 및 결과 확인.
    - 실패: 중복 데이터, 유효성 오류 등.
    - 예외: 도메인 예외 처리(16.1 참조).
  - **규칙**:
    - Repository는 모킹하지 않고 실제 H2 DB 사용.
    - 외부 시스템(API, Kafka 등)은 MockK로 모킹.
  - **예시**:

```kotlin
import io.kotest.core.spec.style.BehaviorSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.transaction.annotation.Transactional

@SpringBootTest
@Transactional
class CreateUserCommandHandlerTest : BehaviorSpec({
  val handler = getBean<CreateUserCommandHandler>()
  val repository = getBean<UserRepository>()

  given("유효한 사용자 생성 요청이 주어졌을 때") {
	  val command = CreateUserCommand("Alice", "alice@example.com")
	  when("핸들러를 실행하면") {
		  val result = handler.handle(command)
		  then("성공 결과가 반환되고 DB에 저장된다") {
			  result.success shouldBe true
			  result.correlationId shouldNotBe null
			  val user = repository.findByEmail(Email.of("alice@example.com"))
			  user?.name shouldBe "Alice"
		  }
	  }
  }
})
```

- **2.4.1.4.3 Infrastructure 레이어**
  - **스타일**: `FunSpec` (DB 연동 테스트에 적합).
  - **환경**: Testcontainers + PostgreSQL (프로젝트 DB에 맞게 조정 가능).
  - **테스트 대상**: Repository 구현체, Entity 매핑.
  - **시나리오**:
    - 성공: 데이터 저장 및 조회.
    - 실패: 잘못된 쿼리, 매핑 오류.
  - **공통 설정**:

```kotlin
import org.testcontainers.containers.PostgreSQLContainer

object PostgresContainer : PostgreSQLContainer<PostgresContainer>("postgres:15") {
  init {
	  withDatabaseName("testdb")
	  withUsername("test")
	  withPassword("test")
  }
}
```

- **예시**:

```kotlin
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe

class UserRepositoryImplTest : FunSpec({
  beforeSpec { PostgresContainer.start() }
  afterSpec { PostgresContainer.stop() }

  val jpaRepository = getBean<SpringDataJpaUserRepository>() // SpringDataJpaUserRepository 를 빈으로 주입받도록 수정
  val repository = UserRepositoryImpl(jpaRepository)

  test("사용자 저장 및 조회 성공") {
	  val user = User(UserId.of(1L), "Bob", Email.of("bob@example.com"))
	  repository.save(user)
	  val found = repository.findById(UserId.of(1L))
	  found shouldNotBe null
	  found?.name shouldBe "Bob"
  }

  test("존재하지 않는 ID 조회 시 null 반환") {
	  val found = repository.findById(UserId.of(999L))
	  found shouldBe null
  }
})
```

- **2.4.1.4.4 Presentation 레이어**
  - **스타일**: `DescribeSpec` (API 요청-응답 구조에 적합).
  - **환경**: `@WebMvcTest` + MockMvc.
  - **테스트 대상**: Controller, DTO 유효성 검사(15 참조), HATEOAS 링크(13 참조).
  - **시나리오**:
    - 성공: 정상 요청에 대한 응답.
    - 실패: 유효성 검사 실패, 비즈니스 로직 오류.
    - HATEOAS: 링크 포함 확인.
  - **예시**:

```kotlin
import io.kotest.core.spec.style.DescribeSpec
import io.mockk.every
import io.mockk.mockk
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
import org.springframework.http.MediaType
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status

@WebMvcTest(UserCommandController::class)
class UserCommandControllerTest : DescribeSpec({
  val mockMvc = getBean<MockMvc>()
  val handler = mockk<CreateUserCommandHandler>()

  describe("POST /api/v1/users") {
	  context("유효한 요청일 때") {
		  it("성공 응답과 correlationId를 반환한다") {
			  every { handler.handle(any()) } returns CommandResult(true, "corr-123")
			  mockMvc.perform(post("/api/v1/users")
				  .contentType(MediaType.APPLICATION_JSON)
				  .content("""{"name":"Alice","email":"alice@example.com","password":"Pass123!"}"""))
				  .andExpect(status().isOk)
				  .andExpect(jsonPath("$.status").value("success"))
				  .andExpect(jsonPath("$.correlationId").value("corr-123"))
		  }
	  }

	  context("유효하지 않은 이메일일 때") {
		  it("400 에러와 ProblemDetail을 반환한다") {
			  mockMvc.perform(post("/api/v1/users")
				  .contentType(MediaType.APPLICATION_JSON)
				  .content("""{"name":"Alice","email":"invalid","password":"Pass123!"}"""))
				  .andExpect(status().isBadRequest)
				  .andExpect(jsonPath("$.errorCode").value("VALIDATION_ERROR"))
		  }
	  }
  }
})
```

#### 2.4.1.5 MockK 사용 전략

- **규칙**:
  - 외부 시스템(API, Kafka 등)은 MockK로 모킹.
  - Repository는 H2 또는 Testcontainers로 실제 동작 테스트.
- **주요 사용법**:
  - `mockk<T>()`: 모킹 객체 생성.
  - `every {}`: 동작 정의.
  - `coEvery {}`: 코루틴 비동기 모킹.
  - `verify {}`: 호출 검증.
- **예시**:

```kotlin
val apiClient = mockk<ExternalApiClient>()
every { apiClient.call(any()) } returns "mocked response"
val result = service.callApi("input")
result shouldBe "mocked response"
verify { apiClient.call("input") }
```

#### 2.4.1.6 Kotest 필수 Matcher & Assertion

- **동등성**: `shouldBe`, `shouldEqual`.
- **Null 확인**: `shouldNotBe null`, `shouldBe null`.
- **예외**: `shouldThrow<Exception> {}`.
- **컬렉션**: `shouldHaveSize(n)`, `shouldContain(element)`.
- **문자열**: `shouldStartWith`, `shouldMatch(regex)`.

#### 2.4.1.7 코루틴 비동기 테스트 전략

- **규칙**:
  - 비동기 Command(11.3)는 `coEvery`로 모킹.
  - `@Transactional` 롤백이 적용되지 않을 수 있으므로, 비동기 결과는 별도 확인.
- **예시**:

```kotlin
import io.kotest.core.spec.style.FunSpec
import io.mockk.coEvery

class AsyncCommandHandlerTest : FunSpec({
  val handler = mockk<CreateUserAsyncCommandHandler>()
  test("비동기 사용자 생성 성공") {
	  coEvery { handler.handle(any()) } returns AsyncCommandResult(true, "job-123")
	  val result = handler.handle(CreateUserCommand("Alice", "alice@example.com"))
	  result.jobId shouldBe "job-123"
  }
})
```

#### 2.4.1.8 테스트 커버리지 목표 및 도구

- **목표**:
  - Domain, Application: 80% 이상.
  - Infrastructure: 70% 이상.
  - Presentation: 주요 API 70% 이상.
- **도구**: JaCoCo.

```groovy
  plugins {
      id "jacoco"
  }
  jacocoTestReport {
      reports {
          xml.required = true
          html.required = true
      }
  }
  tasks.test {
      finalizedBy jacocoTestReport
  }
```

- **유지보수**:
  - 코드 변경 시 테스트 동기화.
  - Kotest Spec으로 리팩토링 용이성 확보.

#### 2.4.1.9 주의사항

- **도메인 순수성**: Domain 테스트는 순수 Kotlin으로 작성하며, Spring/JPA 의존성 배제(5.3.4).
- **Testcontainers 성능**: 실행 속도가 느리므로, 유닛 테스트와 통합 테스트를 분리 고려.
- **Swagger 일치성**: Presentation 응답이 Swagger 명세와 일치해야 함(17.4).
- **비동기 롤백**: 별도 스레드 사용 시 `@Transactional` 롤백이 적용되지 않을 수 있음.
- **H2 한계**: H2는 PostgreSQL과 미세한 차이가 있으므로, 중요한 쿼리는 Testcontainers로 검증.

## 답변: MSA 스타일의 독립적인 구성을 위한 도메인별 모듈화

**섹션 제목:** 1.2.1.2 도메인별 모듈화

**내용:**

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.

---

## 문서 추가 및 수정 사항 (2025-04-03)
알겠습니다. 지적해주신 부분 반영하여 더욱 명확한 규칙 문서 형태로 수정했습니다. "~해야 합니다" 와 같은 제안형 어미를 "~해야 한다", "~필수적으로 명시해야 한다" 등의 강제성을 띈 어미로 변경하여 규칙 문서의 명확성을 높였습니다. 수정된 내용은 아래와 같습니다.

## 답변: MSA 스타일의 독립적인 구성을 위한 도메인별 모듈화

**섹션 제목:** 1.2.1.2 도메인별 모듈화

**내용:**

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.

---

## 문서 추가 및 수정 사항 (2025-04-03)

**추가 수정 사항:**

1. **`@ConsistentCopyVisibility` 사용 (규칙)**:
   - 문서에 `@ConsistentCopyVisibility` 어노테이션에 대한 내용을 **필수적으로 명시해야 한다.**
   - **수정**: JPA 엔티티를 Kotlin `data class`로 정의하고 불변성을 유지하고자 할 때, Hibernate 프록시와 Kotlin의 `copy` 기능이 충돌하는 상황이 발생할 수 있다. `@ConsistentCopyVisibility` 어노테이션은 이러한 문제를 해결하기 위해 사용**해야 한다.**
   - **설명**: Kotlin `data class`는 `copy()` 메서드를 자동으로 생성한다. JPA 엔티티를 `data class`로 선언하면, Hibernate가 지연 로딩(Lazy Loading)을 위해 생성하는 프록시 객체와 `copy()` 메서드가 함께 사용될 때 예기치 않은 동작이 발생할 수 있다. 특히, 프록시 객체의 속성에 직접 접근하여 `copy()`를 호출하면 프록시 초기화가 제대로 이루어지지 않아 데이터 무결성을 해칠 수 있다.
   - `@ConsistentCopyVisibility` 어노테이션은 Kotlin 컴파일러에게 `data class`의 `copy()` 메서드 내에서 프록시 객체의 속성에 접근할 때의 가시성을 제어하도록 지시한다. 이를 통해 Hibernate 프록시와 Kotlin `data class`가 JPA 환경에서 안전하게 함께 동작하도록 **보장해야 한다.**

   - **주의**: `@ConsistentCopyVisibility`는 JPA 엔티티를 Kotlin `data class`로 정의하고 불변성을 유지하고자 할 때 Hibernate 프록시 관련 문제를 해결하기 위한 **선택적인** 어노테이션이다. 모든 JPA 엔티티에 필수로 적용해야 하는 것은 아니며, Hibernate 프록시와 `copy()` 메서드 간의 충돌 가능성이 있을 때 고려할 수 있다.  **불변 객체 복사본 생성 및 데이터 무결성 보장** 이라는 기존 설명은 `@ConsistentCopyVisibility`의 정확한 역할과 다소 거리가 있다. `@ConsistentCopyVisibility`는 불변성 자체를 강제하거나 복사본을 생성하는 기능이 아니라, Hibernate 와 Kotlin data class 의 호환성을 위한 기술적인 해결책으로 이해**해야 한다.**

2. **팩토리 메서드 패턴 (규칙)**:
   - 객체 생성과 관련된 팩토리 메서드 패턴 사용 방식에 대한 추가 설명이 **필요하다.**
   - Value Object (VO) 작성 규칙 (2.2.2) 에서 `companion object`의 `of` 메서드를 통해 객체 생성을 제어하는 방식을 설명하고 있지만, 팩토리 메서드 패턴의 의도와 장점을 명확히 설명하는 부분이 부족**하다.**
   - 팩토리 메서드 패턴을 사용하는 이유 (객체 생성 로직 캡슐화, 유효성 검사, 객체 생성 과정 단순화 등) 와 함께, 다양한 팩토리 메서드 활용 예시 (정적 팩토리 메서드, 팩토리 클래스 등) 를 추가하여 개발자들이 객체 생성 패턴을 효과적으로 적용할 수 있도록 돕는 것이 중요**하다.**
   - 특히 도메인 레이어에서 Aggregate, Entity, VO 등 다양한 객체 생성 시 팩토리 메서드 패턴을 일관성 있게 적용하는 방법을 제시**해야 한다.**

3. **Aggregate 및 DDD 하위 엔티티 팩토리 함수 (`create`, `reconstitute`) (필수 규칙)**:
   - Aggregate 및 DDD 관점에서의 하위 엔티티는 객체 생성 시 **반드시** `create` 및 `reconstitute` 팩토리 함수를 `companion object` 내에 가져야 한다. 이는 **필수 규칙**이다.
   - **목적**: 객체 생성 의도를 명확히 구분하고, 객체 생성 시점과 방식에 따라 다른 로직을 적용하기 위함이다.
   - **`create` 함수**:
     - 새로운 Aggregate 또는 하위 엔티티를 생성할 때 사용**해야 한다.**
     - 초기 상태 설정, 유효성 검사, 도메인 이벤트 발행 등 객체 생성 시 필요한 초기화 로직을 포함**해야 한다.**
     - 일반적으로 사용자 입력 또는 애플리케이션 레이어의 요청에 의해 호출**되어야 한다.**
   - **`reconstitute` 함수**:
     - 영속화된 데이터로부터 Aggregate 또는 하위 엔티티를 재구성할 때 사용**해야 한다.**
     - 데이터베이스 또는 외부 저장소에서 읽어온 데이터를 기반으로 객체를 복원**해야 한다.**
     - 초기화 로직이나 유효성 검사를 최소화하거나 생략하고, 주로 데이터 매핑 및 객체 속성 설정에 집중**해야 한다.**
     - 리포지토리 레이어에서 데이터베이스 조회 후 호출**되어야 한다.**
   - **구현 방식**: `companion object` 내에 `create` 및 `reconstitute` 함수를 정의**해야 한다.**
   - **예시 (Aggregate - `User`):** (기존 예시와 동일)

   - **예시 (DDD 하위 엔티티 - `OrderItem`):** (기존 예시와 동일)

   - **사용 규칙**:
     - 새로운 객체 생성 시에는 반드시 `create` 팩토리 함수를 사용**해야 한다.**
     - 리포지토리에서 데이터를 조회하여 도메인 객체로 변환할 때는 `reconstitute` 팩토리 함수를 사용**해야 한다.**
     - `private constructor` 를 사용하여 직접적인 객체 생성을 막고 팩토리 함수를 통한 생성을 강제**해야 한다.**
   - **장점**:
     - 객체 생성 의도 명확화: 코드 가독성 및 유지보수성 향상.
     - 객체 생성 로직 분리: 생성 방식에 따른 로직 분리 및 관리 용이.
     - 도메인 모델의 일관성 유지: 객체 생성 규칙 강제 및 도메인 불변성 보장.
