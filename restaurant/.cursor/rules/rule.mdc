---
description: 
globs: 
alwaysApply: true
---
# 프로젝트 기술 문서

## 1. 프로젝트 개요

### 1.1 기술 스택

- **프레임워크**: Spring Boot
- **빌드 도구**: Gradle
- **프로그래밍 언어**: Kotlin
- **매핑 방식**: 확장 함수 기반 수동 매핑

### 1.2 아키텍처 원칙

- **도메인 주도 설계(DDD)**: 핵심 도메인 로직에 집중합니다.
- **클린 아키텍처**: 시스템을 Presentation, Application, Domain, Infrastructure의 4개 레이어로 명확히 구분합니다. 이외에 특별한 상위 레이어로 Messaging 레이어를 도입하며 `@KafkaListener`나 이와 비슷한 책임을 가지는 코드만 존재합니다.
- **이벤트 소싱**: 사용하지 않습니다. 비동기 상태 추적은 별도의 상태 저장소를 통해 구현됩니다。

---

## 2. 모듈화 전략

### 2.1 멀티모듈 프로젝트

- **레이어별 모듈 분리**: Presentation, Application, Domain, Infrastructure 레이어별로 모듈을 분리하여 관리합니다.
- **목적**: 한 영역의 변경이 다른 영역에 미치는 영향을 최소화합니다.

### 2.2 도메인별 모듈화

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.

### 2.3 공통 모듈 (`common`)

- **내용**: 전역에서 사용하는 순수 유틸리티, 공유 추상 클래스, 인터페이스 등이 포함됩니다.
- **주의**: 과도한 의존을 피하여 “공통 모듈 지옥”을 방지합니다.

---

## 3. CQRS 패턴

### 3.1 Command

- **역할**: 상태 변경이나 특정 기능 실행을 위한 데이터 전송을 담당합니다.
- **특징**: 애플리케이션 레이어에서 Command는 데이터(상태 변경 결과)를 반환하지 않습니다.

### 3.2 Query

- **역할**: 데이터 조회 또는 검색을 위한 요청을 처리합니다.

---

## 4. DTO 네이밍 규칙 및 변환 규칙

### 4.1 Presentation 레이어

- **Request DTO**: 사용자로부터 입력받은 데이터를 담으며, 이름 뒤에 “Request”를 붙입니다.
  - 예: `UserCreateRequest`, `ProductUpdateRequest`, `LoginRequest`
- **Response DTO**: API가 응답으로 반환하는 데이터를 담으며, 이름 뒤에 “Response”를 붙입니다.
  - 예: `UserInfoResponse`, `ProductDetailResponse`, `AuthTokenResponse`

### 4.2 Application 레이어

- **Command DTO**: 특정 기능 실행(명령)에 필요한 데이터를 캡슐화하며, 이름 뒤에 “Command”를 붙입니다.
  - 예: `CreateUserCommand`, `UpdateProductCommand`
- **Query DTO**: 데이터 조회 및 검색 요청에 필요한 정보를 전달하며, 이름 뒤에 “Query”를 붙입니다.
  - 예: `GetUserQuery`, `FindProductsQuery`

### 4.3 DTO 변환 규칙

- **원칙**: Presentation 레이어의 `Request DTO`는 애플리케이션 레이어의 `Command DTO` 또는 `Query DTO`로 변환되며, 모든 변환은 확장 함수를 통해 수동으로 구현됩니다.
- **구현**: 별도의 매핑 라이브러리(MapStruct 등)를 사용하지 않고, Kotlin의 확장 함수를 활용하여 변환 로직을 객체에 직접 정의합니다.
  - **설명**: 변환 로직은 소스 객체의 확장 함수로 작성되며, 필요 시 유효성 검사를 포함합니다.
  - **장점**:
    - **간결성**: Kotlin의 idiomatic한 스타일로 코드가 자연스럽고 직관적입니다.
    - **유연성**: 복잡한 변환 로직이나 조건문을 쉽게 추가할 수 있습니다.
    - **의존성 감소**: 외부 라이브러리 없이 순수 Kotlin으로 구현됩니다.
  - **단점**:
    - **보일러플레이트 코드**: 반복적인 변환 코드가 늘어날 수 있습니다.
    - **컴파일 타임 검증 부재**: 자동화 도구의 검증이 없으므로 테스트로 보완해야 합니다.
    - **일관성 관리**: 팀원 간 동일한 패턴 준수를 위한 가이드 필요.
- **위치**: 변환 함수는 소스 객체가 속한 레이어에 정의됩니다.
  - 예: `UserCreateRequestV1.toCommand()`는 Presentation 레이어에 위치.
- **예시**:
  ```kotlin
  package com.example.presentation.user.v1.dto.request

  import com.example.application.user.command.CreateUserCommand

  fun UserCreateRequestV1.toCommand(): CreateUserCommand = CreateUserCommand(
      name = name.trim(),
      email = email.lowercase()
  )
  ```

  - **사용 예시**:
    ```kotlin
    val command = request.toCommand()
    ```

---

## 5. 레이어 간 의존성 및 도메인 규칙

### 5.1 도메인 레이어의 독립성

- **규칙**: Domain 레이어는 Presentation, Application, Infrastructure 레이어를 절대 참조하지 않습니다.
- **목적**: 도메인의 순수성을 유지합니다.

### 5.2 Aggregate의 VO 사용 범위

- **규칙**: 도메인 내 Aggregate(집합체)의 Value Object(VO)는 Domain 레이어 외부에서 사용하지 않습니다.
- **목적**: 도메인 경계 내에서만 활용합니다.

### 5.3 엔티티 정의 규칙

#### 5.3.1 JPA 엔티티의 위치

- **규칙**: JPA 엔티티는 `Infrastructure` 레이어에 정의합니다.
- **목적**: 데이터베이스와의 매핑을 담당하는 JPA 엔티티를 인프라스트럭처 레이어로 분리하여, 도메인 레이어의 순수성을 유지하고 기술적 의존성을 격리합니다.
- **구현**:
  - JPA 엔티티는 `@Entity` 어노테이션을 사용하며, 데이터베이스 테이블과 매핑됩니다.
  - 도메인 로직은 JPA 엔티티에 포함시키지 않고, 필요 시 도메인 레이어의 Aggregate나 VO로 변환하여 사용합니다.
- **예시**:
  ```kotlin
  @Entity
  @Table(name = "users")
  data class UserEntity(
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      val id: Long? = null,
      val name: String,
      val email: String
  )
  ```

---
### 5.3.2 Aggregate와 VO의 위치

- **규칙**: Aggregate, Value Object(VO), 그리고 기타 DDD 엔티티는 `Domain` 레이어에 정의하며, 외부 기술 프레임워크(JPA, Spring 등)에 의존하지 않도록 최대한 순수하게 유지합니다. 또한, 도메인 내 하위 엔티티는 `entity` 폴더에 별도로 정의되며, 이는 `Infrastructure` 레이어의 JPA 엔티티와 구분됩니다.
- **목적**: 도메인 로직의 독립성과 재사용성을 보장하며, 비즈니스 규칙을 기술적 세부사항과 분리합니다. 하위 엔티티를 `entity` 폴더에 분리함으로써 도메인 내 엔티티의 계층 구조를 명확히 하고, JPA 엔티티와의 혼동을 방지합니다.
- **구현**:
  - Aggregate는 도메인 내의 루트 엔티티로, 비즈니스 규칙과 불변성을 관리합니다.
  - VO는 불변 객체로, 도메인 내에서 값의 의미를 캡슐화합니다.
  - 하위 엔티티는 `entity` 폴더 내에 정의되며, 도메인 로직을 포함할 수 있는 객체로 Aggregate와의 관계를 나타냅니다. 이들은 JPA 엔티티가 아니며, 데이터베이스 매핑과는 무관합니다.
  - JPA 엔티티와의 매핑은 `Infrastructure` 레이어에서 별도로 처리하며, 확장 함수를 활용해 변환합니다.
- **예시**:
  ```kotlin
  // 도메인 레이어 내 Aggregate
  data class Order(
      val id: OrderId,
      val items: List<OrderItem>
  )

  // 도메인 레이어 내 하위 엔티티 (entity 폴더에 위치)
  package com.example.domain.order.entity

  data class OrderItem(
      val productId: ProductId,
      val quantity: Int
  )

  @JvmInline
  value class OrderId(val value: Long)

  @JvmInline
  value class ProductId(val value: Long)
  ```

---

#### 5.3.3 JPA 엔티티와 DDD 엔티티 간 매핑

- **규칙**: JPA 엔티티와 도메인 레이어의 Aggregate/VO 간 변환은 `Infrastructure` 또는 `Application` 레이어에서 수행하며, 확장 함수를 사용하여 수동으로 매핑 로직을 정의합니다.
- **목적**: 도메인 레이어의 순수성을 유지하면서, 데이터 영속성과 도메인 로직을 분리합니다.
- **구현**:
  - `Infrastructure` 레이어에서 Repository가 JPA 엔티티를 조회/저장하고, 이를 도메인 객체로 변환합니다.
  - 변환 로직은 JPA 엔티티와 도메인 객체에 정의된 확장 함수로 처리됩니다.
- **예시**:
  ```kotlin
  package com.example.infrastructure.user.entity

  import com.example.domain.user.User
  import com.example.domain.user.vo.UserId
  import com.example.domain.user.vo.Email

  fun UserEntity.toDomain(): User = User(
      id = id?.let { UserId(it) } ?: throw IllegalArgumentException("Entity ID는 null일 수 없습니다."),
      name = name,
      email = Email(value = email)
  )

  fun User.toEntity(): UserEntity = UserEntity(
      id = id.value,
      name = name,
      email = email.value
  )

  @Repository
  class UserRepository(
      private val jpaRepository: SpringDataJpaUserRepository
  ) {
      fun findById(id: UserId): User? {
          return jpaRepository.findById(id.value)?.toDomain()
      }

      fun save(user: User): User {
          val entity = user.toEntity()
          return jpaRepository.save(entity).toDomain()
      }
  }
  ```

#### 5.3.4 주의사항

- **도메인 레이어의 순수성**: 도메인 객체는 JPA 어노테이션(`@Entity`, `@Id` 등)이나 Spring 관련 의존성을 포함시키지 않습니다.
- **성능 고려**: 빈번한 객체 변환으로 인한 오버헤드를 줄이기 위해, 필요한 경우 매핑 로직을 최적화하거나 캐싱을 고려합니다.
- **테스트 용이성**: 도메인 레이어는 가능하다면 순수 Kotlin으로 작성되므로, 단위 테스트 시 mocking 없이 독립적으로 테스트 가능합니다。

---

## 6. 애플리케이션 레이어 구조

### 6.1 예시 디렉터리 구조

```plaintext
domains:
 user:
   src:
     main:
       kotlin:
         com:
           example:
             application:
               command:
                 - CreateUserCommand.kt
                 - UpdateUserCommand.kt
                 - extensions.kt  # Command → Domain 변환 확장 함수
                 - handler
                   - CreateUserCommandHandler.kt
                   - UpdateUserCommandHandler.kt
               query:
                 - GetUserQuery.kt
                 - FindUsersQuery.kt
                 - handler
                   - GetUserQueryHandler.kt
                   - FindUsersQueryHandler.kt
               common:
                 - UserApplicationException.kt
 order:
   src:
     main:
       kotlin:
         com:
           example:
             application:
               command:
                 - CreateOrderCommand.kt
                 - UpdateOrderCommand.kt
                 - CancelOrderCommand.kt
                 - extensions.kt  # Command → Domain 변환 확장 함수
                 - handler
                   - CreateOrderCommandHandler.kt
                   - UpdateOrderCommandHandler.kt
                   - CancelOrderCommandHandler.kt
               query:
                 - GetOrderQuery.kt
                 - FindOrdersQuery.kt
                 - FindOrdersByCustomerQuery.kt
                 - handler
                   - GetOrderQueryHandler.kt
                   - FindOrdersQueryHandler.kt
                   - FindOrdersByCustomerQueryHandler.kt
               common:
                 - OrderApplicationException.kt
```

---

## 7. 프레젠테이션 레이어 구조

### 7.1 예시 디렉터리 구조

```plaintext
domains:
 user:
   src:
     main:
       kotlin:
         com:
           example:
             presentation:
               v1:
                 command:
                   - UserCommandController.kt
                   dto:
                     request:
                       - UserCreateRequestV1.kt
                       - UserUpdateRequestV1.kt
                       - extensions.kt  # Request → Command 변환 확장 함수
                     response:
                       - UserResponseV1.kt
                       - UserSearchResponseV1.kt
                 query:
                   - UserQueryController.kt
 order:
   src:
     main:
       kotlin:
         com:
           example:
             presentation:
               v1:
                 command:
                   - OrderCommandController.kt
                   dto:
                     request:
                       - OrderCreateRequestV1.kt
                       - OrderCancelRequestV1.kt
                       - extensions.kt  # Request → Command 변환 확장 함수
                     response:
                       - OrderResponseV1.kt
                       - OrderHistoryResponseV1.kt
                 query:
                   - OrderQueryController.kt
```

---

## 8. Query 전략

### 8.1 페이지네이션

- **규칙**: 다건 조회는 페이지네이션을 적용.
- **방식**: 결정 시 커서 페이지네이션을 기본.

---

## 9. Command 요청에 대한 REST 응답 규칙

### 9.1 동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, 애플리케이션 레이어의 Command 실행 결과를 기반으로 최소한의 메타데이터를 반환합니다.
- **필수 필드**: `status`, `message`, `correlationId` (결과 확인용 식별자)
- **예시**:
  ```json
  {
    "status": "success",
    "message": "요청이 처리되었습니다.",
    "correlationId": "correlation123"
  }
  ```

### 9.2 비동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, URL 처리는 프레젠테이션 레이어에서만 수행됩니다. 애플리케이션 레이어는 `jobId`만 제공합니다.
- **필수 필드**: `status`, `message`, `jobId`, 상태 조회 및 관리용 링크
- **예시**:
  ```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job12345",
    "links": [
      {
        "rel": "job-status-ws",
        "href": "wss://example.com/ws/job-status/job12345",
        "type": "ws",
        "action": "subscribe"
      },
      {
        "rel": "job-none-ws",
        "href": "/api/v1/jobs/status/job12345",
        "type": "http",
        "method": "GET",
        "action": "get-status"
      }
    ]
  }
  ```

---

## 10. Command 요청에 대한 REST 실패 응답 규칙

(기존 내용이 RFC 7807 준수로 섹션 12에서 통합되었으므로 생략)

---

## 11. 애플리케이션 레이어에서 Command 리턴 규칙

### 11.1 기본 원칙

- **규칙**: Command 핸들러는 상태 변경만 수행하며, 비즈니스 데이터(예: 생성된 엔티티의 상세 정보)를 반환하지 않습니다.
- **참고**: 결과 확인용 `correlationId` 또는 `jobId`는 반환 가능하며, 이는 프레젠테이션 레이어에서 처리됩니다.

### 11.2 동기 Command 처리

- **리턴 값**: `CommandResult` 객체
- **필수 필드**:
  - `success`: boolean
  - `correlationId`: string
- **예시**:
  ```json
  {
    "success": true,
    "correlationId": "corr-456"
  }
  ```

### 11.3 비동기 Command 처리

- **리턴 값**: `AsyncCommandResult` 객체
- **필수 필드**:
  - `success`: boolean
  - `jobId`: string
- **예시**:
  ```json
  {
    "success": true,
    "jobId": "job-789"
  }
  ```

- **참고**: 상태 추적은 데이터베이스 테이블 또는 메시지 큐를 통해 관리되며, 이벤트 소싱은 사용하지 않습니다.

### 11.4 실패 처리

- **리턴 값**: `CommandResult` 또는 `AsyncCommandResult` 객체에 오류 정보 포함
- **필수 필드**:
  - `success`: false
  - `errorCode`: string
- **예시**:
  ```json
  {
    "success": false,
    "errorCode": "VALIDATION_ERROR"
  }
  ```

- **참고**: 실패 시 프레젠테이션 레이어에서 `ProblemDetail`을 사용해 RFC 7807 형식으로 변환되며, 자세한 내용은 섹션 12. 에러 처리를 참조하세요.

### 11.5 구현 참고

- **동기 Command 핸들러 예시**:
  ```kotlin
  class CreateUserCommandHandler(
      private val userRepository: UserRepository
  ) {
      fun handle(command: CreateUserCommand): CommandResult {
          val user = command.toUser()
          userRepository.save(user)
          return CommandResult(true, UUID.randomUUID().toString())
      }
  }
  ```

- **프레젠테이션 계층에서의 변환**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler
  ) {
      @PostMapping
      fun createUser(@RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
          val command = request.toCommand()
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

---

## 12. 에러 처리

### 12.1 목적

- 시스템의 안정성을 유지하고, 클라이언트에게 RFC 7807("Problem Details for HTTP APIs")에 준수하는 명확한 에러 메시지를 제공하기 위해 일관된 에러 처리 전략을 정의합니다.
- 레이어별로 적절한 에러 처리를 통해 책임을 명확히 하고, 에러의 원인을 쉽게 파악할 수 있도록 합니다.

### 12.2 레이어별 에러 처리

#### 12.2.1 Presentation 레이어

- **역할**: 클라이언트의 요청을 검증하고, 애플리케이션 레이어로 전달하기 전에 유효성 검사를 수행합니다.
- **에러 유형**: 요청 데이터의 유효성 검사 실패, 인증/인가 실패 등.
- **처리 방식**: `@Valid` 어노테이션을 사용한 유효성 검사, Spring Security를 통한 인증/인가 처리.
- **응답**: `ProblemDetail`을 사용하여 RFC 7807 형식으로 클라이언트에게 반환.

#### 12.2.2 Application 레이어

- **역할**: 비즈니스 로직을 실행하며, 도메인 레이어와 상호작용합니다.
- **에러 유형**: 비즈니스 규칙 위반, 도메인 로직 에러 등.
- **처리 방식**: 도메인에서 발생한 예외를 catching하고, `CommandResult` 또는 `AsyncCommandResult`에 에러 정보를 포함하여 반환. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환.
- **응답**: CommandResult 또는 AsyncCommandResult에 에러 정보를 포함하여 반환.

#### 12.2.3 Domain 레이어

- **역할**: 핵심 비즈니스 로직을 포함하며, 도메인 규칙을 준수합니다.
- **에러 유형**: 도메인 규칙 위반 (예: 무효한 상태 전환).
- **처리 방식**: 도메인 예외를 throw하여 상위 레이어로 전달.
- **예외 클래스**: `DomainException`과 같은 커스텀 예외 클래스를 사용.

#### 12.2.4 Infrastructure 레이어

- **역할**: 데이터베이스, 외부 API 등과의 통신을 담당합니다.
- **에러 유형**: 데이터베이스 연결 실패, 외부 API 응답 지연 등.
- **처리 방식**: 인프라 관련 예외를 catching하고, 애플리케이션 레이어에서 처리할 수 있는 형태로 변환.
- **예외 클래스**: `InfrastructureException`과 같은 커스텀 예외 클래스를 사용.

### 12.3 에러 응답 형식

- **형식**: 모든 에러 응답은 RFC 7807에 따라 JSON 형식으로 반환되며, Spring Boot 3.0 이상에서 제공하는 `ProblemDetail` 클래스를 기본으로 사용합니다. `ProblemDetail`은 다음과 같은 필드를 포함합니다:
  - `type`: 문제 유형을 식별하는 URI (기본값: "about:blank")
  - `title`: 문제 유형에 대한 간단한 설명 (문제 유형별 고정 문자열)
  - `status`: HTTP 상태 코드
  - `detail`: 문제에 대한 인스턴스별 설명
  - `instance`: 문제를 발생시킨 특정 요청을 식별하는 URI (선택적)
  - 확장 필드: `errorCode` (에러 식별용 고유 코드), `timestamp` (에러 발생 시각) 등은 `setProperty` 메서드를 통해 추가됩니다.
- **예시**:
  ```json
  {
    "type": "https://example.com/probs/user-not-found",
    "title": "User Not Found",
    "status": 404,
    "detail": "사용자를 찾을 수 없습니다.",
    "instance": "/api/v1/users/123",
    "errorCode": "USER_NOT_FOUND",
    "timestamp": "2025-03-24T12:00:00Z"
  }
  ```

---

## 13. HATEOAS 및 URI 템플릿 사용 규칙

### 13.1 목적

- RESTful API에서 클라이언트가 하드코딩된 URL에 의존하지 않고, 동적으로 제공되는 링크를 통해 리소스를 탐색할 수 있도록 HATEOAS(Hypermedia as the Engine of Application State)를 적용합니다.
- URI 템플릿을 활용하여 경로 변경에 유연하게 대응합니다.

### 13.2 기본 규칙

- **의존성**: Spring HATEOAS(`spring-boot-starter-hateoas`)를 사용합니다.
- **링크 포함**: 성공적인 Command 요청(동기/비동기) 응답에는 관련 리소스 상태 확인 또는 다음 작업을 위한 링크를 포함합니다.
- **실패 응답**: 링크는 선택 사항이며, 오류 해결을 위한 추가 링크(예: 재시도)가 있다면 포함 권장.

### 13.3 링크 구조

- **필수 필드**: 모든 링크는 `rel`(관계), `href`(URL), `method`(HTTP 메서드)를 포함합니다.
- **형식**:
  ```kotlin
  mapOf(
      "rel" to "관계_이름",
      "href" to "리소스_URL",
      "method" to "HTTP_메서드"
  )
  ```

---

## 14 프로젝트 구조 참고용

```
domains/
├── common/
│   ├── src/main/kotlin/com/example/common/
│   ├── dto/
│   │   ├── CommandResult.kt
│   │   └── AsyncCommandResult.kt
│   ├── exception/
│   │   ├── DomainException.kt
│   │   ├── ApplicationException.kt
│   │   ├── InfrastructureException.kt
│   │   └── PresentationException.kt
│   └── build.gradle.kts
│
├── user/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/user/
│   │   │   └── UserApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/user/
│   │   │   ├── aggregate/User.kt (Aggregate)
│   │   │   ├── vo/UserId.kt (VO)
│   │   │   ├── vo/Email.kt (VO)
│   │   │   ├── repository/UserRepository.kt (Interface)
│   │   │   └── exception/UserDomainException.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/user/
│   │   │   ├── command/
│   │   │   │   ├── CreateUserCommand.kt
│   │   │   │   ├── UpdateUserCommand.kt
│   │   │   │   ├── extensions.kt  # Command → Domain 변환
│   │   │   │   └── handler/
│   │   │   │       ├── CreateUserCommandHandler.kt
│   │   │   │       └── UpdateUserCommandHandler.kt
│   │   │   ├── query/
│   │   │   │   ├── GetUserQuery.kt
│   │   │   │   ├── FindUsersQuery.kt
│   │   │   │   └── handler/
│   │   │   │       ├── GetUserQueryHandler.kt
│   │   │   │       └── FindUsersQueryHandler.kt
│   │   │   └── exception/UserApplicationException.kt
│   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/user/
│   │   │   ├── entity/
│   │   │   │   ├── UserEntity.kt
│   │   │   │   └── extensions.kt  # Domain ↔ Entity 변환
│   │   │   ├── repository/
│   │   │   │   ├── SpringDataJpaUserRepository.kt
│   │   │   │   └── UserRepositoryImpl.kt
│   │   │   └── exception/UserInfrastructureException.kt
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/user/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── UserCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── UserCreateRequestV1.kt
│   │   │   │   │       ├── UserUpdateRequestV1.kt
│   │   │   │   │       └── extensions.kt  # Request → Command 변환
│   │   │   │   └── query/
│   │   │   │       ├── UserQueryController.kt
│   │   │   └── exception/UserPresentationException.kt
│   │   └── build.gradle.kts
│   └── build.gradle.kts
│
├── order/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/order/
│   │   │   └── OrderApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/order/
│   │   │   ├── aggregate/
│   │   │   │   └── Order.kt (Aggregate)
│   │   │   ├── entity/
│   │   │   │   └── OrderItem.kt (하위 엔티티, JPA 엔티티와 다름)
│   │   │   ├── vo/
│   │   │   │   ├── OrderId.kt (VO)
│   │   │   │   └── ProductId.kt (VO)
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/order/
│   │   │   ├── command/
│   │   │   │   ├── CreateOrderCommand.kt
│   │   │   │   ├── extensions.kt  # Command → Domain 변환
│   │   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/order/
│   │   │   ├── entity/
│   │   │   │   ├── OrderEntity.kt
│   │   │   │   └── extensions.kt  # Domain ↔ Entity 변환
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/order/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── OrderCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── OrderCreateRequestV1.kt
│   │   │   │   │       └── extensions.kt  # Request → Command 변환
│   │   │   └── build.gradle.kts
│   └── build.gradle.kts
│
└── build.gradle.kts (최상위)
```

---

## 15. Presentation 레이어 validation

- **목적**: 클라이언트로부터 입력받은 데이터의 유효성을 검증하여 잘못된 요청을 조기에 차단하고, 시스템의 안정성과 데이터 무결성을 보장합니다.
- **규칙**: Presentation 레이어에서 요청 데이터(`Request DTO`)의 유효성 검사는 `jakarta.validation.constraints` 패키지의 어노테이션을 적극 활용하여 수행합니다.
- **의존성**: Spring Boot Starter Validation(`spring-boot-starter-validation`)을 사용하며, Gradle에 추가합니다.
  - **설정 예시**:
    ```groovy
    dependencies {
        implementation "org.springframework.boot:spring-boot-starter-validation"
    }
    ```

- **적용 방식**:
  - 모든 `Request DTO` 필드에 대해 적절한 검증 어노테이션을 적용합니다.
  - 컨트롤러 메서드에서 `@Valid` 어노테이션을 사용하여 유효성 검사를 트리거합니다.
- **예시**:
  - **Request DTO 정의**:
    ```kotlin
    data class UserCreateRequestV1(
        @field:NotBlank(message = "이름은 필수입니다.")
        val name: String,
        @field:NotBlank(message = "이메일은 필수입니다.")
        @field:Email(message = "유효한 이메일 형식이어야 합니다.")
        val email: String
    )
    ```

  - **컨트롤러에서 사용**:
    ```kotlin
    @RestController
    @RequestMapping("/api/v1/users")
    class UserCommandController(
        private val createUserCommandHandler: CreateUserCommandHandler
    ) {
        @PostMapping
        fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
            val command = request.toCommand()
            val result = createUserCommandHandler.handle(command)
            return ResponseEntity.ok(mapOf(
                "status" to "success",
                "message" to "요청이 처리되었습니다.",
                "correlationId" to result.correlationId
            ))
        }
    }
    ```

---

## 16. 도메인 익셉션의 전파

### 16.1 CommandResult 기반 처리 (예외 없이 결과만 반환)

애플리케이션 레이어에서 도메인 익셉션을 잡아 `CommandResult`로 변환한 경우, 프레젠테이션 레이어는 `CommandResult`의 상태를 확인하여 `ProblemDetail`을 사용해 RFC 7807 형식의 응답을 구성합니다.

- **구현 예시**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler
  ) {
      @PostMapping
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
          val command = request.toCommand()
          val result = createUserCommandHandler.handle(command)

          return if (result.success) {
              ResponseEntity.ok(mapOf(
                  "status" to "success",
                  "message" to "요청이 처리되었습니다.",
                  "correlationId" to result.correlationId
              ))
          } else {
              val problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                  type = URI.create("https://example.com/probs/user-creation-failed")
                  title = "User Creation Failed"
                  detail = "사용자 생성에 실패했습니다."
                  instance = URI.create("/api/v1/users")
                  setProperty("errorCode", result.errorCode ?: "USER_CREATION_FAILED")
                  setProperty("timestamp", Instant.now().toString())
              }
              ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
          }
      }
  }
  ```

---

## 17. Presentation 레이어에서 Swagger 적용

### 17.1 목적

- API의 명세를 문서화하고, 클라이언트 및 개발자가 쉽게 이해하고 테스트할 수 있도록 Swagger를 Presentation 레이어에 적용합니다.

### 17.2 의존성 설정

- **의존성**: `springdoc-openapi-starter-webmvc-ui`를 사용.
  ```groovy
  dependencies {
      implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2"
  }
  ```

### 17.3 기본 설정

- **구성**:
  ```kotlin
  @Configuration
  class SwaggerConfig {
      @Bean
      fun customOpenAPI(): OpenAPI {
          return OpenAPI()
              .info(Info().title("Project API").version("v1").description("Spring Boot 기반 프로젝트 API 문서"))
      }
  }
  ```

### 17.4 API 문서화

- **예시**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler
  ) {
      @PostMapping
      @Operation(summary = "새로운 사용자 생성", description = "사용자 정보를 입력받아 새로운 사용자를 생성합니다.")
      @ApiResponses(
          ApiResponse(responseCode = "200", description = "사용자 생성 성공",
              content = [Content(schema = Schema(implementation = Map::class))]),
          ApiResponse(responseCode = "400", description = "잘못된 요청 데이터",
              content = [Content(schema = Schema(implementation = ProblemDetail::class))])
      )
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
          val command = request.toCommand()
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

---

## 18. 테스트 작성 가이드

### 18.1 Kotest 개요 및 테스트 원칙

- **표준화**: 모든 테스트는 Kotest를 사용합니다.
- **목표**: 가독성, 독립성, 단일 책임, 반복 가능성, 빠른 실행.

### 18.2 기술 스택과 Gradle 설정

```kotlin
dependencies {
    testImplementation("io.kotest:kotest-runner-junit5:5.9.1")
    testImplementation("io.kotest:kotest-assertions-core:5.9.1")
    testImplementation("io.mockk:mockk:1.13.11")
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.4")
}
```

---

## 19. Value Object 작성 가이드

### 19.1 목적

Value Object(VO)는 도메인 레이어에서 불변 값을 캡슐화하며, 도메인 규칙을 강제합니다.

### 19.2 기본 규칙

- **불변성**: 생성 후 상태가 변경되지 않습니다.
- **Private Constructor**: 생성자를 `private`으로 설정.
- **Companion Object**: `of` 메서드로 생성 제어.
- **예시**:
  ```kotlin
  data class Email private constructor(
      val value: String
  ) {
      companion object {
          fun of(value: String): Email {
              require(value.contains("@")) { "유효한 이메일 형식이 아닙니다." }
              return Email(value)
          }
      }
  }
  ```

---

## 20. Kafka 및 Avro 사용 규칙

### 20.1 목적

Kafka를 활용한 이벤트 기반 아키텍처에서 Avro를 데이터 직렬화 포맷으로 사용합니다.

### 20.2 기본 규칙

- **메시징 시스템**: Apache Kafka
- **직렬화 포맷**: Avro
- **스키마 관리**: Confluent Schema Registry

---

## 21. JPA 엔티티 작성 규칙

### 21.1 목적

JPA 엔티티는 데이터베이스와 객체 간 매핑을 담당하며, `Infrastructure` 레이어에서 정의됩니다.

### 21.2 기본 규칙

- **위치**: `Infrastructure` 레이어.
- **불변성**: 모든 필드는 `val`로 정의.
- **예시**:
  ```kotlin
  @Entity
  @Table(name = "users")
  class UserEntity(
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      val id: Long? = null,
      val name: String,
      val email: String
  )
  ```

---




---

최신버전 목록
- `com.h2database:h2` 2.3.232** (2024년 8월 11일 릴리스)
- `id("io.spring.dependency-management")` 1.1.7** (2024년 12월 17일 릴리스)
- `id("org.springframework.boot")` 3.4.4** (2025년 3월 21일 릴리스)
- `io.mockk:mockk` 1.13.17** (2024년 12월 20일 릴리스)
- `java` - 최신 릴리스 버전은 **JDK 24**, 최신 LTS 버전은 **JDK 21**
- `kotlin("jvm")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("kapt")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.allopen")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.jpa")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.noarg")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.spring")` 2.1.20** (2025년 3월 20일 릴리스)
- `org.assertj:assertj-core` - 안정 버전은 **3.27.3** (2025년 1월 18일 릴리스), 마일스톤 버전은 **4.0.0-M1** (2025년 3월 10일 릴리스)
- `org.jetbrains.kotlin:kotlin-reflect` 2.1.20** (2025년 3월 20일 릴리스)
- `org.jetbrains.kotlin:kotlin-stdlib-jdk8` 2.1.20** (2025년 3월 20일 릴리스)
- `org.junit.jupiter:junit-jupiter-api` 5.11.4** (2025년 1월 출시)
- `org.junit.jupiter:junit-jupiter-engine` 5.11.4** (2025년 1월 출시)
- `org.mapstruct:mapstruct-processor` 1.6.3** (2024년 11월 9일 릴리스)
- `org.mapstruct:mapstruct` 1.6.3** (2024년 11월 9일 릴리스)
- `org.springdoc:springdoc-openapi-starter-webmvc-ui` 2.8.4**
- `org.springframework:spring-context` 7.0.0-M3** (2025년 3월 13일 릴리스)
- `org.springframework:spring-tx` 7.0.0-M3**
- `org.springframework:spring-web` 7.0.0-M3** (2025년 3월 13일 릴리스)
- `org.springframework.boot:spring-boot-starter-data-jpa` 3.4.4**
- `org.springframework.boot:spring-boot-starter-hateoas` 3.4.4**
- `org.springframework.boot:spring-boot-starter-test` 3.4.4**
- `org.springframework.boot:spring-boot-starter-validation` 3.4.4**
- `org.springframework.boot:spring-boot-starter-web` 3.4.4**
- `org.webjars:webjars-locator-core` 0.59**
