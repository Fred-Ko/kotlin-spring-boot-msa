---
description: 
globs: 
alwaysApply: true
---
# 프로젝트 기술 문서

## 1. 프로젝트 개요

### 1.1 기술 스택

- **프레임워크**: Spring Boot
- **빌드 도구**: Gradle
- **프로그래밍 언어**: Kotlin
- **매핑 라이브러리**: MapStruct

### 1.2 아키텍처 원칙

- **도메인 주도 설계(DDD)**: 핵심 도메인 로직에 집중합니다.
- **클린 아키텍처**: 시스템을 Presentation, Application, Domain, Infrastructure의 4개 레이어로 명확히 구분합니다. 이외에 특별한 상위 레이어로 Messaging 레이어를 도입하며 @KafkaListener나 이와 비슷한 책임을 가지는 코드만 존재한다.
- **이벤트 소싱**: 사용하지 않습니다. 비동기 상태 추적은 별도의 상태 저장소를 통해 구현됩니다.

---

## 2. 모듈화 전략

### 2.1 멀티모듈 프로젝트

- **레이어별 모듈 분리**: Presentation, Application, Domain, Infrastructure 레이어별로 모듈을 분리하여 관리합니다.
- **목적**: 한 영역의 변경이 다른 영역에 미치는 영향을 최소화합니다.

### 2.2 도메인별 모듈화

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.

### 2.3 공통 모듈 (`common`)

- **내용**: 전역에서 사용하는 순수 유틸리티, 공유 추상 클래스, 인터페이스 등이 포함됩니다.
- **주의**: 과도한 의존을 피하여 “공통 모듈 지옥”을 방지합니다.

---

## 3. CQRS 패턴

### 3.1 Command

- **역할**: 상태 변경이나 특정 기능 실행을 위한 데이터 전송을 담당합니다.
- **특징**: 애플리케이션 레이어에서 Command는 데이터(상태 변경 결과)를 반환하지 않습니다.

### 3.2 Query

- **역할**: 데이터 조회 또는 검색을 위한 요청을 처리합니다.

---

## 4. DTO 네이밍 규칙

### 4.1 Presentation 레이어

- **Request DTO**: 사용자로부터 입력받은 데이터를 담으며, 이름 뒤에 “Request”를 붙입니다.
  - 예: `UserCreateRequest`, `ProductUpdateRequest`, `LoginRequest`
- **Response DTO**: API가 응답으로 반환하는 데이터를 담으며, 이름 뒤에 “Response”를 붙입니다.
  - 예: `UserInfoResponse`, `ProductDetailResponse`, `AuthTokenResponse`

### 4.2 Application 레이어

- **Command DTO**: 특정 기능 실행(명령)에 필요한 데이터를 캡슐화하며, 이름 뒤에 “Command”를 붙입니다.
  - 예: `CreateUserCommand`, `UpdateProductCommand`
- **Query DTO**: 데이터 조회 및 검색 요청에 필요한 정보를 전달하며, 이름 뒤에 “Query”를 붙입니다.
  - 예: `GetUserQuery`, `FindProductsQuery`

### 4.3 DTO 변환 규칙

- **원칙**: Presentation 레이어의 `Request DTO`는 애플리케이션 레이어의 `Command DTO` 또는 `Query DTO`로 변환되어 사용됩니다.
- **구현**: MapStruct를 사용하여 객체 간 매핑을 자동화합니다.
  - **설명**: 인터페이스를 통해 매핑 규칙을 정의하며, 컴파일 타임에 매핑 코드를 생성하여 런타임 오버헤드를 줄입니다.
  - **장점**:
    - **생산성**: 반복적인 매핑 코드를 줄여 개발 속도가 빨라집니다.
    - **유지보수**: 명시적인 인터페이스로 일관성을 유지하며, 변경이 용이합니다.
    - **복잡한 매핑 지원**: 중첩 객체, 컬렉션 매핑 등 복잡한 경우에도 쉽게 처리 가능합니다.
  - **단점**:
    - **의존성 추가**: MapStruct와 관련 빌드 설정이 프로젝트에 추가됩니다.
    - **커스터마이징 한계**: 특정 요구사항에 맞춘 세밀한 조정이 인터페이스 수정으로 제한될 수 있습니다.
    - **학습 곡선**: 팀원 모두가 MapStruct 인터페이스 작성법을 익혀야 합니다.
- **설정**:
  - Gradle에 MapStruct 의존성 추가:

    ```groovy
    dependencies {
        implementation "org.mapstruct:mapstruct:1.5.5.Final"
        annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"
    }
    ```

  - Spring Boot와 통합 시 `@Mapper(componentModel = "spring")` 사용.
- **예시 (MapStruct 사용)**:

  ```kotlin
  @Mapper(componentModel = "spring")
  interface UserMapper {
      fun toCreateUserCommand(request: UserCreateRequest): CreateUserCommand
  }
  ```

  - 사용 예시:

    ```kotlin
    @Autowired
    private lateinit var userMapper: UserMapper

    val command = userMapper.toCreateUserCommand(request)
    ```

---

## 5. 레이어 간 의존성 및 도메인 규칙

### 5.1 도메인 레이어의 독립성

- **규칙**: Domain 레이어는 Presentation, Application, Infrastructure 레이어를 절대 참조하지 않습니다.
- **목적**: 도메인의 순수성을 유지합니다.

### 5.2 Aggregate의 VO 사용 범위

- **규칙**: 도메인 내 Aggregate(집합체)의 Value Object(VO)는 Domain 레이어 외부에서 사용하지 않습니다.
- **목적**: 도메인 경계 내에서만 활용합니다.

### 5.3 엔티티 정의 규칙

#### 5.3.1 JPA 엔티티의 위치

- **규칙**: JPA 엔티티는 `Infrastructure` 레이어에 정의합니다.
- **목적**: 데이터베이스와의 매핑을 담당하는 JPA 엔티티를 인프라스트럭처 레이어로 분리하여, 도메인 레이어의 순수성을 유지하고 기술적 의존성을 격리합니다.
- **구현**:
  - JPA 엔티티는 `@Entity` 어노테이션을 사용하며, 데이터베이스 테이블과 매핑됩니다.
  - 도메인 로직은 JPA 엔티티에 포함시키지 않고, 필요 시 도메인 레이어의 Aggregate나 VO로 변환하여 사용합니다.
- **예시**:

  ```kotlin
  @Entity
  @Table(name = "users")
  data class UserEntity(
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      val id: Long? = null,
      val name: String,
      val email: String
  )
  ```

#### 5.3.2 Aggregate와 VO의 위치

- **규칙**: Aggregate, Value Object(VO), 그리고 기타 DDD 엔티티는 `Domain` 레이어에 정의하며, 외부 기술 프레임워크(JPA, Spring 등)에 의존하지 않도록 최대한 순수하게 유지합니다.
- **목적**: 도메인 로직의 독립성과 재사용성을 보장하며, 비즈니스 규칙을 기술적 세부사항과 분리합니다.
- **구현**:
  - Aggregate는 도메인 내의 루트 엔티티로, 비즈니스 규칙과 불변성을 관리합니다.
  - VO는 불변 객체로, 도메인 내에서 값의 의미를 캡슐화합니다.
  - JPA 엔티티와의 매핑은 `Infrastructure` 레이어에서 별도로 처리하며, MapStruct를 활용해 변환합니다.
- **예시**:

  ```kotlin
  data class User(
      val id: UserId,
      val name: String,
      val email: Email
  ) {
      fun updateName(newName: String): User {
          return copy(name = newName)
      }
  }

  @JvmInline
  value class UserId(val value: Long)

  data class Email(val value: String) {
      init {
          require(value.contains("@")) { "유효한 이메일 형식이 아닙니다." }
      }
  }
  ```

#### 5.3.3 JPA 엔티티와 DDD 엔티티 간 매핑

- **규칙**: JPA 엔티티와 도메인 레이어의 Aggregate/VO 간 변환은 `Infrastructure` 또는 `Application` 레이어에서 수행하며, MapStruct를 사용하지 않고 직접 매핑 로직을 정의합니다.
- **목적**: 도메인 레이어의 순수성을 유지하면서, 데이터 영속성과 도메인 로직을 분리합니다.
- **구현**:
  - `Infrastructure` 레이어에서 Repository가 JPA 엔티티를 조회/저장하고, 이를 도메인 객체로 변환합니다.
  - MapStruct 인터페이스를 통해 명시적이고 컴파일 타임에 검증 가능한 매핑을 제공합니다.
- **예시**:

  ```kotlin
  @Component
  class UserEntityMapper {
      fun toEntity(user: User): UserEntity {
          return UserEntity(
              id = user.id.value,
              name = user.name,
              email = user.email.value
          )
      }

      fun toDomain(entity: UserEntity): User {
          return User(
              id = UserId(entity.id!!),
              name = entity.name,
              email = Email(entity.email)
          )
      }
  }

  @Repository
  class UserRepository(
      private val jpaRepository: SpringDataJpaUserRepository,
      private val userEntityMapper: UserEntityMapper
  ) {
      fun findById(id: UserId): User? {
          return jpaRepository.findById(id.value)?.let { userEntityMapper.toDomain(it) }
      }

      fun save(user: User): User {
          val entity = userEntityMapper.toEntity(user)
          return userEntityMapper.toDomain(jpaRepository.save(entity))
      }
  }
  ```

#### 5.3.4 주의사항

- **도메인 레이어의 순수성**: 도메인 객체는 JPA 어노테이션(`@Entity`, `@Id` 등)이나 Spring 관련 의존성을 포함시키지 않습니다.
- **성능 고려**: 빈번한 객체 변환으로 인한 오버헤드를 줄이기 위해, 필요한 경우 매핑 로직을 최적화하거나 캐싱을 고려합니다.
- **테스트 용이성**: 도메인 레이어는 가능하다면 순수 Kotlin으로 작성되므로, 단위 테스트 시 mocking 없이 독립적으로 테스트 가능합니다.

---

## 6. 애플리케이션 레이어 구조

### 6.1 예시 디렉터리 구조

```plaintext
domains:
 user:
   src:
  main:
    kotlin:
   com:
     example:
    application:
      command:
     - CreateUserCommand.kt
     - UpdateUserCommand.kt
     - handler
      - CreateUserCommandHandler.kt
      - UpdateUserCommandHandler.kt
      query:
     - GetUserQuery.kt
     - FindUsersQuery.kt
     - handler
      - GetUserQueryHandler.kt
      - FindUsersQueryHandler.kt
      mapper:
     - UserMapper.kt
      common:
     - UserApplicationException.kt
 order:
   src:
     main:
       kotlin:
         com:
           example:
             application:
               command:
                 - CreateOrderCommand.kt
                 - UpdateOrderCommand.kt
                 - CancelOrderCommand.kt
                 - handler
                   - CreateOrderCommandHandler.kt
                   - UpdateOrderCommandHandler.kt
                   - CancelOrderCommandHandler.kt
               query:
                 - GetOrderQuery.kt
                 - FindOrdersQuery.kt
                 - FindOrdersByCustomerQuery.kt
                 - handler
                   - GetOrderQueryHandler.kt
                   - FindOrdersQueryHandler.kt
                   - FindOrdersByCustomerQueryHandler.kt
               mapper:
                 - OrderMapper.kt
               common:
                 - OrderApplicationException.kt
```

---

## 7. 프레젠테이션 레이어 구조

### 7.1 예시 디렉터리 구조

```plaintext
domains:
 user:
   src:
  main:
    kotlin:
   com:
     example:
    presentation:
      v1:
     command:
       - UserCommandController.kt
       dto:
      request:
        - UserCreateRequestV1.kt
        - UserUpdateRequestV1.kt
     query:
       - UserQueryController.kt
       dto:
      response:
        - UserResponseV1.kt
        - UserSearchResponseV1.kt
      v2:
     command:
       - UserCommandControllerV2.kt
       dto:
      request:
        - UserCreateRequestV2.kt
     query:
       - UserQueryControllerV2.kt
       dto:
      response:
        - UserDetailResponseV2.kt
 order:
   src:
  main:
    kotlin:
   com:
     example:
    presentation:
      v1:
     command:
       - OrderCommandController.kt
       dto:
      request:
        - OrderCreateRequestV1.kt
        - OrderCancelRequestV1.kt
     query:
       - OrderQueryController.kt
       dto:
      response:
        - OrderResponseV1.kt
        - OrderHistoryResponseV1.kt
```

---

## 8. Query 전략

### 8.1 페이지네이션

- **규칙**: 다건 조회는 페이지네이션을 적용.
- **방식**: 결정 시 커서 페이지네이션을 기본.

---

## 9. Command 요청에 대한 REST 응답 규칙

### 9.1 동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, 애플리케이션 레이어의 Command 실행 결과를 기반으로 최소한의 메타데이터를 반환합니다.
- **필수 필드**: `status`, `message`, `correlationId` (결과 확인용 식별자)
- **예시**:

  ```json
  {
    "status": "success",
    "message": "요청이 처리되었습니다.",
    "correlationId": "correlation123"
  }
  ```

### 9.2 비동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, URL 처리는 프레젠테이션 레이어에서만 수행됩니다. 애플리케이션 레이어는 `jobId`만 제공합니다.
- **필수 필드**: `status`, `message`, `jobId`, 상태 조회 및 관리용 링크
- **예시**:

  ```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job12345",
    "links": [
      {
        "rel": "job-status-ws",
        "href": "wss://example.com/ws/job-status/job12345",
        "type": "ws",
        "action": "subscribe"
      },
      {
        "rel": "job-none-ws",
        "href": "/api/v1/jobs/status/job12345",
        "type": "http",
        "method": "GET",
        "action": "get-status"
      }
    ]
  }
  ```

---

## 10. Command 요청에 대한 REST 실패 응답 규칙

(기존 내용이 RFC 7807 준수로 섹션 12에서 통합되었으므로 생략)

---

## 11. 애플리케이션 레이어에서 Command 리턴 규칙

### 11.1 기본 원칙

- **규칙**: Command 핸들러는 상태 변경만 수행하며, 비즈니스 데이터(예: 생성된 엔티티의 상세 정보)를 반환하지 않습니다.
- **참고**: 결과 확인용 `correlationId` 또는 `jobId`는 반환 가능하며, 이는 프레젠테이션 레이어에서 처리됩니다.

### 11.2 동기 Command 처리

- **리턴 값**: `CommandResult` 객체
- **필수 필드**:
  - `success`: boolean
  - `correlationId`: string
- **예시**:

  ```json
  {
    "success": true,
    "correlationId": "corr-456"
  }
  ```

### 11.3 비동기 Command 처리

- **리턴 값**: `AsyncCommandResult` 객체
- **필수 필드**:
  - `success`: boolean
  - `jobId`: string
- **예시**:

  ```json
  {
    "success": true,
    "jobId": "job-789"
  }
  ```

- **참고**: 상태 추적은 데이터베이스 테이블 또는 메시지 큐를 통해 관리되며, 이벤트 소싱은 사용하지 않습니다.

### 11.4 실패 처리

- **리턴 값**: `CommandResult` 또는 `AsyncCommandResult` 객체에 오류 정보 포함
- **필수 필드**:
  - `success`: false
  - `errorCode`: string
- **예시**:

  ```json
  {
    "success": false,
    "errorCode": "VALIDATION_ERROR"
  }
  ```

- **참고**: 실패 시 프레젠테이션 레이어에서 `ProblemDetail`을 사용해 RFC 7807 형식으로 변환되며, 자세한 내용은 섹션 12. 에러 처리를 참조하세요.

### 11.5 구현 참고

- **동기 Command 핸들러 예시**:

  ```kotlin
  class CreateUserCommandHandler {
      fun handle(command: CreateUserCommand): CommandResult {
          userRepository.save(User(command.name, command.email))
          return CommandResult(true, UUID.randomUUID().toString())
      }
  }
  ```

- **프레젠테이션 계층에서의 변환 (MapStruct 사용)**:

  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserController(
      private val createUserCommandHandler: CreateUserCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping
      fun createUser(@RequestBody request: UserCreateRequest): ResponseEntity<Any> {
          val command = userMapper.toCreateUserCommand(request)
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

- **MapStruct 매퍼 정의**:

  ```kotlin
  @Mapper(componentModel = "spring")
  interface UserMapper {
      fun toCreateUserCommand(request: UserCreateRequest): CreateUserCommand
  }
  ```

---

## 12. 에러 처리

### 12.1 목적

- 시스템의 안정성을 유지하고, 클라이언트에게 RFC 7807("Problem Details for HTTP APIs")에 준수하는 명확한 에러 메시지를 제공하기 위해 일관된 에러 처리 전략을 정의합니다.
- 레이어별로 적절한 에러 처리를 통해 책임을 명확히 하고, 에러의 원인을 쉽게 파악할 수 있도록 합니다.

### 12.2 레이어별 에러 처리

#### 12.2.1 Presentation 레이어

- **역할**: 클라이언트의 요청을 검증하고, 애플리케이션 레이어로 전달하기 전에 유효성 검사를 수행합니다.
- **에러 유형**: 요청 데이터의 유효성 검사 실패, 인증/인가 실패 등.
- **처리 방식**: `@Valid` 어노테이션을 사용한 유효성 검사, Spring Security를 통한 인증/인가 처리.
- **응답**: `ProblemDetail`을 사용하여 RFC 7807 형식으로 클라이언트에게 반환.

#### 12.2.2 Application 레이어

- **역할**: 비즈니스 로직을 실행하며, 도메인 레이어와 상호작용합니다.
- **에러 유형**: 비즈니스 규칙 위반, 도메인 로직 에러 등.
- **처리 방식**: 도메인에서 발생한 예외를 catching하고, `CommandResult` 또는 `AsyncCommandResult`에 에러 정보를 포함하여 반환. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환.
- **응답**: CommandResult 또는 AsyncCommandResult에 에러 정보를 포함하여 반환.

#### 12.2.3 Domain 레이어

- **역할**: 핵심 비즈니스 로직을 포함하며, 도메인 규칙을 준수합니다.
- **에러 유형**: 도메인 규칙 위반 (예: 무효한 상태 전환).
- **처리 방식**: 도메인 예외를 throw하여 상위 레이어로 전달.
- **예외 클래스**: `DomainException`과 같은 커스텀 예외 클래스를 사용.

#### 12.2.4 Infrastructure 레이어

- **역할**: 데이터베이스, 외부 API 등과의 통신을 담당합니다.
- **에러 유형**: 데이터베이스 연결 실패, 외부 API 응답 지연 등.
- **처리 방식**: 인프라 관련 예외를 catching하고, 애플리케이션 레이어에서 처리할 수 있는 형태로 변환.
- **예외 클래스**: `InfrastructureException`과 같은 커스텀 예외 클래스를 사용.

### 12.3 에러 응답 형식

- **형식**: 모든 에러 응답은 RFC 7807에 따라 JSON 형식으로 반환되며, Spring Boot 3.0 이상에서 제공하는 `ProblemDetail` 클래스를 기본으로 사용합니다. `ProblemDetail`은 다음과 같은 필드를 포함합니다:
  - `type`: 문제 유형을 식별하는 URI (기본값: "about:blank")
  - `title`: 문제 유형에 대한 간단한 설명 (문제 유형별 고정 문자열)
  - `status`: HTTP 상태 코드
  - `detail`: 문제에 대한 인스턴스별 설명
  - `instance`: 문제를 발생시킨 특정 요청을 식별하는 URI (선택적)
  - 확장 필드: `errorCode` (에러 식별용 고유 코드), `timestamp` (에러 발생 시각) 등은 `setProperty` 메서드를 통해 추가됩니다.
- **예시**:

  ```json
  {
    "type": "https://example.com/probs/user-not-found",
    "title": "User Not Found",
    "status": 404,
    "detail": "사용자를 찾을 수 없습니다.",
    "instance": "/api/v1/users/123",
    "errorCode": "USER_NOT_FOUND",
    "timestamp": "2025-03-24T12:00:00Z"
  }
  ```

- **구현 참고**:
  - `ProblemDetail`은 Spring Boot 3.0 이상에서 기본 제공되며, 별도 의존성 추가 없이 사용 가능합니다. Spring Boot 2.x를 사용하는 경우, `org.zalando:problem-spring-web` 라이브러리를 통해 유사한 기능을 구현할 수 있습니다.
  - `status` 필드는 `UserErrorCode` enum에 정의된 `HttpStatus` 값과 일치해야 하며, 자세한 내용은 섹션 12.6을 참조하세요.

### 12.4 로깅

- **규칙**: 모든 에러는 로깅되며, 로깅 레벨은 에러의 심각도에 따라 다릅니다.
  - **INFO**: 클라이언트의 잘못된 요청 (예: 유효성 검사 실패)
  - **WARN**: 시스템의 일부 기능에 영향을 미치는 에러
  - **ERROR**: 시스템의 주요 기능에 영향을 미치는 심각한 에러
- **로깅 형식**: 에러 코드, 메시지, 스택 트레이스(필요 시) 포함.

### 12.5 예외 클래스

- **커스텀 예외**: 프로젝트에서는 다음과 같은 커스텀 예외 클래스를 정의합니다.
  - `DomainException`: 도메인 레이어에서 발생하는 예외
  - `ApplicationException`: 애플리케이션 레이어에서 발생하는 예외
  - `InfrastructureException`: 인프라 레이어에서 발생하는 예외
  - `PresentationException`: 프레젠테이션 레이어에서 발생하는 예외
- **사용 예시**:

  ```kotlin
  class UserNotFoundException(message: String) : DomainException(message)
  ```

### 12.6 에러 코드 및 Type URI

- **규칙**: 모든 에러는 고유한 에러 코드를 가지며, `type` URI와 HTTP 상태 코드(`HttpStatus`)와 매핑됩니다. 클라이언트가 문제를 식별하고 대응할 수 있도록 API 문서에 정의됩니다.
- **형식**:
  - `errorCode`: 대문자 스네이크 케이스 (예: `USER_NOT_FOUND`, `INVALID_INPUT`)
  - `type`: "<https://example.com/probs/{errorCode> 소문자}" 형식
  - `status`: `org.springframework.http.HttpStatus` 열거형 값으로, 각 에러 코드에 적합한 HTTP 상태 코드를 나타냅니다.
- **구현**: 에러 코드는 `UserErrorCode`와 같은 enum 클래스에 정의되며, `code`, `message`, `status` 필드를 포함합니다.
- **예시**:

  ```kotlin
  enum class UserErrorCode(val code: String, val message: String, val status: HttpStatus) {
      NOT_FOUND("USER_NOT_FOUND", "사용자를 찾을 수 없습니다.", HttpStatus.NOT_FOUND),
      UNAUTHORIZED("UNAUTHORIZED", "인증에 실패했습니다.", HttpStatus.UNAUTHORIZED),
      INVALID_INPUT("INVALID_INPUT", "입력값이 유효하지 않습니다.", HttpStatus.BAD_REQUEST),
      UNKNOWN("UNKNOWN_ERROR", "알 수 없는 오류가 발생했습니다.", HttpStatus.BAD_REQUEST);

      companion object {
          fun fromCode(code: String?): UserErrorCode =
              entries.find { it.code == code } ?: UNKNOWN
      }
  }
  ```

- **사용 예시**:

  ```kotlin
  val error = UserErrorCode.fromCode(result.errorCode)
  val problem = ProblemDetail.forStatus(error.status).apply {
      type = URI.create("https://example.com/probs/${error.code.lowercase()}")
      title = error.code.replace("_", " ").capitalize()
      detail = error.message
      instance = URI.create("/api/v1/users/$userId")
      setProperty("errorCode", error.code)
      setProperty("timestamp", Instant.now().toString())
  }
  ```

- **문서화**: 에러 코드, `type` URI, 그리고 해당 HTTP 상태 코드는 API 문서(Swagger 등)에 명시되며, `UserErrorCode` enum을 기반으로 자동 생성될 수 있습니다.
- **주의사항**:
  - 새로운 에러 코드를 추가할 때는 적절한 `HttpStatus`를 선택하여 일관성을 유지해야 합니다.
  - `UNKNOWN_ERROR`는 기본값으로 사용되며, 예상치 못한 오류에 대한 fallback으로 활용됩니다.

### 12.7 글로벌 예외 처리

- **구현**: Spring의 `@ControllerAdvice`를 사용하여 전역적으로 예외를 처리하며, `ProblemDetail`을 활용해 RFC 7807 형식으로 응답을 반환합니다. `UserErrorCode` enum을 참조하여 적절한 HTTP 상태 코드를 설정합니다.
- **예시**:

  ```kotlin
  import org.springframework.http.HttpStatus
  import org.springframework.http.ProblemDetail
  import org.springframework.web.bind.annotation.ControllerAdvice
  import org.springframework.web.bind.annotation.ExceptionHandler
  import org.springframework.http.ResponseEntity
  import java.net.URI
  import java.time.Instant

  @ControllerAdvice
  class GlobalExceptionHandler {
      @ExceptionHandler(DomainException::class)
      fun handleDomainException(ex: DomainException): ResponseEntity<ProblemDetail> {
          val error = UserErrorCode.NOT_FOUND // 실제로는 에러 코드 매핑 로직 필요
          val problem = ProblemDetail.forStatus(error.status).apply {
              type = URI.create("https://example.com/probs/${error.code.lowercase()}")
              title = error.code.replace("_", " ").capitalize()
              detail = ex.message ?: error.message
              instance = URI.create("/api/v1/users/123")
              setProperty("errorCode", error.code)
              setProperty("timestamp", Instant.now().toString())
          }
          return ResponseEntity.status(error.status).body(problem)
      }

      @ExceptionHandler(UserCommandException::class)
      fun handleUserCommandException(ex: UserCommandException): ResponseEntity<ProblemDetail> {
          val error = UserErrorCode.fromCode(ex.errorCode)
          val problem = ProblemDetail.forStatus(error.status).apply {
              type = URI.create("https://example.com/probs/${error.code.lowercase()}")
              title = error.code.replace("_", " ").capitalize()
              detail = ex.message ?: error.message
              instance = URI.create("/api/v1/users/register")
              setProperty("errorCode", error.code)
              setProperty("timestamp", Instant.now().toString())
          }
          return ResponseEntity.status(error.status).body(problem)
      }
  }

  class UserCommandException(val errorCode: String?, message: String) : RuntimeException(message)
  ```

- **참고**:
  - `UserErrorCode` enum을 활용하여 `status`, `type`, `title`, `detail`을 동적으로 설정하며, 하드코딩을 최소화합니다.
  - 커스텀 예외 클래스(예: `UserCommandException`)에서 `errorCode`를 전달받아 매핑합니다.

### 12.8 비동기 에러 처리

- **특징**: 비동기 Command의 경우, 에러가 발생하면 `AsyncCommandResult`에 에러 정보를 포함하여 반환합니다. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환하여 응답합니다.
- **응답 형식** (RFC 7807 준수):

  ```json
  {
    "type": "https://example.com/probs/async-processing-error",
    "title": "Async Processing Error",
    "status": 400,
    "detail": "비동기 작업 처리에 실패했습니다.",
    "instance": "/api/v1/users/async",
    "errorCode": "ASYNC_PROCESSING_ERROR",
    "timestamp": "2025-03-24T12:00:00Z",
    "jobId": "job123"
  }
  ```

- **상태 조회**: 클라이언트는 `jobId`를 사용하여 작업의 최종 상태를 조회할 수 있으며, 에러 발생 시 상세 에러 정보를 확인할 수 있습니다.
- **구현 예시**:

  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserAsyncCommandController(
      private val handler: CreateUserAsyncCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping("/async")
      fun createUserAsync(@RequestBody request: UserCreateRequest): ResponseEntity<Any> {
          val command = userMapper.toCreateUserCommand(request)
          val result = handler.handle(command)
          return if (result.success) {
              ResponseEntity.accepted().body(mapOf(
                  "status" to "accepted",
                  "message" to "요청이 접수되었습니다.",
                  "jobId" to result.jobId
              ))
          } else {
              val error = UserErrorCode.fromCode(result.errorCode)
              val problem = ProblemDetail.forStatus(error.status).apply {
                  type = URI.create("https://example.com/probs/${error.code.lowercase()}")
                  title = error.code.replace("_", " ").capitalize()
                  detail = error.message
                  instance = URI.create("/api/v1/users/async")
                  setProperty("errorCode", error.code)
                  setProperty("timestamp", Instant.now().toString())
                  setProperty("jobId", result.jobId)
              }
              ResponseEntity.status(error.status).body(problem)
          }
      }
  }
  ```

---

### 수정 요약

- **12.3**: `status`가 `UserErrorCode`의 `HttpStatus`와 연계됨을 명시.
- **12.6**: `UserErrorCode`에 `HttpStatus` 필드 추가, `fromCode` 헬퍼 메서드 포함, 사용 예시와 문서화 가이드라인 업데이트.
- **12.7**: 글로벌 예외 처리에서 `UserErrorCode`를 활용한 동적 `ProblemDetail` 생성 예시 추가.
- **12.8**: 비동기 에러 처리에서도 `UserErrorCode`를 사용하도록 예시 수정.

이로써 `UserErrorCode` 개선 사항이 **12. 에러 처리** 섹션에 완전히 반영되었습니다. 추가적인 조정이 필요하면 말씀해주세요
---

## 13. HATEOAS 및 URI 템플릿 사용 규칙

### 13.1 목적

- RESTful API에서 클라이언트가 하드코딩된 URL에 의존하지 않고, 동적으로 제공되는 링크를 통해 리소스를 탐색할 수 있도록 HATEOAS(Hypermedia as the Engine of Application State)를 적용합니다.
- URI 템플릿을 활용하여 경로 변경에 유연하게 대응합니다.

### 13.2 기본 규칙

- **의존성**: Spring HATEOAS(`spring-boot-starter-hateoas`)를 사용합니다.
- **링크 포함**: 성공적인 Command 요청(동기/비동기) 응답에는 관련 리소스 상태 확인 또는 다음 작업을 위한 링크를 포함합니다.
- **실패 응답**: 링크는 선택 사항이며, 오류 해결을 위한 추가 링크(예: 재시도)가 있다면 포함 권장. 실패 응답은 `ProblemDetail`을 사용하여 처리되며, 섹션 12. 에러 처리를 참조하세요.

### 13.3 링크 구조

- **필수 필드**: 모든 링크는 `rel`(관계), `href`(URL), `method`(HTTP 메서드)를 포함합니다.
- **형식**:

  ```kotlin
  mapOf(
      "rel" to "관계_이름",
      "href" to "리소스_URL",
      "method" to "HTTP_메서드"
  )
  ```

- **예시**:

  ```kotlin
  mapOf(
      "rel" to "job-status",
      "href" to "/api/v1/jobs/status/job123",
      "method" to "GET"
  )
  ```

### 13.4 URI 템플릿 사용

- **하드코딩 금지**: 링크 경로는 하드코딩하지 않고, Spring HATEOAS의 `linkTo`와 `methodOn`을 사용해 동적으로 생성합니다.
- **형식**:

  ```kotlin
  linkTo<컨트롤러_클래스> { 메서드(파라미터) }.withRel("관계_이름")
  ```

- **예시**:

  ```kotlin
  val statusLink = linkTo<JobStatusController> { getJobStatus(jobId) }.withRel("job-status")
  ```

### 13.5 비동기 Command 규칙

- **필수 링크**: 비동기 응답에는 작업 상태 확인을 위한 `job-status` 링크를 포함하며, `jobId`를 기반으로 생성합니다.
- **예시**:

  ```kotlin
  val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
  "links" to listOf(mapOf("rel" to statusLink.rel.value(), "href" to statusLink.href, "method" to "GET"))
  ```

### 13.6 응답 형식

- **규칙**: 링크는 응답의 `links` 필드에 `List<Map<String, String>>`로 포함됩니다.
- **예시**:

  ```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job123",
    "links": [
      {
        "rel": "job-status",
        "href": "/api/v1/jobs/status/job123",
        "method": "GET"
      }
    ]
  }
  ```

### 13.7 구현 참고

- **비동기 Command 예시 (MapStruct 사용)**:

  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserAsyncCommandController(
      private val handler: CreateUserAsyncCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping("/async")
      fun createUserAsync(@RequestBody request: UserCreateRequest): ResponseEntity<Map<String, Any>> {
          val command = userMapper.toCreateUserCommand(request)
          val result = handler.handle(command)
          val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
          return if (result.success) {
              ResponseEntity.accepted().body(mapOf(
                  "status" to "accepted",
                  "message" to "요청이 접수되었습니다.",
                  "jobId" to result.jobId,
                  "links" to listOf(mapOf(
                      "rel" to statusLink.rel.value(),
                      "href" to statusLink.href,
                      "method" to "GET"
                  ))
              ))
          } else {
              // ProblemDetail을 사용한 에러 응답은 섹션 12.8 참조
              throw ApplicationException("비동기 작업 실패")
          }
      }
  }
  ```

### 13.8 준수 사항

- **컨트롤러 메서드 명명**: `linkTo`가 참조하므로 메서드 이름은 명확해야 합니다(예: `getJobStatus`).
- **테스트**: `MockMvc`를 사용해 링크 생성을 검증합니다.
- **문서화**: Swagger와 통합 시 `links` 필드를 명시적으로 정의합니다.

---

## 14 프로젝트 구조 참고용

아래는 참고용이고 그대로 하라는건 아니다.

```
domains/
├── common/
│   ├── src/main/kotlin/com/example/common/
│   ├── dto/
│   │   ├── CommandResult.kt
│   │   └── AsyncCommandResult.kt
│   ├── exception/
│   │   ├── DomainException.kt
│   │   ├── ApplicationException.kt
│   │   ├── InfrastructureException.kt
│   │   └── PresentationException.kt
│   └── config/
│       ├── MapStructConfig.kt
│       └── GlobalExceptionHandler.kt
│   └── build.gradle.kts
│
├── user/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/user/
│   │   │   └── UserApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/user/
│   │   │   ├── aggregate/User.kt (Aggregate)
│   │   │   ├── vo/UserId.kt (VO)
│   │   │   ├── vo/Email.kt (VO)
│   │   │   ├── repository/UserRepository.kt (Interface)
│   │   │   └── exception/UserDomainException.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/user/
│   │   │   ├── command/
│   │   │   │   ├── CreateUserCommand.kt
│   │   │   │   ├── UpdateUserCommand.kt
│   │   │   │   └── handler/
│   │   │   │       ├── CreateUserCommandHandler.kt
│   │   │   │       └── UpdateUserCommandHandler.kt
│   │   │   ├── query/
│   │   │   │   ├── GetUserQuery.kt
│   │   │   │   ├── FindUsersQuery.kt
│   │   │   │   └── handler/
│   │   │   │       ├── GetUserQueryHandler.kt
│   │   │   │       └── FindUsersQueryHandler.kt
│   │   │   ├── mapper/UserMapper.kt
│   │   │   └── common/UserApplicationException.kt
│   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/user/
│   │   │   ├── entity/UserEntity.kt
│   │   │   ├── mapper/UserEntityMapper.kt
│   │   │   ├── repository/
│   │   │   │   ├── SpringDataJpaUserRepository.kt
│   │   │   │   └── UserRepositoryImpl.kt
│   │   │   └── exception/UserInfrastructureException.kt
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/user/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── UserCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── UserCreateRequestV1.kt
│   │   │   │   │       └── UserUpdateRequestV1.kt
│   │   │   │   └── query/
│   │   │   │       ├── UserQueryController.kt
│   │   │   │       └── dto/response/
│   │   │   │           ├── UserResponseV1.kt
│   │   │   │           └── UserSearchResponseV1.kt
│   │   │   └── exception/UserPresentationException.kt
│   │   └── build.gradle.kts
│   └── build.gradle.kts
│
├── order/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/order/
│   │   │   └── OrderApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/order/
│   │   │   ├── aggregate/Order.kt (Aggregate)
│   │   │   ├── vo/OrderId.kt (VO)
│   │   │   ├── entity/OrderItem.kt (Entity/VO)
│   │   │   ├── vo/OrderStatus.kt (Enum)
│   │   │   ├── repository/OrderRepository.kt (Interface)
│   │   │   └── exception/OrderDomainException.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/order/
│   │   │   ├── command/
│   │   │   │   ├── CreateOrderCommand.kt
│   │   │   │   ├── UpdateOrderCommand.kt
│   │   │   │   ├── CancelOrderCommand.kt
│   │   │   │   └── handler/
│   │   │   │       ├── CreateOrderCommandHandler.kt
│   │   │   │       ├── UpdateOrderCommandHandler.kt
│   │   │   │       └── CancelOrderCommandHandler.kt
│   │   │   ├── query/
│   │   │   │   ├── GetOrderQuery.kt
│   │   │   │   ├── FindOrdersQuery.kt
│   │   │   │   ├── FindOrdersByCustomerQuery.kt
│   │   │   │   └── handler/
│   │   │   │       ├── GetOrderQueryHandler.kt
│   │   │   │       ├── FindOrdersQueryHandler.kt
│   │   │   │       └── FindOrdersByCustomerQueryHandler.kt
│   │   │   ├── mapper/OrderMapper.kt
│   │   │   └── common/OrderApplicationException.kt
│   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/order/
│   │   │   ├── entity/
│   │   │   │   ├── OrderEntity.kt
│   │   │   │   └── OrderItemEntity.kt
│   │   │   ├── mapper/OrderEntityMapper.kt
│   │   │   ├── repository/
│   │   │   │   ├── SpringDataJpaOrderRepository.kt
│   │   │   │   └── OrderRepositoryImpl.kt
│   │   │   └── exception/OrderInfrastructureException.kt
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/order/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── OrderCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── OrderCreateRequestV1.kt
│   │   │   │   │       └── OrderCancelRequestV1.kt
│   │   │   │   └── query/
│   │   │   │       ├── OrderQueryController.kt
│   │   │   │       └── dto/response/
│   │   │   │           ├── OrderResponseV1.kt
│   │   │   │           └── OrderHistoryResponseV1.kt
│   │   │   └── exception/OrderPresentationException.kt
│   │   └── build.gradle.kts
│   └── build.gradle.kts
│
└── build.gradle.kts (최상위)
```

---

## 15 Presentation 레이어 validation

- **목적**: 클라이언트로부터 입력받은 데이터의 유효성을 검증하여 잘못된 요청을 조기에 차단하고, 시스템의 안정성과 데이터 무결성을 보장합니다.
- **규칙**: Presentation 레이어에서 요청 데이터(`Request DTO`)의 유효성 검사는 `jakarta.validation.constraints` 패키지의 어노테이션을 적극 활용하여 수행합니다.
- **의존성**: Spring Boot Starter Validation(`spring-boot-starter-validation`)을 사용하며, Gradle에 추가합니다.
  - **설정 예시**:

    ```groovy
    dependencies {
        implementation "org.springframework.boot:spring-boot-starter-validation"
    }
    ```

- **적용 방식**:
  - 모든 `Request DTO` 필드에 대해 적절한 검증 어노테이션을 적용합니다.
  - 컨트롤러 메서드에서 `@Valid` 어노테이션을 사용하여 유효성 검사를 트리거합니다.
  - 검증 실패 시, Spring의 `MethodArgumentNotValidException`을 통해 `ProblemDetail` 형식으로 에러 응답을 반환합니다(12.7 글로벌 예외 처리 참조).

- **주요 검증 어노테이션**:
  - `@NotNull`: 필수 입력값 검증
  - `@NotBlank`: 공백 문자열 방지 (문자열에 적용)
  - `@Size`: 문자열 길이 또는 컬렉션 크기 제한
  - `@Min` / `@Max`: 숫자 값의 범위 제한
  - `@Email`: 이메일 형식 검증
  - `@Pattern`: 정규 표현식을 통한 형식 검증
  - 기타: 프로젝트 요구사항에 따라 커스텀 어노테이션 정의 가능

- **예시**:
  - **Request DTO 정의**:

    ```kotlin
    data class UserCreateRequestV1(
        @field:NotBlank(message = "이름은 필수입니다.")
        @field:Size(min = 2, max = 50, message = "이름은 2~50자 사이여야 합니다.")
        val name: String,

        @field:NotBlank(message = "이메일은 필수입니다.")
        @field:Email(message = "유효한 이메일 형식이어야 합니다.")
        val email: String,

        @field:NotBlank(message = "비밀번호는 필수입니다.")
        @field:Size(min = 8, max = 20, message = "비밀번호는 8~20자 사이여야 합니다.")
        @field:Pattern(
            regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d@$!%*#?&]+$",
            message = "비밀번호는 영문자와 숫자를 포함해야 합니다."
        )
        val password: String
    )
    ```

  - **컨트롤러에서 사용**:

    ```kotlin
    @RestController
    @RequestMapping("/api/v1/users")
    class UserCommandController(
        private val createUserCommandHandler: CreateUserCommandHandler,
        private val userMapper: UserMapper
    ) {
        @PostMapping
        fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
            val command = userMapper.toCreateUserCommand(request)
            val result = createUserCommandHandler.handle(command)
            return ResponseEntity.ok(mapOf(
                "status" to "success",
                "message" to "요청이 처리되었습니다.",
                "correlationId" to result.correlationId
            ))
        }
    }
    ```

- **에러 응답**: 검증 실패 시, `ProblemDetail`을 사용하여 RFC 7807 형식을 따르며, 필드별 에러 메시지를 확장 필드 `invalid-params`로 포함합니다.
  - **예시 응답**:

    ```json
    {
        "type": "https://example.com/probs/invalid-params",
        "title": "Invalid Input",
        "status": 400,
        "detail": "입력 데이터가 유효하지 않습니다.",
        "instance": "/api/v1/users",
        "errorCode": "VALIDATION_ERROR",
        "timestamp": "2025-03-24T10:00:00Z",
        "invalid-params": [
            {
                "field": "name",
                "message": "이름은 필수입니다."
            },
            {
                "field": "email",
                "message": "유효한 이메일 형식이어야 합니다."
            }
        ]
    }
    ```

---

## 16. 도메인 익셉션의 전파

### 16.1 CommandResult 기반 처리 (예외 없이 결과만 반환)

애플리케이션 레이어에서 도메인 익셉션을 잡아 `CommandResult`로 변환한 경우, 프레젠테이션 레이어는 `CommandResult`의 상태를 확인하여 `ProblemDetail`을 사용해 RFC 7807 형식의 응답을 구성합니다.

- **구현 예시**:

  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
          val command = userMapper.toCreateUserCommand(request)
          val result = createUserCommandHandler.handle(command)

          return if (result.success) {
              ResponseEntity.ok(mapOf(
                  "status" to "success",
                  "message" to "요청이 처리되었습니다.",
                  "correlationId" to result.correlationId
              ))
          } else {
              val problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                  type = URI.create("https://example.com/probs/user-creation-failed")
                  title = "User Creation Failed"
                  detail = "사용자 생성에 실패했습니다."
                  instance = URI.create("/api/v1/users")
                  setProperty("errorCode", result.errorCode ?: "USER_CREATION_FAILED")
                  setProperty("timestamp", Instant.now().toString())
              }
              ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
          }
      }
  }
  ```

- **Command 핸들러 예시**:

  ```kotlin
  class CreateUserCommandHandler(
      private val userRepository: UserRepository
  ) {
      fun handle(command: CreateUserCommand): CommandResult {
          return try {
              userRepository.save(User(command.name, command.email))
              CommandResult(true, UUID.randomUUID().toString())
          } catch (e: DomainException) {
              CommandResult(false, "USER_CREATION_FAILED")
          }
      }
  }
  ```

- **응답 예시**:
  - 성공:

    ```json
    {
      "status": "success",
      "message": "요청이 처리되었습니다.",
      "correlationId": "corr-456"
    }
    ```

  - 실패:

    ```json
    {
      "type": "https://example.com/probs/user-creation-failed",
      "title": "User Creation Failed",
      "status": 400,
      "detail": "사용자 생성에 실패했습니다.",
      "instance": "/api/v1/users",
      "errorCode": "USER_CREATION_FAILED",
      "timestamp": "2025-03-24T10:00:00Z"
    }
    ```

---

## 17. Presentation 레이어에서 Swagger 적용

### 17.1 목적

- API의 명세를 문서화하고, 클라이언트 및 개발자가 쉽게 이해하고 테스트할 수 있도록 Swagger를 Presentation 레이어에 적용합니다. 이를 통해 API의 엔드포인트, 요청/응답 형식, 에러 응답 등을 명확히 정의하고 유지보수성을 높입니다.

### 17.2 의존성 설정

- **의존성**: Spring Boot 프로젝트에서 Swagger를 사용하기 위해 `springdoc-openapi` 라이브러리를 사용합니다.
  - **Gradle 설정 예시**:

    ```groovy
    dependencies {
        implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2"
    }
    ```

- **설명**: `springdoc-openapi-starter-webmvc-ui`는 Spring Boot와 통합된 OpenAPI 3 명세를 생성하며, Swagger UI를 기본 제공합니다.

### 17.3 기본 설정

- **구성**: Spring Boot의 `@Configuration` 클래스를 통해 Swagger 설정을 커스터마이징합니다.
- **예시**:

  ```kotlin
  import io.swagger.v3.oas.models.OpenAPI
  import io.swagger.v3.oas.models.info.Info
  import org.springframework.context.annotation.Bean
  import org.springframework.context.annotation.Configuration

  @Configuration
  class SwaggerConfig {
      @Bean
      fun customOpenAPI(): OpenAPI {
          return OpenAPI()
              .info(
                  Info()
                      .title("Project API")
                      .version("v1")
                      .description("Spring Boot 기반 프로젝트 API 문서")
              )
      }
  }
  ```

- **접근 경로**: 기본적으로 `/v3/api-docs`에서 OpenAPI JSON을 확인할 수 있으며, `/swagger-ui.html`에서 Swagger UI에 접근 가능합니다.

### 17.4 API 문서화

- **어노테이션 사용**: Presentation 레이어의 컨트롤러에 OpenAPI 어노테이션(`@Operation`, `@ApiResponse`, `@Parameter` 등)을 적용하여 API를 문서화합니다.
- **규칙**:
  - 모든 엔드포인트는 `@Operation`으로 설명을 추가합니다.
  - 요청/응답 DTO는 스키마로 자동 생성되며, 추가 설명은 `@Schema`로 제공합니다.
  - 에러 응답은 RFC 7807(`ProblemDetail`) 형식을 반영하여 정의합니다(섹션 12 참조).

- **예시**:

  ```kotlin
  import io.swagger.v3.oas.annotations.Operation
  import io.swagger.v3.oas.annotations.media.Content
  import io.swagger.v3.oas.annotations.media.Schema
  import io.swagger.v3.oas.annotations.responses.ApiResponse
  import io.swagger.v3.oas.annotations.responses.ApiResponses
  import org.springframework.http.ResponseEntity
  import org.springframework.web.bind.annotation.*
  import jakarta.validation.Valid

  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping
      @Operation(summary = "새로운 사용자 생성", description = "사용자 정보를 입력받아 새로운 사용자를 생성합니다.")
      @ApiResponses(
          ApiResponse(responseCode = "200", description = "사용자 생성 성공",
              content = [Content(schema = Schema(implementation = Map::class))]),
          ApiResponse(responseCode = "400", description = "잘못된 요청 데이터",
              content = [Content(schema = Schema(implementation = ProblemDetail::class))])
      )
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
          val command = userMapper.toCreateUserCommand(request)
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

- **Request DTO 문서화**:

  ```kotlin
  import io.swagger.v3.oas.annotations.media.Schema

  @Schema(description = "사용자 생성 요청 데이터")
  data class UserCreateRequestV1(
      @field:Schema(description = "사용자 이름", example = "John Doe", required = true)
      @field:NotBlank(message = "이름은 필수입니다.")
      val name: String,

      @field:Schema(description = "사용자 이메일", example = "john.doe@example.com", required = true)
      @field:NotBlank(message = "이메일은 필수입니다.")
      @field:Email(message = "유효한 이메일 형식이어야 합니다.")
      val email: String
  )
  ```

### 17.5 HATEOAS 통합

- **규칙**: 섹션 13에서 정의된 HATEOAS 링크(`links` 필드)를 Swagger 문서에 반영합니다.
- **구현**: 응답 객체에 `links` 필드를 명시하며, `@Schema`로 설명을 추가합니다.
- **예시**:

  ```kotlin
  @Operation(summary = "비동기 사용자 생성", description = "비동기로 사용자 생성 요청을 접수합니다.")
  @ApiResponses(
      ApiResponse(responseCode = "202", description = "요청 접수 완료",
          content = [Content(schema = Schema(implementation = Map::class))])
  )
  @PostMapping("/async")
  fun createUserAsync(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
      val command = userMapper.toCreateUserCommand(request)
      val result = handler.handle(command)
      val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
      return ResponseEntity.accepted().body(mapOf(
          "status" to "accepted",
          "message" to "요청이 접수되었습니다.",
          "jobId" to result.jobId,
          "links" to listOf(mapOf(
              "rel" to statusLink.rel.value(),
              "href" to statusLink.href,
              "method" to "GET"
          ))
      ))
  }
  ```

### 17.6 에러 응답 문서화

- **규칙**: 섹션 12.3에 정의된 `ProblemDetail` 형식을 Swagger에 반영하며, `UserErrorCode` enum을 기반으로 주요 에러를 문서화합니다.
- **예시**:

  ```kotlin
  @ApiResponses(
      ApiResponse(responseCode = "400", description = "유효성 검사 실패",
          content = [Content(schema = Schema(implementation = ProblemDetail::class))])
  )
  ```

### 17.7 Swagger UI 커스터마이징

- **설정**: `application.yml` 또는 `application.properties`를 통해 Swagger UI 경로와 옵션을 조정 가능합니다.
- **예시**:

  ```yaml
  springdoc:
    swagger-ui:
      path: /custom-swagger-ui.html
      display-request-duration: true
  ```

### 17.8 주의사항

- **버전 관리**: API 버전(`v1`, `v2` 등)에 따라 별도의 Swagger 그룹을 설정하여 문서를 분리할 수 있습니다.
  - 예: `springdoc.group-configs` 설정 사용.
- **성능**: 대규모 프로젝트에서는 Swagger 생성 시 성능 영향을 최소화하기 위해 필요한 엔드포인트만 노출하도록 필터링 고려.
- **보안**: 운영 환경에서는 Swagger UI 접근을 제한하거나 비활성화합니다(예: `springdoc.swagger-ui.enabled=false`).

---

# 18. 테스트 작성 가이드

유닛 테스트는 개별 단위(모듈, 함수, 클래스 등)의 동작을 검증하여 코드 품질을 보장하고 리팩토링 시 안정성을 유지하는 데 목적이 있습니다. 이 가이드는 Kotest, MockK, Testcontainers를 핵심 도구로 사용하여 프로젝트의 각 레이어(Presentation, Application, Domain, Infrastructure)에 대한 테스트 전략을 설명합니다.

---

## 18.1 유닛 테스트의 목표와 원칙
- **목표**: 각 레이어와 모듈이 의도대로 동작하는지 확인.
- **원칙**:
  - **격리성**: 외부 의존성(예: DB, API)을 모킹하여 독립적으로 실행.
  - **반복 가능성**: 동일 입력에 대해 항상 동일 결과 반환.
  - **단일 책임**: 하나의 테스트는 하나의 기능만 검증.
  - **빠른 실행**: 개발 생산성 향상을 위해 신속히 실행.

문서에서 도메인 레이어는 순수 Kotlin으로 작성되며 외부 프레임워크 의존성을 피하므로(5.3.4), 특히 도메인 테스트는 MockK 없이도 쉽게 작성 가능합니다.

---

## 18.2 기술 스택과 도구
- **테스트 프레임워크**: Kotest
  - Kotlin 전용 프레임워크로, 다양한 테스트 스타일(Spec)과 속성 기반 테스트 지원.
- **모킹 도구**: MockK
  - Kotlin에 최적화된 모킹 라이브러리로, 코루틴과 `suspend` 함수 모킹 가능.
- **인프라 테스트**: Testcontainers
  - Docker 컨테이너를 활용해 실제 DB나 외부 서비스를 테스트 환경에서 실행.
- **Gradle 의존성 설정**:
  ```groovy
  dependencies {
      testImplementation "io.kotest:kotest-runner-junit5:5.8.0"
      testImplementation "io.kotest:kotest-assertions-core:5.8.0" // Kotest Assertions
      testImplementation "io.mockk:mockk:1.13.8"
      testImplementation "org.testcontainers:testcontainers:1.19.3"
      testImplementation "org.testcontainers:postgresql:1.19.3" // PostgreSQL 예시
  }
  ```

---

## 18.3 레이어별 유닛 테스트 작성 전략

### 18.3.1 Domain 레이어
- **대상**: Aggregate, Value Object(VO), 도메인 로직
- **특징**: 외부 의존성 없음(5.3.2). Kotest의 `BehaviorSpec` 또는 `FunSpec`으로 가독성 높게 작성.
- **작성 방식**:
  - 객체 생성 및 불변성 검증.
  - 비즈니스 규칙 테스트.
  - 예외 발생 시나리오 확인.
- **예시**: `User` Aggregate 테스트
  ```kotlin
  import io.kotest.core.spec.style.FunSpec
  import io.kotest.matchers.shouldBe
  import io.kotest.assertions.throwables.shouldThrow

  class UserTest : FunSpec({
      test("유효한 데이터로 User 생성 성공") {
          val user = User(UserId(1L), "John Doe", Email("john@example.com"))
          user.name shouldBe "John Doe"
          user.email.value shouldBe "john@example.com"
      }

      test("잘못된 이메일 형식으로 생성 시 예외 발생") {
          val exception = shouldThrow<IllegalArgumentException> {
              User(UserId(1L), "John Doe", Email("invalid-email"))
          }
          exception.message shouldBe "유효한 이메일 형식이 아닙니다."
      }

      test("이름 업데이트 성공") {
          val user = User(UserId(1L), "John Doe", Email("john@example.com"))
          val updatedUser = user.updateName("Jane Doe")
          updatedUser.name shouldBe "Jane Doe"
          updatedUser.id shouldBe user.id // 불변성 확인
      }
  })
  ```

### 18.3.2 Application 레이어 

- **대상**: CommandHandler, QueryHandler
    
- **주요 전략**: Spring Boot 테스트 환경(@SpringBootTest)과 H2 인메모리 데이터베이스를 활용하여 테스트합니다. 각 테스트 메소드 실행 후 @Transactional 어노테이션을 통해 트랜잭션 롤백을 수행하여 테스트 간 격리성을 확보합니다. 이 방식은 실제 데이터베이스 상호작용을 포함하여 더 높은 수준의 통합 검증을 제공합니다.
    
- **보조 전략**: 데이터베이스 외의 외부 시스템(예: 외부 API 클라이언트, 메시지 큐 발행기 등) 의존성은 MockK를 사용하여 모킹할 수 있습니다. 레포지토리 인터페이스 자체를 모킹하는 방식은 이 전략에서는 지양합니다.
    
- **테스트 내용**:
    
    - CommandHandler/QueryHandler의 비즈니스 로직 실행 검증.
        
    - 데이터베이스 상태 변경 확인 (필요시 EntityManager 또는 Repository 조회 사용).
        
    - Command/Query 실행 결과(CommandResult, AsyncCommandResult, 조회 DTO 등) 검증.
        
    - 도메인 예외 또는 애플리케이션 예외 발생 시 핸들러의 적절한 결과 반환 또는 예외 전파 확인 (섹션 16 참조).
        
- **설정**:
    
    - build.gradle.kts에 com.h2database:h2 의존성을 추가합니다.
        
    - src/test/resources/application-test.yml (또는 .properties) 파일에 H2 데이터베이스 설정을 구성합니다 (예: spring.datasource.url=jdbc:h2:mem:testdb;MODE=MySQL, spring.jpa.hibernate.ddl-auto=create-drop).
        
    - 테스트 클래스에 @SpringBootTest와 @Transactional 어노테이션을 적용합니다.
        
- **예시**: CreateUserCommandHandler 테스트 (H2 및 롤백 사용)
    
    ```kotlin
    import com.example.application.user.command.CreateUserCommand
    import com.example.application.user.command.handler.CreateUserCommandHandler
    import com.example.common.dto.CommandResult
    import com.example.domain.user.repository.UserRepository
    import com.example.domain.user.vo.Email
    import com.example.domain.user.vo.Name // Name VO 임포트 추가 (가정)
    import io.kotest.matchers.shouldBe
    import io.kotest.matchers.shouldNotBe
    import org.junit.jupiter.api.DisplayName
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.transaction.annotation.Transactional
    import java.util.UUID
    
    @SpringBootTest // Spring 컨텍스트 로드
    @Transactional // 각 테스트 후 롤백
    class CreateUserCommandHandlerTest @Autowired constructor(
        private val handler: CreateUserCommandHandler, // 핸들러 주입
        private val userRepository: UserRepository // 실제 레포지토리 주입 (H2 사용)
    ) {
    
        @Test
        @DisplayName("유효한 Command로 사용자 생성 시 성공 CommandResult 반환")
        fun `handle valid command should return success result`() {
            // given
            val name = "John Doe"
            val email = "john.doe@example.com"
            val command = CreateUserCommand(name, email)
    
            // when
            val result = handler.handle(command)
    
            // then
            result.success shouldBe true
            result.correlationId shouldNotBe null
            result.errorCode shouldBe null
    
            // DB 상태 검증 (선택적)
            val foundUser = userRepository.findByEmail(Email.of(email)) // Email VO 사용
            foundUser shouldNotBe null
            foundUser?.name?.value shouldBe name // Name VO 사용 가정
        }
    
        @Test
        @DisplayName("중복된 이메일로 사용자 생성 시 실패 CommandResult 반환")
        fun `handle command with duplicate email should return failure result`() {
            // given: 먼저 사용자를 하나 생성
            val existingEmail = "existing@example.com"
            val existingUser = User(Name.of("Existing User"), Email.of(existingEmail)) // VO 사용
            userRepository.save(existingUser)
    
            val command = CreateUserCommand("New User", existingEmail) // 중복 이메일 사용
    
            // when
            val result = handler.handle(command) // 핸들러 내에서 예외를 잡고 CommandResult로 변환한다고 가정 (16.1 참조)
    
            // then
            result.success shouldBe false
            result.errorCode shouldBe "DUPLICATE_EMAIL" // 예시 에러 코드
            result.correlationId shouldBe null // 실패 시 correlationId는 없을 수 있음
        }
    
        @Test
        @DisplayName("잘못된 형식의 이메일로 사용자 생성 시 (VO 검증 실패) 실패 CommandResult 반환")
        fun `handle command with invalid email format should return failure result`() {
            // given
            val command = CreateUserCommand("Test User", "invalid-email-format")
    
            // when: 핸들러 내부에서 Email VO 생성 시 require 에러 발생하고, 이를 catch하여 CommandResult 반환 가정
            val result = handler.handle(command)
    
            // then
            result.success shouldBe false
            result.errorCode shouldBe "INVALID_EMAIL_FORMAT" // 예시 에러 코드
        }
    }
   
    ```
    
- **장점**:
    
    - 모킹 방식보다 실제 실행 환경에 가깝게 테스트할 수 있습니다.        
    - 애플리케이션 로직과 데이터베이스 상호작용(매핑, 제약 조건 등)을 함께 검증하여 신뢰도를 높입니다.
        
- **단점**:    
    - 순수 MockK를 사용하는 방식보다 테스트 실행 속도가 느릴 수 있습니다.        
    - 테스트 환경 설정(H2, Spring Context 로딩)이 추가로 필요합니다.

- **주의**: @Transactional은 기본적으로 테스트 메소드 종료 시 롤백하지만, 테스트 내에서 별도의 스레드를 생성하여 DB 작업을 수행하는 경우 해당 작업은 롤백되지 않을 수 있습니다. 비동기 처리 테스트 시 주의가 필요합니다.
### 18.3.3 Infrastructure 레이어
- **대상**: Repository 구현체, Entity 매핑
- **특징**: Testcontainers로 실제 DB(PostgreSQL 등)를 띄워 JPA 동작 검증(5.3.1).
- **작성 방식**:
  - Testcontainers로 PostgreSQL 컨테이너 설정.
  - Spring의 `@DataJpaTest`와 통합.
  - 매핑 로직 검증.
- **예시**: `UserRepositoryImpl` 테스트
  ```kotlin
  import io.kotest.core.spec.style.FunSpec
  import io.kotest.matchers.shouldBe
  import org.springframework.beans.factory.annotation.Autowired
  import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest
  import org.testcontainers.containers.PostgreSQLContainer
  import org.testcontainers.junit.jupiter.Container
  import org.testcontainers.junit.jupiter.Testcontainers

  @DataJpaTest
  @Testcontainers
  class UserRepositoryImplTest : FunSpec() {
      companion object {
          @Container
          val postgres = PostgreSQLContainer("postgres:15").apply {
              withDatabaseName("testdb")
              withUsername("test")
              withPassword("test")
          }
      }

      @Autowired
      private lateinit var jpaRepository: SpringDataJpaUserRepository
      private val userEntityMapper = UserEntityMapper()
      private lateinit var repository: UserRepository

      init {
          beforeSpec {
              repository = UserRepository(jpaRepository, userEntityMapper)
          }

          test("사용자 저장 및 조회 성공") {
              val user = User(UserId(1L), "John Doe", Email("john@example.com"))
              val savedUser = repository.save(user)

              val foundUser = repository.findById(UserId(1L))
              foundUser?.name shouldBe "John Doe"
          }
      }
  }
  ```
  - **설정 참고**: `application-test.yml`에 Testcontainers의 DB 연결 정보 동적 주입 필요.

### 18.3.4 Presentation 레이어
- **대상**: Controller, DTO 유효성 검사
- **특징**: MockK로 Application 레이어 모킹, Kotest로 HTTP 요청/응답 테스트(15. Presentation Validation).
- **작성 방식**:
  - Spring의 `MockMvc`와 통합.
  - `@Valid` 유효성 검사 확인.
  - HATEOAS 링크 검증(13.3).
- **예시**: `UserCommandController` 테스트
  ```kotlin
  import io.kotest.core.spec.style.FunSpec
  import io.kotest.matchers.shouldBe
  import io.mockk.every
  import io.mockk.mockk
  import org.springframework.beans.factory.annotation.Autowired
  import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
  import org.springframework.http.MediaType
  import org.springframework.test.web.servlet.MockMvc
  import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
  import org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath
  import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
  import com.fasterxml.jackson.databind.ObjectMapper

  @WebMvcTest(UserCommandController::class)
  class UserCommandControllerTest : FunSpec({
      @Autowired
      lateinit var mockMvc: MockMvc
      @Autowired
      lateinit var objectMapper: ObjectMapper

      val createUserCommandHandler = mockk<CreateUserCommandHandler>()
      val userMapper = mockk<UserMapper>()

      beforeEach {
          every { userMapper.toCreateUserCommand(any()) } returns CreateUserCommand("John Doe", "john@example.com")
      }

      test("유효한 요청으로 사용자 생성 성공") {
          val request = UserCreateRequestV1("John Doe", "john@example.com", "Password123!")
          every { createUserCommandHandler.handle(any()) } returns CommandResult(true, "corr-123")

          mockMvc.perform(
              post("/api/v1/users")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request))
          )
              .andExpect(status().isOk)
              .andExpect(jsonPath("$.status").value("success"))
              .andExpect(jsonPath("$.correlationId").value("corr-123"))
      }

      test("유효하지 않은 이메일로 요청 시 400 반환") {
          val invalidRequest = UserCreateRequestV1("John Doe", "invalid-email", "Password123!")

          mockMvc.perform(
              post("/api/v1/users")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(invalidRequest))
          )
              .andExpect(status().isBadRequest)
              .andExpect(jsonPath("$.errorCode").value("VALIDATION_ERROR"))
      }
  })
  ```

---

## 18.4 모킹과 의존성 주입
- **MockK 사용**:
  - `mockk()`: 모킹 객체 생성.
  - `every {}`: 동작 정의.
  - `verify {}`: 호출 검증.
  - 코루틴 지원: `coEvery {}`로 비동기 Command 테스트(11.3).
- **예시**: 비동기 Command 모킹
  ```kotlin
  test("비동기 Command 핸들러 테스트") {
      coEvery { handler.handle(any()) } returns AsyncCommandResult(true, "job-123")
      val result = handler.handle(command)
      result.jobId shouldBe "job-123"
  }
  ```

---

## 18.5 테스트 커버리지와 유지보수
- **커버리지 목표**: 도메인 및 애플리케이션 레이어 80% 이상.
- **도구**: Kotest와 JaCoCo 통합
  ```groovy
  plugins {
      id "jacoco"
  }
  jacocoTestReport {
      reports {
          xml.required = true
          html.required = true
      }
  }
  ```
- **유지보수**: 코드 변경 시 테스트 동기화, Kotest의 가독성 높은 Spec으로 리팩토링 용이.

---

## 18.6 주의사항
- **도메인 순수성**: Kotest로 순수 Kotlin 테스트 유지(5.3.4).
- **Testcontainers 성능**: 실행 속도가 느리므로 유닛 테스트와 통합 테스트 분리 고려.
- **Swagger 일치성**: Presentation 테스트에서 응답이 Swagger 명세와 일치하는지 확인(17.4).
- **코루틴**: MockK의 `coEvery`로 비동기 로직 정확히 모킹(11.3).

---

## 19. Value Object 작성 가이드

### 19.1 목적
Value Object(VO)는 도메인 레이어에서 불변 값을 캡슐화하며, 도메인 규칙을 강제합니다(5.3.2). 이 가이드는 VO의 복잡도와 관계없이 통일된 작성 규칙을 제공하여 코드의 일관성, 가독성, 유지보수성을 보장하는 것을 목표로 합니다.

### 19.2 기본 규칙
- **불변성**: VO는 생성 후 상태가 변경되지 않는 불변 객체로 설계됩니다.
- **Private Constructor**: 직접 객체 생성을 차단하기 위해 생성자를 `private`으로 설정합니다.
- **Companion Object**: VO 생성은 `companion object`에 정의된 `of` 메서드를 통해 제어됩니다.
- **유효성 검사**: `of` 메서드에서 `require`를 사용해 입력값의 유효성을 검사합니다.
- **toString 오버라이드**: 디버깅과 로깅의 편의를 위해 `toString()`을 값 자체로 반환하도록 재정의합니다.

### 19.3 VO 작성 패턴
모든 VO는 다음 구조를 따릅니다:
- **`data class`로 작성**: 단순 VO와 복잡 VO 모두 `data class`를 사용합니다.
- **`private constructor`로 생성 차단**: 외부에서 직접 생성하지 못하도록 제한합니다.
- **`companion object`에서 `of` 메서드로 생성**: 생성 로직을 통제합니다.
- **유효성 검사**: `of` 메서드 내에서 수행합니다.
- **`toString()` 오버라이드**: 값을 문자열로 반환합니다.

#### 19.3.1 예시: 단순 VO (`UserId`)
```kotlin
package com.example.domain.user.vo

data class UserId private constructor(
    val value: Long
) {
    companion object {
        fun of(value: Long): UserId {
            require(value > 0) { "UserId는 0보다 커야 합니다." }
            return UserId(value)
        }
    }

    override fun toString(): String = value.toString()
}
```

#### 19.3.2 예시: 복잡 VO (`Password`)
```kotlin
package com.example.domain.user.vo

import java.security.MessageDigest

data class Password private constructor(
    val encodedValue: String
) {
    companion object {
        private const val SALT = "ddd-user-salt"
        private const val MIN_LENGTH = 8
        private val PASSWORD_REGEX = Regex("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d@$!%*#?&]+$")

        fun of(rawPassword: String): Password {
            require(rawPassword.length >= MIN_LENGTH) { "비밀번호는 최소 ${MIN_LENGTH}글자 이상이어야 합니다." }
            require(rawPassword.matches(PASSWORD_REGEX)) { "비밀번호는 영문자와 숫자를 포함해야 합니다." }
            return Password(encode(rawPassword))
        }

        fun fromEncoded(encodedPassword: String): Password {
            return Password(encodedPassword)
        }

        private fun encode(rawPassword: String): String {
            val saltedPassword = rawPassword + SALT
            val messageDigest = MessageDigest.getInstance("SHA-256")
            val digest = messageDigest.digest(saltedPassword.toByteArray())
            return digest.fold("") { str, byte -> str + "%02x".format(byte) }
        }
    }

    fun matches(rawPassword: String): Boolean = encodedValue == encode(rawPassword)

    override fun toString(): String = encodedValue
}
```

### 19.4 세부 규칙

#### 19.4.1 생성 제어
- 모든 VO는 `companion object`의 `of` 메서드로만 생성됩니다.
- 필요 시 추가 생성 메서드(예: `fromEncoded`)를 `companion object`에 정의합니다.

#### 19.4.2 유효성 검사
- `of` 메서드에서 `require`를 사용해 유효성을 검사하며, 실패 시 도메인 의미를 담은 메시지를 반환합니다.
- 예시:
  ```kotlin
  require(value.isNotBlank()) { "이름은 공백일 수 없습니다." }
  ```

#### 19.4.3 네이밍 규칙
- **클래스명**: VO가 표현하는 값의 의미를 명확히 (예: `Email`, `UserId`).
- **프로퍼티명**: 기본적으로 `value` 사용, 특수한 경우 의미 있는 이름 (예: `encodedValue`).
- **생성 메서드**: 기본은 `of`, 특수 생성은 의미 반영 (예: `fromEncoded`).

#### 19.4.4 추가 메서드
- VO에 도메인 로직이 필요할 경우 (예: `matches`), 의미 있는 메서드만 추가합니다.
- 복잡한 로직 (예: 암호화)은 `companion object`의 `private` 메서드로 분리합니다.

#### 19.4.5 상수 및 정규식
- 상수와 정규식은 `companion object`에 `private`으로 정의하며, 대문자 스네이크 케이스 사용 (예: `MIN_LENGTH`, `PASSWORD_REGEX`).

### 19.5 적용 예시
#### 19.5.1 `Email`
```kotlin
package com.example.domain.user.vo

data class Email private constructor(
    val value: String
) {
    companion object {
        private val EMAIL_REGEX = Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z0-9.-]+$")

        fun of(value: String): Email {
            require(value.matches(EMAIL_REGEX)) { "유효한 이메일 형식이 아닙니다." }
            return Email(value)
        }
    }

    override fun toString(): String = value
}
```

#### 19.5.2 `Name`
```kotlin
package com.example.domain.user.vo

data class Name private constructor(
    val value: String
) {
    companion object {
        fun of(value: String): Name {
            require(value.isNotBlank()) { "이름은 공백일 수 없습니다." }
            require(value.length in 2..50) { "이름은 2~50자 사이여야 합니다." }
            return Name(value)
        }
    }

    override fun toString(): String = value
}
```

### 19.6 주의사항
- **의존성 배제**: VO는 순수 Kotlin으로 작성되며, JPA나 Spring 어노테이션을 포함시키지 않습니다(5.3.4).
- **성능**: 복잡한 유효성 검사(예: 정규식)가 빈번히 호출될 경우, 캐싱이나 최적화를 고려합니다.
- **테스트**: 모든 VO는 Kotest로 유닛 테스트를 작성하며, 생성 성공/실패와 추가 메서드 동작을 검증합니다(18.3.1).

### 19.7 장점
- **일관성**: 모든 VO가 동일한 구조로 작성되어 코드 이해와 유지보수가 용이합니다.
- **유연성**: 단순 VO와 복잡 VO 모두 동일 패턴으로 커버 가능합니다.
- **안정성**: 생성 시 유효성 검사가 강제되어 런타임 오류가 줄어듭니다.

---

## 20. Kafka 및 Avro 사용 규칙

### 20.1 목적
Kafka를 활용한 이벤트 기반 아키텍처에서 Avro를 데이터 직렬화 포맷으로 사용하며, 스키마 레지스트리를 통해 스키마를 중앙 집중식으로 관리합니다. 이를 통해 대규모 조직에서의 이벤트 처리(Saga, Request & Response), 외부 도메인 이벤트 발행, 스키마 버전 관리, 공통 데이터 구조의 재사용성을 보장합니다.

---

### 20.2 기본 규칙

#### 20.2.1 기술 스택
- **메시징 시스템**: Apache Kafka
- **직렬화 포맷**: Avro
- **스키마 관리**: Confluent Schema Registry
- **Kafka 클라이언트**: Spring Kafka (`spring-kafka`)

#### 20.2.2 아키텍처 원칙
- **내부 이벤트**: Kafka를 사용하지 않으며, 애플리케이션 내부에서는 메모리 내 이벤트 버스(예: Spring `ApplicationEvent`)를 활용합니다.
- **외부 이벤트**: Kafka를 통해 발행하며, 외부 도메인 이벤트와 내부 이벤트를 명확히 구분합니다.
- **Saga**: 분산 트랜잭션 처리를 위해 Saga 패턴을 적용하며, 이벤트는 상태 변경 명령과 보상 트랜잭션으로 구성됩니다.
- **Request & Response**: 동기 요청-응답 패턴은 Kafka Streams 또는 별도 HTTP API로 처리하며, 비동기 이벤트는 Kafka 토픽으로 발행합니다。

---

### 20.3 토픽 네이밍 컨벤션
대규모 회사 환경을 가정하여 토픽 이름은 계층적이고 명확한 구조를 따릅니다.

#### 20.3.1 규칙
- **형식**: `{environment}.{domain}.{event-type}.{entity}.{version}`
  - `environment`: 운영 환경 (예: `prod`, `staging`, `dev`)
  - `domain`: 도메인 이름 (예: `user`, `order`, `payment`)
  - `event-type`: 이벤트 유형 (예: `domain-event`, `saga`, `request`, `response`)
  - `entity`: 엔티티 이름 (예: `user`, `order`, `transaction`)
  - `version`: 스키마 버전 (예: `v1`, `v2`)
- **외부용 구분**: 외부 도메인 이벤트는 `domain-event` 유형으로 한정하며, 내부용은 Kafka 토픽을 생성하지 않습니다.
- **예시**:
  - `prod.user.domain-event.user.v1`: 사용자 도메인의 외부 이벤트 (버전 1)
  - `prod.order.saga.order.v2`: 주문 도메인의 Saga 이벤트 (버전 2)
  - `staging.payment.request.transaction.v1`: 결제 도메인의 요청 토픽 (버전 1)
  - `staging.payment.response.transaction.v1`: 결제 도메인의 응답 토픽 (버전 1)

#### 20.3.2 주의사항
- 토픽 이름은 소문자와 하이픈(`-`)만 사용하며, 최대 249자로 제한합니다.
- 버전은 스키마 레지스트리의 `schemaVersion`과 일치해야 합니다.

---

### 20.4 Avro 스키마 관리

#### 20.4.1 저장 경로
- **위치**: 각 도메인 모듈의 `infrastructure` 레이어 내 `avro` 디렉터리에 저장합니다.
- **구체적 경로**:
  ```
  domains/
  ├── user/
  │   ├── infrastructure/
  │   │   ├── src/main/resources/avro/
  │   │   │   ├── user-domain-event-v1.avsc
  │   │   │   └── user-saga-v1.avsc
  ├── order/
  │   ├── infrastructure/
  │   │   ├── src/main/resources/avro/
  │   │   │   ├── order-domain-event-v1.avsc
  │   │   │   └── order-saga-v2.avsc
  ```
- **파일명 형식**: `{entity}-{event-type}-{version}.avsc`

#### 20.4.2 관리 방식
- **스키마 정의**: `.avsc` 파일로 작성하며, Confluent Schema Registry에 등록합니다.
- **버전 관리**: 스키마 변경 시 새로운 `.avsc` 파일을 생성하고, 기존 스키마와의 호환성(Backward, Forward, Full)을 보장합니다.
- **빌드 프로세스**: Gradle 플러그인(`com.github.davidmc24.gradle.plugin.avro`)을 사용해 `.avsc` 파일로부터 Kotlin 클래스를 자동 생성합니다.
  - **Gradle 설정**:
    ```groovy
    plugins {
        id "com.github.davidmc24.gradle.plugin.avro" version "1.9.1"
    }
    dependencies {
        implementation "org.apache.avro:avro:1.11.3"
        implementation "io.confluent:kafka-avro-serializer:7.5.0"
    }
    avro {
        createSetters = false // 불변 객체 생성
        fieldVisibility = "PRIVATE"
    }
    ```
- **생성된 클래스 위치**: `infrastructure/src/main/kotlin/com/example/infrastructure/{domain}/avro/`

#### 20.4.3 예시: `UserDomainEvent` 스키마
```json
{
  "namespace": "com.example.infrastructure.user.avro",
  "type": "record",
  "name": "UserDomainEvent",
  "fields": [
    {"name": "envelope", "type": "com.example.common.avro.Envelope"},
    {"name": "payload", "type": {
      "type": "record",
      "name": "UserPayload",
      "fields": [
        {"name": "userId", "type": "long"},
        {"name": "name", "type": "string"},
        {"name": "email", "type": "string"},
        {"name": "eventType", "type": "string"}
      ]
    }}
  ]
}
```

---

### 20.5 Envelope 구조
모든 Kafka 메시지는 `Envelope`를 포함하며, 스키마 버전을 필수 필드로 정의합니다. 타임스탬프는 나노초 단위를 사용합니다.

#### 20.5.1 정의
- **위치**: 공통 모듈(`common`)의 `avro` 디렉터리에 저장.
  ```
  domains/
  ├── common/
  │   ├── src/main/resources/avro/
  │   │   └── envelope.avsc
  ```
- **스키마**:
```json
{
  "namespace": "com.example.common.avro",
  "type": "record",
  "name": "Envelope",
  "fields": [
    {"name": "schemaVersion", "type": "string"},
    {"name": "eventId", "type": "string"},
    {"name": "timestamp", "type": "long", "doc": "Event timestamp in nanoseconds"},
    {"name": "source", "type": "string"}
  ]
}
```

#### 20.5.2 규칙
- **`schemaVersion`**: 토픽 이름의 `version`과 일치 (예: `v1`, `v2`).
- **`eventId`**: UUID로 고유 식별자 생성.
- **`timestamp`**: 이벤트 발생 시각을 나노초 단위로 기록 (Unix epoch nanoseconds, `System.nanoTime()` 사용).
- **`source`**: 이벤트 발행 도메인 (예: `user`, `order`).

#### 20.5.3 사용 예시
```kotlin
val envelope = Envelope(
    schemaVersion = "v1",
    eventId = UUID.randomUUID().toString(),
    timestamp = System.nanoTime(), // 나노초 단위 타임스탬프
    source = "user"
)
val event = UserDomainEvent(envelope, UserPayload(1L, "John Doe", "john@example.com", "CREATED"))
```

---

### 20.6 공통 파트 관리

#### 20.6.1 위치
- **공통 모듈**: `domains/common/`에 위치.
- **구체적 경로**:
  ```
  domains/
  ├── common/
  │   ├── src/main/resources/avro/
  │   │   └── envelope.avsc
  │   ├── src/main/kotlin/com/example/common/avro/
  │   │   └── Envelope.kt (자동 생성)
  │   ├── build.gradle.kts
  ```

#### 20.6.2 관리 방식
- **재사용**: `Envelope`는 모든 도메인 이벤트에서 공통으로 포함되며, 각 도메인의 `.avsc` 파일에서 참조합니다.
- **업데이트**: 공통 스키마 변경 시, 모든 도메인에서 호환성 테스트를 수행한 후 배포합니다.
- **의존성 설정**:
  ```groovy
  dependencies {
      implementation project(":domains:common")
  }
  ```

---

### 20.7 Kafka 사용 패턴

#### 20.7.1 Saga
- **토픽**: `{environment}.{domain}.saga.{entity}.{version}`
- **메시지**: 상태 변경 명령과 보상 트랜잭션 이벤트를 발행.
- **예시**:
  ```kotlin
  @KafkaListener(topics = ["prod.order.saga.order.v1"])
  fun handleSaga(event: OrderSagaEvent) {
      when (event.payload.eventType) {
          "CREATE" -> processOrderCreation(event)
          "COMPENSATE" -> compensateOrderCreation(event)
      }
  }
  ```

#### 20.7.2 Request & Response
- **토픽**: 
  - 요청: `{environment}.{domain}.request.{entity}.{version}`
  - 응답: `{environment}.{domain}.response.{entity}.{version}`
- **구현**: `correlationId`를 `Envelope.eventId`로 사용해 요청-응답 매핑.
- **예시**:
  ```kotlin
  @KafkaListener(topics = ["prod.payment.request.transaction.v1"])
  fun handleRequest(event: PaymentRequestEvent): PaymentResponseEvent {
      val response = processPayment(event.payload)
      return PaymentResponseEvent(envelope.copy(eventId = event.envelope.eventId), response)
  }
  ```

#### 20.7.3 외부 도메인 이벤트
- **토픽**: `{environment}.{domain}.domain-event.{entity}.{version}`
- **규칙**: 내부 이벤트는 Kafka로 발행하지 않으며, 외부 시스템과의 통신에만 사용.
- **예시**:
  ```kotlin
  kafkaTemplate.send("prod.user.domain-event.user.v1", UserDomainEvent(envelope, payload))
  ```

---

### 20.8 설정 예시

#### 20.8.1 Spring Kafka 설정
```kotlin
@Configuration
class KafkaConfig {
    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, Any> {
        return KafkaTemplate(producerConfig())
    }

    private fun producerConfig(): ProducerFactory<String, Any> {
        val config = mapOf(
            ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to "localhost:9092",
            ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to StringSerializer::class.java,
            ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to KafkaAvroSerializer::class.java,
            "schema.registry.url" to "http://localhost:8081"
        )
        return DefaultKafkaProducerFactory(config)
    }
}
```

#### 20.8.2 스키마 레지스트리 설정
- **URL**: `application.yml`에 정의.
```yaml
spring:
  kafka:
    properties:
      schema.registry.url: http://localhost:8081
```

---

### 20.9 주의사항
- **스키마 호환성**: 스키마 변경 시 Confluent Schema Registry의 호환성 규칙(기본: Backward)을 준수합니다.
- **토픽 분리**: 대규모 트래픽을 고려해 도메인별, 이벤트 유형별로 토픽을 세분화합니다.
- **테스트**: Testcontainers를 사용해 Kafka와 Schema Registry를 포함한 통합 테스트를 작성합니다(섹션 18.3.3 참조).
- **타임스탬프 정밀도**: `timestamp`는 나노초 단위로 기록되며, 시스템 간 시간 동기화(NTP 등)를 통해 정확성을 보장해야 합니다.
- **버전 관리**: `schemaVersion`과 토픽 버전이 일치하지 않을 경우 즉시 감지할 수 있도록 모니터링 설정을 추가합니다.

---


---

최신버전 목록
- `com.h2database:h2` 2.3.232** (2024년 8월 11일 릴리스)
- `id("io.spring.dependency-management")` 1.1.7** (2024년 12월 17일 릴리스)
- `id("org.springframework.boot")` 3.4.4** (2025년 3월 21일 릴리스)
- `io.mockk:mockk` 1.13.17** (2024년 12월 20일 릴리스)
- `java` - 최신 릴리스 버전은 **JDK 24**, 최신 LTS 버전은 **JDK 21**
- `kotlin("jvm")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("kapt")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.allopen")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.jpa")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.noarg")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.spring")` 2.1.20** (2025년 3월 20일 릴리스)
- `org.assertj:assertj-core` - 안정 버전은 **3.27.3** (2025년 1월 18일 릴리스), 마일스톤 버전은 **4.0.0-M1** (2025년 3월 10일 릴리스)
- `org.jetbrains.kotlin:kotlin-reflect` 2.1.20** (2025년 3월 20일 릴리스)
- `org.jetbrains.kotlin:kotlin-stdlib-jdk8` 2.1.20** (2025년 3월 20일 릴리스)
- `org.junit.jupiter:junit-jupiter-api` 5.11.4** (2025년 1월 출시)
- `org.junit.jupiter:junit-jupiter-engine` 5.11.4** (2025년 1월 출시)
- `org.mapstruct:mapstruct-processor` 1.6.3** (2024년 11월 9일 릴리스)
- `org.mapstruct:mapstruct` 1.6.3** (2024년 11월 9일 릴리스)
- `org.springdoc:springdoc-openapi-starter-webmvc-ui` 2.8.4**
- `org.springframework:spring-context` 7.0.0-M3** (2025년 3월 13일 릴리스)
- `org.springframework:spring-tx` 7.0.0-M3**
- `org.springframework:spring-web` 7.0.0-M3** (2025년 3월 13일 릴리스)
- `org.springframework.boot:spring-boot-starter-data-jpa` 3.4.4**
- `org.springframework.boot:spring-boot-starter-hateoas` 3.4.4**
- `org.springframework.boot:spring-boot-starter-test` 3.4.4**
- `org.springframework.boot:spring-boot-starter-validation` 3.4.4**
- `org.springframework.boot:spring-boot-starter-web` 3.4.4**
- `org.webjars:webjars-locator-core` 0.59**
