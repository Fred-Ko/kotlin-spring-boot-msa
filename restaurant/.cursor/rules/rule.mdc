---
description: 
globs: 
alwaysApply: true
---
# 프로젝트 기술 문서

## 1. 프로젝트 개요

### 1.1 기술 스택

- **프레임워크**: Spring Boot
- **빌드 도구**: Gradle
- **프로그래밍 언어**: Kotlin
- **매핑 방식**: 확장 함수 기반 수동 매핑

### 1.2 아키텍처 원칙

- **도메인 주도 설계(DDD)**: 핵심 도메인 로직에 집중합니다.
- **클린 아키텍처**: 시스템을 Presentation, Application, Domain, Infrastructure의 4개 레이어로 명확히 구분합니다. 이외에 특별한 상위 레이어로 Messaging 레이어를 도입하며 `@KafkaListener`나 이와 비슷한 책임을 가지는 코드만 존재합니다.
- **이벤트 소싱**: 사용하지 않습니다. 비동기 상태 추적은 별도의 상태 저장소를 통해 구현됩니다。

---

## 2. 모듈화 전략

### 2.1 멀티모듈 프로젝트

- **레이어별 모듈 분리**: Presentation, Application, Domain, Infrastructure 레이어별로 모듈을 분리하여 관리합니다.
- **목적**: 한 영역의 변경이 다른 영역에 미치는 영향을 최소화합니다.

### 2.2 도메인별 모듈화

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.

### 2.3 공통 모듈 (`common`)

- **내용**: 전역에서 사용하는 순수 유틸리티, 공유 추상 클래스, 인터페이스 등이 포함됩니다.
- **주의**: 과도한 의존을 피하여 “공통 모듈 지옥”을 방지합니다.

---

## 3. CQRS 패턴

### 3.1 Command

- **역할**: 상태 변경이나 특정 기능 실행을 위한 데이터 전송을 담당합니다.
- **특징**: 애플리케이션 레이어에서 Command는 데이터(상태 변경 결과)를 반환하지 않습니다.

### 3.2 Query

- **역할**: 데이터 조회 또는 검색을 위한 요청을 처리합니다.

---

## 4. DTO 네이밍 규칙 및 변환 규칙

### 4.1 Presentation 레이어

- **Request DTO**: 사용자로부터 입력받은 데이터를 담으며, 이름 뒤에 “Request”를 붙입니다.
  - 예: `UserCreateRequest`, `ProductUpdateRequest`, `LoginRequest`
- **Response DTO**: API가 응답으로 반환하는 데이터를 담으며, 이름 뒤에 “Response”를 붙입니다.
  - 예: `UserInfoResponse`, `ProductDetailResponse`, `AuthTokenResponse`

### 4.2 Application 레이어

- **Command DTO**: 특정 기능 실행(명령)에 필요한 데이터를 캡슐화하며, 이름 뒤에 “Command”를 붙입니다.
  - 예: `CreateUserCommand`, `UpdateProductCommand`
- **Query DTO**: 데이터 조회 및 검색 요청에 필요한 정보를 전달하며, 이름 뒤에 “Query”를 붙입니다.
  - 예: `GetUserQuery`, `FindProductsQuery`

### 4.3 DTO 변환 규칙

- **원칙**: Presentation 레이어의 `Request DTO`는 애플리케이션 레이어의 `Command DTO` 또는 `Query DTO`로 변환되며, 모든 변환은 확장 함수를 통해 수동으로 구현됩니다.
- **구현**: 별도의 매핑 라이브러리(MapStruct 등)를 사용하지 않고, Kotlin의 확장 함수를 활용하여 변환 로직을 객체에 직접 정의합니다.
  - **설명**: 변환 로직은 소스 객체의 확장 함수로 작성되며, 필요 시 유효성 검사를 포함합니다.
  - **장점**:
    - **간결성**: Kotlin의 idiomatic한 스타일로 코드가 자연스럽고 직관적입니다.
    - **유연성**: 복잡한 변환 로직이나 조건문을 쉽게 추가할 수 있습니다.
    - **의존성 감소**: 외부 라이브러리 없이 순수 Kotlin으로 구현됩니다.
  - **단점**:
    - **보일러플레이트 코드**: 반복적인 변환 코드가 늘어날 수 있습니다.
    - **컴파일 타임 검증 부재**: 자동화 도구의 검증이 없으므로 테스트로 보완해야 합니다.
    - **일관성 관리**: 팀원 간 동일한 패턴 준수를 위한 가이드 필요.
- **위치**: 변환 함수는 소스 객체가 속한 레이어에 정의됩니다.
  - 예: `UserCreateRequestV1.toCommand()`는 Presentation 레이어에 위치.
- **예시**:
  ```kotlin
  package com.example.presentation.user.v1.dto.request

  import com.example.application.user.command.CreateUserCommand

  fun UserCreateRequestV1.toCommand(): CreateUserCommand = CreateUserCommand(
      name = name.trim(),
      email = email.lowercase()
  )
  ```

  - **사용 예시**:
    ```kotlin
    val command = request.toCommand()
    ```

---

## 5. 레이어 간 의존성 및 도메인 규칙

### 5.1 도메인 레이어의 독립성

- **규칙**: Domain 레이어는 Presentation, Application, Infrastructure 레이어를 절대 참조하지 않습니다.
- **목적**: 도메인의 순수성을 유지합니다.

### 5.2 Aggregate의 VO 사용 범위

- **규칙**: 도메인 내 Aggregate(집합체)의 Value Object(VO)는 Domain 레이어 외부에서 사용하지 않습니다.
- **목적**: 도메인 경계 내에서만 활용합니다.

### 5.3 엔티티 정의 규칙

#### 5.3.1 JPA 엔티티의 위치

- **규칙**: JPA 엔티티는 `Infrastructure` 레이어에 정의합니다.
- **목적**: 데이터베이스와의 매핑을 담당하는 JPA 엔티티를 인프라스트럭처 레이어로 분리하여, 도메인 레이어의 순수성을 유지하고 기술적 의존성을 격리합니다.
- **구현**:
  - JPA 엔티티는 `@Entity` 어노테이션을 사용하며, 데이터베이스 테이블과 매핑됩니다.
  - 도메인 로직은 JPA 엔티티에 포함시키지 않고, 필요 시 도메인 레이어의 Aggregate나 VO로 변환하여 사용합니다.
- **예시**:
  ```kotlin
  @Entity
  @Table(name = "users")
  data class UserEntity(
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      val id: Long? = null,
      val name: String,
      val email: String
  )
  ```

### 5.3.2 Aggregate와 VO의 위치

- **규칙**: Aggregate, Value Object(VO), 그리고 기타 DDD 엔티티는 `Domain` 레이어에 정의하며, 외부 기술 프레임워크(JPA, Spring 등)에 의존하지 않도록 최대한 순수하게 유지합니다. 또한, 도메인 내 하위 엔티티는 `entity` 폴더에 별도로 정의되며, 이는 `Infrastructure` 레이어의 JPA 엔티티와 구분됩니다.
- **목적**: 도메인 로직의 독립성과 재사용성을 보장하며, 비즈니스 규칙을 기술적 세부사항과 분리합니다. 하위 엔티티를 `entity` 폴더에 분리함으로써 도메인 내 엔티티의 계층 구조를 명확히 하고, JPA 엔티티와의 혼동을 방지합니다.
- **구현**:
  - Aggregate는 도메인 내의 루트 엔티티로, 비즈니스 규칙과 불변성을 관리합니다.
  - VO는 불변 객체로, 도메인 내에서 값의 의미를 캡슐화합니다.
  - 하위 엔티티는 `entity` 폴더 내에 정의되며, 도메인 로직을 포함할 수 있는 객체로 Aggregate와의 관계를 나타냅니다. 이들은 JPA 엔티티가 아니며, 데이터베이스 매핑과는 무관합니다.
  - JPA 엔티티와의 매핑은 `Infrastructure` 레이어에서 별도로 처리하며, 확장 함수를 활용해 변환합니다.
- **예시**:
  ```kotlin
  // 도메인 레이어 내 Aggregate
  data class Order(
      val id: OrderId,
      val items: List<OrderItem>
  )

  // 도메인 레이어 내 하위 엔티티 (entity 폴더에 위치)
  package com.example.domain.order.entity

  data class OrderItem(
      val productId: ProductId,
      val quantity: Int
  )

  @JvmInline
  value class OrderId(val value: Long)

  @JvmInline
  value class ProductId(val value: Long)
  ```

#### 5.3.3 JPA 엔티티와 DDD 엔티티 간 매핑

- **규칙**: JPA 엔티티와 도메인 레이어의 Aggregate/VO 간 변환은 `Infrastructure` 또는 `Application` 레이어에서 수행하며, 확장 함수를 사용하여 수동으로 매핑 로직을 정의합니다.
- **목적**: 도메인 레이어의 순수성을 유지하면서, 데이터 영속성과 도메인 로직을 분리합니다.
- **구현**:
  - `Infrastructure` 레이어에서 Repository가 JPA 엔티티를 조회/저장하고, 이를 도메인 객체로 변환합니다.
  - 변환 로직은 JPA 엔티티와 도메인 객체에 정의된 확장 함수로 처리됩니다.
- **예시**:
  ```kotlin
  package com.example.infrastructure.user.entity

  import com.example.domain.user.User
  import com.example.domain.user.vo.UserId
  import com.example.domain.user.vo.Email

  fun UserEntity.toDomain(): User = User(
      id = id?.let { UserId(it) },
      name = name,
      email = Email(value = email)
  )

  fun User.toEntity(): UserEntity = UserEntity(
      id = id?.value,
      name = name,
      email = email.value
  )

  @Repository
  class UserRepository(
      private val jpaRepository: SpringDataJpaUserRepository
  ) {
      fun findById(id: UserId): User? {
          return jpaRepository.findById(id.value)?.toDomain()
      }

      fun save(user: User): User {
          val entity = user.toEntity()
          return jpaRepository.save(entity).toDomain()
      }
  }
  ```

#### 5.3.4 주의사항

- **도메인 레이어의 순수성**: 도메인 객체는 JPA 어노테이션(`@Entity`, `@Id` 등)이나 Spring 관련 의존성을 포함시키지 않습니다.
- **성능 고려**: 빈번한 객체 변환으로 인한 오버헤드를 줄이기 위해, 필요한 경우 매핑 로직을 최적화하거나 캐싱을 고려합니다.
- **테스트 용이성**: 도메인 레이어는 가능하다면 순수 Kotlin으로 작성되므로, 단위 테스트 시 mocking 없이 독립적으로 테스트 가능합니다。

---

## 6. 애플리케이션 레이어 구조

### 6.1 예시 디렉터리 구조

```plaintext
domains:
 user:
   src:
     main:
       kotlin:
         com:
           example:
             application:
               command:
                 - CreateUserCommand.kt
                 - UpdateUserCommand.kt
                 - extensions.kt  # Command → Domain 변환 확장 함수
                 - handler
                   - CreateUserCommandHandler.kt
                   - UpdateUserCommandHandler.kt
               query:
                 - GetUserQuery.kt
                 - FindUsersQuery.kt
                 - handler
                   - GetUserQueryHandler.kt
                   - FindUsersQueryHandler.kt
               common:
                 - UserApplicationException.kt
 order:
   src:
     main:
       kotlin:
         com:
           example:
             application:
               command:
                 - CreateOrderCommand.kt
                 - UpdateOrderCommand.kt
                 - CancelOrderCommand.kt
                 - extensions.kt  # Command → Domain 변환 확장 함수
                 - handler
                   - CreateOrderCommandHandler.kt
                   - UpdateOrderCommandHandler.kt
                   - CancelOrderCommandHandler.kt
               query:
                 - GetOrderQuery.kt
                 - FindOrdersQuery.kt
                 - FindOrdersByCustomerQuery.kt
                 - handler
                   - GetOrderQueryHandler.kt
                   - FindOrdersQueryHandler.kt
                   - FindOrdersByCustomerQueryHandler.kt
               common:
                 - OrderApplicationException.kt
```

---

## 7. 프레젠테이션 레이어 구조

### 7.1 예시 디렉터리 구조

```plaintext
domains:
 user:
   src:
     main:
       kotlin:
         com:
           example:
             presentation:
               v1:
                 command:
                   - UserCommandController.kt
                   dto:
                     request:
                       - UserCreateRequestV1.kt
                       - UserUpdateRequestV1.kt
                       - extensions.kt  # Request → Command 변환 확장 함수
                     response:
                       - UserResponseV1.kt
                       - UserSearchResponseV1.kt
                 query:
                   - UserQueryController.kt
 order:
   src:
     main:
       kotlin:
         com:
           example:
             presentation:
               v1:
                 command:
                   - OrderCommandController.kt
                   dto:
                     request:
                       - OrderCreateRequestV1.kt
                       - OrderCancelRequestV1.kt
                       - extensions.kt  # Request → Command 변환 확장 함수
                     response:
                       - OrderResponseV1.kt
                       - OrderHistoryResponseV1.kt
                 query:
                   - OrderQueryController.kt
```

---

## 8. Query 전략

### 8.1 페이지네이션

- **규칙**: 다건 조회는 페이지네이션을 적용.
- **방식**: 결정 시 커서 페이지네이션을 기본으로 사용하며, Spring Data의 `Pageable`을 활용.

---

## 9. Command 요청에 대한 REST 응답 규칙

### 9.1 동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, 애플리케이션 레이어의 Command 실행 결과를 기반으로 최소한의 메타데이터를 반환합니다.
- **필수 필드**: `status`, `message`, `correlationId` (결과 확인용 식별자)
- **예시**:
  ```json
  {
    "status": "success",
    "message": "요청이 처리되었습니다.",
    "correlationId": "correlation123"
  }
  ```

### 9.2 비동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, URL 처리는 프레젠테이션 레이어에서만 수행됩니다. 애플리케이션 레이어는 `jobId`만 제공합니다.
- **필수 필드**: `status`, `message`, `jobId`, 상태 조회 및 관리용 링크
- **예시**:
  ```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job12345",
    "links": [
      {
        "rel": "job-status-ws",
        "href": "wss://example.com/ws/job-status/job12345",
        "type": "ws",
        "action": "subscribe"
      },
      {
        "rel": "job-none-ws",
        "href": "/api/v1/jobs/status/job12345",
        "type": "http",
        "method": "GET",
        "action": "get-status"
      }
    ]
  }
  ```

---

## 10. Command 요청에 대한 REST 실패 응답 규칙

### 10.1 실패 응답 구조

- **규칙**: 실패 응답은 RFC 7807(`Problem Details for HTTP APIs`)에 준수하며, Spring Boot 3.0 이상에서 제공하는 `ProblemDetail` 클래스를 사용합니다.
- **필수 필드**:
  - `type`: 문제 유형을 식별하는 URI (기본값: "about:blank")
  - `title`: 문제 유형에 대한 간단한 설명
  - `status`: HTTP 상태 코드
  - `detail`: 문제에 대한 인스턴스별 설명
- **선택 필드**:
  - `instance`: 문제를 발생시킨 요청 URI
  - 확장 필드: `errorCode`, `timestamp` 등
- **예시**:
  ```json
  {
    "type": "https://example.com/probs/validation-error",
    "title": "Validation Error",
    "status": 400,
    "detail": "입력 데이터가 유효하지 않습니다.",
    "instance": "/api/v1/users",
    "errorCode": "VALIDATION_ERROR",
    "timestamp": "2025-03-24T12:00:00Z"
  }
  ```

---

## 11. 애플리케이션 레이어에서 Command 리턴 규칙

### 11.1 기본 원칙

- **규칙**: Command 핸들러는 상태 변경만 수행하며, 비즈니스 데이터(예: 생성된 엔티티의 상세 정보)를 반환하지 않습니다.
- **참고**: 결과 확인용 `correlationId` 또는 `jobId`는 반환 가능하며, 이는 프레젠테이션 레이어에서 처리됩니다.

### 11.2 동기 Command 처리

- **리턴 값**: `CommandResult` 객체
- **필수 필드**:
  - `success`: boolean
  - `correlationId`: string
- **예시**:
  ```kotlin
  data class CommandResult(
      val success: Boolean,
      val correlationId: String,
      val errorCode: String? = null
  )
  ```

### 11.3 비동기 Command 처리

- **리턴 값**: `AsyncCommandResult` 객체
- **필수 필드**:
  - `success`: boolean
  - `jobId`: string
- **예시**:
  ```kotlin
  data class AsyncCommandResult(
      val success: Boolean,
      val jobId: String,
      val errorCode: String? = null
  )
  ```

### 11.4 실패 처리

- **리턴 값**: `CommandResult` 또는 `AsyncCommandResult` 객체에 오류 정보 포함
- **예시**:
  ```kotlin
  CommandResult(success = false, correlationId = "corr-456", errorCode = "VALIDATION_ERROR")
  ```

### 11.5 구현 참고

- **동기 Command 핸들러 예시**:
  ```kotlin
  class CreateUserCommandHandler(
      private val userRepository: UserRepository
  ) {
      fun handle(command: CreateUserCommand): CommandResult {
          val user = command.toUser()
          userRepository.save(user)
          return CommandResult(true, UUID.randomUUID().toString())
      }
  }
  ```

---

## 12. 에러 처리

### 12.1 목적

- 시스템의 안정성을 유지하고, 클라이언트에게 명확한 에러 메시지를 제공합니다.

### 12.2 레이어별 에러 처리

#### 12.2.1 Presentation 레이어

- **역할**: 클라이언트 요청 검증 및 에러 응답 생성.
- **에러 유형**: 유효성 검사 실패, 인증/인가 실패.
- **처리 방식**: `@Valid`로 유효성 검사, Spring Security로 인증/인가 처리.

#### 12.2.2 Application 레이어

- **역할**: 비즈니스 로직 실행 및 도메인 예외 처리.
- **에러 유형**: 비즈니스 규칙 위반.
- **처리 방식**: 도메인 예외를 `CommandResult`로 변환.

#### 12.2.3 Domain 레이어

- **역할**: 비즈니스 규칙 준수.
- **에러 유형**: 도메인 규칙 위반.
- **처리 방식**: 커스텀 예외(`DomainException`) 발생.

#### 12.2.4 Infrastructure 레이어

- **역할**: 외부 시스템 통신.
- **에러 유형**: DB 연결 실패, API 호출 오류.
- **처리 방식**: 커스텀 예외(`InfrastructureException`)로 변환.

### 12.3 에러 응답 형식

- **형식**: RFC 7807 준수, `ProblemDetail` 사용.
- **예시**:
  ```json
  {
    "type": "https://example.com/probs/user-not-found",
    "title": "User Not Found",
    "status": 404,
    "detail": "사용자를 찾을 수 없습니다.",
    "instance": "/api/v1/users/123",
    "errorCode": "USER_NOT_FOUND",
    "timestamp": "2025-03-24T12:00:00Z"
  }
  ```

---

## 13. HATEOAS 및 URI 템플릿 사용 규칙

### 13.1 목적

- 클라이언트가 동적 링크를 통해 리소스를 탐색하도록 HATEOAS를 적용.

### 13.2 기본 규칙

- **의존성**: Spring HATEOAS 사용.
- **링크 포함**: 성공 응답에 관련 링크 포함.

### 13.3 링크 구조

- **필수 필드**: `rel`, `href`, `method`.
- **예시**:
  ```kotlin
  mapOf("rel" to "self", "href" to "/api/v1/users/123", "method" to "GET")
  ```

---

## 14 프로젝트 구조 참고용

```
domains/
├── common/
│   ├── src/main/kotlin/com/example/common/
│   ├── dto/
│   │   ├── CommandResult.kt
│   │   └── AsyncCommandResult.kt
│   ├── exception/
│   │   ├── DomainException.kt
│   │   ├── ApplicationException.kt
│   │   ├── InfrastructureException.kt
│   │   └── PresentationException.kt
│   └── build.gradle.kts
│
├── user/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/user/
│   │   │   └── UserApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/user/
│   │   │   ├── aggregate/User.kt
│   │   │   ├── vo/UserId.kt
│   │   │   ├── vo/Email.kt
│   │   │   ├── repository/UserRepository.kt
│   │   │   └── exception/UserDomainException.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/user/
│   │   │   ├── command/
│   │   │   │   ├── CreateUserCommand.kt
│   │   │   │   ├── UpdateUserCommand.kt
│   │   │   │   ├── extensions.kt  # Command → Domain 변환
│   │   │   │   └── handler/
│   │   │   │       ├── CreateUserCommandHandler.kt
│   │   │   │       └── UpdateUserCommandHandler.kt
│   │   │   ├── query/
│   │   │   │   ├── GetUserQuery.kt
│   │   │   │   ├── FindUsersQuery.kt
│   │   │   │   └── handler/
│   │   │   │       ├── GetUserQueryHandler.kt
│   │   │   │       └── FindUsersQueryHandler.kt
│   │   │   └── exception/UserApplicationException.kt
│   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/user/
│   │   │   ├── entity/
│   │   │   │   ├── UserEntity.kt
│   │   │   │   └── extensions.kt  # Domain ↔ Entity 변환
│   │   │   ├── repository/
│   │   │   │   ├── SpringDataJpaUserRepository.kt
│   │   │   │   └── UserRepositoryImpl.kt
│   │   │   └── exception/UserInfrastructureException.kt
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/user/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── UserCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── UserCreateRequestV1.kt
│   │   │   │   │       ├── UserUpdateRequestV1.kt
│   │   │   │   │       └── extensions.kt  # Request → Command 변환
│   │   │   │   └── query/
│   │   │   │       ├── UserQueryController.kt
│   │   │   └── exception/UserPresentationException.kt
│   │   └── build.gradle.kts
│   └── build.gradle.kts
│
├── order/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/order/
│   │   │   └── OrderApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/order/
│   │   │   ├── aggregate/Order.kt
│   │   │   ├── vo/OrderId.kt
│   │   │   ├── entity/OrderItem.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/order/
│   │   │   ├── command/
│   │   │   │   ├── CreateOrderCommand.kt
│   │   │   │   ├── extensions.kt  # Command → Domain 변환
│   │   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/order/
│   │   │   ├── entity/
│   │   │   │   ├── OrderEntity.kt
│   │   │   │   └── extensions.kt  # Domain ↔ Entity 변환
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/order/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── OrderCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── OrderCreateRequestV1.kt
│   │   │   │   │       └── extensions.kt  # Request → Command 변환
│   │   │   └── build.gradle.kts
│   └── build.gradle.kts
│
└── build.gradle.kts (최상위)
```

---

## 15. Presentation 레이어 validation

- **목적**: 클라이언트로부터 입력받은 데이터의 유효성을 검증하여 잘못된 요청을 조기에 차단.
- **규칙**: `jakarta.validation.constraints` 어노테이션 사용.
- **의존성**:
  ```groovy
  dependencies {
      implementation "org.springframework.boot:spring-boot-starter-validation"
  }
  ```
- **예시**:
  ```kotlin
  data class UserCreateRequestV1(
      @field:NotBlank(message = "이름은 필수입니다.")
      val name: String,
      @field:NotBlank(message = "이메일은 필수입니다.")
      @field:Email(message = "유효한 이메일 형식이어야 합니다.")
      val email: String
  )
  ```

---

## 16. 도메인 익셉션의 전파

### 16.1 CommandResult 기반 처리

- **구현 예시**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler
  ) {
      @PostMapping
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
          val command = request.toCommand()
          val result = createUserCommandHandler.handle(command)

          return if (result.success) {
              ResponseEntity.ok(mapOf(
                  "status" to "success",
                  "message" to "요청이 처리되었습니다.",
                  "correlationId" to result.correlationId
              ))
          } else {
              val problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                  type = URI.create("https://example.com/probs/user-creation-failed")
                  title = "User Creation Failed"
                  detail = "사용자 생성에 실패했습니다."
                  instance = URI.create("/api/v1/users")
                  setProperty("errorCode", result.errorCode ?: "USER_CREATION_FAILED")
                  setProperty("timestamp", Instant.now().toString())
              }
              ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
          }
      }
  }
  ```

---

## 17. Presentation 레이어에서 Swagger 적용

### 17.1 목적

- API 명세 문서화 및 테스트 용이성 제공.

### 17.2 의존성 설정

- **의존성**:
  ```groovy
  dependencies {
      implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2"
  }
  ```

### 17.3 기본 설정

- **구성**:
  ```kotlin
  @Configuration
  class SwaggerConfig {
      @Bean
      fun customOpenAPI(): OpenAPI {
          return OpenAPI()
              .info(Info().title("Project API").version("v1").description("Spring Boot 기반 프로젝트 API 문서"))
      }
  }
  ```

### 17.4 API 문서화

- **예시**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler
  ) {
      @PostMapping
      @Operation(summary = "새로운 사용자 생성", description = "사용자 정보를 입력받아 새로운 사용자를 생성합니다.")
      @ApiResponses(
          ApiResponse(responseCode = "200", description = "사용자 생성 성공",
              content = [Content(schema = Schema(implementation = Map::class))]),
          ApiResponse(responseCode = "400", description = "잘못된 요청 데이터",
              content = [Content(schema = Schema(implementation = ProblemDetail::class))])
      )
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
          val command = request.toCommand()
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

---

## 18. 테스트 작성 가이드

### 18.1 Kotest 개요 및 테스트 원칙

- **표준화**: Kotest 사용.
- **목표**: 가독성, 독립성, 단일 책임, 반복 가능성, 빠른 실행.

### 18.2 기술 스택과 Gradle 설정

```kotlin
dependencies {
    testImplementation("io.kotest:kotest-runner-junit5:5.9.1")
    testImplementation("io.kotest:kotest-assertions-core:5.9.1")
    testImplementation("io.mockk:mockk:1.13.11")
    testImplementation("org.springframework.boot:spring-boot-starter-test:3.2.4")
}
```

### 18.3 테스트 예시

- **DTO 변환 테스트**:
  ```kotlin
  class UserCreateRequestV1Test : StringSpec({
      "UserCreateRequestV1에서 CreateUserCommand로 변환" {
          val request = UserCreateRequestV1(" John ", "JOHN@example.com")
          val command = request.toCommand()
          command.name shouldBe "John"
          command.email shouldBe "john@example.com"
      }
  })
  ```

---

## 19. Value Object 작성 가이드

### 19.1 목적

- 불변 값 캡슐화 및 도메인 규칙 강제.

### 19.2 기본 규칙

- **불변성**: 생성 후 상태 변경 불가.
- **Private Constructor**: 생성자 비공개.
- **Companion Object**: `of` 메서드로 생성.
- **예시**:
  ```kotlin
  data class Email private constructor(
      val value: String
  ) {
      companion object {
          fun of(value: String): Email {
              require(value.contains("@")) { "유효한 이메일 형식이 아닙니다." }
              return Email(value)
          }
      }
  }
  ```

---

## 20. Kafka 및 Avro 사용 규칙

### 20.1 목적

- 이벤트 기반 아키텍처에서 Kafka와 Avro를 사용.

### 20.2 기본 규칙

- **메시징 시스템**: Apache Kafka.
- **직렬화 포맷**: Avro.
- **스키마 관리**: Confluent Schema Registry.
- **예시**:
  ```kotlin
  @KafkaListener(topics = ["user-events"])
  fun handleUserEvent(event: UserEvent) {
      // 이벤트 처리 로직
  }
  ```

---

## 21. JPA 엔티티 작성 규칙

### 21.1 목적

- 데이터베이스와 객체 간 매핑.

### 21.2 기본 규칙

- **위치**: `Infrastructure` 레이어.
- **불변성**: `val` 사용.
- **예시**:
  ```kotlin
  @Entity
  @Table(name = "users")
  class UserEntity(
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      val id: Long? = null,
      val name: String,
      val email: String
  )
  ```

---



---

최신버전 목록
- `com.h2database:h2` 2.3.232** (2024년 8월 11일 릴리스)
- `id("io.spring.dependency-management")` 1.1.7** (2024년 12월 17일 릴리스)
- `id("org.springframework.boot")` 3.4.4** (2025년 3월 21일 릴리스)
- `io.mockk:mockk` 1.13.17** (2024년 12월 20일 릴리스)
- `java` - 최신 릴리스 버전은 **JDK 24**, 최신 LTS 버전은 **JDK 21**
- `kotlin("jvm")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("kapt")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.allopen")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.jpa")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.noarg")` 2.1.20** (2025년 3월 20일 릴리스)
- `kotlin("plugin.spring")` 2.1.20** (2025년 3월 20일 릴리스)
- `org.assertj:assertj-core` - 안정 버전은 **3.27.3** (2025년 1월 18일 릴리스), 마일스톤 버전은 **4.0.0-M1** (2025년 3월 10일 릴리스)
- `org.jetbrains.kotlin:kotlin-reflect` 2.1.20** (2025년 3월 20일 릴리스)
- `org.jetbrains.kotlin:kotlin-stdlib-jdk8` 2.1.20** (2025년 3월 20일 릴리스)
- `org.junit.jupiter:junit-jupiter-api` 5.11.4** (2025년 1월 출시)
- `org.junit.jupiter:junit-jupiter-engine` 5.11.4** (2025년 1월 출시)
- `org.mapstruct:mapstruct-processor` 1.6.3** (2024년 11월 9일 릴리스)
- `org.mapstruct:mapstruct` 1.6.3** (2024년 11월 9일 릴리스)
- `org.springdoc:springdoc-openapi-starter-webmvc-ui` 2.8.4**
- `org.springframework:spring-context` 7.0.0-M3** (2025년 3월 13일 릴리스)
- `org.springframework:spring-tx` 7.0.0-M3**
- `org.springframework:spring-web` 7.0.0-M3** (2025년 3월 13일 릴리스)
- `org.springframework.boot:spring-boot-starter-data-jpa` 3.4.4**
- `org.springframework.boot:spring-boot-starter-hateoas` 3.4.4**
- `org.springframework.boot:spring-boot-starter-test` 3.4.4**
- `org.springframework.boot:spring-boot-starter-validation` 3.4.4**
- `org.springframework.boot:spring-boot-starter-web` 3.4.4**
- `org.webjars:webjars-locator-core` 0.59**
