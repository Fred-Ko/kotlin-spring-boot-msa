---
description: 
globs: 
alwaysApply: true
---
# 프로젝트 기술 문서 

## 1. 프로젝트 개요

### 1.1 기술 스택

- **프레임워크**: Spring Boot  
- **빌드 도구**: Gradle  
- **프로그래밍 언어**: Kotlin  
- **매핑 라이브러리**: MapStruct  

### 1.2 아키텍처 원칙

- **도메인 주도 설계(DDD)**: 핵심 도메인 로직에 집중합니다.  
- **클린 아키텍처**: 시스템을 Presentation, Application, Domain, Infrastructure의 4개 레이어로 명확히 구분합니다. 이외에 특별한 상위 레이어로 Messaging 레이어를 도입하며 @KafkaListener나 이와 비슷한 책임을 가지는 코드만 존재한다.
- **이벤트 소싱**: 사용하지 않습니다. 비동기 상태 추적은 별도의 상태 저장소를 통해 구현됩니다.  

---

## 2. 모듈화 전략

### 2.1 멀티모듈 프로젝트

- **레이어별 모듈 분리**: Presentation, Application, Domain, Infrastructure 레이어별로 모듈을 분리하여 관리합니다.  
- **목적**: 한 영역의 변경이 다른 영역에 미치는 영향을 최소화합니다.  

### 2.2 도메인별 모듈화

- **구성**: 각 도메인은 최상위 폴더로 분리됩니다(예: `domains/user`, `domains/order`).  
- **목적**: MSA(마이크로서비스 아키텍처) 스타일의 독립적인 구성을 유지합니다.  

### 2.3 공통 모듈 (`common`)

- **내용**: 전역에서 사용하는 순수 유틸리티, 공유 추상 클래스, 인터페이스 등이 포함됩니다.  
- **주의**: 과도한 의존을 피하여 “공통 모듈 지옥”을 방지합니다.  

---

## 3. CQRS 패턴

### 3.1 Command

- **역할**: 상태 변경이나 특정 기능 실행을 위한 데이터 전송을 담당합니다.  
- **특징**: 애플리케이션 레이어에서 Command는 데이터(상태 변경 결과)를 반환하지 않습니다.  

### 3.2 Query

- **역할**: 데이터 조회 또는 검색을 위한 요청을 처리합니다.  

---

## 4. DTO 네이밍 규칙

### 4.1 Presentation 레이어

- **Request DTO**: 사용자로부터 입력받은 데이터를 담으며, 이름 뒤에 “Request”를 붙입니다.  
  - 예: `UserCreateRequest`, `ProductUpdateRequest`, `LoginRequest`  
- **Response DTO**: API가 응답으로 반환하는 데이터를 담으며, 이름 뒤에 “Response”를 붙입니다.  
  - 예: `UserInfoResponse`, `ProductDetailResponse`, `AuthTokenResponse`  

### 4.2 Application 레이어

- **Command DTO**: 특정 기능 실행(명령)에 필요한 데이터를 캡슐화하며, 이름 뒤에 “Command”를 붙입니다.  
  - 예: `CreateUserCommand`, `UpdateProductCommand`  
- **Query DTO**: 데이터 조회 및 검색 요청에 필요한 정보를 전달하며, 이름 뒤에 “Query”를 붙입니다.  
  - 예: `GetUserQuery`, `FindProductsQuery`  

### 4.3 DTO 변환 규칙

- **원칙**: Presentation 레이어의 `Request DTO`는 애플리케이션 레이어의 `Command DTO` 또는 `Query DTO`로 변환되어 사용됩니다.  
- **구현**: MapStruct를 사용하여 객체 간 매핑을 자동화합니다.  
  - **설명**: 인터페이스를 통해 매핑 규칙을 정의하며, 컴파일 타임에 매핑 코드를 생성하여 런타임 오버헤드를 줄입니다.  
  - **장점**:  
    - **생산성**: 반복적인 매핑 코드를 줄여 개발 속도가 빨라집니다.  
    - **유지보수**: 명시적인 인터페이스로 일관성을 유지하며, 변경이 용이합니다.  
    - **복잡한 매핑 지원**: 중첩 객체, 컬렉션 매핑 등 복잡한 경우에도 쉽게 처리 가능합니다.  
  - **단점**:  
    - **의존성 추가**: MapStruct와 관련 빌드 설정이 프로젝트에 추가됩니다.  
    - **커스터마이징 한계**: 특정 요구사항에 맞춘 세밀한 조정이 인터페이스 수정으로 제한될 수 있습니다.  
    - **학습 곡선**: 팀원 모두가 MapStruct 인터페이스 작성법을 익혀야 합니다.  
- **설정**:  
  - Gradle에 MapStruct 의존성 추가:  

    ```groovy
    dependencies {
        implementation "org.mapstruct:mapstruct:1.5.5.Final"
        annotationProcessor "org.mapstruct:mapstruct-processor:1.5.5.Final"
    }
    ```

  - Spring Boot와 통합 시 `@Mapper(componentModel = "spring")` 사용.  
- **예시 (MapStruct 사용)**:  

  ```kotlin
  @Mapper(componentModel = "spring")
  interface UserMapper {
      fun toCreateUserCommand(request: UserCreateRequest): CreateUserCommand
  }
  ```

  - 사용 예시:  

    ```kotlin
    @Autowired
    private lateinit var userMapper: UserMapper

    val command = userMapper.toCreateUserCommand(request)
    ```

---

## 5. 레이어 간 의존성 및 도메인 규칙

### 5.1 도메인 레이어의 독립성

- **규칙**: Domain 레이어는 Presentation, Application, Infrastructure 레이어를 절대 참조하지 않습니다.  
- **목적**: 도메인의 순수성을 유지합니다.  

### 5.2 Aggregate의 VO 사용 범위

- **규칙**: 도메인 내 Aggregate(집합체)의 Value Object(VO)는 Domain 레이어 외부에서 사용하지 않습니다.  
- **목적**: 도메인 경계 내에서만 활용합니다.  

### 5.3 엔티티 정의 규칙 

#### 5.3.1 JPA 엔티티의 위치

- **규칙**: JPA 엔티티는 `Infrastructure` 레이어에 정의합니다.  
- **목적**: 데이터베이스와의 매핑을 담당하는 JPA 엔티티를 인프라스트럭처 레이어로 분리하여, 도메인 레이어의 순수성을 유지하고 기술적 의존성을 격리합니다.  
- **구현**:  
  - JPA 엔티티는 `@Entity` 어노테이션을 사용하며, 데이터베이스 테이블과 매핑됩니다.  
  - 도메인 로직은 JPA 엔티티에 포함시키지 않고, 필요 시 도메인 레이어의 Aggregate나 VO로 변환하여 사용합니다.  
- **예시**:  

  ```kotlin
  @Entity
  @Table(name = "users")
  data class UserEntity(
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      val id: Long? = null,
      val name: String,
      val email: String
  )
  ```

#### 5.3.2 Aggregate와 VO의 위치

- **규칙**: Aggregate, Value Object(VO), 그리고 기타 DDD 엔티티는 `Domain` 레이어에 정의하며, 외부 기술 프레임워크(JPA, Spring 등)에 의존하지 않도록 최대한 순수하게 유지합니다.  
- **목적**: 도메인 로직의 독립성과 재사용성을 보장하며, 비즈니스 규칙을 기술적 세부사항과 분리합니다.  
- **구현**:  
  - Aggregate는 도메인 내의 루트 엔티티로, 비즈니스 규칙과 불변성을 관리합니다.  
  - VO는 불변 객체로, 도메인 내에서 값의 의미를 캡슐화합니다.  
  - JPA 엔티티와의 매핑은 `Infrastructure` 레이어에서 별도로 처리하며, MapStruct를 활용해 변환합니다.  
- **예시**:  

  ```kotlin
  data class User(
      val id: UserId,
      val name: String,
      val email: Email
  ) {
      fun updateName(newName: String): User {
          return copy(name = newName)
      }
  }

  @JvmInline
  value class UserId(val value: Long)

  data class Email(val value: String) {
      init {
          require(value.contains("@")) { "유효한 이메일 형식이 아닙니다." }
      }
  }
  ```

#### 5.3.3 JPA 엔티티와 DDD 엔티티 간 매핑

- **규칙**: JPA 엔티티와 도메인 레이어의 Aggregate/VO 간 변환은 `Infrastructure` 또는 `Application` 레이어에서 수행하며, MapStruct를 사용하지 않고 직접 매핑 로직을 정의합니다.  
- **목적**: 도메인 레이어의 순수성을 유지하면서, 데이터 영속성과 도메인 로직을 분리합니다.  
- **구현**:  
  - `Infrastructure` 레이어에서 Repository가 JPA 엔티티를 조회/저장하고, 이를 도메인 객체로 변환합니다.  
  - MapStruct 인터페이스를 통해 명시적이고 컴파일 타임에 검증 가능한 매핑을 제공합니다.  
- **예시**:  

  ```kotlin
  @Component
  class UserEntityMapper {
      fun toEntity(user: User): UserEntity {
          return UserEntity(
              id = user.id.value,
              name = user.name,
              email = user.email.value
          )
      }

      fun toDomain(entity: UserEntity): User {
          return User(
              id = UserId(entity.id!!),
              name = entity.name,
              email = Email(entity.email)
          )
      }
  }

  @Repository
  class UserRepository(
      private val jpaRepository: SpringDataJpaUserRepository,
      private val userEntityMapper: UserEntityMapper
  ) {
      fun findById(id: UserId): User? {
          return jpaRepository.findById(id.value)?.let { userEntityMapper.toDomain(it) }
      }

      fun save(user: User): User {
          val entity = userEntityMapper.toEntity(user)
          return userEntityMapper.toDomain(jpaRepository.save(entity))
      }
  }
  ```

#### 5.3.4 주의사항

- **도메인 레이어의 순수성**: 도메인 객체는 JPA 어노테이션(`@Entity`, `@Id` 등)이나 Spring 관련 의존성을 포함시키지 않습니다.  
- **성능 고려**: 빈번한 객체 변환으로 인한 오버헤드를 줄이기 위해, 필요한 경우 매핑 로직을 최적화하거나 캐싱을 고려합니다.  
- **테스트 용이성**: 도메인 레이어는 가능하다면 순수 Kotlin으로 작성되므로, 단위 테스트 시 mocking 없이 독립적으로 테스트 가능합니다.  

---

## 6. 애플리케이션 레이어 구조

### 6.1 예시 디렉터리 구조

```plaintext
domains:
	user:
	  src:
		main:
		  kotlin:
			com:
			  example:
				application:
				  command:
					- CreateUserCommand.kt
					- UpdateUserCommand.kt
					- handler
						- CreateUserCommandHandler.kt
						- UpdateUserCommandHandler.kt
				  query:
					- GetUserQuery.kt
					- FindUsersQuery.kt
					- handler
						- GetUserQueryHandler.kt
						- FindUsersQueryHandler.kt
				  mapper:
					- UserMapper.kt
				  common:
					- UserApplicationException.kt
	order:
	  src:
	    main:
	      kotlin:
	        com:
	          example:
	            application:
	              command:
	                - CreateOrderCommand.kt
	                - UpdateOrderCommand.kt
	                - CancelOrderCommand.kt
	                - handler
	                  - CreateOrderCommandHandler.kt
	                  - UpdateOrderCommandHandler.kt
	                  - CancelOrderCommandHandler.kt
	              query:
	                - GetOrderQuery.kt
	                - FindOrdersQuery.kt
	                - FindOrdersByCustomerQuery.kt
	                - handler
	                  - GetOrderQueryHandler.kt
	                  - FindOrdersQueryHandler.kt
	                  - FindOrdersByCustomerQueryHandler.kt
	              mapper:
	                - OrderMapper.kt
	              common:
	                - OrderApplicationException.kt
```

---

## 7. 프레젠테이션 레이어 구조

### 7.1 예시 디렉터리 구조

```plaintext
domains:
	user:
	  src:
		main:
		  kotlin:
			com:
			  example:
				presentation:
				  v1:
					command:
					  - UserCommandController.kt
					  dto:
						request:
						  - UserCreateRequestV1.kt
						  - UserUpdateRequestV1.kt
					query:
					  - UserQueryController.kt
					  dto:
						response:
						  - UserResponseV1.kt
						  - UserSearchResponseV1.kt
				  v2:
					command:
					  - UserCommandControllerV2.kt
					  dto:
						request:
						  - UserCreateRequestV2.kt
					query:
					  - UserQueryControllerV2.kt
					  dto:
						response:
						  - UserDetailResponseV2.kt
	order:
	  src:
		main:
		  kotlin:
			com:
			  example:
				presentation:
				  v1:
					command:
					  - OrderCommandController.kt
					  dto:
						request:
						  - OrderCreateRequestV1.kt
						  - OrderCancelRequestV1.kt
					query:
					  - OrderQueryController.kt
					  dto:
						response:
						  - OrderResponseV1.kt
						  - OrderHistoryResponseV1.kt
```

---

## 8. Query 전략

### 8.1 페이지네이션

- **규칙**: 다건 조회는 페이지네이션을 적용.
- **방식**: 결정 시 커서 페이지네이션을 기본.  

---

## 9. Command 요청에 대한 REST 응답 규칙

### 9.1 동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, 애플리케이션 레이어의 Command 실행 결과를 기반으로 최소한의 메타데이터를 반환합니다.  
- **필수 필드**: `status`, `message`, `correlationId` (결과 확인용 식별자)  
- **예시**:  

  ```json
  {
    "status": "success",
    "message": "요청이 처리되었습니다.",
    "correlationId": "correlation123"
  }
  ```

### 9.2 비동기 응답

- **특징**: 프레젠테이션 레이어에서 제공되며, URL 처리는 프레젠테이션 레이어에서만 수행됩니다. 애플리케이션 레이어는 `jobId`만 제공합니다.  
- **필수 필드**: `status`, `message`, `jobId`, 상태 조회 및 관리용 링크  
- **예시**:  

  ```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job12345",
    "links": [
      {
        "rel": "job-status-ws",
        "href": "wss://example.com/ws/job-status/job12345",
        "type": "ws",
        "action": "subscribe"
      },
      {
        "rel": "job-none-ws",
        "href": "/api/v1/jobs/status/job12345",
        "type": "http",
        "method": "GET",
        "action": "get-status"
      }
    ]
  }
  ```

---

## 10. Command 요청에 대한 REST 실패 응답 규칙

(기존 내용이 RFC 7807 준수로 섹션 12에서 통합되었으므로 생략)

---

## 11. 애플리케이션 레이어에서 Command 리턴 규칙

### 11.1 기본 원칙

- **규칙**: Command 핸들러는 상태 변경만 수행하며, 비즈니스 데이터(예: 생성된 엔티티의 상세 정보)를 반환하지 않습니다.  
- **참고**: 결과 확인용 `correlationId` 또는 `jobId`는 반환 가능하며, 이는 프레젠테이션 레이어에서 처리됩니다.  

### 11.2 동기 Command 처리

- **리턴 값**: `CommandResult` 객체  
- **필수 필드**:
  - `success`: boolean  
  - `correlationId`: string  
- **예시**:  

  ```json
  {
    "success": true,
    "correlationId": "corr-456"
  }
  ```

### 11.3 비동기 Command 처리

- **리턴 값**: `AsyncCommandResult` 객체  
- **필수 필드**:
  - `success`: boolean  
  - `jobId`: string  
- **예시**:  

  ```json
  {
    "success": true,
    "jobId": "job-789"
  }
  ```

- **참고**: 상태 추적은 데이터베이스 테이블 또는 메시지 큐를 통해 관리되며, 이벤트 소싱은 사용하지 않습니다.  

### 11.4 실패 처리

- **리턴 값**: `CommandResult` 또는 `AsyncCommandResult` 객체에 오류 정보 포함  
- **필수 필드**:
  - `success`: false  
  - `errorCode`: string  
- **예시**:  

  ```json
  {
    "success": false,
    "errorCode": "VALIDATION_ERROR"
  }
  ```
- **참고**: 실패 시 프레젠테이션 레이어에서 `ProblemDetail`을 사용해 RFC 7807 형식으로 변환되며, 자세한 내용은 섹션 12. 에러 처리를 참조하세요.

### 11.5 구현 참고

- **동기 Command 핸들러 예시**:  

  ```kotlin
  class CreateUserCommandHandler {
      fun handle(command: CreateUserCommand): CommandResult {
          userRepository.save(User(command.name, command.email))
          return CommandResult(true, UUID.randomUUID().toString())
      }
  }
  ```

- **프레젠테이션 계층에서의 변환 (MapStruct 사용)**:  

  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserController(
      private val createUserCommandHandler: CreateUserCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping
      fun createUser(@RequestBody request: UserCreateRequest): ResponseEntity<Any> {
          val command = userMapper.toCreateUserCommand(request)
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

- **MapStruct 매퍼 정의**:  

  ```kotlin
  @Mapper(componentModel = "spring")
  interface UserMapper {
      fun toCreateUserCommand(request: UserCreateRequest): CreateUserCommand
  }
  ```

---

## 12. 에러 처리

### 12.1 목적

- 시스템의 안정성을 유지하고, 클라이언트에게 RFC 7807("Problem Details for HTTP APIs")에 준수하는 명확한 에러 메시지를 제공하기 위해 일관된 에러 처리 전략을 정의합니다.
- 레이어별로 적절한 에러 처리를 통해 책임을 명확히 하고, 에러의 원인을 쉽게 파악할 수 있도록 합니다.

### 12.2 레이어별 에러 처리

#### 12.2.1 Presentation 레이어

- **역할**: 클라이언트의 요청을 검증하고, 애플리케이션 레이어로 전달하기 전에 유효성 검사를 수행합니다.
- **에러 유형**: 요청 데이터의 유효성 검사 실패, 인증/인가 실패 등.
- **처리 방식**: `@Valid` 어노테이션을 사용한 유효성 검사, Spring Security를 통한 인증/인가 처리.
- **응답**: `ProblemDetail`을 사용하여 RFC 7807 형식으로 클라이언트에게 반환.

#### 12.2.2 Application 레이어

- **역할**: 비즈니스 로직을 실행하며, 도메인 레이어와 상호작용합니다.
- **에러 유형**: 비즈니스 규칙 위반, 도메인 로직 에러 등.
- **처리 방식**: 도메인에서 발생한 예외를 catching하고, `CommandResult` 또는 `AsyncCommandResult`에 에러 정보를 포함하여 반환. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환.
- **응답**: CommandResult 또는 AsyncCommandResult에 에러 정보를 포함하여 반환.

#### 12.2.3 Domain 레이어

- **역할**: 핵심 비즈니스 로직을 포함하며, 도메인 규칙을 준수합니다.
- **에러 유형**: 도메인 규칙 위반 (예: 무효한 상태 전환).
- **처리 방식**: 도메인 예외를 throw하여 상위 레이어로 전달.
- **예외 클래스**: `DomainException`과 같은 커스텀 예외 클래스를 사용.

#### 12.2.4 Infrastructure 레이어

- **역할**: 데이터베이스, 외부 API 등과의 통신을 담당합니다.
- **에러 유형**: 데이터베이스 연결 실패, 외부 API 응답 지연 등.
- **처리 방식**: 인프라 관련 예외를 catching하고, 애플리케이션 레이어에서 처리할 수 있는 형태로 변환.
- **예외 클래스**: `InfrastructureException`과 같은 커스텀 예외 클래스를 사용.

### 12.3 에러 응답 형식

- **형식**: 모든 에러 응답은 RFC 7807에 따라 JSON 형식으로 반환되며, Spring Boot 3.0 이상에서 제공하는 `ProblemDetail` 클래스를 기본으로 사용합니다. `ProblemDetail`은 다음과 같은 필드를 포함합니다:
  - `type`: 문제 유형을 식별하는 URI (기본값: "about:blank")
  - `title`: 문제 유형에 대한 간단한 설명 (문제 유형별 고정 문자열)
  - `status`: HTTP 상태 코드
  - `detail`: 문제에 대한 인스턴스별 설명
  - `instance`: 문제를 발생시킨 특정 요청을 식별하는 URI (선택적)
  - 확장 필드: `errorCode` (에러 식별용 고유 코드), `timestamp` (에러 발생 시각) 등은 `setProperty` 메서드를 통해 추가됩니다.
- **예시**:
  ```json
  {
    "type": "https://example.com/probs/user-not-found",
    "title": "User Not Found",
    "status": 404,
    "detail": "사용자를 찾을 수 없습니다.",
    "instance": "/api/v1/users/123",
    "errorCode": "USER_NOT_FOUND",
    "timestamp": "2025-03-24T12:00:00Z"
  }
  ```
- **구현 참고**: 
  - `ProblemDetail`은 Spring Boot 3.0 이상에서 기본 제공되며, 별도 의존성 추가 없이 사용 가능합니다. Spring Boot 2.x를 사용하는 경우, `org.zalando:problem-spring-web` 라이브러리를 통해 유사한 기능을 구현할 수 있습니다.
  - `status` 필드는 `UserErrorCode` enum에 정의된 `HttpStatus` 값과 일치해야 하며, 자세한 내용은 섹션 12.6을 참조하세요.

### 12.4 로깅

- **규칙**: 모든 에러는 로깅되며, 로깅 레벨은 에러의 심각도에 따라 다릅니다.
  - **INFO**: 클라이언트의 잘못된 요청 (예: 유효성 검사 실패)
  - **WARN**: 시스템의 일부 기능에 영향을 미치는 에러
  - **ERROR**: 시스템의 주요 기능에 영향을 미치는 심각한 에러
- **로깅 형식**: 에러 코드, 메시지, 스택 트레이스(필요 시) 포함.

### 12.5 예외 클래스

- **커스텀 예외**: 프로젝트에서는 다음과 같은 커스텀 예외 클래스를 정의합니다.
  - `DomainException`: 도메인 레이어에서 발생하는 예외
  - `ApplicationException`: 애플리케이션 레이어에서 발생하는 예외
  - `InfrastructureException`: 인프라 레이어에서 발생하는 예외
  - `PresentationException`: 프레젠테이션 레이어에서 발생하는 예외
- **사용 예시**:
  ```kotlin
  class UserNotFoundException(message: String) : DomainException(message)
  ```

### 12.6 에러 코드 및 Type URI

- **규칙**: 모든 에러는 고유한 에러 코드를 가지며, `type` URI와 HTTP 상태 코드(`HttpStatus`)와 매핑됩니다. 클라이언트가 문제를 식별하고 대응할 수 있도록 API 문서에 정의됩니다.
- **형식**: 
  - `errorCode`: 대문자 스네이크 케이스 (예: `USER_NOT_FOUND`, `INVALID_INPUT`)
  - `type`: "https://example.com/probs/{errorCode 소문자}" 형식
  - `status`: `org.springframework.http.HttpStatus` 열거형 값으로, 각 에러 코드에 적합한 HTTP 상태 코드를 나타냅니다.
- **구현**: 에러 코드는 `UserErrorCode`와 같은 enum 클래스에 정의되며, `code`, `message`, `status` 필드를 포함합니다.
- **예시**:
  ```kotlin
  enum class UserErrorCode(val code: String, val message: String, val status: HttpStatus) {
      NOT_FOUND("USER_NOT_FOUND", "사용자를 찾을 수 없습니다.", HttpStatus.NOT_FOUND),
      UNAUTHORIZED("UNAUTHORIZED", "인증에 실패했습니다.", HttpStatus.UNAUTHORIZED),
      INVALID_INPUT("INVALID_INPUT", "입력값이 유효하지 않습니다.", HttpStatus.BAD_REQUEST),
      UNKNOWN("UNKNOWN_ERROR", "알 수 없는 오류가 발생했습니다.", HttpStatus.BAD_REQUEST);

      companion object {
          fun fromCode(code: String?): UserErrorCode =
              entries.find { it.code == code } ?: UNKNOWN
      }
  }
  ```
- **사용 예시**:
  ```kotlin
  val error = UserErrorCode.fromCode(result.errorCode)
  val problem = ProblemDetail.forStatus(error.status).apply {
      type = URI.create("https://example.com/probs/${error.code.lowercase()}")
      title = error.code.replace("_", " ").capitalize()
      detail = error.message
      instance = URI.create("/api/v1/users/$userId")
      setProperty("errorCode", error.code)
      setProperty("timestamp", Instant.now().toString())
  }
  ```
- **문서화**: 에러 코드, `type` URI, 그리고 해당 HTTP 상태 코드는 API 문서(Swagger 등)에 명시되며, `UserErrorCode` enum을 기반으로 자동 생성될 수 있습니다.
- **주의사항**: 
  - 새로운 에러 코드를 추가할 때는 적절한 `HttpStatus`를 선택하여 일관성을 유지해야 합니다.
  - `UNKNOWN_ERROR`는 기본값으로 사용되며, 예상치 못한 오류에 대한 fallback으로 활용됩니다.

### 12.7 글로벌 예외 처리

- **구현**: Spring의 `@ControllerAdvice`를 사용하여 전역적으로 예외를 처리하며, `ProblemDetail`을 활용해 RFC 7807 형식으로 응답을 반환합니다. `UserErrorCode` enum을 참조하여 적절한 HTTP 상태 코드를 설정합니다.
- **예시**:
  ```kotlin
  import org.springframework.http.HttpStatus
  import org.springframework.http.ProblemDetail
  import org.springframework.web.bind.annotation.ControllerAdvice
  import org.springframework.web.bind.annotation.ExceptionHandler
  import org.springframework.http.ResponseEntity
  import java.net.URI
  import java.time.Instant

  @ControllerAdvice
  class GlobalExceptionHandler {
      @ExceptionHandler(DomainException::class)
      fun handleDomainException(ex: DomainException): ResponseEntity<ProblemDetail> {
          val error = UserErrorCode.NOT_FOUND // 실제로는 에러 코드 매핑 로직 필요
          val problem = ProblemDetail.forStatus(error.status).apply {
              type = URI.create("https://example.com/probs/${error.code.lowercase()}")
              title = error.code.replace("_", " ").capitalize()
              detail = ex.message ?: error.message
              instance = URI.create("/api/v1/users/123")
              setProperty("errorCode", error.code)
              setProperty("timestamp", Instant.now().toString())
          }
          return ResponseEntity.status(error.status).body(problem)
      }

      @ExceptionHandler(UserCommandException::class)
      fun handleUserCommandException(ex: UserCommandException): ResponseEntity<ProblemDetail> {
          val error = UserErrorCode.fromCode(ex.errorCode)
          val problem = ProblemDetail.forStatus(error.status).apply {
              type = URI.create("https://example.com/probs/${error.code.lowercase()}")
              title = error.code.replace("_", " ").capitalize()
              detail = ex.message ?: error.message
              instance = URI.create("/api/v1/users/register")
              setProperty("errorCode", error.code)
              setProperty("timestamp", Instant.now().toString())
          }
          return ResponseEntity.status(error.status).body(problem)
      }
  }

  class UserCommandException(val errorCode: String?, message: String) : RuntimeException(message)
  ```
- **참고**: 
  - `UserErrorCode` enum을 활용하여 `status`, `type`, `title`, `detail`을 동적으로 설정하며, 하드코딩을 최소화합니다.
  - 커스텀 예외 클래스(예: `UserCommandException`)에서 `errorCode`를 전달받아 매핑합니다.

### 12.8 비동기 에러 처리

- **특징**: 비동기 Command의 경우, 에러가 발생하면 `AsyncCommandResult`에 에러 정보를 포함하여 반환합니다. 프레젠테이션 레이어에서 이를 `ProblemDetail`로 변환하여 응답합니다.
- **응답 형식** (RFC 7807 준수):
  ```json
  {
    "type": "https://example.com/probs/async-processing-error",
    "title": "Async Processing Error",
    "status": 400,
    "detail": "비동기 작업 처리에 실패했습니다.",
    "instance": "/api/v1/users/async",
    "errorCode": "ASYNC_PROCESSING_ERROR",
    "timestamp": "2025-03-24T12:00:00Z",
    "jobId": "job123"
  }
  ```
- **상태 조회**: 클라이언트는 `jobId`를 사용하여 작업의 최종 상태를 조회할 수 있으며, 에러 발생 시 상세 에러 정보를 확인할 수 있습니다.
- **구현 예시**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserAsyncCommandController(
      private val handler: CreateUserAsyncCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping("/async")
      fun createUserAsync(@RequestBody request: UserCreateRequest): ResponseEntity<Any> {
          val command = userMapper.toCreateUserCommand(request)
          val result = handler.handle(command)
          return if (result.success) {
              ResponseEntity.accepted().body(mapOf(
                  "status" to "accepted",
                  "message" to "요청이 접수되었습니다.",
                  "jobId" to result.jobId
              ))
          } else {
              val error = UserErrorCode.fromCode(result.errorCode)
              val problem = ProblemDetail.forStatus(error.status).apply {
                  type = URI.create("https://example.com/probs/${error.code.lowercase()}")
                  title = error.code.replace("_", " ").capitalize()
                  detail = error.message
                  instance = URI.create("/api/v1/users/async")
                  setProperty("errorCode", error.code)
                  setProperty("timestamp", Instant.now().toString())
                  setProperty("jobId", result.jobId)
              }
              ResponseEntity.status(error.status).body(problem)
          }
      }
  }
  ```

---

### 수정 요약
- **12.3**: `status`가 `UserErrorCode`의 `HttpStatus`와 연계됨을 명시.
- **12.6**: `UserErrorCode`에 `HttpStatus` 필드 추가, `fromCode` 헬퍼 메서드 포함, 사용 예시와 문서화 가이드라인 업데이트.
- **12.7**: 글로벌 예외 처리에서 `UserErrorCode`를 활용한 동적 `ProblemDetail` 생성 예시 추가.
- **12.8**: 비동기 에러 처리에서도 `UserErrorCode`를 사용하도록 예시 수정.

이로써 `UserErrorCode` 개선 사항이 **12. 에러 처리** 섹션에 완전히 반영되었습니다. 추가적인 조정이 필요하면 말씀해주세요!
---

## 13. HATEOAS 및 URI 템플릿 사용 규칙

### 13.1 목적

- RESTful API에서 클라이언트가 하드코딩된 URL에 의존하지 않고, 동적으로 제공되는 링크를 통해 리소스를 탐색할 수 있도록 HATEOAS(Hypermedia as the Engine of Application State)를 적용합니다.  
- URI 템플릿을 활용하여 경로 변경에 유연하게 대응합니다.

### 13.2 기본 규칙

- **의존성**: Spring HATEOAS(`spring-boot-starter-hateoas`)를 사용합니다.  
- **링크 포함**: 성공적인 Command 요청(동기/비동기) 응답에는 관련 리소스 상태 확인 또는 다음 작업을 위한 링크를 포함합니다.  
- **실패 응답**: 링크는 선택 사항이며, 오류 해결을 위한 추가 링크(예: 재시도)가 있다면 포함 권장. 실패 응답은 `ProblemDetail`을 사용하여 처리되며, 섹션 12. 에러 처리를 참조하세요.

### 13.3 링크 구조

- **필수 필드**: 모든 링크는 `rel`(관계), `href`(URL), `method`(HTTP 메서드)를 포함합니다.  
- **형식**:  

  ```kotlin
  mapOf(
      "rel" to "관계_이름",
      "href" to "리소스_URL",
      "method" to "HTTP_메서드"
  )
  ```

- **예시**:  

  ```kotlin
  mapOf(
      "rel" to "job-status",
      "href" to "/api/v1/jobs/status/job123",
      "method" to "GET"
  )
  ```

### 13.4 URI 템플릿 사용

- **하드코딩 금지**: 링크 경로는 하드코딩하지 않고, Spring HATEOAS의 `linkTo`와 `methodOn`을 사용해 동적으로 생성합니다.  
- **형식**:  

  ```kotlin
  linkTo<컨트롤러_클래스> { 메서드(파라미터) }.withRel("관계_이름")
  ```

- **예시**:  

  ```kotlin
  val statusLink = linkTo<JobStatusController> { getJobStatus(jobId) }.withRel("job-status")
  ```

### 13.5 비동기 Command 규칙

- **필수 링크**: 비동기 응답에는 작업 상태 확인을 위한 `job-status` 링크를 포함하며, `jobId`를 기반으로 생성합니다.  
- **예시**:  

  ```kotlin
  val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
  "links" to listOf(mapOf("rel" to statusLink.rel.value(), "href" to statusLink.href, "method" to "GET"))
  ```

### 13.6 응답 형식

- **규칙**: 링크는 응답의 `links` 필드에 `List<Map<String, String>>`로 포함됩니다.  
- **예시**:  

  ```json
  {
    "status": "accepted",
    "message": "요청이 접수되었습니다.",
    "jobId": "job123",
    "links": [
      {
        "rel": "job-status",
        "href": "/api/v1/jobs/status/job123",
        "method": "GET"
      }
    ]
  }
  ```

### 13.7 구현 참고

- **비동기 Command 예시 (MapStruct 사용)**:  

  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserAsyncCommandController(
      private val handler: CreateUserAsyncCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping("/async")
      fun createUserAsync(@RequestBody request: UserCreateRequest): ResponseEntity<Map<String, Any>> {
          val command = userMapper.toCreateUserCommand(request)
          val result = handler.handle(command)
          val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
          return if (result.success) {
              ResponseEntity.accepted().body(mapOf(
                  "status" to "accepted",
                  "message" to "요청이 접수되었습니다.",
                  "jobId" to result.jobId,
                  "links" to listOf(mapOf(
                      "rel" to statusLink.rel.value(),
                      "href" to statusLink.href,
                      "method" to "GET"
                  ))
              ))
          } else {
              // ProblemDetail을 사용한 에러 응답은 섹션 12.8 참조
              throw ApplicationException("비동기 작업 실패")
          }
      }
  }
  ```

### 13.8 준수 사항

- **컨트롤러 메서드 명명**: `linkTo`가 참조하므로 메서드 이름은 명확해야 합니다(예: `getJobStatus`).  
- **테스트**: `MockMvc`를 사용해 링크 생성을 검증합니다.  
- **문서화**: Swagger와 통합 시 `links` 필드를 명시적으로 정의합니다.

---

## 14 프로젝트 구조 참고용
아래는 참고용이고 그대로 하라는건 아니다.
```
domains/
├── common/
│   ├── src/main/kotlin/com/example/common/
│   ├── dto/
│   │   ├── CommandResult.kt
│   │   └── AsyncCommandResult.kt
│   ├── exception/
│   │   ├── DomainException.kt
│   │   ├── ApplicationException.kt
│   │   ├── InfrastructureException.kt
│   │   └── PresentationException.kt
│   └── config/
│       ├── MapStructConfig.kt
│       └── GlobalExceptionHandler.kt
│   └── build.gradle.kts
│
├── user/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/user/
│   │   │   └── UserApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/user/
│   │   │   ├── aggregate/User.kt (Aggregate)
│   │   │   ├── vo/UserId.kt (VO)
│   │   │   ├── vo/Email.kt (VO)
│   │   │   ├── repository/UserRepository.kt (Interface)
│   │   │   └── exception/UserDomainException.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/user/
│   │   │   ├── command/
│   │   │   │   ├── CreateUserCommand.kt
│   │   │   │   ├── UpdateUserCommand.kt
│   │   │   │   └── handler/
│   │   │   │       ├── CreateUserCommandHandler.kt
│   │   │   │       └── UpdateUserCommandHandler.kt
│   │   │   ├── query/
│   │   │   │   ├── GetUserQuery.kt
│   │   │   │   ├── FindUsersQuery.kt
│   │   │   │   └── handler/
│   │   │   │       ├── GetUserQueryHandler.kt
│   │   │   │       └── FindUsersQueryHandler.kt
│   │   │   ├── mapper/UserMapper.kt
│   │   │   └── common/UserApplicationException.kt
│   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/user/
│   │   │   ├── entity/UserEntity.kt
│   │   │   ├── mapper/UserEntityMapper.kt
│   │   │   ├── repository/
│   │   │   │   ├── SpringDataJpaUserRepository.kt
│   │   │   │   └── UserRepositoryImpl.kt
│   │   │   └── exception/UserInfrastructureException.kt
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/user/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── UserCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── UserCreateRequestV1.kt
│   │   │   │   │       └── UserUpdateRequestV1.kt
│   │   │   │   └── query/
│   │   │   │       ├── UserQueryController.kt
│   │   │   │       └── dto/response/
│   │   │   │           ├── UserResponseV1.kt
│   │   │   │           └── UserSearchResponseV1.kt
│   │   │   └── exception/UserPresentationException.kt
│   │   └── build.gradle.kts
│   └── build.gradle.kts
│
├── order/
│   ├── apps/
│   │   ├── src/main/kotlin/com/example/apps/order/
│   │   │   └── OrderApplication.kt
│   │   └── build.gradle.kts
│   ├── domain/
│   │   ├── src/main/kotlin/com/example/domain/order/
│   │   │   ├── aggregate/Order.kt (Aggregate)
│   │   │   ├── vo/OrderId.kt (VO)
│   │   │   ├── entity/OrderItem.kt (Entity/VO)
│   │   │   ├── vo/OrderStatus.kt (Enum)
│   │   │   ├── repository/OrderRepository.kt (Interface)
│   │   │   └── exception/OrderDomainException.kt
│   │   └── build.gradle.kts
│   ├── application/
│   │   ├── src/main/kotlin/com/example/application/order/
│   │   │   ├── command/
│   │   │   │   ├── CreateOrderCommand.kt
│   │   │   │   ├── UpdateOrderCommand.kt
│   │   │   │   ├── CancelOrderCommand.kt
│   │   │   │   └── handler/
│   │   │   │       ├── CreateOrderCommandHandler.kt
│   │   │   │       ├── UpdateOrderCommandHandler.kt
│   │   │   │       └── CancelOrderCommandHandler.kt
│   │   │   ├── query/
│   │   │   │   ├── GetOrderQuery.kt
│   │   │   │   ├── FindOrdersQuery.kt
│   │   │   │   ├── FindOrdersByCustomerQuery.kt
│   │   │   │   └── handler/
│   │   │   │       ├── GetOrderQueryHandler.kt
│   │   │   │       ├── FindOrdersQueryHandler.kt
│   │   │   │       └── FindOrdersByCustomerQueryHandler.kt
│   │   │   ├── mapper/OrderMapper.kt
│   │   │   └── common/OrderApplicationException.kt
│   │   └── build.gradle.kts
│   ├── infrastructure/
│   │   ├── src/main/kotlin/com/example/infrastructure/order/
│   │   │   ├── entity/
│   │   │   │   ├── OrderEntity.kt
│   │   │   │   └── OrderItemEntity.kt
│   │   │   ├── mapper/OrderEntityMapper.kt
│   │   │   ├── repository/
│   │   │   │   ├── SpringDataJpaOrderRepository.kt
│   │   │   │   └── OrderRepositoryImpl.kt
│   │   │   └── exception/OrderInfrastructureException.kt
│   │   └── build.gradle.kts
│   ├── presentation/
│   │   ├── src/main/kotlin/com/example/presentation/order/
│   │   │   ├── v1/
│   │   │   │   ├── command/
│   │   │   │   │   ├── OrderCommandController.kt
│   │   │   │   │   └── dto/request/
│   │   │   │   │       ├── OrderCreateRequestV1.kt
│   │   │   │   │       └── OrderCancelRequestV1.kt
│   │   │   │   └── query/
│   │   │   │       ├── OrderQueryController.kt
│   │   │   │       └── dto/response/
│   │   │   │           ├── OrderResponseV1.kt
│   │   │   │           └── OrderHistoryResponseV1.kt
│   │   │   └── exception/OrderPresentationException.kt
│   │   └── build.gradle.kts
│   └── build.gradle.kts
│
└── build.gradle.kts (최상위)
```

---

## 15 Presentation 레이어 validation

- **목적**: 클라이언트로부터 입력받은 데이터의 유효성을 검증하여 잘못된 요청을 조기에 차단하고, 시스템의 안정성과 데이터 무결성을 보장합니다.  
- **규칙**: Presentation 레이어에서 요청 데이터(`Request DTO`)의 유효성 검사는 `jakarta.validation.constraints` 패키지의 어노테이션을 적극 활용하여 수행합니다.  
- **의존성**: Spring Boot Starter Validation(`spring-boot-starter-validation`)을 사용하며, Gradle에 추가합니다.  
  - **설정 예시**:  

    ```groovy
    dependencies {
        implementation "org.springframework.boot:spring-boot-starter-validation"
    }
    ```

- **적용 방식**:  
  - 모든 `Request DTO` 필드에 대해 적절한 검증 어노테이션을 적용합니다.  
  - 컨트롤러 메서드에서 `@Valid` 어노테이션을 사용하여 유효성 검사를 트리거합니다.  
  - 검증 실패 시, Spring의 `MethodArgumentNotValidException`을 통해 `ProblemDetail` 형식으로 에러 응답을 반환합니다(12.7 글로벌 예외 처리 참조).  

- **주요 검증 어노테이션**:  
  - `@NotNull`: 필수 입력값 검증  
  - `@NotBlank`: 공백 문자열 방지 (문자열에 적용)  
  - `@Size`: 문자열 길이 또는 컬렉션 크기 제한  
  - `@Min` / `@Max`: 숫자 값의 범위 제한  
  - `@Email`: 이메일 형식 검증  
  - `@Pattern`: 정규 표현식을 통한 형식 검증  
  - 기타: 프로젝트 요구사항에 따라 커스텀 어노테이션 정의 가능  

- **예시**:  
  - **Request DTO 정의**:  

    ```kotlin
    data class UserCreateRequestV1(
        @field:NotBlank(message = "이름은 필수입니다.")
        @field:Size(min = 2, max = 50, message = "이름은 2~50자 사이여야 합니다.")
        val name: String,

        @field:NotBlank(message = "이메일은 필수입니다.")
        @field:Email(message = "유효한 이메일 형식이어야 합니다.")
        val email: String,

        @field:NotBlank(message = "비밀번호는 필수입니다.")
        @field:Size(min = 8, max = 20, message = "비밀번호는 8~20자 사이여야 합니다.")
        @field:Pattern(
            regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d@$!%*#?&]+$",
            message = "비밀번호는 영문자와 숫자를 포함해야 합니다."
        )
        val password: String
    )
    ```

  - **컨트롤러에서 사용**:  

    ```kotlin
    @RestController
    @RequestMapping("/api/v1/users")
    class UserCommandController(
        private val createUserCommandHandler: CreateUserCommandHandler,
        private val userMapper: UserMapper
    ) {
        @PostMapping
        fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
            val command = userMapper.toCreateUserCommand(request)
            val result = createUserCommandHandler.handle(command)
            return ResponseEntity.ok(mapOf(
                "status" to "success",
                "message" to "요청이 처리되었습니다.",
                "correlationId" to result.correlationId
            ))
        }
    }
    ```

- **에러 응답**: 검증 실패 시, `ProblemDetail`을 사용하여 RFC 7807 형식을 따르며, 필드별 에러 메시지를 확장 필드 `invalid-params`로 포함합니다.  
  - **예시 응답**:  

    ```json
    {
        "type": "https://example.com/probs/invalid-params",
        "title": "Invalid Input",
        "status": 400,
        "detail": "입력 데이터가 유효하지 않습니다.",
        "instance": "/api/v1/users",
        "errorCode": "VALIDATION_ERROR",
        "timestamp": "2025-03-24T10:00:00Z",
        "invalid-params": [
            {
                "field": "name",
                "message": "이름은 필수입니다."
            },
            {
                "field": "email",
                "message": "유효한 이메일 형식이어야 합니다."
            }
        ]
    }
    ```

---

## 16. 도메인 익셉션의 전파

### 16.1 CommandResult 기반 처리 (예외 없이 결과만 반환)
애플리케이션 레이어에서 도메인 익셉션을 잡아 `CommandResult`로 변환한 경우, 프레젠테이션 레이어는 `CommandResult`의 상태를 확인하여 `ProblemDetail`을 사용해 RFC 7807 형식의 응답을 구성합니다.

- **구현 예시**:
  ```kotlin
  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Any> {
          val command = userMapper.toCreateUserCommand(request)
          val result = createUserCommandHandler.handle(command)

          return if (result.success) {
              ResponseEntity.ok(mapOf(
                  "status" to "success",
                  "message" to "요청이 처리되었습니다.",
                  "correlationId" to result.correlationId
              ))
          } else {
              val problem = ProblemDetail.forStatus(HttpStatus.BAD_REQUEST).apply {
                  type = URI.create("https://example.com/probs/user-creation-failed")
                  title = "User Creation Failed"
                  detail = "사용자 생성에 실패했습니다."
                  instance = URI.create("/api/v1/users")
                  setProperty("errorCode", result.errorCode ?: "USER_CREATION_FAILED")
                  setProperty("timestamp", Instant.now().toString())
              }
              ResponseEntity.status(HttpStatus.BAD_REQUEST).body(problem)
          }
      }
  }
  ```

- **Command 핸들러 예시**:
  ```kotlin
  class CreateUserCommandHandler(
      private val userRepository: UserRepository
  ) {
      fun handle(command: CreateUserCommand): CommandResult {
          return try {
              userRepository.save(User(command.name, command.email))
              CommandResult(true, UUID.randomUUID().toString())
          } catch (e: DomainException) {
              CommandResult(false, "USER_CREATION_FAILED")
          }
      }
  }
  ```

- **응답 예시**:
  - 성공:
    ```json
    {
      "status": "success",
      "message": "요청이 처리되었습니다.",
      "correlationId": "corr-456"
    }
    ```
  - 실패:
    ```json
    {
      "type": "https://example.com/probs/user-creation-failed",
      "title": "User Creation Failed",
      "status": 400,
      "detail": "사용자 생성에 실패했습니다.",
      "instance": "/api/v1/users",
      "errorCode": "USER_CREATION_FAILED",
      "timestamp": "2025-03-24T10:00:00Z"
    }
    ```

---

## 17. Presentation 레이어에서 Swagger 적용

### 17.1 목적

- API의 명세를 문서화하고, 클라이언트 및 개발자가 쉽게 이해하고 테스트할 수 있도록 Swagger를 Presentation 레이어에 적용합니다. 이를 통해 API의 엔드포인트, 요청/응답 형식, 에러 응답 등을 명확히 정의하고 유지보수성을 높입니다.

### 17.2 의존성 설정

- **의존성**: Spring Boot 프로젝트에서 Swagger를 사용하기 위해 `springdoc-openapi` 라이브러리를 사용합니다.  
  - **Gradle 설정 예시**:  

    ```groovy
    dependencies {
        implementation "org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.2"
    }
    ```

- **설명**: `springdoc-openapi-starter-webmvc-ui`는 Spring Boot와 통합된 OpenAPI 3 명세를 생성하며, Swagger UI를 기본 제공합니다.

### 17.3 기본 설정

- **구성**: Spring Boot의 `@Configuration` 클래스를 통해 Swagger 설정을 커스터마이징합니다.  
- **예시**:  

  ```kotlin
  import io.swagger.v3.oas.models.OpenAPI
  import io.swagger.v3.oas.models.info.Info
  import org.springframework.context.annotation.Bean
  import org.springframework.context.annotation.Configuration

  @Configuration
  class SwaggerConfig {
      @Bean
      fun customOpenAPI(): OpenAPI {
          return OpenAPI()
              .info(
                  Info()
                      .title("Project API")
                      .version("v1")
                      .description("Spring Boot 기반 프로젝트 API 문서")
              )
      }
  }
  ```

- **접근 경로**: 기본적으로 `/v3/api-docs`에서 OpenAPI JSON을 확인할 수 있으며, `/swagger-ui.html`에서 Swagger UI에 접근 가능합니다.

### 17.4 API 문서화

- **어노테이션 사용**: Presentation 레이어의 컨트롤러에 OpenAPI 어노테이션(`@Operation`, `@ApiResponse`, `@Parameter` 등)을 적용하여 API를 문서화합니다.  
- **규칙**:  
  - 모든 엔드포인트는 `@Operation`으로 설명을 추가합니다.  
  - 요청/응답 DTO는 스키마로 자동 생성되며, 추가 설명은 `@Schema`로 제공합니다.  
  - 에러 응답은 RFC 7807(`ProblemDetail`) 형식을 반영하여 정의합니다(섹션 12 참조).  

- **예시**:  

  ```kotlin
  import io.swagger.v3.oas.annotations.Operation
  import io.swagger.v3.oas.annotations.media.Content
  import io.swagger.v3.oas.annotations.media.Schema
  import io.swagger.v3.oas.annotations.responses.ApiResponse
  import io.swagger.v3.oas.annotations.responses.ApiResponses
  import org.springframework.http.ResponseEntity
  import org.springframework.web.bind.annotation.*
  import jakarta.validation.Valid

  @RestController
  @RequestMapping("/api/v1/users")
  class UserCommandController(
      private val createUserCommandHandler: CreateUserCommandHandler,
      private val userMapper: UserMapper
  ) {
      @PostMapping
      @Operation(summary = "새로운 사용자 생성", description = "사용자 정보를 입력받아 새로운 사용자를 생성합니다.")
      @ApiResponses(
          ApiResponse(responseCode = "200", description = "사용자 생성 성공", 
              content = [Content(schema = Schema(implementation = Map::class))]),
          ApiResponse(responseCode = "400", description = "잘못된 요청 데이터", 
              content = [Content(schema = Schema(implementation = ProblemDetail::class))])
      )
      fun createUser(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
          val command = userMapper.toCreateUserCommand(request)
          val result = createUserCommandHandler.handle(command)
          return ResponseEntity.ok(mapOf(
              "status" to "success",
              "message" to "요청이 처리되었습니다.",
              "correlationId" to result.correlationId
          ))
      }
  }
  ```

- **Request DTO 문서화**:  

  ```kotlin
  import io.swagger.v3.oas.annotations.media.Schema

  @Schema(description = "사용자 생성 요청 데이터")
  data class UserCreateRequestV1(
      @field:Schema(description = "사용자 이름", example = "John Doe", required = true)
      @field:NotBlank(message = "이름은 필수입니다.")
      val name: String,

      @field:Schema(description = "사용자 이메일", example = "john.doe@example.com", required = true)
      @field:NotBlank(message = "이메일은 필수입니다.")
      @field:Email(message = "유효한 이메일 형식이어야 합니다.")
      val email: String
  )
  ```

### 17.5 HATEOAS 통합

- **규칙**: 섹션 13에서 정의된 HATEOAS 링크(`links` 필드)를 Swagger 문서에 반영합니다.  
- **구현**: 응답 객체에 `links` 필드를 명시하며, `@Schema`로 설명을 추가합니다.  
- **예시**:  

  ```kotlin
  @Operation(summary = "비동기 사용자 생성", description = "비동기로 사용자 생성 요청을 접수합니다.")
  @ApiResponses(
      ApiResponse(responseCode = "202", description = "요청 접수 완료", 
          content = [Content(schema = Schema(implementation = Map::class))])
  )
  @PostMapping("/async")
  fun createUserAsync(@Valid @RequestBody request: UserCreateRequestV1): ResponseEntity<Map<String, Any>> {
      val command = userMapper.toCreateUserCommand(request)
      val result = handler.handle(command)
      val statusLink = linkTo<JobStatusController> { getJobStatus(result.jobId!!) }.withRel("job-status")
      return ResponseEntity.accepted().body(mapOf(
          "status" to "accepted",
          "message" to "요청이 접수되었습니다.",
          "jobId" to result.jobId,
          "links" to listOf(mapOf(
              "rel" to statusLink.rel.value(),
              "href" to statusLink.href,
              "method" to "GET"
          ))
      ))
  }
  ```

### 17.6 에러 응답 문서화

- **규칙**: 섹션 12.3에 정의된 `ProblemDetail` 형식을 Swagger에 반영하며, `UserErrorCode` enum을 기반으로 주요 에러를 문서화합니다.  
- **예시**:  

  ```kotlin
  @ApiResponses(
      ApiResponse(responseCode = "400", description = "유효성 검사 실패", 
          content = [Content(schema = Schema(implementation = ProblemDetail::class))])
  )
  ```

### 17.7 Swagger UI 커스터마이징

- **설정**: `application.yml` 또는 `application.properties`를 통해 Swagger UI 경로와 옵션을 조정 가능합니다.  
- **예시**:  

  ```yaml
  springdoc:
    swagger-ui:
      path: /custom-swagger-ui.html
      display-request-duration: true
  ```

### 17.8 주의사항

- **버전 관리**: API 버전(`v1`, `v2` 등)에 따라 별도의 Swagger 그룹을 설정하여 문서를 분리할 수 있습니다.  
  - 예: `springdoc.group-configs` 설정 사용.  
- **성능**: 대규모 프로젝트에서는 Swagger 생성 시 성능 영향을 최소화하기 위해 필요한 엔드포인트만 노출하도록 필터링 고려.  
- **보안**: 운영 환경에서는 Swagger UI 접근을 제한하거나 비활성화합니다(예: `springdoc.swagger-ui.enabled=false`).
